/**************************************************************
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 *************************************************************/



package org.openoffice.test.common;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URL;
import java.net.URLConnection;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Properties;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import org.w3c.dom.Document;


/**
 * Utilities related to the file system
 *
 */
public class FileUtil {

    private final static DateFormat FILENAME_FORMAT = new SimpleDateFormat("yyMMddHHmm");

    private FileUtil(){

    }

    public static Document parseXML(String path) {
        try {
            DocumentBuilderFactory dbfac = DocumentBuilderFactory.newInstance();
            dbfac.setNamespaceAware(true);
            DocumentBuilder docBuilder = dbfac.newDocumentBuilder();
            return docBuilder.parse(path);
        } catch (Exception e) {
            return null;
        }
    }

    public static String getStringByXPath(String xml, String xpathStr) {
        Document doc = parseXML(xml);
        if (doc == null)
            return null;

        try {
            XPathFactory factory = XPathFactory.newInstance();
            XPath xpath = factory.newXPath();
            XPathExpression expr = xpath.compile(xpathStr);
            return (String) expr.evaluate(doc);
        } catch (XPathExpressionException e) {
            e.printStackTrace();
            return null;
        }


    }



    /**
     * Update the given property in a properties file
     * @param file the properties file path
     * @param key the key
     * @param value the value
     */
    public static void updateProperty(String file, String key, String value) {
        Properties map = new Properties();
        map.put(key, value);
        updateProperty(file, map);
    }

    /**
     * Update the given properties in a properties file
     * @param file the properties file path
     * @param props properties updated
     */
    public static void updateProperty(String file, Properties props) {
        Properties properties = loadProperties(file);
        properties.putAll(props);
        storeProperties(file, properties);
    }

    /**
     * Load a properties file to Properties class
     * @param file the properties file path
     * @return
     */
    public static Properties loadProperties(String file) {
        return loadProperties(new File(file));
    }

    /**
     * Load a properties file to Properties class
     * @param file the properties file
     * @return
     */
    public static Properties loadProperties(File file) {
        Properties properties = new Properties();
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(file);
            properties.load(fis);
        } catch (IOException e) {
            //System.out.println("Can't read properties file.");
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    // ignore
                }
            }
        }

        return properties;
    }

    /**
     * Store properties into a file
     * @param file the properties file path
     * @param properties the properties to be stored
     */
    public static void storeProperties(String file, Properties properties) {
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(file);
            properties.store(fos, "Generated By PropertyFileUtils");
        } catch (IOException e) {
            throw new RuntimeException(e);
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    // ignore
                }
            }
        }
    }



    /**
     * Delete a property in a properties file
     * @param file the properties file path
     * @param key the key to be deleted
     */
    public static void deleteProperty(String file, String key) {
        Properties properties = loadProperties(file);
        properties.remove(key);
        storeProperties(file, properties);
    }

    /**
     * Load a file as string
     * @param file the file path
     * @return
     */
    public static String readFileAsString(String file) {
        return readFileAsString(new File(file));
    }

    /**
     * Load a file as string
     * @param file the file path
     * @return
     */
    public static String readFileAsString(File file) {
        StringBuffer strBuffer = new StringBuffer(10240);
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader(file));
            char[] buf = new char[1024];
            int count = 0;
            while ((count = reader.read(buf)) != -1) {
                strBuffer.append(buf, 0, count);
            }
        } catch (IOException e) {
        } finally {
            if (reader != null)
                try {
                    reader.close();
                } catch (IOException e) {
                    // ignore
                }
        }

        return strBuffer.toString();
    }

    /**
     * Find the first file matching the given name.
     * @param dir The directory to search in
     * @param name Regular Expression to match the file name
     * @return
     */
    public static File findFile(File dir, String name) {
        if (!dir.isDirectory())
            return null;
        File[] files = dir.listFiles();
        for (int i = 0; i < files.length; i++) {
            if (files[i].isDirectory()) {
                File ret = findFile(files[i], name);
                if (ret != null)
                    return ret;
            } else if (files[i].getName().matches(name)) {
                return files[i];
            }
        }

        return null;
    }

    /**
     * Find the last file matching the given name.
     * @param dir The directory to search in
     * @param name Regular Expression to match the file name
     * @return
     */
    public static File findLastFile(File dir, String name) {
        if (!dir.isDirectory())
            return null;
        File[] files = dir.listFiles();
        File file = null;
        for (int i = 0; i < files.length; i++) {
            if (files[i].isDirectory()) {
                File ret = findFile(files[i], name);
                if (ret != null)
                    file = ret;
            } else if (files[i].getName().matches(name)) {
                file = files[i];
            }
        }

        return file;
    }

    /**
     * find the first file matching the given name.
     * @param dirs The directories to search in. Use ';' separate each directory.
     * @param name Regular Expression to match the file name
     * @return
     */
    public static File findFile(String dirs, String name) {
        String[] directories = dirs.split(";");
        for (String s : directories) {
            File dir = new File(s);
            if (!dir.exists())
                continue;
            File file = findFile(dir, name);
            if (file != null)
                return file;
        }

        return null;
    }


    /**
     * find the last file matching the given name.
     * @param dirs The directories to search in. Use ';' separate each directory.
     * @param name Regular Expression to match the file name
     * @return
     */
    public static File findLastFile(String dirs, String name) {
        String[] directories = dirs.split(";");
        for (String s : directories) {
            File dir = new File(s);
            if (!dir.exists())
                continue;
            File file = findLastFile(dir, name);
            if (file != null)
                return file;
        }

        return null;
    }

    /**
     * find the directory matching the given name.
     * @param dir The directory to search in
     * @param name Regular Expression to match the file name
     * @return
     */
    public static File findDir(String dir, String dirName) {
        File[] files = new File(dir).listFiles();
        for (int i = 0; i < files.length; i++) {
            if (!files[i].isDirectory()) {
                File ret = findFile(files[i], dirName);
                if (ret != null)
                    return ret;
            } else if (files[i].getName().matches(dirName)) {
                return files[i];
            }
        }

        return null;
    }


    public static void writeStringToFile(String filePath, String contents) {
        FileWriter writer = null;
        try {
            File file = new File(filePath);
            file.getParentFile().mkdirs();
            writer = new FileWriter(file);
            if (contents != null)
                writer.write(contents);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (writer != null)
                try {
                    writer.close();
                } catch (IOException e) {
                }
        }
    }

    /**
     * Appeand a string to the tail of a file
     * @param file
     * @param contents
     */
    public static void appendStringToFile(String file, String contents) {
        FileWriter writer = null;
        try {
            writer = new FileWriter(file, true);
            writer.write(contents);
        } catch (IOException e) {
            System.out.println("Warning:" + e.getMessage());
        } finally {
            if (writer != null)
                try {
                    writer.close();
                } catch (IOException e) {
                }
        }
    }

    /**
     * Replace string in the file use regular expression
     * @param file
     * @param expr
     * @param substitute
     */
    public static void replace(String file, String expr, String substitute) {
        String str = readFileAsString(file);
        str = str.replaceAll(expr, substitute);
        writeStringToFile(file, str);
    }

    /**
     * Recursively copy all files in the source dir into the destination dir
     * @param fromDirName the source dir
     * @param toDirName the destination dir
     * @return
     */
    public static boolean copyDir(String fromDirName, String toDirName)  {
        return copyDir(new File(fromDirName), new File(toDirName), true);
    }

    /**
     * Copy all files in the source dir into the destination dir
     * @param fromDir
     * @param toDir
     * @param recursive
     * @return
     */
    public static boolean copyDir(File fromDir, File toDir, boolean recursive) {
        if (!fromDir.exists() || !fromDir.isDirectory()) {
            System.err.println("The source dir doesn't exist, or isn't dir.");
            return false;
        }
        if (toDir.exists() && !toDir.isDirectory())
            return false;
        boolean result = true;
        toDir.mkdirs();
        File[] files = fromDir.listFiles();
        for (int i = 0; i < files.length; i++) {
            if (files[i].isDirectory() && recursive)
                result &= copyDir(files[i], new File(toDir, files[i].getName()), true);
            else
                result &= copyFile(files[i], toDir);
        }

        return result;
    }

    /**
     * Copy a file
     * @param fromFile
     * @param toFile
     * @return
     */
    public static boolean copyFile(File fromFile, File toFile) {
         if (!fromFile.exists() || !fromFile.isFile() || !fromFile.canRead()) {
            System.err.println(fromFile.getAbsolutePath() + "doesn't exist, or isn't file, or can't be read");
            return false;
         }

         if (toFile.isDirectory())
           toFile = new File(toFile, fromFile.getName());

         FileInputStream from = null;
         FileOutputStream to = null;
         try {
           from = new FileInputStream(fromFile);
           File p = toFile.getParentFile();
           if (p != null && !p.exists())
               p.mkdirs();
           to = new FileOutputStream(toFile);
           byte[] buffer = new byte[4096];
           int bytesRead;
           while ((bytesRead = from.read(buffer)) != -1)
             to.write(buffer, 0, bytesRead);

           return true;
         } catch (IOException e) {
            //Can't copy
            e.printStackTrace();
            return false;
         } finally {
           if (from != null)
             try {
               from.close();
             } catch (IOException e) {
             }
           if (to != null)
             try {
               to.close();
             } catch (IOException e) {
             }
         }
    }

    /**
     * Copy a file
     * @param fromFileName
     * @param toFileName
     * @return
     */
    public static boolean copyFile(String fromFileName, String toFileName) {
        return copyFile(new File(fromFileName), new File(toFileName));
    }

    /**
     * Copy all the files under fromDirName to toDirName
     * @param fromDirName
     * @param toDirName
     * @return
     */
    public static boolean copyFiles(String fromDirName, String toDirName) {
        boolean res = true;

        File fromDir = new File(fromDirName);
        if (!fromDir.exists() || !fromDir.isDirectory() || !fromDir.canRead()) {
            System.err.println(fromDir.getAbsolutePath() + "doesn't exist, or isn't file, or can't be read");
            return false;
         }
        File [] files = fromDir.listFiles();
        for(int i=0; i<files.length; i++){
            if(files[i].isDirectory()){
                res = res && copyDir(fromDirName + "/" + files[i].getName(), toDirName + "/" + files[i].getName());
            }
            else
                res = res && copyFile(fromDirName + "/" + files[i].getName(), toDirName + "/" + files[i].getName());
        }
        return res;
    }

    /**
     * Delete a file
     * @param file
     * @return
     */
    public static boolean deleteFile(File path) {
        if (!path.exists())
            return true;

        if (path.isDirectory()) {
            File[] files = path.listFiles();
            for (int i = 0; i < files.length; i++) {
                if (files[i].isDirectory()) {
                    deleteFile(files[i]);
                } else {
                    files[i].delete();
                }
            }
        }

        return path.delete();
    }

    public static boolean deleteFile(String path) {
        return deleteFile(new File(path));
    }

    public static boolean fileExists(String file) {
        return new File(file).exists();
    }

    /**
     * Get the extension name of a file
     * @param file
     * @return
     */
    public static String getFileExtName(String file) {
        if (file == null)
            return null;
        int i = file.lastIndexOf('.');
        if (i < 0 && i >= file.length() - 1)
            return null;
        return file.substring(i+1);
    }
     /**
     * Get the file's size
     * @param file
     * @return KB
     */
    public static long getFileSize(String filePath){
        long totalSize = 0;
        FileInputStream f = null;
        File file = new File(filePath);

        try {
            f = new FileInputStream(file);
            totalSize = f.available();
            f.close();
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        return totalSize/1000;
    }

    /**
     * Get the folder's size
     * @param folder's path
     * @return Kb
     */
    public static long getFolderSize(String dir){
        long totalSize = 0;
        File[] files = new File(dir).listFiles();

        for(int i=0; i<files.length; i++){
            if(files[i].isDirectory())
                totalSize = totalSize + getFolderSize(files[i].getAbsolutePath())*1000;
            else
                totalSize = totalSize + files[i].length();
        }

        return totalSize/1000;
    }

    /**
     * unzip file to the unzipToLoc
     * @param folder's path
     * @return Kb
     */
    public static void unzipFile(String unzipfile, String unzipDest){
            try {
              File dest = new File(unzipDest);
              ZipInputStream zin = new ZipInputStream(new FileInputStream(unzipfile));
              ZipEntry entry;
              //Create folder
              while ( (entry = zin.getNextEntry()) != null){
                if (entry.isDirectory()) {
                  File directory = new File(dest, entry.getName());
                  if (!directory.exists())
                    if (!directory.mkdirs())
                      System.exit(0);
                  zin.closeEntry();
                }
                if (!entry.isDirectory()) {
                  File myFile = new File(entry.getName());
                  FileOutputStream fout = new FileOutputStream(unzipDest + "/" + myFile.getPath());
                  DataOutputStream dout = new DataOutputStream(fout);
                  byte[] b = new byte[1024];
                  int len = 0;
                  while ( (len = zin.read(b)) != -1) {
                    dout.write(b, 0, len);
                  }
                  dout.close();
                  fout.close();
                  zin.closeEntry();
                }
              }
            }
            catch (IOException e) {
              e.printStackTrace();
              System.out.println(e);
            }
    }

    public static File getUniqueFile(File dir, String prefix, String suffix) {
        String name = prefix + "." + FILENAME_FORMAT.format(new Date()) + ".";
        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            File file = new File(dir, name + i + suffix);
            if (!file.exists()) {
                return file;
            }
        }

        return null;
    }

    public static File getUniqueFile(String dir, String prefix, String suffix) {
        return getUniqueFile(new File(dir), prefix, suffix);
    }


    public static File download(String urlString, File output) {
        InputStream in = null;
        OutputStream out = null;
        System.out.println("[Vclauto] Download '" + urlString + "'");
        try {
            URL url = new URL(urlString);
            URLConnection urlConnection = url.openConnection();
            int totalSize = urlConnection.getContentLength();
            in = urlConnection.getInputStream();
            if (output.isDirectory()) {
                output = new File(output, url.getPath());
                output.getParentFile().mkdirs();
            }
            out = new FileOutputStream(output);

            byte[] buffer = new byte[1024 * 100]; // 100k
            int count = 0;
            int totalCount = 0;
            int progress = 0;
            while ((count = in.read(buffer)) > 0) {
                out.write(buffer, 0, count);
                totalCount += count;

                if (totalSize > 0) {
                    int nowProgress = totalCount * 10 / totalSize;
                    if (nowProgress > progress) {
                        progress = nowProgress;
                        System.out.print(".");
                    }
                }

            }
            System.out.println("Done!");
            return output;
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("Error!");
            return null;
        } finally {
            if (in != null)
                try {
                    in.close();
                } catch (IOException e) {
                }
            if (out != null)
                try {
                    out.close();
                } catch (IOException e) {

                }
        }
    }

}
