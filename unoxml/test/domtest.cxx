/**************************************************************
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 *************************************************************/



// autogenerated file with codegen.pl

#include "gtest/gtest.h"

#include <rtl/ref.hxx>
#include <osl/file.hxx>
#include <osl/process.h>
#include <comphelper/seqstream.hxx>
#include <comphelper/sequence.hxx>
#include <cppuhelper/compbase1.hxx>
#include <cppuhelper/bootstrap.hxx>
#include <cppuhelper/basemutex.hxx>

#include <com/sun/star/xml/sax/FastToken.hpp>
#include <com/sun/star/xml/sax/XSAXSerializable.hpp>
#include <com/sun/star/xml/sax/XFastSAXSerializable.hpp>

#include <cstdlib>

#include "../source/dom/documentbuilder.hxx"


using namespace ::DOM;
using namespace ::comphelper;
using namespace ::com::sun::star;

namespace
{

// valid xml
static const char validTestFile[] =
"<?xml version=\"1.0\" encoding=\"UTF-8\"?> \
 <office:document-content \
   xmlns:office=\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" \
   xmlns:xlink=\"http://www.w3.org/1999/xlink\" \
   office:version=\"1.0\"> \
   <office:scripts/> \
   <xlink:test/> \
   <office:automatic-styles teststyle=\"test\"/> \
   <moretest/> \
    some text öäü \
 </office:document-content> \
";

// generates a warning: unsupported xml version, unknown xml:space
// value
static const char warningTestFile[] =
"<?xml version=\"47-11.0\" encoding=\"UTF-8\"?> \
 <office:document-content \
   xmlns:office=\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" \
   xml:space=\"blafasl\" \
   office:version=\"1.0\"> \
   <office:scripts/> \
   <office:automatic-styles/> \
 </office:document-content> \
";

// <?xml not at start of file
static const char errorTestFile[] =
" <?xml version=\"1.0\" encoding=\"UTF-8\"?> \
 <office:document-content \
   xmlns:office=\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" \
   office:version=\"1.0\"> \
   <office:scripts/> \
   <office:automatic-styles/> \
 </office:document-content> \
";

// plain empty
static const char fatalTestFile[] = "";

struct ErrorHandler
    : public ::cppu::WeakImplHelper1< xml::sax::XErrorHandler >
{
    sal_uInt32 mnErrCount;
    sal_uInt32 mnFatalCount;
    sal_uInt32 mnWarnCount;

    bool noErrors() const { return !mnErrCount && !mnFatalCount && !mnWarnCount; }

    ErrorHandler() : mnErrCount(0), mnFatalCount(0), mnWarnCount(0)
    {}

    virtual void SAL_CALL error( const uno::Any& ) throw (xml::sax::SAXException, uno::RuntimeException)
    {
        ++mnErrCount;
    }

    virtual void SAL_CALL fatalError( const uno::Any& ) throw (xml::sax::SAXException, uno::RuntimeException)
    {
        ++mnFatalCount;
    }

    virtual void SAL_CALL warning( const uno::Any& ) throw (xml::sax::SAXException, uno::RuntimeException)
    {
        ++mnWarnCount;
    }
};

struct DocumentHandler
    : public ::cppu::WeakImplHelper1< xml::sax::XFastDocumentHandler >
{
    // XFastContextHandler
    virtual void SAL_CALL startFastElement( ::sal_Int32 Element, const uno::Reference< xml::sax::XFastAttributeList >& Attribs ) throw (xml::sax::SAXException, uno::RuntimeException)
    {
        OSL_TRACE("Seen element: %c with namespace 0x%x",
                  Element & 0xFFFF, Element & 0xFFFF0000);
    }

    virtual void SAL_CALL startUnknownElement( const ::rtl::OUString& Namespace, const ::rtl::OUString& Name, const uno::Reference< xml::sax::XFastAttributeList >& Attribs ) throw (xml::sax::SAXException, uno::RuntimeException)
    {
    }

    virtual void SAL_CALL endFastElement( ::sal_Int32 Element ) throw (xml::sax::SAXException, uno::RuntimeException)
    {
    }

    virtual void SAL_CALL endUnknownElement( const ::rtl::OUString& Namespace, const ::rtl::OUString& Name ) throw (xml::sax::SAXException, uno::RuntimeException)
    {
    }

    virtual uno::Reference< xml::sax::XFastContextHandler > SAL_CALL createFastChildContext( ::sal_Int32 Element, const uno::Reference< xml::sax::XFastAttributeList >& Attribs ) throw (xml::sax::SAXException, uno::RuntimeException)
    {
        return this;
    }

    virtual uno::Reference< xml::sax::XFastContextHandler > SAL_CALL createUnknownChildContext( const ::rtl::OUString& Namespace, const ::rtl::OUString& Name, const uno::Reference< xml::sax::XFastAttributeList >& Attribs ) throw (xml::sax::SAXException, uno::RuntimeException)
    {
        return this;
    }

    virtual void SAL_CALL characters( const ::rtl::OUString& aChars ) throw (xml::sax::SAXException, uno::RuntimeException)
    {
    }

    // XFastDocumentHandler
    virtual void SAL_CALL startDocument(  ) throw (xml::sax::SAXException, uno::RuntimeException)
    {
    }

    virtual void SAL_CALL endDocument(  ) throw (xml::sax::SAXException, uno::RuntimeException)
    {
    }

    virtual void SAL_CALL setDocumentLocator( const uno::Reference< xml::sax::XLocator >& xLocator ) throw (xml::sax::SAXException, uno::RuntimeException)
    {
    }
};

struct TokenHandler
    : public ::cppu::WeakImplHelper1< xml::sax::XFastTokenHandler >
{
    virtual ::sal_Int32 SAL_CALL getToken( const ::rtl::OUString& Identifier ) throw (uno::RuntimeException)
    {
        EXPECT_TRUE( false ) << "TokenHandler::getToken() unexpected call";
        return -1;
    }

    virtual ::rtl::OUString SAL_CALL getIdentifier( ::sal_Int32 Token ) throw (uno::RuntimeException)
    {
        EXPECT_TRUE( false ) << "TokenHandler::getIdentifier() unexpected call";
        return rtl::OUString();
    }

    virtual ::sal_Int32 SAL_CALL getTokenFromUTF8( const uno::Sequence< ::sal_Int8 >& Identifier ) throw (uno::RuntimeException)
    {
        OSL_TRACE("getTokenFromUTF8() %s", (const char*)Identifier.getConstArray());
        return Identifier.getLength() ? Identifier[0] : 0;
    }

    virtual uno::Sequence< ::sal_Int8 > SAL_CALL getUTF8Identifier( ::sal_Int32 Token ) throw (uno::RuntimeException)
    {
        EXPECT_TRUE( false) << "TokenHandler::getUTF8Identifier() unexpected call";
        return uno::Sequence<sal_Int8>();
    }
};

struct BasicTest : public ::testing::Test
{
    rtl::Reference<CDocumentBuilder>    mxDomBuilder;
    rtl::Reference<ErrorHandler>        mxErrHandler;
    rtl::Reference<SequenceInputStream> mxValidInStream;
    rtl::Reference<SequenceInputStream> mxWarningInStream;
    rtl::Reference<SequenceInputStream> mxErrorInStream;
    rtl::Reference<SequenceInputStream> mxFatalInStream;

    void SetUp()
    {
        // luckily, DOM builder doesn't use service fac, so we need
        // not bootstrap uno here
        mxErrHandler.set( new ErrorHandler() );
        mxDomBuilder.set( new CDocumentBuilder(Reference< XMultiServiceFactory >() ));
        mxValidInStream.set( new SequenceInputStream(ByteSequence((sal_Int8*)validTestFile,
                                                                  sizeof(validTestFile)/sizeof(*validTestFile))) );
        mxWarningInStream.set( new SequenceInputStream(ByteSequence((sal_Int8*)warningTestFile,
                                                                    sizeof(warningTestFile)/sizeof(*warningTestFile))) );
        mxErrorInStream.set( new SequenceInputStream(ByteSequence((sal_Int8*)errorTestFile,
                                                                  sizeof(errorTestFile)/sizeof(*errorTestFile))) );
        mxFatalInStream.set( new SequenceInputStream(ByteSequence((sal_Int8*)fatalTestFile,
                                                                  sizeof(fatalTestFile)/sizeof(*fatalTestFile))) );
        mxDomBuilder->setErrorHandler(mxErrHandler.get());
    }
};

TEST_F(BasicTest, validInputTest)
{
    ASSERT_TRUE( mxDomBuilder->parse(
        uno::Reference<io::XInputStream>(
            mxValidInStream.get())).is() ) << "Valid input file did not result in XDocument #1";
    ASSERT_TRUE( mxErrHandler->noErrors() ) << "Valid input file resulted in parse errors";
}

TEST_F(BasicTest, warningInputTest)
{
    ASSERT_TRUE( mxDomBuilder->parse(
        uno::Reference<io::XInputStream>(
            mxWarningInStream.get())).is() ) << "Valid input file did not result in XDocument #2";
    ASSERT_TRUE( mxErrHandler->mnWarnCount && !mxErrHandler->mnErrCount && !mxErrHandler->mnFatalCount )
        << "No parse warnings in unclean input file";
}

TEST_F(BasicTest, errorInputTest)
{
    ASSERT_TRUE( mxDomBuilder->parse(
        uno::Reference<io::XInputStream>(
            mxErrorInStream.get())).is() ) << "Valid input file did not result in XDocument #3";
    ASSERT_TRUE( !mxErrHandler->mnWarnCount && mxErrHandler->mnErrCount && !mxErrHandler->mnFatalCount )
        << "No parse errors in unclean input file";
}

TEST_F(BasicTest, fatalInputTest)
{
    ASSERT_TRUE( !mxDomBuilder->parse(
        uno::Reference<io::XInputStream>(
            mxFatalInStream.get())).is() ) << "Broken input file resulted in XDocument";
    ASSERT_TRUE( !mxErrHandler->mnWarnCount && !mxErrHandler->mnErrCount && mxErrHandler->mnFatalCount )
        << "No fatal parse errors in unclean input file";
};


struct SerializerTest : public ::testing::Test
{
    SerializerTest() : mbUnoInitialized(false) {}

    uno::Reference<uno::XComponentContext>                   mxCtx;
    rtl::Reference<CDocumentBuilder>                         mxDomBuilder;
    rtl::Reference<ErrorHandler>                             mxErrHandler;
    rtl::Reference<SequenceInputStream>                      mxInStream;
    rtl::Reference<DocumentHandler>                          mxHandler;
    rtl::Reference<TokenHandler>                             mxTokHandler;
    uno::Sequence< beans::Pair< rtl::OUString, sal_Int32 > > maRegisteredNamespaces;
    bool                                                     mbUnoInitialized;

    void SetUp()
    {
        // need working typelib, bootstrap UNO now
        if( !mbUnoInitialized )
        {
            const char* pArgs( getenv("UNOXML_DOMTEST_FORWARD") );
            ASSERT_TRUE(pArgs) << "Test file parameter";

            const rtl::OUString sBaseDir=rtl::OUString::createFromAscii(pArgs);

            // bootstrap UNO
            try
            {
                ::rtl::OUString aIniUrl;
                ASSERT_TRUE(
                    osl_getFileURLFromSystemPath(
                        (sBaseDir+rtl::OUString::createFromAscii("unoxml_unittest_test.ini")).pData,
                        &aIniUrl.pData ) == osl_File_E_None ) << "Converting ini file to URL";

                mxCtx = ::cppu::defaultBootstrap_InitialComponentContext(aIniUrl);
                ASSERT_TRUE(mxCtx.is()) << "Getting component context";
            }
            catch( uno::Exception& )
            {
                ASSERT_TRUE(false) << "Bootstrapping UNO";
            }

            mbUnoInitialized = true;
        }

        mxErrHandler.set( new ErrorHandler() );
        mxDomBuilder.set( new CDocumentBuilder(
                              uno::Reference< lang::XMultiServiceFactory >(
                                  mxCtx->getServiceManager(),
                                  uno::UNO_QUERY )));
        mxInStream.set( new SequenceInputStream(ByteSequence((sal_Int8*)validTestFile,
                                                             sizeof(validTestFile)/sizeof(*validTestFile))) );
        mxDomBuilder->setErrorHandler(mxErrHandler.get());

        mxHandler.set( new DocumentHandler() );
        mxTokHandler.set( new TokenHandler() );

        maRegisteredNamespaces.realloc(2);
        maRegisteredNamespaces[0] = beans::make_Pair(
            rtl::OUString(
                RTL_CONSTASCII_USTRINGPARAM(
                    "urn:oasis:names:tc:opendocument:xmlns:office:1.0") ),
            xml::sax::FastToken::NAMESPACE);
        maRegisteredNamespaces[1] = beans::make_Pair(
            rtl::OUString(
                RTL_CONSTASCII_USTRINGPARAM(
                    "http://www.w3.org/1999/xlink") ),
            2*xml::sax::FastToken::NAMESPACE);
    }
};

TEST_F(SerializerTest, serializerTest)
{
    uno::Reference< xml::dom::XDocument > xDoc=
        mxDomBuilder->parse(
            uno::Reference<io::XInputStream>(
                mxInStream.get()));
    ASSERT_TRUE( xDoc.is() ) << "Valid input file did not result in XDocument";
    ASSERT_TRUE( mxErrHandler->noErrors() ) << "Valid input file resulted in parse errors";

    uno::Reference< xml::sax::XSAXSerializable > xSaxSerializer(
        xDoc, uno::UNO_QUERY);
    ASSERT_TRUE( xSaxSerializer.is() ) << "XSAXSerializable not supported";

    uno::Reference< xml::sax::XFastSAXSerializable > xFastSaxSerializer(
        xDoc, uno::UNO_QUERY);
    ASSERT_TRUE( xSaxSerializer.is() ) << "XFastSAXSerializable not supported";

    xFastSaxSerializer->fastSerialize( mxHandler.get(),
                                       mxTokHandler.get(),
                                       uno::Sequence< beans::StringPair >(),
                                       maRegisteredNamespaces );
}

}


int main(int argc, char **argv)
{
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
