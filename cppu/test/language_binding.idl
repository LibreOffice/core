/*************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2008 by Sun Microsystems, Inc.
 *
 * OpenOffice.org - a multi-platform office productivity suite
 *
 * $RCSfile: language_binding.idl,v $
 * $Revision: 1.5 $
 *
 * This file is part of OpenOffice.org.
 *
 * OpenOffice.org is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 3
 * only, as published by the Free Software Foundation.
 *
 * OpenOffice.org is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License version 3 for more details
 * (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU Lesser General Public License
 * version 3 along with OpenOffice.org.  If not, see
 * <http://www.openoffice.org/license.html>
 * for a copy of the LGPLv3 License.
 *
 ************************************************************************/
#ifndef _TEST_LANGUAGE_BINDING_IDL_
#define _TEST_LANGUAGE_BINDING_IDL_

#include <com/sun/star/uno/XInterface.idl>
#include <com/sun/star/lang/IllegalArgumentException.idl>

module test
{

enum TestEnum
{
    TEST,
    ONE,
    TWO,
    CHECK,
    LOLA,
    PALOO,
    ZA
};

/**
 * simple c++ types
 */
struct TestSimple
{
    boolean                    Bool;
    char                       Char;
    byte                       Byte;
    short                      Short;
    unsigned short             UShort;
    long                       Long;
    unsigned long              ULong;
    hyper                      Hyper;
    unsigned hyper             UHyper;
    float                      Float;
    double                     Double;
    test::TestEnum             Enum;
};
/**
 * equal to max size returned in registers on x86_64
 */
struct SmallStruct
{
    hyper                      a;
    hyper                      b;
};
/**
 * equal to max size returned in registers on ia64
 */
struct MediumStruct
{
    hyper                      a;
    hyper                      b;
    hyper                      c;
    hyper                      d;
};
/**
 * bigger than max size returned in registers on ia64
 */
struct BigStruct
{
    hyper                      a;
    hyper                      b;
    hyper                      c;
    hyper                      d;
    hyper                      e;
    hyper                      f;
    hyper                      g;
    hyper                      h;
};
/**
 * all floats, ia64 claims to handle them specially
 */
struct AllFloats
{
    float                      a;
    float                      b;
    float                      c;
    float                      d;
};

/**
 * complex c++ types
 */
struct TestElement : test::TestSimple
{
    string                     String;
    com::sun::star::uno::XInterface   Interface;
    any                        Any;
};
struct TestDataElements : test::TestElement
{
    sequence<test::TestElement > Sequence;
};

typedef TestDataElements TestData;

/**
 * Monster test interface to test language binding calls.
 *
 * @author Daniel Boelzle
 */
interface XLBTestBase : com::sun::star::uno::XInterface
{
    /**
     * in parameter test, tests by calls reference also (complex types)
     */
    [oneway] void setValues( [in] boolean bBool, [in] char cChar, [in] byte nByte,
                             [in] short nShort, [in] unsigned short nUShort,
                             [in] long nLong, [in] unsigned long nULong,
                             [in] hyper nHyper, [in] unsigned hyper nUHyper,
                             [in] float fFloat, [in] double fDouble,
                             [in] test::TestEnum eEnum, [in] string aString,
                             [in] com::sun::star::uno::XInterface xInterface, [in] any aAny,
                             [in] sequence<test::TestElement > aSequence,
                             [in] test::TestData aStruct );
    /**
     * inout parameter test
     */
    test::TestData setValues2( [inout] boolean bBool, [inout] char cChar, [inout] byte nByte,
                               [inout] short nShort, [inout] unsigned short nUShort,
                               [inout] long nLong, [inout] unsigned long nULong,
                               [inout] hyper nHyper, [inout] unsigned hyper nUHyper,
                               [inout] float fFloat, [inout] double fDouble,
                               [inout] test::TestEnum eEnum, [inout] string aString,
                               [inout] com::sun::star::uno::XInterface xInterface, [inout] any aAny,
                               [inout] sequence<test::TestElement > aSequence,
                               [inout] test::TestData aStruct );

    /**
     * out parameter test
     */
    test::TestData getValues( [out] boolean bBool, [out] char cChar, [out] byte nByte,
                              [out] short nShort, [out] unsigned short nUShort,
                              [out] long nLong, [out] unsigned long nULong,
                              [out] hyper nHyper, [out] unsigned hyper nUHyper,
                              [out] float fFloat, [out] double fDouble,
                              [out] test::TestEnum eEnum, [out] string aString,
                              [out] com::sun::star::uno::XInterface xInterface, [out] any aAny,
                              [out] sequence<test::TestElement > aSequence,
                              [out] test::TestData aStruct );

    /**
     * register return test 1
     */
    test::SmallStruct echoSmallStruct( [in] test::SmallStruct aStruct );

    /**
     * register return test 2
     */
    test::MediumStruct echoMediumStruct( [in] test::MediumStruct aStruct );

    /**
     * register return test 3
     */
    test::BigStruct echoBigStruct( [in] test::BigStruct aStruct );

    /**
     * register return test 4
     */
    test::AllFloats echoAllFloats( [in] test::AllFloats aStruct );

    [attribute] boolean                  Bool;
    [attribute] byte                     Byte;
    [attribute] char                     Char;
    [attribute] short                    Short;
    [attribute] unsigned short           UShort;
    [attribute] long                     Long;
    [attribute] unsigned long            ULong;
    [attribute] hyper                    Hyper;
    [attribute] unsigned hyper           UHyper;
    [attribute] float                    Float;
    [attribute] double                   Double;
    [attribute] test::TestEnum           Enum;
    [attribute] string                   String;
    [attribute] com::sun::star::uno::XInterface Interface;
    [attribute] any                      Any;
    [attribute] sequence<test::TestElement > Sequence;
    [attribute] test::TestData           Struct;
};


/**
 * Inherting from monster; adds raiseException().
 *
 * @author Daniel Boelzle
 */
interface XLanguageBindingTest : test::XLBTestBase
{
    /**
     * params are there only for dummy, to test if all temp out params will be released.
     */
    test::TestData raiseException( [out] boolean bBool, [out] char cChar, [out] byte nByte,
                                   [out] short nShort, [out] unsigned short nUShort,
                                   [out] long nLong, [out] unsigned long nULong,
                                   [out] hyper nHyper, [out] unsigned hyper nUHyper,
                                   [out] float fFloat, [out] double fDouble,
                                   [out] test::TestEnum eEnum, [out] string aString,
                                   [out] com::sun::star::uno::XInterface xInterface, [out] any aAny,
                                   [out] sequence<test::TestElement > aSequence,
                                   [out] test::TestData aStruct )
        raises( com::sun::star::lang::IllegalArgumentException );

    /**
     * raises runtime exception
     */
    [attribute] long                     RuntimeException;
};

}; // test


#endif
