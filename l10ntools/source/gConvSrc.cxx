/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
 * This file is part of the LibreOffice project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * This file incorporates work covered by the following license notice:
 *
 *   Licensed to the Apache Software Foundation (ASF) under one or more
 *   contributor license agreements. See the NOTICE file distributed
 *   with this work for additional information regarding copyright
 *   ownership. The ASF licenses this file to you under the Apache
 *   License, Version 2.0 (the "License"); you may not use this file
 *   except in compliance with the License. You may obtain a copy of
 *   the License at http://www.apache.org/licenses/LICENSE-2.0 .
 */
#include <string>
#include <vector>

#include "gL10nMem.hxx"

#include "gConvSrc.hxx"
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <sstream>


/*****************************************************************************
 *********************   G C O N S R C W R A P . C X X   *********************
 *****************************************************************************
 * This includes the c code generated by flex
 *****************************************************************************/



/************   I N T E R F A C E   I M P L E M E N T A T I O N   ************/
convert_src::convert_src(l10nMem& crMemory)
                        : convert_gen_impl(crMemory),
                          mbExpectValue(false),
                          mbEnUs(false),
                          mbExpectName(false),
                          mbExpectMacro(false),
                          mbAutoPush(false),
                          mbValuePresent(false),
                          mbInList(false),
                          mbInListItem(false)
{}
convert_src::~convert_src()
{}



/**********************   I M P L E M E N T A T I O N   **********************/
//namespace SrcWrap
//{
//#define IMPLptr convert_gen_impl::mcImpl
//#define LOCptr ((convert_src *)convert_gen_impl::mcImpl)
//#include "gConSrc_yy.c"
//}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_src::execute()
{
//  SrcWrap::yylex();
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_src::setValue(char *syyText, char *sbuildValue)
{
  copySource(syyText);

  if (mbInList && !mbInListItem)
  {
    setListItem("", true);
    setListItem("", false);
  }
  msValue        = sbuildValue;
  mbValuePresent = true;
  mbExpectValue  = false;
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_src::setLang(char *syyText, bool bEnUs)
{
  std::string useText = copySource(syyText) + " is no en-US language";

  mbEnUs = bEnUs;
  if (!bEnUs && mbExpectValue)
      l10nMem::showError(useText);
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_src::setId(char *syyText, bool bId)
{
  copySource(syyText);
  if (bId || !mcStack.back().size())
    mbExpectName = mbAutoPush = true;
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_src::setText(char *syyText)
{
  msTextName    = copySource(syyText);
  mbExpectValue = true;
  mbEnUs        = false;
  trim(msTextName);
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_src::setName(char *syyText)
{
  std::string useText = copySource(syyText);

  trim(useText);
  if (mbExpectName)
  {
    mbExpectName = false;
    if (!mbAutoPush)
      msName = useText;
    else
    {
      mbAutoPush = false;
      if (mcStack.size())
        mcStack.pop_back();
      mcStack.push_back(useText);
    }
  }
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_src::setCmd(char *syyText)
{
  msCmd        = copySource(syyText);
  mbExpectName = true;
  mbInList     = false;
  trim(msCmd);
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_src::setMacro(char *syyText)
{
  msCmd         = copySource(syyText);
  mbExpectName  =
  mbExpectMacro =
  mbAutoPush    = true;
  miMacroLevel  = mcStack.size();
  mcStack.push_back("");
  trim(msCmd);
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_src::setList(char *syyText)
{
  msCmd       = copySource(syyText);
  miListCount = 0;
  mbInList    = true;
  trim(msCmd);
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_src::setNL(char *syyText, bool bMacro)
{
  int         nL;
  std::string sKey;

  copySource(syyText);

  if (msTextName.size() && mbValuePresent && mbEnUs)
  {
    // locate key and extract it
    buildKey(sKey);

    for (nL = -1;;)
    {
      nL = msValue.find("\\\"", nL+1);
      if (nL == (int)std::string::npos)
        break;
      msValue.erase(nL,1);
    }
    for (nL = -1;;)
    {
      nL = msValue.find("\\\\", nL+1);
      if (nL == (int)std::string::npos)
        break;
      msValue.erase(nL,1);
    }

    sKey += "." + msCmd + "." + msTextName;
    if (msValue.size() && msValue != "-")
    {
      mcMemory.setSourceKey(miLineNo, msSourceFile, sKey, msValue, mbMergeMode);
      if (mbMergeMode)
        insertLanguagePart(sKey, msTextName);
    }
  }

  if (!bMacro && mbExpectMacro)
  {
    while ((int)mcStack.size() > miMacroLevel)
      mcStack.pop_back();
    mbEnUs        =
    mbExpectMacro = false;
  }

  mbValuePresent =
  mbExpectName   =
  mbAutoPush     = false;
  msValue.clear();
  msTextName.clear();
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_src::startBlock(char *syyText)
{
  copySource(syyText);

  mcStack.push_back(msName);
  msName.clear();
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_src::stopBlock(char *syyText)
{
  copySource(syyText);

  // check for correct node/prop relations
  if (mcStack.size())
    mcStack.pop_back();

  mbInList =
  mbEnUs   = false;
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_src::setListItem(char const *syyText, bool bIsStart)
{
  copySource(syyText);

  if (bIsStart)
  {
    if (!miListCount)
    {
      mcStack.pop_back();
      msName = "dummy";
      mcStack.push_back(msName);
    }
    msTextName         = "item";
    mbExpectValue =
    mbExpectName  =
    mbInListItem  = true;
    msName.clear();
  }
  else
  {
    if (mbInListItem)
    {
      std::stringstream ssBuf;
      std::string       myKey;


      ++miListCount;
      mcStack.pop_back();
      if (mbExpectName)
      {
        ssBuf  << miListCount;
        msName  = "item" + ssBuf.str();
      }
      mcStack.push_back(msName);
      mbInListItem =
      mbExpectName = false;

      // check key or add seq.
      buildKey(myKey);
    }
  }
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_src::trim(std::string& sText)
{
  int nL;


  while (sText[0] == ' ' || sText[0] == '\t')
    sText.erase(0,1);
  for (nL = sText.size(); sText[nL-1] == ' ' || sText[nL-1] == '\t'; --nL);
  if (nL != (int)sText.size())
    sText.erase(nL);
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_src::buildKey(std::string& sKey)
{
  int nL;


  sKey.clear();
  for (nL = 0; nL < (int)mcStack.size(); ++nL)
    if (mcStack[nL].size())
      sKey += (sKey.size() ? "." : "") + mcStack[nL];
}



/**********************   I M P L E M E N T A T I O N   **********************/
void convert_src::insertLanguagePart(std::string& sKey, std::string& sTextType)
{
  std::string sLang, sText, sTagText;


  // just to please compiler
  sKey = sKey;

  // prepare to read all languages
  mcMemory.prepareMerge();
  for (; mcMemory.getMergeLang(sLang, sText);)
  {
    // Prepare tag start and end
    sTagText = sTextType + "[ " + sLang + " ] = \"" + sText + "\" ;" +
               (mbExpectMacro ? "\\" : "") + "\n";
    writeSourceFile(sTagText);
  }
}
