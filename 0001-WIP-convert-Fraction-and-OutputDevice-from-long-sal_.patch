From 58f03fece40d73bfbe0b13ab6d847f4d915c4e80 Mon Sep 17 00:00:00 2001
From: Noel Grandin <noel@peralex.com>
Date: Tue, 28 Jun 2016 13:19:27 +0200
Subject: [PATCH] WIP convert Fraction and OutputDevice from long->sal_Int64

otherwise, on Windows, the code is using 32-bit integers

Change-Id: Idde0a56f2cd25d7a64d5f7af47b4139f104aa918
---
 include/tools/fract.hxx         |  12 ++---
 include/vcl/outdev.hxx          |  10 ++--
 include/vcl/outdevmap.hxx       |  20 ++++----
 tools/qa/cppunit/test_fract.cxx |   7 ---
 tools/source/generic/fract.cxx  |  35 -------------
 vcl/source/outdev/map.cxx       | 106 ++++++++++++++++++++--------------------
 6 files changed, 72 insertions(+), 118 deletions(-)

diff --git a/include/tools/fract.hxx b/include/tools/fract.hxx
index adecddf..172aea0 100644
--- a/include/tools/fract.hxx
+++ b/include/tools/fract.hxx
@@ -25,29 +25,25 @@
 
 class SvStream;
 
-// This class uses the platform defined type 'long' as valid values but do all
-// calculations using sal_Int64 with checks for 'long' overflows.
 class SAL_WARN_UNUSED TOOLS_DLLPUBLIC Fraction
 {
     struct Impl;
 
     std::unique_ptr<Impl> mpImpl;
 
-    bool            HasOverflowValue();
-
 public:
                     Fraction();
                     Fraction( const Fraction & rFrac );
-                    Fraction( long nNum, long nDen=1 );
+                    Fraction( sal_Int64 nNumerator, sal_Int64 nDenominator=1 );
                     Fraction( double dVal );
                     ~Fraction();
 
     bool            IsValid() const;
 
-    long            GetNumerator() const;
-    long            GetDenominator() const;
+    sal_Int64       GetNumerator() const;
+    sal_Int64       GetDenominator() const;
 
-    operator        long() const;
+    operator        sal_Int64() const;
     operator        double() const;
 
     Fraction&       operator=( const Fraction& rfrFrac );
diff --git a/include/vcl/outdev.hxx b/include/vcl/outdev.hxx
index ff331a5..20f9017 100644
--- a/include/vcl/outdev.hxx
+++ b/include/vcl/outdev.hxx
@@ -1822,7 +1822,7 @@ private:
 
      @returns Device's X pixel coordinate
      */
-    SAL_DLLPRIVATE long         ImplLogicXToDevicePixel( long nX ) const;
+    SAL_DLLPRIVATE sal_Int64     ImplLogicXToDevicePixel( sal_Int64 nX ) const;
 
     /** Convert a logical Y coordinate to a device pixel's Y coordinate.
 
@@ -1835,7 +1835,7 @@ private:
 
      @returns Device's Y pixel coordinate
      */
-    SAL_DLLPRIVATE long         ImplLogicYToDevicePixel( long nY ) const;
+    SAL_DLLPRIVATE sal_Int64     ImplLogicYToDevicePixel( sal_Int64 nY ) const;
 
     /** Convert a logical height to a height in units of device pixels.
 
@@ -1847,7 +1847,7 @@ private:
 
      @returns Height in units of device pixels.
      */
-    SAL_DLLPRIVATE long         ImplLogicHeightToDevicePixel( long nHeight ) const;
+    SAL_DLLPRIVATE sal_Int64     ImplLogicHeightToDevicePixel( sal_Int64 nHeight ) const;
 
     /** Convert device pixels to a width in logical units.
 
@@ -1858,7 +1858,7 @@ private:
 
      @returns Width in logical units.
      */
-    SAL_DLLPRIVATE long         ImplDevicePixelToLogicWidth( long nWidth ) const;
+    SAL_DLLPRIVATE sal_Int64     ImplDevicePixelToLogicWidth( sal_Int64 nWidth ) const;
 
     /** Convert device pixels to a height in logical units.
 
@@ -1869,7 +1869,7 @@ private:
 
      @returns Height in logical units.
      */
-    SAL_DLLPRIVATE long         ImplDevicePixelToLogicHeight( long nHeight ) const;
+    SAL_DLLPRIVATE sal_Int64     ImplDevicePixelToLogicHeight( sal_Int64 nHeight ) const;
 
     /** Convert logical height to device pixels, with exact sub-pixel value.
 
diff --git a/include/vcl/outdevmap.hxx b/include/vcl/outdevmap.hxx
index 05f43c0..89e0bd3 100644
--- a/include/vcl/outdevmap.hxx
+++ b/include/vcl/outdevmap.hxx
@@ -22,12 +22,12 @@
 
 struct ImplMapRes
 {
-    long                mnMapOfsX;          // Offset in X direction
-    long                mnMapOfsY;          // Offset in Y direction
-    long                mnMapScNumX;        // Scaling factor - numerator in X direction
-    long                mnMapScNumY;        // Scaling factor - numerator in Y direction
-    long                mnMapScDenomX;      // Scaling factor - denominator in X direction
-    long                mnMapScDenomY;      // Scaling factor - denominator in Y direction
+    sal_Int64           mnMapOfsX;          // Offset in X direction
+    sal_Int64           mnMapOfsY;          // Offset in Y direction
+    sal_Int64           mnMapScNumX;        // Scaling factor - numerator in X direction
+    sal_Int64           mnMapScNumY;        // Scaling factor - numerator in Y direction
+    sal_Int64           mnMapScDenomX;      // Scaling factor - denominator in X direction
+    sal_Int64           mnMapScDenomY;      // Scaling factor - denominator in Y direction
     double              mfOffsetX;
     double              mfOffsetY;
     double              mfScaleX;
@@ -36,10 +36,10 @@ struct ImplMapRes
 
 struct ImplThresholdRes
 {
-    long                mnThresLogToPixX;   // Thresholds for calculation
-    long                mnThresLogToPixY;   // with BigInts
-    long                mnThresPixToLogX;   // ""
-    long                mnThresPixToLogY;   // ""
+    sal_Int64            mnThresLogToPixX;   // Thresholds for calculation
+    sal_Int64            mnThresLogToPixY;   // with BigInts
+    sal_Int64            mnThresPixToLogX;   // ""
+    sal_Int64            mnThresPixToLogY;   // ""
 };
 
 #endif // INCLUDED_VCL_OUTDEVMAP_HXX
diff --git a/tools/qa/cppunit/test_fract.cxx b/tools/qa/cppunit/test_fract.cxx
index 6352588..febece0 100644
--- a/tools/qa/cppunit/test_fract.cxx
+++ b/tools/qa/cppunit/test_fract.cxx
@@ -96,16 +96,9 @@ public:
         CPPUNIT_ASSERT_EQUAL(1L, f.GetDenominator());
     }
 
-    void testCreateFromDoubleIn32BitsPlatform() {
-        // This pass in 64 bits but fail in 32 bits
-        Fraction f(0.960945);
-        CPPUNIT_ASSERT_EQUAL(true, f.IsValid());
-    }
-
     CPPUNIT_TEST_SUITE(FractionTest);
     CPPUNIT_TEST(testFraction);
     CPPUNIT_TEST(testMinLongDouble);
-    CPPUNIT_TEST(testCreateFromDoubleIn32BitsPlatform);
     CPPUNIT_TEST_SUITE_END();
 };
 
diff --git a/tools/source/generic/fract.cxx b/tools/source/generic/fract.cxx
index 12530c7..88c3d78 100644
--- a/tools/source/generic/fract.cxx
+++ b/tools/source/generic/fract.cxx
@@ -83,8 +83,6 @@ Fraction::Fraction( double dVal ) : mpImpl(new Impl)
     try
     {
         mpImpl->value = rational_FromDouble<sal_Int64>( dVal );
-        if ( HasOverflowValue() )
-            throw boost::bad_rational();
         mpImpl->valid = true;
     }
     catch (const boost::bad_rational&)
@@ -98,15 +96,6 @@ Fraction::~Fraction()
 {
 }
 
-bool Fraction::HasOverflowValue()
-{
-    //coverity[result_independent_of_operands]
-    return mpImpl->value.numerator() < std::numeric_limits<long>::min() ||
-        mpImpl->value.numerator() > std::numeric_limits<long>::max() ||
-        mpImpl->value.denominator() < std::numeric_limits<long>::min() ||
-        mpImpl->value.denominator() > std::numeric_limits<long>::max();
-}
-
 Fraction::operator double() const
 {
     if (!mpImpl->valid)
@@ -135,12 +124,6 @@ Fraction& Fraction::operator += ( const Fraction& rVal )
 
     mpImpl->value += rVal.mpImpl->value;
 
-    if ( HasOverflowValue() )
-    {
-        mpImpl->valid = false;
-        SAL_WARN( "tools.fraction", "'operator +=' detected overflow" );
-    }
-
     return *this;
 }
 
@@ -157,12 +140,6 @@ Fraction& Fraction::operator -= ( const Fraction& rVal )
 
     mpImpl->value -= rVal.mpImpl->value;
 
-    if ( HasOverflowValue() )
-    {
-        mpImpl->valid = false;
-        SAL_WARN( "tools.fraction", "'operator -=' detected overflow" );
-    }
-
     return *this;
 }
 
@@ -179,12 +156,6 @@ Fraction& Fraction::operator *= ( const Fraction& rVal )
 
     mpImpl->value *= rVal.mpImpl->value;
 
-    if ( HasOverflowValue() )
-    {
-        mpImpl->valid = false;
-        SAL_WARN( "tools.fraction", "'operator *=' detected overflow" );
-    }
-
     return *this;
 }
 
@@ -201,12 +172,6 @@ Fraction& Fraction::operator /= ( const Fraction& rVal )
 
     mpImpl->value /= rVal.mpImpl->value;
 
-    if ( HasOverflowValue() )
-    {
-        mpImpl->valid = false;
-        SAL_WARN( "tools.fraction", "'operator /=' detected overflow" );
-    }
-
     return *this;
 }
 
diff --git a/vcl/source/outdev/map.cxx b/vcl/source/outdev/map.cxx
index 871407d..ef121fa 100644
--- a/vcl/source/outdev/map.cxx
+++ b/vcl/source/outdev/map.cxx
@@ -30,9 +30,9 @@
 #include <basegfx/matrix/b2dhommatrix.hxx>
 
 static int const s_ImplArySize = MAP_PIXEL+1;
-static const long aImplNumeratorAry[s_ImplArySize] =
+static const sal_Int64 aImplNumeratorAry[s_ImplArySize] =
     {    1,   1,   5,  50,    1,   1,  1, 1,  1,    1, 1 };
-static const long aImplDenominatorAry[s_ImplArySize] =
+static const sal_Int64 aImplDenominatorAry[s_ImplArySize] =
      { 2540, 254, 127, 127, 1000, 100, 10, 1, 72, 1440, 1 };
 
 /*
@@ -40,7 +40,7 @@ Reduces accuracy until it is a fraction (should become
 ctor fraction once); we could also do this with BigInts
 */
 
-static Fraction ImplMakeFraction( long nN1, long nN2, long nD1, long nD2 )
+static Fraction ImplMakeFraction( sal_Int64 nN1, sal_Int64 nN2, sal_Int64 nD1, sal_Int64 nD2 )
 {
     if( nD1 == 0 || nD2 == 0 ) //under these bad circumstances the following while loop will be endless
     {
@@ -48,7 +48,7 @@ static Fraction ImplMakeFraction( long nN1, long nN2, long nD1, long nD2 )
         return Fraction( 1, 1 );
     }
 
-    long i = 1;
+    sal_Int64 i = 1;
 
     if ( nN1 < 0 ) { i = -i; nN1 = -nN1; }
     if ( nN2 < 0 ) { i = -i; nN2 = -nN2; }
@@ -81,7 +81,7 @@ static Fraction ImplMakeFraction( long nN1, long nN2, long nD1, long nD2 )
 // rMapRes.nMapScNum?
 // rMapRes.nMapScDenom?         > 0
 
-static void ImplCalcBigIntThreshold( long nDPIX, long nDPIY,
+static void ImplCalcBigIntThreshold( sal_Int64 nDPIX, sal_Int64 nDPIY,
                                      const ImplMapRes& rMapRes,
                                      ImplThresholdRes& rThresRes )
 {
@@ -93,9 +93,9 @@ static void ImplCalcBigIntThreshold( long nDPIX, long nDPIY,
     else
     {
         // calculate thresholds for BigInt arithmetic
-        long    nDenomHalfX = rMapRes.mnMapScDenomX / 2;
-        sal_uLong   nDenomX     = rMapRes.mnMapScDenomX;
-        long    nProductX   = nDPIX * rMapRes.mnMapScNumX;
+        sal_Int64    nDenomHalfX = rMapRes.mnMapScDenomX / 2;
+        sal_uLong    nDenomX     = rMapRes.mnMapScDenomX;
+        sal_Int64    nProductX   = nDPIX * rMapRes.mnMapScNumX;
 
         if ( !nProductX )
             rThresRes.mnThresLogToPixX = LONG_MAX;
@@ -118,9 +118,9 @@ static void ImplCalcBigIntThreshold( long nDPIX, long nDPIY,
     else
     {
         // calculate thresholds for BigInt arithmetic
-        long    nDenomHalfY = rMapRes.mnMapScDenomY / 2;
-        sal_uLong   nDenomY     = rMapRes.mnMapScDenomY;
-        long    nProductY   = nDPIY * rMapRes.mnMapScNumY;
+        sal_Int64    nDenomHalfY = rMapRes.mnMapScDenomY / 2;
+        sal_uLong    nDenomY     = rMapRes.mnMapScDenomY;
+        sal_Int64    nProductY   = nDPIY * rMapRes.mnMapScNumY;
 
         if ( !nProductY )
             rThresRes.mnThresLogToPixY = LONG_MAX;
@@ -142,7 +142,7 @@ static void ImplCalcBigIntThreshold( long nDPIX, long nDPIY,
 }
 
 static void ImplCalcMapResolution( const MapMode& rMapMode,
-                                   long nDPIX, long nDPIY, ImplMapRes& rMapRes )
+                                   sal_Int64 nDPIX, sal_Int64 nDPIY, ImplMapRes& rMapRes )
 {
     rMapRes.mfScaleX = 1.0;
     rMapRes.mfScaleY = 1.0;
@@ -282,7 +282,7 @@ static void ImplCalcMapResolution( const MapMode& rMapMode,
                 aX += BigInt( aScaleX.GetNumerator()/2 );
         }
         aX /= BigInt( aScaleX.GetNumerator() );
-        rMapRes.mnMapOfsX = (long)aX + aOrigin.X();
+        rMapRes.mnMapOfsX = (sal_Int64)aX + aOrigin.X();
         BigInt aY( rMapRes.mnMapOfsY );
         aY *= BigInt( aScaleY.GetDenominator() );
         if( rMapRes.mnMapOfsY >= 0 )
@@ -300,7 +300,7 @@ static void ImplCalcMapResolution( const MapMode& rMapMode,
                 aY += BigInt( aScaleY.GetNumerator()/2 );
         }
         aY /= BigInt( aScaleY.GetNumerator() );
-        rMapRes.mnMapOfsY = (long)aY + aOrigin.Y();
+        rMapRes.mnMapOfsY = (sal_Int64)aY + aOrigin.Y();
     }
 
     rMapRes.mfScaleX *= (double)rMapRes.mnMapScNumX * (double)aScaleX.GetNumerator() /
@@ -325,7 +325,7 @@ static void ImplCalcMapResolution( const MapMode& rMapMode,
 }
 
 inline void ImplCalcMapResolution( const MapMode& rMapMode,
-                                   long nDPIX, long nDPIY,
+                                   sal_Int64 nDPIX, sal_Int64 nDPIY,
                                    ImplMapRes& rMapRes,
                                    ImplThresholdRes& rThresRes )
 {
@@ -352,8 +352,8 @@ void OutputDevice::ImplInvalidateViewTransform()
     }
 }
 
-static long ImplLogicToPixel( long n, long nDPI, long nMapNum, long nMapDenom,
-                              long nThres )
+static sal_Int64 ImplLogicToPixel( sal_Int64 n, sal_Int64 nDPI, sal_Int64 nMapNum, sal_Int64 nMapDenom,
+                              sal_Int64 nThres )
 {
     assert(nDPI > 0);
 #if (SAL_TYPES_SIZEOFLONG < 8)
@@ -378,10 +378,10 @@ static long ImplLogicToPixel( long n, long nDPI, long nMapNum, long nMapDenom,
         n64 *= nMapNum;
         n64 *= nDPI;
         if( nMapDenom == 1 )
-            n = (long)n64;
+            n = (sal_Int64)n64;
         else
         {
-            n = (long)(2 * n64 / nMapDenom);
+            n = (sal_Int64)(2 * n64 / nMapDenom);
             if( n < 0 ) --n; else ++n;
             n /= 2;
         }
@@ -389,8 +389,8 @@ static long ImplLogicToPixel( long n, long nDPI, long nMapNum, long nMapDenom,
     return n;
 }
 
-static long ImplPixelToLogic( long n, long nDPI, long nMapNum, long nMapDenom,
-                              long nThres )
+static sal_Int64 ImplPixelToLogic( sal_Int64 n, sal_Int64 nDPI, sal_Int64 nMapNum, sal_Int64 nMapDenom,
+                              sal_Int64 nThres )
 {
     assert(nDPI > 0);
     if (nMapNum == 0)
@@ -407,14 +407,14 @@ static long ImplPixelToLogic( long n, long nDPI, long nMapNum, long nMapDenom,
     {
         sal_Int64 n64 = n;
         n64 *= nMapDenom;
-        long nDenom  = nDPI * nMapNum;
-        n = (long)(2 * n64 / nDenom);
+        sal_Int64 nDenom  = nDPI * nMapNum;
+        n = (sal_Int64)(2 * n64 / nDenom);
     }
     if( n < 0 ) --n; else ++n;
     return (n / 2);
 }
 
-long OutputDevice::ImplLogicXToDevicePixel( long nX ) const
+sal_Int64 OutputDevice::ImplLogicXToDevicePixel( sal_Int64 nX ) const
 {
     if ( !mbMap )
         return nX+mnOutOffX;
@@ -424,7 +424,7 @@ long OutputDevice::ImplLogicXToDevicePixel( long nX ) const
                              maThresRes.mnThresLogToPixX )+mnOutOffX+mnOutOffOrigX;
 }
 
-long OutputDevice::ImplLogicYToDevicePixel( long nY ) const
+sal_Int64 OutputDevice::ImplLogicYToDevicePixel( sal_Int64 nY ) const
 {
     if ( !mbMap )
         return nY+mnOutOffY;
@@ -434,7 +434,7 @@ long OutputDevice::ImplLogicYToDevicePixel( long nY ) const
                              maThresRes.mnThresLogToPixY )+mnOutOffY+mnOutOffOrigY;
 }
 
-long OutputDevice::ImplLogicWidthToDevicePixel( long nWidth ) const
+sal_Int64 OutputDevice::ImplLogicWidthToDevicePixel( sal_Int64 nWidth ) const
 {
     if ( !mbMap )
         return nWidth;
@@ -444,7 +444,7 @@ long OutputDevice::ImplLogicWidthToDevicePixel( long nWidth ) const
                              maThresRes.mnThresLogToPixX );
 }
 
-long OutputDevice::ImplLogicHeightToDevicePixel( long nHeight ) const
+sal_Int64 OutputDevice::ImplLogicHeightToDevicePixel( sal_Int64 nHeight ) const
 {
     if ( !mbMap )
         return nHeight;
@@ -462,7 +462,7 @@ float OutputDevice::ImplFloatLogicHeightToDevicePixel( float fLogicHeight) const
     return fPixelHeight;
 }
 
-long OutputDevice::ImplDevicePixelToLogicWidth( long nWidth ) const
+sal_Int64 OutputDevice::ImplDevicePixelToLogicWidth( sal_Int64 nWidth ) const
 {
     if ( !mbMap )
         return nWidth;
@@ -472,7 +472,7 @@ long OutputDevice::ImplDevicePixelToLogicWidth( long nWidth ) const
                              maThresRes.mnThresPixToLogX );
 }
 
-long OutputDevice::ImplDevicePixelToLogicHeight( long nHeight ) const
+sal_Int64 OutputDevice::ImplDevicePixelToLogicHeight( sal_Int64 nHeight ) const
 {
     if ( !mbMap )
         return nHeight;
@@ -1516,8 +1516,8 @@ static void verifyUnitSourceDest( MapUnit eUnitSource, MapUnit eUnitDest )
 }
 
 #define ENTER3( eUnitSource, eUnitDest )                                \
-    long nNumerator      = 1;       \
-    long nDenominator    = 1;       \
+    sal_Int64 nNumerator      = 1;       \
+    sal_Int64 nDenominator    = 1;       \
     SAL_WARN_IF( eUnitSource >= s_ImplArySize, "vcl", "Invalid source map unit");    \
     SAL_WARN_IF( eUnitDest >= s_ImplArySize, "vcl", "Invalid destination map unit"); \
     if( (eUnitSource < s_ImplArySize) && (eUnitDest < s_ImplArySize) )  \
@@ -1550,11 +1550,11 @@ static void verifyUnitSourceDest( MapUnit eUnitSource, MapUnit eUnitDest )
     ImplCalcMapResolution( rMapModeDest, 72, 72, aMapResDest )
 
 // return (n1 * n2 * n3) / (n4 * n5)
-static long fn5( const long n1,
-                 const long n2,
-                 const long n3,
-                 const long n4,
-                 const long n5 )
+static sal_Int64 fn5( const sal_Int64 n1,
+                 const sal_Int64 n2,
+                 const sal_Int64 n3,
+                 const sal_Int64 n4,
+                 const sal_Int64 n5 )
 {
     if ( n1 == 0 || n2 == 0 || n3 == 0 || n4 == 0 || n5 == 0 )
         return 0;
@@ -1581,7 +1581,7 @@ static long fn5( const long n1,
         } // of if
         else
         {
-            long n8 = n4 * n5;
+            sal_Int64 n8 = n4 * n5;
 
             if ( a7.IsNeg() )
                 a7 -= n8 / 2;
@@ -1590,11 +1590,11 @@ static long fn5( const long n1,
 
             a7 /= n8;
         } // of else
-        return (long)a7;
+        return (sal_Int64)a7;
     } // of if
     else
     {
-        long n6 = n2 * n3;
+        sal_Int64 n6 = n2 * n3;
 
         if ( LONG_MAX / std::abs(n1) < std::abs(n6) )
         {
@@ -1617,7 +1617,7 @@ static long fn5( const long n1,
             } // of if
             else
             {
-                long n8 = n4 * n5;
+                sal_Int64 n8 = n4 * n5;
 
                 if ( a7.IsNeg() )
                     a7 -= n8 / 2;
@@ -1626,11 +1626,11 @@ static long fn5( const long n1,
 
                 a7 /= n8;
             } // of else
-            return (long)a7;
+            return (sal_Int64)a7;
         } // of if
         else
         {
-            long n7 = n1 * n6;
+            sal_Int64 n7 = n1 * n6;
 
             if ( LONG_MAX / std::abs(n4) < std::abs(n5) )
             {
@@ -1646,12 +1646,12 @@ static long fn5( const long n1,
                     a7 += a9;
 
                 a7 /= a8;
-                return (long)a7;
+                return (sal_Int64)a7;
             } // of if
             else
             {
-                const long n8 = n4 * n5;
-                const long n8_2 = n8 / 2;
+                const sal_Int64 n8 = n4 * n5;
+                const sal_Int64 n8_2 = n8 / 2;
 
                 if( n7 < 0 )
                 {
@@ -1668,7 +1668,7 @@ static long fn5( const long n1,
 }
 
 // return (n1 * n2) / n3
-static long fn3( const long n1, const long n2, const long n3 )
+static sal_Int64 fn3( const sal_Int64 n1, const sal_Int64 n2, const sal_Int64 n3 )
 {
     if ( n1 == 0 || n2 == 0 || n3 == 0 )
         return 0;
@@ -1683,12 +1683,12 @@ static long fn3( const long n1, const long n2, const long n3 )
             a4 += n3 / 2;
 
         a4 /= n3;
-        return (long)a4;
+        return (sal_Int64)a4;
     } // of if
     else
     {
-        long        n4 = n1 * n2;
-        const long  n3_2 = n3 / 2;
+        sal_Int64        n4 = n1 * n2;
+        const sal_Int64  n3_2 = n3 / 2;
 
         if( n4 < 0 )
         {
@@ -1918,7 +1918,7 @@ Rectangle OutputDevice::LogicToLogic( const Rectangle& rRectSource,
     }
 }
 
-long OutputDevice::LogicToLogic( long nLongSource,
+sal_Int64 OutputDevice::LogicToLogic( sal_Int64 nLongSource,
                                  MapUnit eUnitSource, MapUnit eUnitDest )
 {
     if ( eUnitSource == eUnitDest )
@@ -1949,7 +1949,7 @@ void OutputDevice::SetPixelOffset( const Size& rOffset )
 
 namespace vcl {
 
-long Window::ImplLogicUnitToPixelX( long nX, MapUnit eUnit )
+sal_Int64 Window::ImplLogicUnitToPixelX( sal_Int64 nX, MapUnit eUnit )
 {
     if ( eUnit != MAP_PIXEL )
     {
@@ -1974,7 +1974,7 @@ long Window::ImplLogicUnitToPixelX( long nX, MapUnit eUnit )
     return nX;
 }
 
-long Window::ImplLogicUnitToPixelY( long nY, MapUnit eUnit )
+sal_Int64 Window::ImplLogicUnitToPixelY( sal_Int64 nY, MapUnit eUnit )
 {
     if ( eUnit != MAP_PIXEL )
     {
@@ -2001,7 +2001,7 @@ long Window::ImplLogicUnitToPixelY( long nY, MapUnit eUnit )
 
 } /* namespace vcl */
 
-DeviceCoordinate OutputDevice::LogicWidthToDeviceCoordinate( long nWidth ) const
+DeviceCoordinate OutputDevice::LogicWidthToDeviceCoordinate( sal_Int64 nWidth ) const
 {
     if ( !mbMap )
         return (DeviceCoordinate)nWidth;
-- 
2.7.4

