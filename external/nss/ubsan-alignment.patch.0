--- nss/lib/freebl/md5.c
+++ nss/lib/freebl/md5.c
@@ -445,7 +445,7 @@
     /* Iterate over 64-byte chunks of the message. */
     while (inputLen >= MD5_BUFFER_SIZE) {
 #ifdef IS_LITTLE_ENDIAN
-#ifdef NSS_X86_OR_X64
+#if 0
         /* x86 can handle arithmetic on non-word-aligned buffers */
         wBuf = (PRUint32 *)input;
 #else
--- nss/lib/freebl/sha_fast.c
+++ nss/lib/freebl/sha_fast.c
@@ -16,7 +16,7 @@
 #include "ssltrace.h"
 #endif
 
-static void shaCompress(volatile SHA_HW_t *X, const PRUint32 *datain);
+static void shaCompress(volatile SHA_HW_t *X, const unsigned char *datain);
 
 #define W u.w
 #define B u.b
@@ -241,7 +241,7 @@
  * code on AMD64.
  */
 static void
-shaCompress(volatile SHA_HW_t *X, const PRUint32 *inbuf)
+shaCompress(volatile SHA_HW_t *X, const unsigned char *inbuf)
 {
     register SHA_HW_t A, B, C, D, E;
 
@@ -277,7 +277,7 @@
     a = SHA_ROTL(b, 5) + SHA_F4(c, d, e) + a + XW(n) + K3; \
     c = SHA_ROTL(c, 30)
 
-#define LOAD(n) XW(n) = SHA_HTONL(inbuf[n])
+#define LOAD(n) XW(n) = (((PRUint32)inbuf[4*n])<<24)|(((PRUint32)inbuf[4*n+1])<<16)|(((PRUint32)inbuf[4*n+2])<<8)|((PRUint32)inbuf[4*n+3])
 
     A = XH(0);
     B = XH(1);
