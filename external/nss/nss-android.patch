--- a/a/nspr/configure
+++ a/a/nspr/configure
@@ -2509,7 +2509,7 @@ MOZ_OPTIMIZE=
 OBJDIR='$(OBJDIR_NAME)'
 OBJDIR_NAME=.
 OBJDIR_SUFFIX=OBJ
-NSINSTALL='$(MOD_DEPTH)/config/$(OBJDIR_NAME)/nsinstall'
+NSINSTALL="/usr/bin/python /home/brainbreaker/AndroidStudioProjects/1NEW/libreoffice/external/nss/nsinstall.py"
 NOSUCHFILE=/no-such-file
 LIBNSPR='-L$(dist_libdir) -lnspr$(MOD_MAJOR_VERSION)'
 LIBPLC='-L$(dist_libdir) -lplc$(MOD_MAJOR_VERSION)'
--- a/a/nss/coreconf/arch.mk
+++ a/a/nss/coreconf/arch.mk
@@ -237,7 +237,7 @@ ifeq ($(OS_TARGET),Android)
    OS_TEST := arm
    OS_ARCH = Android
    ifndef OS_TARGET_RELEASE
-	OS_TARGET_RELEASE := 8
+	OS_TARGET_RELEASE := 15
    endif
 endif

--- a/a/nss/coreconf/config.mk
+++ a/a/nss/coreconf/config.mk
@@ -208,3 +208,7 @@ DEFINES += -DSSL_DISABLE_DEPRECATED_CIPHER_SUITE_NAMES
 # exported symbols, which causes problem when NSS is built as part of Mozilla.
 # So we add a NSS_SSL_ENABLE_ZLIB variable to allow Mozilla to turn this off.
 NSS_SSL_ENABLE_ZLIB = 1
+
+# Define the NATIVE_CC variable. 
+# Without it, "make" tries to compile and link nsinstall with cross compiler and fails
+NATIVE_CC = gcc
\ No newline at end of file
--- a/a/nss/coreconf/Linux.mk
+++ a/a/nss/coreconf/Linux.mk
@@ -33,7 +33,7 @@ endif
 	ANDROID_TARGET=$(ANDROID_PREFIX)-$(ANDROID_TOOLCHAIN_VERSION)
 	# should autodetect which linux we are on, currently android only
 	# supports linux-x86 prebuilts
-	ANDROID_TOOLCHAIN=$(ANDROID_NDK)/toolchains/$(ANDROID_TARGET)/prebuilt/linux-x86
+	ANDROID_TOOLCHAIN=$(ANDROID_NDK)/toolchains/$(ANDROID_TARGET)/prebuilt/linux-x86_64
 	ANDROID_SYSROOT=$(ANDROID_NDK)/platforms/android-$(OS_TARGET_RELEASE)/arch-$(OS_TEST)
 	ANDROID_CC=$(ANDROID_TOOLCHAIN)/bin/$(ANDROID_PREFIX)-gcc
 	ANDROID_CCC=$(ANDROID_TOOLCHAIN)/bin/$(ANDROID_PREFIX)-g++
--- a/a/nss/coreconf/Werror.mk
+++ a/a/nss/coreconf/Werror.mk
@@ -54,7 +54,7 @@ ifndef WARNING_CFLAGS
     ifdef CC_IS_CLANG
       # -Qunused-arguments : clang objects to arguments that it doesn't understand
       #    and fixing this would require rearchitecture
-      WARNING_CFLAGS += -Qunused-arguments
+      # WARNING_CFLAGS += -Qunused-arguments
       # -Wno-parentheses-equality : because clang warns about macro expansions
       WARNING_CFLAGS += $(call disable_warning,parentheses-equality)
       ifdef BUILD_OPT
--- a/a/nspr/config/Makefile.in
+++ a/a/nspr/config/Makefile.in
@@ -26,11 +26,8 @@ RELEASE_BINS	= nspr-config
 
 include $(topsrcdir)/config/config.mk
 
-CSRCS	= now.c
-
 # This version hasn't been ported for us; the one in mozilla/config has
 ifneq ($(OS_ARCH),OS2)
-CSRCS  += nsinstall.c
  
 PLSRCS	= nfspwd.pl
 endif
@@ -76,19 +73,6 @@ endif
 
 include $(topsrcdir)/config/rules.mk
 
-PROGS	= $(OBJDIR)/now$(PROG_SUFFIX)
-
-ifeq (,$(CROSS_COMPILE)$(filter-out OS2 WINNT,$(OS_ARCH)))
-TARGETS = $(PROGS)
-else
-ifeq (,$(filter-out SYMBIAN WINCE,$(OS_ARCH)))
-TARGETS = $(PROGS)
-else
-PROGS	+= $(OBJDIR)/nsinstall$(PROG_SUFFIX)
-TARGETS = $(PROGS) $(PLSRCS:.pl=)
-endif
-endif
-
 OUTOPTION = -o # end of the line
 ifeq (,$(filter-out WINNT WIN95 WINCE,$(OS_TARGET)))
 ifndef NS_USE_GCC
--- a/home/brainbreaker/CppProjects/nss-3.29.5/nss/lib/freebl/unix_rand.c
+++ a/a/nss/lib/freebl/unix_rand.c
@@ -682,134 +682,6 @@ RNG_GetNoise(void *buf, size_t maxbytes)
     return n;
 }
 
-#define SAFE_POPEN_MAXARGS 10 /* must be at least 2 */
-
-/*
- * safe_popen is static to this module and we know what arguments it is
- * called with. Note that this version only supports a single open child
- * process at any time.
- */
-static pid_t safe_popen_pid;
-static struct sigaction oldact;
-
-static FILE *
-safe_popen(char *cmd)
-{
-    int p[2], fd, argc;
-    pid_t pid;
-    char *argv[SAFE_POPEN_MAXARGS + 1];
-    FILE *fp;
-    static char blank[] = " \t";
-    static struct sigaction newact;
-
-    if (pipe(p) < 0)
-        return 0;
-
-    fp = fdopen(p[0], "r");
-    if (fp == 0) {
-        close(p[0]);
-        close(p[1]);
-        return 0;
-    }
-
-    /* Setup signals so that SIGCHLD is ignored as we want to do waitpid */
-    newact.sa_handler = SIG_DFL;
-    newact.sa_flags = 0;
-    sigfillset(&newact.sa_mask);
-    sigaction(SIGCHLD, &newact, &oldact);
-
-    pid = fork();
-    switch (pid) {
-        int ndesc;
-
-        case -1:
-            fclose(fp); /* this closes p[0], the fd associated with fp */
-            close(p[1]);
-            sigaction(SIGCHLD, &oldact, NULL);
-            return 0;
-
-        case 0:
-            /* dup write-side of pipe to stderr and stdout */
-            if (p[1] != 1)
-                dup2(p[1], 1);
-            if (p[1] != 2)
-                dup2(p[1], 2);
-
-            /*
-             * close the other file descriptors, except stdin which we
-             * try reassociating with /dev/null, first (bug 174993)
-             */
-            if (!freopen("/dev/null", "r", stdin))
-                close(0);
-            ndesc = getdtablesize();
-            for (fd = PR_MIN(65536, ndesc); --fd > 2; close(fd))
-                ;
-
-            /* clean up environment in the child process */
-            putenv("PATH=/bin:/usr/bin:/sbin:/usr/sbin:/etc:/usr/etc");
-            putenv("SHELL=/bin/sh");
-            putenv("IFS= \t");
-
-            /*
-             * The caller may have passed us a string that is in text
-             * space. It may be illegal to modify the string
-             */
-            cmd = strdup(cmd);
-            /* format argv */
-            argv[0] = strtok(cmd, blank);
-            argc = 1;
-            while ((argv[argc] = strtok(0, blank)) != 0) {
-                if (++argc == SAFE_POPEN_MAXARGS) {
-                    argv[argc] = 0;
-                    break;
-                }
-            }
-
-            /* and away we go */
-            execvp(argv[0], argv);
-            exit(127);
-            break;
-
-        default:
-            close(p[1]);
-            break;
-    }
-
-    /* non-zero means there's a cmd running */
-    safe_popen_pid = pid;
-    return fp;
-}
-
-static int
-safe_pclose(FILE *fp)
-{
-    pid_t pid;
-    int status = -1, rv;
-
-    if ((pid = safe_popen_pid) == 0)
-        return -1;
-    safe_popen_pid = 0;
-
-    fclose(fp);
-
-    /* yield the processor so the child gets some time to exit normally */
-    PR_Sleep(PR_INTERVAL_NO_WAIT);
-
-    /* if the child hasn't exited, kill it -- we're done with its output */
-    while ((rv = waitpid(pid, &status, WNOHANG)) == -1 && errno == EINTR)
-        ;
-    if (rv == 0) {
-        kill(pid, SIGKILL);
-        while ((rv = waitpid(pid, &status, 0)) == -1 && errno == EINTR)
-            ;
-    }
-
-    /* Reset SIGCHLD signal hander before returning */
-    sigaction(SIGCHLD, &oldact, NULL);
-
-    return status;
-}
-
 #ifdef DARWIN
 #include <TargetConditionals.h>
 #if !TARGET_OS_IPHONE
@@ -817,15 +689,9 @@ safe_pclose(FILE *fp)
 #endif
 #endif
 
-/* Fork netstat to collect its output by default. Do not unset this unless
- * another source of entropy is available
- */
-#define DO_NETSTAT 1
-
 void
 RNG_SystemInfoForRNG(void)
 {
-    FILE *fp;
     char buf[BUFSIZ];
     size_t bytes;
     const char *const *cp;
@@ -860,12 +726,6 @@ RNG_SystemInfoForRNG(void)
     };
 #endif
 
-#if defined(BSDI)
-    static char netstat_ni_cmd[] = "netstat -nis";
-#else
-    static char netstat_ni_cmd[] = "netstat -ni";
-#endif
-
     GiveSystemInfo();
 
     bytes = RNG_GetNoise(buf, sizeof(buf));
@@ -890,7 +750,6 @@ RNG_SystemInfoForRNG(void)
     if (gethostname(buf, sizeof(buf)) == 0) {
         RNG_RandomUpdate(buf, strlen(buf));
     }
-    GiveSystemInfo();
 
     /* grab some data from system's PRNG before any other files. */
     bytes = RNG_FileUpdate("/dev/urandom", SYSTEM_RNG_SEED_COUNT);
@@ -914,33 +773,12 @@ RNG_SystemInfoForRNG(void)
     for (cp = files; *cp; cp++)
         RNG_FileForRNG(*cp);
 
-/*
- * Bug 100447: On BSD/OS 4.2 and 4.3, we have problem calling safe_popen
- * in a pthreads environment.  Therefore, we call safe_popen last and on
- * BSD/OS we do not call safe_popen when we succeeded in getting data
- * from /dev/urandom.
- *
- * Bug 174993: On platforms providing /dev/urandom, don't fork netstat
- * either, if data has been gathered successfully.
- */
-
 #if defined(BSDI) || defined(FREEBSD) || defined(NETBSD) || defined(OPENBSD) || defined(DARWIN) || defined(LINUX) || defined(HPUX)
     if (bytes)
         return;
 #endif
 
 #ifdef SOLARIS
-
-/*
- * On Solaris, NSS may be initialized automatically from libldap in
- * applications that are unaware of the use of NSS. safe_popen forks, and
- * sometimes creates issues with some applications' pthread_atfork handlers.
- * We always have /dev/urandom on Solaris 9 and above as an entropy source,
- * and for Solaris 8 we have the libkstat interface, so we don't need to
- * fork netstat.
- */
-
-#undef DO_NETSTAT
     if (!bytes) {
         /* On Solaris 8, /dev/urandom isn't available, so we use libkstat. */
         PRUint32 kstat_bytes = 0;
@@ -951,15 +789,6 @@ RNG_SystemInfoForRNG(void)
         PORT_Assert(bytes);
     }
 #endif
-
-#ifdef DO_NETSTAT
-    fp = safe_popen(netstat_ni_cmd);
-    if (fp != NULL) {
-        while ((bytes = fread(buf, 1, sizeof(buf), fp)) > 0)
-            RNG_RandomUpdate(buf, bytes);
-        safe_pclose(fp);
-    }
-#endif
 }
 
 #define TOTAL_FILE_LIMIT 1000000 /* one million */
