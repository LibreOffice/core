diff --git a/core/fpdfapi/page/cpdf_colorstate.cpp b/core/fpdfapi/page/cpdf_colorstate.cpp
index 693fcf1..d3e1202 100644
--- a/core/fpdfapi/page/cpdf_colorstate.cpp
+++ b/core/fpdfapi/page/cpdf_colorstate.cpp
@@ -74,6 +74,8 @@ void CPDF_ColorState::SetFillColor(CPDF_ColorSpace* pCS,
                                    uint32_t nValues) {
   ColorData* pData = m_Ref.GetPrivateCopy();
   SetColor(pData->m_FillColor, pData->m_FillRGB, pCS, pValue, nValues);
+  if (pData->m_FillRGB != 0 && pData->m_FillRGB != 0xFFFFFFFF)
+    fprintf(stderr, "COLOR FILL!!!!> %x\n", pData->m_FillRGB);
 }
 
 void CPDF_ColorState::SetStrokeColor(CPDF_ColorSpace* pCS,
@@ -81,6 +83,8 @@ void CPDF_ColorState::SetStrokeColor(CPDF_ColorSpace* pCS,
                                      uint32_t nValues) {
   ColorData* pData = m_Ref.GetPrivateCopy();
   SetColor(pData->m_StrokeColor, pData->m_StrokeRGB, pCS, pValue, nValues);
+  if (pData->m_StrokeRGB != 0 && pData->m_StrokeRGB != 0xFFFFFFFF)
+    fprintf(stderr, "COLOR STROkE!!!!> %x\n", pData->m_StrokeRGB);
 }
 
 void CPDF_ColorState::SetFillPattern(CPDF_Pattern* pPattern,
@@ -99,6 +103,8 @@ void CPDF_ColorState::SetFillPattern(CPDF_Pattern* pPattern,
     }
   }
   pData->m_FillRGB = ret ? FXSYS_RGB(R, G, B) : 0xFFFFFFFF;
+  if (pData->m_FillRGB != 0 && pData->m_FillRGB != 0xFFFFFFFF)
+    fprintf(stderr, "COLOR FILL!!!!> %x\n", pData->m_FillRGB);
 }
 
 void CPDF_ColorState::SetStrokePattern(CPDF_Pattern* pPattern,
@@ -118,13 +124,15 @@ void CPDF_ColorState::SetStrokePattern(CPDF_Pattern* pPattern,
   }
   pData->m_StrokeRGB =
       pData->m_StrokeColor.GetRGB(&R, &G, &B) ? FXSYS_RGB(R, G, B) : 0xFFFFFFFF;
+  if (pData->m_StrokeRGB != 0 && pData->m_StrokeRGB != 0xFFFFFFFF)
+    fprintf(stderr, "COLOR STROkE!!!!> %x\n", pData->m_StrokeRGB);
 }
 
 void CPDF_ColorState::SetColor(CPDF_Color& color,
                                uint32_t& rgb,
                                CPDF_ColorSpace* pCS,
                                float* pValue,
-                               uint32_t nValues) {
+                               uint32_t nValues) const {
   if (pCS)
     color.SetColorSpace(pCS);
   else if (color.IsNull())
diff --git a/core/fpdfapi/page/cpdf_colorstate.h b/core/fpdfapi/page/cpdf_colorstate.h
index 9619051..dbe9c47 100644
--- a/core/fpdfapi/page/cpdf_colorstate.h
+++ b/core/fpdfapi/page/cpdf_colorstate.h
@@ -64,7 +64,7 @@ class CPDF_ColorState {
                 uint32_t& rgb,
                 CPDF_ColorSpace* pCS,
                 float* pValue,
-                uint32_t nValues);
+                uint32_t nValues) const;
 
   SharedCopyOnWrite<ColorData> m_Ref;
 };
diff --git a/core/fpdfapi/page/cpdf_imageobject.cpp b/core/fpdfapi/page/cpdf_imageobject.cpp
index 3b5a740..416d82d 100644
--- a/core/fpdfapi/page/cpdf_imageobject.cpp
+++ b/core/fpdfapi/page/cpdf_imageobject.cpp
@@ -43,6 +43,7 @@ const CPDF_ImageObject* CPDF_ImageObject::AsImage() const {
 void CPDF_ImageObject::CalcBoundingBox() {
   std::tie(m_Left, m_Right, m_Top, m_Bottom) =
       m_Matrix.TransformRect(0.f, 1.f, 1.f, 0.f);
+    // fprintf(stderr, "Image BB: %f, %f, %f, %f\n", m_Left, m_Right, m_Top, m_Bottom);
 }
 
 void CPDF_ImageObject::SetImage(const RetainPtr<CPDF_Image>& pImage) {
diff --git a/core/fpdfapi/page/cpdf_page.cpp b/core/fpdfapi/page/cpdf_page.cpp
index ba93f4a..70d398b 100644
--- a/core/fpdfapi/page/cpdf_page.cpp
+++ b/core/fpdfapi/page/cpdf_page.cpp
@@ -35,12 +35,14 @@ CPDF_Page::CPDF_Page(CPDF_Document* pDocument,
   CFX_FloatRect mediabox = GetBox("MediaBox");
   if (mediabox.IsEmpty())
     mediabox = CFX_FloatRect(0, 0, 612, 792);
+  fprintf(stderr, "Page mediabox: %f, %f, %f, %f\n", mediabox.left, mediabox.right, mediabox.top, mediabox.bottom);
 
   m_BBox = GetBox("CropBox");
   if (m_BBox.IsEmpty())
     m_BBox = mediabox;
   else
     m_BBox.Intersect(mediabox);
+  fprintf(stderr, "Page cropbox: %f, %f, %f, %f\n", m_BBox.left, m_BBox.right, m_BBox.top, m_BBox.bottom);
 
   m_PageSize.width = m_BBox.Width();
   m_PageSize.height = m_BBox.Height();
@@ -48,6 +50,7 @@ CPDF_Page::CPDF_Page(CPDF_Document* pDocument,
   int rotate = GetPageRotation();
   if (rotate % 2)
     std::swap(m_PageSize.width, m_PageSize.height);
+  fprintf(stderr, "Page rotate: %d, Page Width: %f, Page Height: %f\n", rotate, m_PageSize.width, m_PageSize.height);
 
   switch (rotate) {
     case 0:
diff --git a/core/fpdfapi/page/cpdf_pageobject.cpp b/core/fpdfapi/page/cpdf_pageobject.cpp
index 8bb5bf5..9b5e2ce 100644
--- a/core/fpdfapi/page/cpdf_pageobject.cpp
+++ b/core/fpdfapi/page/cpdf_pageobject.cpp
@@ -98,5 +98,7 @@ FX_RECT CPDF_PageObject::GetBBox(const CFX_Matrix* pMatrix) const {
   if (pMatrix)
     rect = pMatrix->TransformRect(rect);
 
+  FX_RECT rc = rect.GetOuterRect();
+  fprintf(stderr, "PageObject BB: %f, %f, %f, %f\n", rc.left, rc.right, rc.top, rc.bottom);
   return rect.GetOuterRect();
 }
diff --git a/core/fpdfapi/page/cpdf_pageobjectlist.cpp b/core/fpdfapi/page/cpdf_pageobjectlist.cpp
index afd2c98..2c8e061 100644
--- a/core/fpdfapi/page/cpdf_pageobjectlist.cpp
+++ b/core/fpdfapi/page/cpdf_pageobjectlist.cpp
@@ -8,6 +8,6 @@
 
 #include "third_party/base/stl_util.h"
 
-CPDF_PageObject* CPDF_PageObjectList::GetPageObjectByIndex(int index) {
+CPDF_PageObject* CPDF_PageObjectList::GetPageObjectByIndex(int index) const {
   return pdfium::IndexInBounds(*this, index) ? (*this)[index].get() : nullptr;
 }
diff --git a/core/fpdfapi/page/cpdf_pageobjectlist.h b/core/fpdfapi/page/cpdf_pageobjectlist.h
index b450537..77c7d81 100644
--- a/core/fpdfapi/page/cpdf_pageobjectlist.h
+++ b/core/fpdfapi/page/cpdf_pageobjectlist.h
@@ -15,7 +15,7 @@ class CPDF_PageObject;
 class CPDF_PageObjectList
     : public std::deque<std::unique_ptr<CPDF_PageObject>> {
  public:
-  CPDF_PageObject* GetPageObjectByIndex(int index);
+  CPDF_PageObject* GetPageObjectByIndex(int index) const;
 };
 
 #endif  // CORE_FPDFAPI_PAGE_CPDF_PAGEOBJECTLIST_H_
diff --git a/core/fpdfapi/render/cpdf_renderstatus.cpp b/core/fpdfapi/render/cpdf_renderstatus.cpp
index 0a01ae0..6947e3a 100644
--- a/core/fpdfapi/render/cpdf_renderstatus.cpp
+++ b/core/fpdfapi/render/cpdf_renderstatus.cpp
@@ -1793,6 +1793,7 @@ bool CPDF_RenderStatus::ProcessText(CPDF_TextObject* textobj,
     return true;
 
   float font_size = textobj->m_TextState.GetFontSize();
+//   fprintf(stderr, "Font size: %f, matrix a: %f, b: %f, c: %f, d: %f, e: %f, f: %f\n", font_size, text_matrix.a, text_matrix.b, text_matrix.c, text_matrix.d, text_matrix.e, text_matrix.f);
   if (bPattern) {
     DrawTextPathWithPattern(textobj, pObj2Device, pFont, font_size,
                             &text_matrix, bFill, bStroke);
diff --git a/core/fxge/cfx_pathdata.cpp b/core/fxge/cfx_pathdata.cpp
index 4ac5cf6..4286de4 100644
--- a/core/fxge/cfx_pathdata.cpp
+++ b/core/fxge/cfx_pathdata.cpp
@@ -199,6 +199,7 @@ void CFX_PathData::Append(const CFX_PathData* pSrc, const CFX_Matrix* pMatrix) {
 void CFX_PathData::AppendPoint(const CFX_PointF& point,
                                FXPT_TYPE type,
                                bool closeFigure) {
+//   fprintf(stderr, "Append: %f, %f (%s)\n", point.x, point.y, closeFigure ? "CLOSE" : "OPEN");
   m_Points.push_back(FX_PATHPOINT(point, type, closeFigure));
 }
 
@@ -290,6 +291,7 @@ CFX_FloatRect CFX_PathData::GetBoundingBox(float line_width,
 void CFX_PathData::Transform(const CFX_Matrix* pMatrix) {
   if (!pMatrix)
     return;
+//   fprintf(stderr, "XForm: %f, %f %f, %f, %f, %f\n", pMatrix->a, pMatrix->b, pMatrix->c, pMatrix->d, pMatrix->e, pMatrix->f);
   for (auto& point : m_Points)
     point.m_Point = pMatrix->Transform(point.m_Point);
 }
diff --git a/fpdfsdk/fpdfeditimg.cpp b/fpdfsdk/fpdfeditimg.cpp
index 0d7ba56..37bdf99 100644
--- a/fpdfsdk/fpdfeditimg.cpp
+++ b/fpdfsdk/fpdfeditimg.cpp
@@ -167,6 +167,26 @@ FPDFImageObj_GetBitmap(FPDF_PAGEOBJECT image_object) {
   return pBitmap.Leak();
 }
 
+FPDF_EXPORT FPDF_BITMAP FPDF_CALLCONV
+FPDFImageObj_GetBitmapBgra(FPDF_PAGEOBJECT image_object) {
+  CPDF_PageObject* pObj = CPDFPageObjectFromFPDFPageObject(image_object);
+  if (!pObj || !pObj->IsImage())
+    return nullptr;
+
+  RetainPtr<CPDF_Image> pImg = pObj->AsImage()->GetImage();
+  if (!pImg)
+    return nullptr;
+
+  RetainPtr<CFX_DIBSource> pSource = pImg->LoadDIBSource();
+  if (!pSource)
+    return nullptr;
+
+  RetainPtr<CFX_DIBitmap> pBitmap;
+  pBitmap = pSource->CloneConvert(FXDIB_Argb);
+
+  return pBitmap.Leak();
+}
+
 FPDF_EXPORT unsigned long FPDF_CALLCONV
 FPDFImageObj_GetImageDataDecoded(FPDF_PAGEOBJECT image_object,
                                  void* buffer,
diff --git a/fpdfsdk/fpdfeditpage.cpp b/fpdfsdk/fpdfeditpage.cpp
index ca2cf3f..832a9ae 100644
--- a/fpdfsdk/fpdfeditpage.cpp
+++ b/fpdfsdk/fpdfeditpage.cpp
@@ -11,12 +11,14 @@
 #include <utility>
 
 #include "core/fpdfapi/edit/cpdf_pagecontentgenerator.h"
+#include "core/fpdfapi/font/cpdf_font.h"
 #include "core/fpdfapi/page/cpdf_form.h"
 #include "core/fpdfapi/page/cpdf_formobject.h"
 #include "core/fpdfapi/page/cpdf_imageobject.h"
 #include "core/fpdfapi/page/cpdf_page.h"
 #include "core/fpdfapi/page/cpdf_pageobject.h"
 #include "core/fpdfapi/page/cpdf_pathobject.h"
+#include "core/fpdfapi/page/cpdf_textobject.h"
 #include "core/fpdfapi/page/cpdf_shadingobject.h"
 #include "core/fpdfapi/parser/cpdf_array.h"
 #include "core/fpdfapi/parser/cpdf_document.h"
@@ -363,3 +365,212 @@ FPDFPageObj_GetBounds(FPDF_PAGEOBJECT pageObject,
   *top = bbox.top;
   return true;
 }
+
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFTextObj_CountChars(FPDF_PAGEOBJECT text_object)
+{
+  if (!text_object)
+    return 0;
+
+  CPDF_TextObject* pTxtObj = CPDFTextObjectFromFPDFPageObject(text_object);
+  return pTxtObj->CountChars();
+}
+
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFTextObj_GetFontSize(FPDF_PAGEOBJECT text_object)
+{
+  if (!text_object)
+    return 0;
+
+  CPDF_TextObject* pTxtObj = CPDFTextObjectFromFPDFPageObject(text_object);
+  return pTxtObj->GetFontSize();
+}
+
+FPDF_EXPORT void FPDF_CALLCONV
+FPDFTextObj_GetMatrix(FPDF_PAGEOBJECT text_object,
+                      double* a,
+                      double* b,
+                      double* c,
+                      double* d,
+                      double* e,
+                      double* f)
+{
+  if (!text_object || !a || !b || !c || !d || !e || !f)
+    return;
+
+  CPDF_TextObject* pTxtObj = CPDFTextObjectFromFPDFPageObject(text_object);
+  const CFX_Matrix& matrix = pTxtObj->GetTextMatrix();
+  *a = matrix.a;
+  *b = matrix.b;
+  *c = matrix.c;
+  *d = matrix.d;
+  *e = matrix.e;
+  *f = matrix.f;
+}
+
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFTextObj_GetUnicode(FPDF_PAGEOBJECT text_object, int index)
+{
+  if (!text_object || index < 0)
+    return 0;
+
+  CPDF_TextObject* pTxtObj = CPDFTextObjectFromFPDFPageObject(text_object);
+  if (index > pTxtObj->CountChars())
+    return 0;
+
+  CPDF_TextObjectItem info;
+  pTxtObj->GetCharInfo(index, &info);
+  return info.m_CharCode;
+}
+
+FPDF_EXPORT int FPDF_CALLCONV FPDFTextObj_GetText(FPDF_PAGEOBJECT text_object,
+                                                  int char_start,
+                                                  int char_count,
+                                                  unsigned short* result) {
+  if (!text_object || char_start < 0 || char_count < 0 || !result)
+    return 0;
+
+  CPDF_TextObject* pTxtObj = CPDFTextObjectFromFPDFPageObject(text_object);
+  int char_available = pTxtObj->CountChars() - char_start;
+  if (char_available <= 0)
+    return 0;
+
+  char_count = std::min(char_count, char_available);
+  if (char_count == 0) {
+    // Writing out "", which has a character count of 1 due to the NUL.
+    *result = '\0';
+    return 1;
+  }
+
+  CPDF_Font* pFont = pTxtObj->GetFont();
+  WideString str;
+  for (uint32_t charcode : pTxtObj->GetCharCodes()) {
+    if (charcode != CPDF_Font::kInvalidCharCode)
+      str += pFont->UnicodeFromCharCode(charcode);
+  }
+
+//   CFX_WideTextBuf m_TextBuf;
+//   WideString str = textpage->GetPageText(char_start, char_count);
+//   return WideString(m_TextBuf.AsStringView().Mid(
+//       static_cast<size_t>(text_start), static_cast<size_t>(text_count)));
+
+//   if (str.GetLength() > static_cast<size_t>(char_count))
+//     str = str.Left(static_cast<size_t>(char_count));
+
+  // Reincode in UTF-16.
+//   WideString str = text.UTF8Decode();
+
+  // UFT16LE_Encode doesn't handle surrogate pairs properly, so it is expected
+  // the number of items to stay the same.
+  ByteString byte_str = str.UTF16LE_Encode();
+  size_t byte_str_len = byte_str.GetLength();
+  int ret_count = byte_str_len / sizeof(unsigned short);
+
+  ASSERT(ret_count <= char_count + 1);  // +1 to account for the NUL terminator.
+  memcpy(result, byte_str.GetBuffer(byte_str_len), byte_str_len);
+  return ret_count;
+}
+
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
+FPDFTextObj_GetColor(FPDF_PAGEOBJECT text_object,
+                     unsigned int* R,
+                     unsigned int* G,
+                     unsigned int* B,
+                     unsigned int* A)
+{
+  CPDF_TextObject* pTxtObj = CPDFTextObjectFromFPDFPageObject(text_object);
+  if (!pTxtObj || !R || !G || !B || !A)
+    return false;
+
+  bool bFill = false;
+  bool bStroke = false;
+  CPDF_Font* pFont = pTxtObj->m_TextState.GetFont();
+  const TextRenderingMode text_render_mode = pTxtObj->m_TextState.GetTextMode();
+  switch (text_render_mode)
+  {
+    case TextRenderingMode::MODE_FILL:
+    case TextRenderingMode::MODE_FILL_CLIP:
+      bFill = true;
+      break;
+    case TextRenderingMode::MODE_STROKE:
+    case TextRenderingMode::MODE_STROKE_CLIP:
+      if (pFont->GetFace())
+        bStroke = true;
+      else
+        bFill = true;
+      break;
+    case TextRenderingMode::MODE_FILL_STROKE:
+    case TextRenderingMode::MODE_FILL_STROKE_CLIP:
+      bFill = true;
+      if (pFont->GetFace())
+        bStroke = true;
+      break;
+    case TextRenderingMode::MODE_INVISIBLE:
+    case TextRenderingMode::MODE_CLIP:
+      return false;
+  }
+
+  const uint32_t RGB = bStroke ? pTxtObj->m_ColorState.GetStrokeRGB() : pTxtObj->m_ColorState.GetFillRGB();
+  *R = FXSYS_GetRValue(RGB);
+  *G = FXSYS_GetGValue(RGB);
+  *B = FXSYS_GetBValue(RGB);
+  *A = static_cast<unsigned int>(
+      (pTxtObj->m_GeneralState.GetStrokeAlpha() * 255.f) + 0.5f);
+
+  return true;
+}
+
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFFormObj_CountSubObjects(FPDF_PAGEOBJECT form_object)
+{
+  CPDF_FormObject* pFrmObj = CPDFFormObjectFromFPDFPageObject(form_object);
+  if (pFrmObj)
+  {
+    const CPDF_PageObjectList* pObjectList = pFrmObj->form()->GetPageObjectList();
+    if (pObjectList)
+        return pObjectList->size();
+  }
+
+  return 0;
+}
+
+FPDF_EXPORT FPDF_PAGEOBJECT FPDF_CALLCONV
+FPDFFormObj_GetSubObject(FPDF_PAGEOBJECT form_object, int index)
+{
+  CPDF_FormObject* pFrmObj = CPDFFormObjectFromFPDFPageObject(form_object);
+  if (pFrmObj)
+  {
+    const CFX_Matrix& matrix = pFrmObj->form_matrix();
+    fprintf(stderr, "Form matrix a: %f, b: %f, c: %f, d: %f, e: %f, f: %f\n", matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
+    const CPDF_PageObjectList* pObjectList = pFrmObj->form()->GetPageObjectList();
+    if (pObjectList)
+        return pObjectList->GetPageObjectByIndex(index);
+  }
+
+  return nullptr;
+}
+
+FPDF_EXPORT void FPDF_CALLCONV
+FPDFFormObj_GetMatrix(FPDF_PAGEOBJECT form_object,
+                      double* a,
+                      double* b,
+                      double* c,
+                      double* d,
+                      double* e,
+                      double* f)
+{
+  if (!form_object || !a || !b || !c || !d || !e || !f)
+    return;
+
+  CPDF_FormObject* pFrmObj = CPDFFormObjectFromFPDFPageObject(form_object);
+  if (pFrmObj)
+  {
+    const CFX_Matrix& matrix = pFrmObj->form_matrix();
+    *a = matrix.a;
+    *b = matrix.b;
+    *c = matrix.c;
+    *d = matrix.d;
+    *e = matrix.e;
+    *f = matrix.f;
+  }
+}
diff --git a/fpdfsdk/fpdfeditpath.cpp b/fpdfsdk/fpdfeditpath.cpp
index a291987..0202284 100644
--- a/fpdfsdk/fpdfeditpath.cpp
+++ b/fpdfsdk/fpdfeditpath.cpp
@@ -101,6 +101,16 @@ FPDFPath_SetStrokeWidth(FPDF_PAGEOBJECT path, float width) {
   return true;
 }
 
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
+FPDFPath_GetStrokeWidth(FPDF_PAGEOBJECT path, float* width) {
+  auto* pPathObj = CPDFPathObjectFromFPDFPageObject(path);
+  if (!pPathObj || !width)
+    return false;
+
+  *width = pPathObj->m_GraphState.GetLineWidth();
+  return true;
+}
+
 FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV FPDFPath_SetFillColor(FPDF_PAGEOBJECT path,
                                                           unsigned int R,
                                                           unsigned int G,
@@ -217,6 +227,25 @@ FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV FPDFPath_SetDrawMode(FPDF_PAGEOBJECT path,
   return true;
 }
 
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV FPDFPath_GetDrawMode(FPDF_PAGEOBJECT path,
+                                                         int* fillmode,
+                                                         FPDF_BOOL* stroke)
+{
+  auto* pPathObj = CPDFPathObjectFromFPDFPageObject(path);
+  if (!pPathObj || !fillmode || !stroke)
+    return false;
+
+  if (pPathObj->m_FillType == FXFILL_ALTERNATE)
+    *fillmode = FPDF_FILLMODE_ALTERNATE;
+  else if (pPathObj->m_FillType == FXFILL_WINDING)
+    *fillmode = FPDF_FILLMODE_WINDING;
+  else
+    *fillmode = 0; // no fill
+
+  *stroke = pPathObj->m_bStroke;
+  return true;
+}
+
 FPDF_EXPORT void FPDF_CALLCONV FPDFPath_SetLineJoin(FPDF_PAGEOBJECT path,
                                                     int line_join) {
   if (!path)
@@ -250,6 +279,30 @@ FPDF_EXPORT void FPDF_CALLCONV FPDFPath_SetLineCap(FPDF_PAGEOBJECT path,
 }
 
 FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
+FPDFPath_GetMatrix(FPDF_PAGEOBJECT path_object,
+                   double* a,
+                   double* b,
+                   double* c,
+                   double* d,
+                   double* e,
+                   double* f)
+{
+  if (!path_object || !a || !b || !c || !d || !e || !f)
+    return false;
+
+  CPDF_PathObject* pPathObj = CPDFPathObjectFromFPDFPageObject(path_object);
+  const CFX_Matrix& pMatrix = pPathObj->m_Matrix;
+  *a = pMatrix.a;
+  *b = pMatrix.b;
+  *c = pMatrix.c;
+  *d = pMatrix.d;
+  *e = pMatrix.e;
+  *f = pMatrix.f;
+
+  return true;
+}
+
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
 FPDFPathSegment_GetPoint(FPDF_PATHSEGMENT segment, float* x, float* y) {
   auto* pPathPoint = FXPathPointFromFPDFPathSegment(segment);
   if (!pPathPoint || !x || !y)
diff --git a/fpdfsdk/fpdftext.cpp b/fpdfsdk/fpdftext.cpp
index 68bf4f8..e073b20 100644
--- a/fpdfsdk/fpdftext.cpp
+++ b/fpdfsdk/fpdftext.cpp
@@ -105,6 +105,28 @@ FPDF_EXPORT double FPDF_CALLCONV FPDFText_GetFontSize(FPDF_TEXTPAGE text_page,
   return charinfo.m_FontSize;
 }
 
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV FPDFText_GetMatrix(FPDF_TEXTPAGE text_page,
+                                                  int index,
+                                                  double* a,
+                                                  double* b,
+                                                  double* c,
+                                                  double* d) {
+  if (!text_page || index < 0)
+    return false;
+
+  CPDF_TextPage* textpage = CPDFTextPageFromFPDFTextPage(text_page);
+  if (index >= textpage->CountChars())
+    return false;
+
+  FPDF_CHAR_INFO charinfo;
+  textpage->GetCharInfo(index, &charinfo);
+  *a = charinfo.m_Matrix.a;
+  *b = charinfo.m_Matrix.b;
+  *c = charinfo.m_Matrix.c;
+  *d = charinfo.m_Matrix.d;
+  return true;
+}
+
 FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV FPDFText_GetCharBox(FPDF_TEXTPAGE text_page,
                                                         int index,
                                                         double* left,
diff --git a/fpdfsdk/fpdfview.cpp b/fpdfsdk/fpdfview.cpp
index e890aa0..b62283f 100644
--- a/fpdfsdk/fpdfview.cpp
+++ b/fpdfsdk/fpdfview.cpp
@@ -336,6 +336,16 @@ CPDF_Page* CPDFPageFromFPDFPage(FPDF_PAGE page) {
 #endif  // PDF_ENABLE_XFA
 }
 
+CPDF_TextObject* CPDFTextObjectFromFPDFPageObject(FPDF_PAGEOBJECT page_object) {
+  auto* obj = CPDFPageObjectFromFPDFPageObject(page_object);
+  return obj ? obj->AsText() : nullptr;
+}
+
+CPDF_FormObject* CPDFFormObjectFromFPDFPageObject(FPDF_PAGEOBJECT page_object) {
+  auto* obj = CPDFPageObjectFromFPDFPageObject(page_object);
+  return obj ? obj->AsForm() : nullptr;
+}
+
 CPDF_PathObject* CPDFPathObjectFromFPDFPageObject(FPDF_PAGEOBJECT page_object) {
   auto* obj = CPDFPageObjectFromFPDFPageObject(page_object);
   return obj ? obj->AsPath() : nullptr;
diff --git a/fpdfsdk/fsdk_define.h b/fpdfsdk/fsdk_define.h
index 77c2315..b61f447 100644
--- a/fpdfsdk/fsdk_define.h
+++ b/fpdfsdk/fsdk_define.h
@@ -25,6 +25,8 @@ class CPDF_Annot;
 class CPDF_Page;
 class CPDF_PageObject;
 class CPDF_PageRenderContext;
+class CPDF_TextObject;
+class CPDF_FormObject;
 class CPDF_PathObject;
 class CPDF_Stream;
 class IFSDK_PAUSE_Adapter;
@@ -65,6 +67,10 @@ FPDF_DOCUMENT FPDFDocumentFromCPDFDocument(CPDF_Document* doc);
 
 CPDF_Page* CPDFPageFromFPDFPage(FPDF_PAGE page);
 
+CPDF_TextObject* CPDFTextObjectFromFPDFPageObject(FPDF_PAGEOBJECT page_object);
+
+CPDF_FormObject* CPDFFormObjectFromFPDFPageObject(FPDF_PAGEOBJECT page_object);
+
 CPDF_PathObject* CPDFPathObjectFromFPDFPageObject(FPDF_PAGEOBJECT page_object);
 
 CPDF_PageObject* CPDFPageObjectFromFPDFPageObject(FPDF_PAGEOBJECT page_object);
diff --git a/public/fpdf_edit.h b/public/fpdf_edit.h
index 54735a3..2e7e2e7 100644
--- a/public/fpdf_edit.h
+++ b/public/fpdf_edit.h
@@ -520,6 +520,15 @@ FPDFPath_GetStrokeColor(FPDF_PAGEOBJECT path,
 FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
 FPDFPath_SetStrokeWidth(FPDF_PAGEOBJECT path, float width);
 
+// Get the stroke width of a path.
+//
+// path   - the handle to the path object.
+// width  - the width of the stroke.
+//
+// Returns TRUE on success
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
+FPDFPath_GetStrokeWidth(FPDF_PAGEOBJECT path, float* width);
+
 // Set the line join of |page_object|.
 //
 // page_object  - handle to a page object.
@@ -688,6 +697,36 @@ FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV FPDFPath_SetDrawMode(FPDF_PAGEOBJECT path,
                                                          int fillmode,
                                                          FPDF_BOOL stroke);
 
+// Get the drawing mode of a path.
+//
+// path     - the handle to the path object.
+// fillmode - the filling mode to be set: 0 for no fill, 1 for alternate, 2 for
+// winding.
+// stroke   - a boolean specifying if the path should be stroked or not.
+//
+// Returns TRUE on success
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV FPDFPath_GetDrawMode(FPDF_PAGEOBJECT path,
+                                                         int* fillmode,
+                                                         FPDF_BOOL* stroke);
+
+// Get the matrix of a particular text object.
+//
+// path_object - Handle of path object returned by FPDFPath_NewPathObj
+//   a            - Pointer to a double value receiving coefficient "a" of the matrix.
+//   b            - Pointer to a double value receiving coefficient "b" of the matrix.
+//   c            - Pointer to a double value receiving coefficient "c" of the matrix.
+//   d            - Pointer to a double value receiving coefficient "d" of the matrix.
+//   e            - Pointer to a double value receiving coefficient "e" of the matrix.
+//   f            - Pointer to a double value receiving coefficient "f" of the matrix.
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
+FPDFPath_GetMatrix(FPDF_PAGEOBJECT path_object,
+                      double* a,
+                      double* b,
+                      double* c,
+                      double* d,
+                      double* e,
+                      double* f);
+
 // Create a new text object using one of the standard PDF fonts.
 //
 // document   - handle to the document.
@@ -761,6 +800,112 @@ FPDFPageObj_CreateTextObj(FPDF_DOCUMENT document,
                           FPDF_FONT font,
                           float font_size);
 
+// Get the number of characters from a text object.
+//
+// text_object - Handle of text object returned by FPDFPageObj_NewTextObj
+//               or FPDFPageObj_NewTextObjEx.
+// Return Value:
+// A character count in the text object.
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFTextObj_CountChars(FPDF_PAGEOBJECT text_object);
+
+
+// Get the font size of a text object.
+//
+// text_object - Handle of text object returned by FPDFPageObj_NewTextObj
+//               or FPDFPageObj_NewTextObjEx.
+//
+// Return Value:
+// The value of the font size
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFTextObj_GetFontSize(FPDF_PAGEOBJECT text_object);
+
+// Get the matrix of a particular text object.
+//
+// text_object - Handle of text object returned by FPDFPageObj_NewTextObj
+//               or FPDFPageObj_NewTextObjEx.
+//   a            - Pointer to a double value receiving coefficient "a" of the matrix.
+//   b            - Pointer to a double value receiving coefficient "b" of the matrix.
+//   c            - Pointer to a double value receiving coefficient "c" of the matrix.
+//   d            - Pointer to a double value receiving coefficient "d" of the matrix.
+//   e            - Pointer to a double value receiving coefficient "e" of the matrix.
+//   f            - Pointer to a double value receiving coefficient "f" of the matrix.
+FPDF_EXPORT void FPDF_CALLCONV
+FPDFTextObj_GetMatrix(FPDF_PAGEOBJECT text_object,
+                      double* a,
+                      double* b,
+                      double* c,
+                      double* d,
+                      double* e,
+                      double* f);
+
+// Get the unicode of a special character in a text object.
+//
+// text_object - Handle of text object returned by FPDFPageObj_NewTextObj
+//               or FPDFPageObj_NewTextObjEx.
+// index - The index of the character to get the unicode.
+// Return Value:
+// The unicode value.
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFTextObj_GetUnicode(FPDF_PAGEOBJECT text_object, int index);
+
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFTextObj_GetText(FPDF_PAGEOBJECT text_object,
+                    int char_start,
+                    int char_count,
+                    unsigned short* result);
+
+// Get the stroke RGBA of a text. Range of values: 0 - 255.
+//
+// path   - the handle to the path object.
+// R      - the red component of the path stroke color.
+// G      - the green component of the path stroke color.
+// B      - the blue component of the path stroke color.
+// A      - the stroke alpha of the path.
+//
+// Returns TRUE on success.
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
+FPDFTextObj_GetColor(FPDF_PAGEOBJECT text_object,
+                     unsigned int* R,
+                     unsigned int* G,
+                     unsigned int* B,
+                     unsigned int* A);
+
+// Get number of page objects inside the form object.
+//
+// form_object - Handle to a form object. Returned by FPDFPage_GetObject.
+// Return value:
+// The number of the page objects.
+FPDF_EXPORT int FPDF_CALLCONV
+FPDFFormObj_CountSubObjects(FPDF_PAGEOBJECT form_object);
+
+// Get the page object from a form object.
+//
+// form_object - Handle to a form object. Returned by FPDFPage_GetObject.
+// index - The index of a page object.
+// Return value:
+// The handle of the page object. Null for failed.
+FPDF_EXPORT FPDF_PAGEOBJECT FPDF_CALLCONV
+FPDFFormObj_GetSubObject(FPDF_PAGEOBJECT form_object, int index);
+
+// Get the matrix of a particular form object.
+//
+// form_object - Handle of form object
+//   a            - Pointer to a double value receiving coefficient "a" of the matrix.
+//   b            - Pointer to a double value receiving coefficient "b" of the matrix.
+//   c            - Pointer to a double value receiving coefficient "c" of the matrix.
+//   d            - Pointer to a double value receiving coefficient "d" of the matrix.
+//   e            - Pointer to a double value receiving coefficient "e" of the matrix.
+//   f            - Pointer to a double value receiving coefficient "f" of the matrix.
+FPDF_EXPORT void FPDF_CALLCONV
+FPDFFormObj_GetMatrix(FPDF_PAGEOBJECT form_object,
+                      double* a,
+                      double* b,
+                      double* c,
+                      double* d,
+                      double* e,
+                      double* f);
+
 #ifdef __cplusplus
 }  // extern "C"
 #endif  // __cplusplus
diff --git a/public/fpdf_text.h b/public/fpdf_text.h
index 043dc16..fe3b971 100644
--- a/public/fpdf_text.h
+++ b/public/fpdf_text.h
@@ -342,6 +342,26 @@ FPDF_EXPORT int FPDF_CALLCONV FPDFText_GetSchCount(FPDF_SCHHANDLE handle);
 //
 FPDF_EXPORT void FPDF_CALLCONV FPDFText_FindClose(FPDF_SCHHANDLE handle);
 
+// Get the matrix of a particular character.
+//
+// text_page - Handle to a text page information structure.
+//             Returned by FPDFText_LoadPage function.
+// index - Zero-based index of the character
+//   a            - Pointer to a double value receiving coefficient "a" of the matrix.
+//   b            - Pointer to a double value receiving coefficient "b" of the matrix.
+//   c            - Pointer to a double value receiving coefficient "c" of the matrix.
+//   d            - Pointer to a double value receiving coefficient "d" of the matrix.
+//
+// Return Value:
+//          On success, return TRUE and fill in |a|, |b|, |c|, and |d|
+FPDF_EXPORT FPDF_BOOL FPDF_CALLCONV
+FPDFText_GetMatrix(FPDF_TEXTPAGE text_page,
+                   int index,
+                   double* a,
+                   double* b,
+                   double* c,
+                   double* d);
+
 // Function: FPDFLink_LoadWebLinks
 //          Prepare information about weblinks in a page.
 // Parameters:
diff --git a/public/fpdfview.h b/public/fpdfview.h
index 35e87ae..80ab0ad 100644
--- a/public/fpdfview.h
+++ b/public/fpdfview.h
@@ -908,6 +908,9 @@ FPDF_EXPORT FPDF_BITMAP FPDF_CALLCONV FPDFBitmap_CreateEx(int width,
 //          function; see the list of such formats above.
 FPDF_EXPORT int FPDF_CALLCONV FPDFBitmap_GetFormat(FPDF_BITMAP bitmap);
 
+FPDF_EXPORT FPDF_BITMAP FPDF_CALLCONV
+FPDFImageObj_GetBitmapBgra(FPDF_PAGEOBJECT image_object);
+
 // Function: FPDFBitmap_FillRect
 //          Fill a rectangle in a bitmap.
 // Parameters:
