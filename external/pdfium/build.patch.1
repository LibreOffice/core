-*- Mode: diff -*-
diff --git a/core/fpdfdoc/cpdf_metadata.cpp b/core/fpdfdoc/cpdf_metadata.cpp
index 31564f45f..5858549ef 100644
--- a/core/fpdfdoc/cpdf_metadata.cpp
+++ b/core/fpdfdoc/cpdf_metadata.cpp
@@ -87,7 +87,7 @@ std::vector<UnsupportedFeature> CPDF_Metadata::CheckForSharedForm() const {
   CFX_XMLParser parser(stream);
   std::unique_ptr<CFX_XMLDocument> doc = parser.Parse();
   if (!doc)
-    return {};
+    return std::vector<UnsupportedFeature>();
 
   std::vector<UnsupportedFeature> unsupported;
   CheckForSharedFormInternal(/*depth=*/0, doc->GetRoot(), &unsupported);
--- a/core/fxge/dib/cfx_cmyk_to_srgb.cpp	2020-09-10 17:32:37.165872018 +0200
+++ b/core/fxge/dib/cfx_cmyk_to_srgb.cpp	2020-09-10 17:33:15.870395738 +0200
@@ -1740,10 +1740,12 @@
   uint8_t y1 = static_cast<int>(y * 255.f + kRoundingOffset);
   uint8_t k1 = static_cast<int>(k * 255.f + kRoundingOffset);
 
+#ifndef _WIN32
   DCHECK_EQ(c1, FXSYS_roundf(c * 255));
   DCHECK_EQ(m1, FXSYS_roundf(m * 255));
   DCHECK_EQ(y1, FXSYS_roundf(y * 255));
   DCHECK_EQ(k1, FXSYS_roundf(k * 255));
+#endif
 
   FX_RGB<uint8_t> int_results = AdobeCMYK_to_sRGB1(c1, m1, y1, k1);
   // Multiply by a constant rather than dividing because division is much
diff --git a/core/fxcodec/jpx/cjpx_decoder.cpp b/core/fxcodec/jpx/cjpx_decoder.cpp
index 2e7a72aa1..65fb3deaa 100644
--- a/core/fxcodec/jpx/cjpx_decoder.cpp
+++ b/core/fxcodec/jpx/cjpx_decoder.cpp
@@ -74,7 +74,7 @@ absl::optional<OpjImageRgbData> alloc_rgb(size_t size) {
   if (!data.b)
     return std::nullopt;
 
-  return data;
+  return std::move(data);
 }
 
 void sycc_to_rgb(int offset,
diff --git a/core/fxcrt/span.h b/core/fxcrt/span.h
index 435fafa85..d8e8bfbc4 100644
--- a/core/fxcrt/span.h
+++ b/core/fxcrt/span.h
@@ -211,7 +211,7 @@ class TRIVIAL_ABI GSL_POINTER span {
 #else
   template <typename Container,
             typename = internal::EnableIfSpanCompatibleContainer<Container, T>>
-  constexpr span(Container& container)
+  span(Container& container)
       : span(container.data(), container.size()) {}
 #endif
 
@@ -225,7 +225,7 @@ class TRIVIAL_ABI GSL_POINTER span {
             size_t M,
             typename R,
             typename = internal::EnableIfLegalSpanConversion<U, T>>
-  constexpr span(const span<U, M, R>& other)
+  span(const span<U, M, R>& other)
       : span(other.data(), other.size()) {}
 
   span& operator=(const span& other) noexcept {
diff --git a/core/fxcrt/numerics/safe_conversions_impl.h b/core/fxcrt/numerics/safe_conversions_impl.h
index 44c921a14..0152a89b7 100644
--- a/core/fxcrt/numerics/safe_conversions_impl.h
+++ b/core/fxcrt/numerics/safe_conversions_impl.h
@@ -89,7 +89,7 @@ constexpr typename std::make_unsigned<T>::type SafeUnsignedAbs(T value) {
 
 // TODO(jschuh): Switch to std::is_constant_evaluated() once C++20 is supported.
 // Alternately, the usage could be restructured for "consteval if" in C++23.
-#define IsConstantEvaluated() (__builtin_is_constant_evaluated())
+#define IsConstantEvaluated() (false)
 
 // TODO(jschuh): Debug builds don't reliably propagate constants, so we restrict
 // some accelerated runtime paths to release builds until this can be forced
diff --git a/third_party/libopenjpeg/openjpeg.c b/third_party/libopenjpeg/openjpeg.c
index 9dd4256d7..949d65830 100644
--- a/third_party/libopenjpeg/openjpeg.c
+++ b/third_party/libopenjpeg/openjpeg.c
@@ -358,7 +358,7 @@ OPJ_BOOL OPJ_CALLCONV opj_setup_decoder(opj_codec_t *p_codec,
     return OPJ_FALSE;
 }
 
-OPJ_API OPJ_BOOL OPJ_CALLCONV opj_decoder_set_strict_mode(opj_codec_t *p_codec,
+OPJ_BOOL OPJ_CALLCONV opj_decoder_set_strict_mode(opj_codec_t *p_codec,
         OPJ_BOOL strict)
 {
     if (p_codec) {
diff --git a/core/fxge/cfx_face.cpp b/core/fxge/cfx_face.cpp
index 7d9cd0f44..0d0a311aa 100644
--- a/core/fxge/cfx_face.cpp
+++ b/core/fxge/cfx_face.cpp
@@ -654,7 +654,7 @@ int CFX_Face::GetCharIndex(uint32_t code) {
 }
 
 int CFX_Face::GetNameIndex(const char* name) {
-  return FT_Get_Name_Index(GetRec(), name);
+  return FT_Get_Name_Index(GetRec(), const_cast<char*>(name));
 }
 
 FX_RECT CFX_Face::GetCharBBox(uint32_t code, int glyph_index) {
