-*- Mode: diff -*-
diff --git a/core/fpdfdoc/cpdf_metadata.cpp b/core/fpdfdoc/cpdf_metadata.cpp
index 31564f45f..5858549ef 100644
--- a/core/fpdfdoc/cpdf_metadata.cpp
+++ b/core/fpdfdoc/cpdf_metadata.cpp
@@ -87,7 +87,7 @@ std::vector<UnsupportedFeature> CPDF_Metadata::CheckForSharedForm() const {
   CFX_XMLParser parser(stream);
   std::unique_ptr<CFX_XMLDocument> doc = parser.Parse();
   if (!doc)
-    return {};
+    return std::vector<UnsupportedFeature>();
 
   std::vector<UnsupportedFeature> unsupported;
   CheckForSharedFormInternal(/*depth=*/0, doc->GetRoot(), &unsupported);
diff --git a/third_party/base/containers/span.h b/third_party/base/containers/span.h
index 435fafa85..d8e8bfbc4 100644
--- a/third_party/base/containers/span.h
+++ b/third_party/base/containers/span.h
@@ -211,7 +211,7 @@ class TRIVIAL_ABI GSL_POINTER span {
 #else
   template <typename Container,
             typename = internal::EnableIfSpanCompatibleContainer<Container, T>>
-  constexpr span(Container& container)
+  span(Container& container)
       : span(container.data(), container.size()) {}
 #endif
 
@@ -225,7 +225,7 @@ class TRIVIAL_ABI GSL_POINTER span {
   // Conversions from spans of compatible types: this allows a span<T> to be
   // seamlessly used as a span<const T>, but not the other way around.
   template <typename U, typename = internal::EnableIfLegalSpanConversion<U, T>>
-  constexpr span(const span<U>& other) : span(other.data(), other.size()) {}
+  span(const span<U>& other) : span(other.data(), other.size()) {}
   span& operator=(const span& other) noexcept {
     if (this != &other) {
       data_ = other.data_;
diff --git a/third_party/base/numerics/safe_conversions_impl.h b/third_party/base/numerics/safe_conversions_impl.h
index 44c921a14..0152a89b7 100644
--- a/third_party/base/numerics/safe_conversions_impl.h
+++ b/third_party/base/numerics/safe_conversions_impl.h
@@ -89,7 +89,7 @@ constexpr typename std::make_unsigned<T>::type SafeUnsignedAbs(T value) {
 
 // TODO(jschuh): Switch to std::is_constant_evaluated() once C++20 is supported.
 // Alternately, the usage could be restructured for "consteval if" in C++23.
-#define IsConstantEvaluated() (__builtin_is_constant_evaluated())
+#define IsConstantEvaluated() (false)
 
 // TODO(jschuh): Debug builds don't reliably propagate constants, so we restrict
 // some accelerated runtime paths to release builds until this can be forced
diff --git a/third_party/libopenjpeg/openjpeg.c b/third_party/libopenjpeg/openjpeg.c
index 9dd4256d7..949d65830 100644
--- a/third_party/libopenjpeg/openjpeg.c
+++ b/third_party/libopenjpeg/openjpeg.c
@@ -358,7 +358,7 @@ OPJ_BOOL OPJ_CALLCONV opj_setup_decoder(opj_codec_t *p_codec,
     return OPJ_FALSE;
 }
 
-OPJ_API OPJ_BOOL OPJ_CALLCONV opj_decoder_set_strict_mode(opj_codec_t *p_codec,
+OPJ_BOOL OPJ_CALLCONV opj_decoder_set_strict_mode(opj_codec_t *p_codec,
         OPJ_BOOL strict)
 {
     if (p_codec) {
diff --git a/core/fxge/cfx_face.cpp b/core/fxge/cfx_face.cpp
index 7d9cd0f44..0d0a311aa 100644
--- a/core/fxge/cfx_face.cpp
+++ b/core/fxge/cfx_face.cpp
@@ -654,7 +654,7 @@ int CFX_Face::GetCharIndex(uint32_t code) {
 }
 
 int CFX_Face::GetNameIndex(const char* name) {
-  return FT_Get_Name_Index(GetRec(), name);
+  return FT_Get_Name_Index(GetRec(), const_cast<char*>(name));
 }
 
 FX_RECT CFX_Face::GetCharBBox(uint32_t code, int glyph_index) {
