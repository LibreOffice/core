-*- Mode: diff -*-
diff --git a/core/fpdfdoc/cpdf_metadata.cpp b/core/fpdfdoc/cpdf_metadata.cpp
index 31564f45f..5858549ef 100644
--- a/core/fpdfdoc/cpdf_metadata.cpp
+++ b/core/fpdfdoc/cpdf_metadata.cpp
@@ -87,7 +87,7 @@ std::vector<UnsupportedFeature> CPDF_Metadata::CheckForSharedForm() const {
   CFX_XMLParser parser(stream);
   std::unique_ptr<CFX_XMLDocument> doc = parser.Parse();
   if (!doc)
-    return {};
+    return std::vector<UnsupportedFeature>();
 
   std::vector<UnsupportedFeature> unsupported;
   CheckForSharedFormInternal(/*depth=*/0, doc->GetRoot(), &unsupported);
--- a/core/fxge/dib/cfx_cmyk_to_srgb.cpp	2020-09-10 17:32:37.165872018 +0200
+++ b/core/fxge/dib/cfx_cmyk_to_srgb.cpp	2020-09-10 17:33:15.870395738 +0200
@@ -1740,10 +1740,12 @@
   uint8_t y1 = static_cast<int>(y * 255.f + kRoundingOffset);
   uint8_t k1 = static_cast<int>(k * 255.f + kRoundingOffset);
 
+#ifndef _WIN32
   DCHECK_EQ(c1, FXSYS_roundf(c * 255));
   DCHECK_EQ(m1, FXSYS_roundf(m * 255));
   DCHECK_EQ(y1, FXSYS_roundf(y * 255));
   DCHECK_EQ(k1, FXSYS_roundf(k * 255));
+#endif
 
   FX_RGB_STRUCT<uint8_t> int_results = AdobeCMYK_to_sRGB1(c1, m1, y1, k1);
   // Multiply by a constant rather than dividing because division is much
diff --git a/core/fxcodec/jpx/cjpx_decoder.cpp b/core/fxcodec/jpx/cjpx_decoder.cpp
index 2e7a72aa1..65fb3deaa 100644
--- a/core/fxcodec/jpx/cjpx_decoder.cpp
+++ b/core/fxcodec/jpx/cjpx_decoder.cpp
@@ -74,7 +74,7 @@ absl::optional<OpjImageRgbData> alloc_rgb(size_t size) {
   if (!data.b)
     return std::nullopt;
 
-  return data;
+  return std::move(data);
 }
 
 void sycc_to_rgb(int offset,
diff --git a/core/fxcrt/span.h b/core/fxcrt/span.h
index 435fafa85..d8e8bfbc4 100644
--- a/core/fxcrt/span.h
+++ b/core/fxcrt/span.h
@@ -211,7 +211,7 @@ class TRIVIAL_ABI GSL_POINTER span {
 #else
   template <typename Container,
             typename = internal::EnableIfSpanCompatibleContainer<Container, T>>
-  constexpr span(Container& container)
+  span(Container& container)
       // SAFETY: `size()` is the number of elements that can be safely accessed
       // at `data()`.
       : UNSAFE_BUFFERS(span(container.data(), container.size())) {}
 #endif
 
@@ -225,7 +225,7 @@ class TRIVIAL_ABI GSL_POINTER span {
             size_t M,
             typename R,
             typename = internal::EnableIfLegalSpanConversion<U, T>>
-  constexpr span(const span<U, M, R>& other)
+  span(const span<U, M, R>& other)
       // SAFETY: `size()` is the number of elements that can be safely accessed
       // at `data()`.
       : UNSAFE_BUFFERS(span(other.data(), other.size())) {}
diff --git a/core/fxcrt/numerics/safe_conversions_impl.h b/core/fxcrt/numerics/safe_conversions_impl.h
index 44c921a14..0152a89b7 100644
--- a/core/fxcrt/numerics/safe_conversions_impl.h
+++ b/core/fxcrt/numerics/safe_conversions_impl.h
@@ -89,7 +89,7 @@ constexpr typename std::make_unsigned<T>::type SafeUnsignedAbs(T value) {
 
 // TODO(jschuh): Switch to std::is_constant_evaluated() once C++20 is supported.
 // Alternately, the usage could be restructured for "consteval if" in C++23.
-#define IsConstantEvaluated() (__builtin_is_constant_evaluated())
+#define IsConstantEvaluated() (false)
 
 // TODO(jschuh): Debug builds don't reliably propagate constants, so we restrict
 // some accelerated runtime paths to release builds until this can be forced
diff --git a/core/fxge/cfx_face.cpp b/core/fxge/cfx_face.cpp
index 7d9cd0f44..0d0a311aa 100644
--- a/core/fxge/cfx_face.cpp
+++ b/core/fxge/cfx_face.cpp
@@ -654,7 +654,7 @@ int CFX_Face::GetCharIndex(uint32_t code) {
 }
 
 int CFX_Face::GetNameIndex(const char* name) {
-  return FT_Get_Name_Index(GetRec(), name);
+  return FT_Get_Name_Index(GetRec(), const_cast<char*>(name));
 }
 
 FX_RECT CFX_Face::GetCharBBox(uint32_t code, int glyph_index) {
diff --git a/core/fpdfdoc/cpdf_action.cpp b/core/fpdfdoc/cpdf_action.cpp
index a5b687d76..076a260d5 100644
--- a/core/fpdfdoc/cpdf_action.cpp
+++ b/core/fpdfdoc/cpdf_action.cpp
@@ -21,7 +21,7 @@
 
 namespace {
 
-constexpr auto kActionTypeStrings = fxcrt::ToArray<const char*>({
+std::array<const char*, 18> kActionTypeStrings = {
     "GoTo",
     "GoToR",
     "GoToE",
@@ -40,7 +40,7 @@ constexpr auto kActionTypeStrings = fxcrt::ToArray<const char*>({
     "Rendition",
     "Trans",
     "GoTo3DView",
-});
+};
 
 }  // namespace
 
diff --git a/core/fpdfdoc/cpdf_dest.cpp b/core/fpdfdoc/cpdf_dest.cpp
index 8026a75d5..34c20d62f 100644
--- a/core/fpdfdoc/cpdf_dest.cpp
+++ b/core/fpdfdoc/cpdf_dest.cpp
@@ -21,12 +21,12 @@ namespace {
 
 // These arrays are indexed by the PDFDEST_VIEW_* constants.
 
-constexpr auto kZoomModes =
-    fxcrt::ToArray<const char*>({"Unknown", "XYZ", "Fit", "FitH", "FitV",
-                                 "FitR", "FitB", "FitBH", "FitBV"});
+std::array<const char*, 9>  kZoomModes = {
+    "Unknown", "XYZ", "Fit", "FitH", "FitV",
+                                 "FitR", "FitB", "FitBH", "FitBV"};
 
-constexpr auto kZoomModeMaxParamCount =
-    fxcrt::ToArray<const uint8_t>({0, 3, 0, 1, 1, 4, 0, 1, 1});
+std::array<const uint8_t, 9> kZoomModeMaxParamCount =
+    {0, 3, 0, 1, 1, 4, 0, 1, 1};
 
 }  // namespace
 
--- pdfium/fpdfsdk/fpdf_annot.cpp.orig	2024-08-15 10:01:30.443712200 +0200
+++ pdfium/fpdfsdk/fpdf_annot.cpp	2024-08-15 10:04:41.161274500 +0200
@@ -1079,8 +1079,8 @@
   if (appearanceMode < 0 || appearanceMode >= FPDF_ANNOT_APPEARANCEMODE_COUNT)
     return false;
 
-  static constexpr auto kModeKeyForMode =
-      fxcrt::ToArray<const char*>({"N", "R", "D"});
+  static constexpr std::array<const char*, 3UL> kModeKeyForMode
+      ({"N", "R", "D"});
   static_assert(kModeKeyForMode.size() == FPDF_ANNOT_APPEARANCEMODE_COUNT,
                 "length of kModeKeyForMode should be equal to "
                 "FPDF_ANNOT_APPEARANCEMODE_COUNT");
--- a/core/fxcrt/fx_memory_wrappers.h	2025-02-13 13:38:35.761778900 +0100
+++ b/core/fxcrt/fx_memory_wrappers.h	2025-02-13 13:38:48.136654800 +0100
@@ -33,9 +33,6 @@
 template <class T, void* Alloc(size_t, size_t), void Free(void*)>
 struct FxPartitionAllocAllocator {
  public:
-  static_assert(std::is_arithmetic<T>::value || std::is_enum<T>::value ||
-                    IsFXDataPartitionException<T>::value,
-                "Only numeric types allowed in this partition");
 
   using value_type = T;
   using pointer = T*;
