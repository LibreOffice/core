diff -ur boost.org/boost/property_tree/detail/json_parser_write.hpp boost/boost/property_tree/detail/json_parser_write.hpp
--- boost.org/boost/property_tree/detail/json_parser_write.hpp	2014-04-17 19:05:33.977738507 +0300
+++ boost/boost/property_tree/detail/json_parser_write.hpp	2014-04-17 19:05:43.497738685 +0300
@@ -27,27 +27,28 @@
         std::basic_string<Ch> result;
         typename std::basic_string<Ch>::const_iterator b = s.begin();
         typename std::basic_string<Ch>::const_iterator e = s.end();
+        typename std::basic_string<Ch>::traits_type::int_type bDref = *b;
         while (b != e)
         {
             // This assumes an ASCII superset. But so does everything in PTree.
             // We escape everything outside ASCII, because this code can't
             // handle high unicode characters.
-            if (*b == 0x20 || *b == 0x21 || (*b >= 0x23 && *b <= 0x2E) ||
-                (*b >= 0x30 && *b <= 0x5B) || (*b >= 0x5D && static_cast<typename std::basic_string<Ch>::traits_type::int_type>(*b) <= 0xFF))
-                result += *b;
-            else if (*b == Ch('\b')) result += Ch('\\'), result += Ch('b');
-            else if (*b == Ch('\f')) result += Ch('\\'), result += Ch('f');
-            else if (*b == Ch('\n')) result += Ch('\\'), result += Ch('n');
-            else if (*b == Ch('\r')) result += Ch('\\'), result += Ch('r');
-            else if (*b == Ch('/')) result += Ch('\\'), result += Ch('/');
-            else if (*b == Ch('"'))  result += Ch('\\'), result += Ch('"');
-            else if (*b == Ch('\\')) result += Ch('\\'), result += Ch('\\');
+            if (bDref == 0x20 || bDref == 0x21 || (bDref >= 0x23 && bDref <= 0x2E) ||
+                (bDref >= 0x30 && bDref <= 0x5B) || (bDref >= 0x5D && static_cast<typename std::basic_string<Ch>::traits_type::int_type>(bDref) <= 0xFF))
+                result += bDref;
+            else if (bDref == Ch('\b')) result += Ch('\\'), result += Ch('b');
+            else if (bDref == Ch('\f')) result += Ch('\\'), result += Ch('f');
+            else if (bDref == Ch('\n')) result += Ch('\\'), result += Ch('n');
+            else if (bDref == Ch('\r')) result += Ch('\\'), result += Ch('r');
+            else if (bDref == Ch('/')) result += Ch('\\'), result += Ch('/');
+            else if (bDref == Ch('"'))  result += Ch('\\'), result += Ch('"');
+            else if (bDref == Ch('\\')) result += Ch('\\'), result += Ch('\\');
             else
             {
                 const char *hexdigits = "0123456789ABCDEF";
                 typedef typename make_unsigned<Ch>::type UCh;
                 unsigned long u = (std::min)(static_cast<unsigned long>(
-                                                 static_cast<UCh>(*b)),
+                                                 static_cast<UCh>(bDref)),
                                              0xFFFFul);
                 int d1 = u / 4096; u -= d1 * 4096;
                 int d2 = u / 256; u -= d2 * 256;
