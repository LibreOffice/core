Use newer API to get the Windows fonts directory, and convert from
UTF-16 to UTF-8, assuming that the returned pathname will be treated
as UTF-8 anyway, and converted to UTF-16 before opening fonts in it
etc.

But probaly fontconfig asumes system codepage for pathnames it uses on
Windows all over the place anyway, so things are really messed up. Oh
well.

--- src/fcint.h
+++ src/fcint.h
@@ -69,9 +69,7 @@
 
 #ifdef _WIN32
 #  include "fcwindows.h"
-typedef UINT (WINAPI *pfnGetSystemWindowsDirectory) (LPSTR, UINT);
 typedef HRESULT (WINAPI *pfnSHGetFolderPathA) (HWND, int, HANDLE, DWORD, LPSTR);
-extern pfnGetSystemWindowsDirectory pGetSystemWindowsDirectory;
 extern pfnSHGetFolderPathA          pSHGetFolderPathA;
 #  define FC_SEARCH_PATH_SEPARATOR ';'
 #  define FC_DIR_SEPARATOR         '\\'
--- src/fcxml.c
+++ src/fcxml.c
@@ -58,8 +58,9 @@
 
 #ifdef _WIN32
 #  include <mbstring.h>
+#  include <wchar.h>
+#  include <Shlobj.h>
 extern FcChar8               fontconfig_instprefix[];
-pfnGetSystemWindowsDirectory pGetSystemWindowsDirectory = NULL;
 pfnSHGetFolderPathA          pSHGetFolderPathA = NULL;
 static void
 _ensureWin32GettersReady ();
@@ -1386,17 +1387,23 @@
 	}
 	strcat ((char *)path, "\\Microsoft\\Windows\\Fonts");
     } else if (strcmp ((const char *)path, "WINDOWSFONTDIR") == 0) {
-	int rc;
-	path = buffer;
-	_ensureWin32GettersReady();
-	rc = pGetSystemWindowsDirectory ((LPSTR)buffer, sizeof (buffer) - 20);
-	if (rc == 0 || rc > sizeof (buffer) - 20) {
+	wchar_t *wpath;
+	int size_needed;
+	
+	if (!SUCCEEDED(SHGetKnownFolderPath(&FOLDERID_Fonts, 0, NULL, &wpath))) {
-	    FcConfigMessage (parse, FcSevereError, "GetSystemWindowsDirectory failed");
+	    FcConfigMessage (parse, FcSevereError, "SHGetKnownFolderPath for FOLDERID_Fonts failed");
 	    return NULL;
 	}
-	if (path[strlen ((const char *)path) - 1] != '\\')
-	    strcat ((char *)path, "\\");
-	strcat ((char *)path, "fonts");
+	/* We assume that the code using fontconfig handles UTF-8 strings and not system codepage */
+	size_needed = WideCharToMultiByte (CP_UTF8, 0, wpath, wcslen(wpath), NULL, 0, NULL, NULL);
+	if (size_needed <= 0 || size_needed > sizeof(buffer)) {
+	    FcConfigMessage (parse, FcSevereError, "WideCharToMultiByte failed");
+	    CoTaskMemFree (wpath);
+	    return NULL;
+	}
+	path = buffer;
+	WideCharToMultiByte(CP_UTF8, 0, wpath, wcslen(wpath), path, size_needed, NULL, NULL);
+	CoTaskMemFree (wpath);
     } else {
 	if (!prefix) {
 	    if (!FcStrIsAbsoluteFilename (path) && path[0] != '~')
@@ -3488,11 +3488,6 @@
 static void
 _ensureWin32GettersReady ()
 {
-    if (!pGetSystemWindowsDirectory) {
-	HMODULE hk32 = GetModuleHandleA ("kernel32.dll");
-	if (!(pGetSystemWindowsDirectory = (pfnGetSystemWindowsDirectory)GetProcAddress (hk32, "GetSystemWindowsDirectoryA")))
-	    pGetSystemWindowsDirectory = (pfnGetSystemWindowsDirectory)GetWindowsDirectory;
-    }
     if (!pSHGetFolderPathA) {
 	HMODULE hSh = LoadLibraryA ("shfolder.dll");
 	/* the check is done later, because there is no provided fallback */
