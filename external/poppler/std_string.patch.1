remove C++20 starts_with

--- poppler/goo/GooString.h.orig	2025-01-09 11:15:13.174300578 +0100
+++ poppler/goo/GooString.h	2025-01-09 11:17:39.568825610 +0100
@@ -237,11 +237,16 @@
     int cmp(const char *sA) const { return compare(sA); }
     int cmpN(const char *sA, int n) const { return compare(0, n, sA); }
 
-    // Return true if strings starts with prefix
-    using std::string::starts_with;
-
-    // Return true if string ends with suffix
-    using std::string::ends_with;
+    bool starts_with(const char *prefix) const
+    {
+        return startsWith(toStr(), prefix);
+    }
+    bool ends_with(const char *suffix) const
+    {
+        return endsWith(toStr(), suffix);
+    }
+    static bool startsWith(std::string_view str, std::string_view prefix) { return str.size() >= prefix.size() && 0 == str.compare(0, prefix.size(), prefix); }
+    static bool endsWith(std::string_view str, std::string_view suffix) { return str.size() >= suffix.size() && 0 == str.compare(str.size() - suffix.size(), suffix.size(), suffix); }
 };
 
 #endif
--- poppler/poppler/UTF.h.orig	2025-01-09 11:25:36.593385806 +0100
+++ poppler/poppler/UTF.h	2025-01-09 11:25:30.852367770 +0100
@@ -54,13 +54,13 @@
 // check whether string starts with Big-Endian byte order mark
 inline bool hasUnicodeByteOrderMark(const std::string &s)
 {
-    return s.starts_with(unicodeByteOrderMark);
+    return s.size() >= unicodeByteOrderMark.size() && 0 == s.compare(0, unicodeByteOrderMark.size(), unicodeByteOrderMark);
 }
 
 // check whether string starts with Little-Endian byte order mark
 inline bool hasUnicodeByteOrderMarkLE(const std::string &s)
 {
-    return s.starts_with(unicodeByteOrderMarkLE);
+    return s.size() >= unicodeByteOrderMarkLE.size() && 0 == s.compare(0, unicodeByteOrderMarkLE.size(), unicodeByteOrderMarkLE);
 }
 
 // put big-endian unicode byte order mark at the beginning of a string
--- poppler/poppler/GlobalParams.cc.orig	2025-01-09 11:26:46.850606552 +0100
+++ poppler/poppler/GlobalParams.cc	2025-01-09 11:29:28.030112935 +0100
@@ -903,7 +903,7 @@
 
 static bool supportedFontForEmbedding(Unicode uChar, const char *filepath, int faceIndex)
 {
-    if (!std::string_view(filepath).ends_with(".ttf") && !std::string_view(filepath).ends_with(".ttc") && !std::string_view(filepath).ends_with(".otf")) {
+    if (!GooString::endsWith(std::string_view(filepath), ".ttf") && !GooString::endsWith(std::string_view(filepath), ".ttc") && !GooString::endsWith(std::string_view(filepath), ".otf")) {
         // for now we only support ttf, ttc, otf fonts
         return false;
     }
--- poppler/poppler/Form.cc.orig2	2025-01-09 11:33:42.284911742 +0100
+++ poppler/poppler/Form.cc	2025-01-09 11:34:46.013111945 +0100
@@ -2818,7 +2818,7 @@
     const Dict *fontDict = fontDictObj.getDict();
     for (int i = 0; i < fontDict->getLength(); ++i) {
         const char *key = fontDict->getKey(i);
-        if (std::string_view(key).starts_with(kOurDictFontNamePrefix)) {
+        if (GooString::startsWith(std::string_view(key), kOurDictFontNamePrefix)) {
             const Object fontObj = fontDict->getVal(i);
             if (fontObj.isDict() && fontObj.dictIs("Font")) {
                 const Object fontBaseFontObj = fontObj.dictLookup("BaseFont");
--- poppler/poppler/PSOutputDev.cc.orig	2025-01-09 12:21:50.100540341 +0100
+++ poppler/poppler/PSOutputDev.cc	2025-01-09 12:21:52.004545519 +0100
@@ -7482,7 +7482,7 @@
     //   for the keyword, which was emitted by the caller)
     // - lines that start with a left paren are treated as <text>
     //   instead of <textline>, so we escape a leading paren
-    if (s.starts_with(unicodeByteOrderMark)) {
+    if (GooString::startsWith(s, unicodeByteOrderMark)) {
         i = 3;
         step = 2;
     } else {
--- poppler/poppler/GfxFont.cc.orig2	2025-01-09 15:28:44.912394819 +0100
+++ poppler/poppler/GfxFont.cc	2025-01-09 15:29:01.903477753 +0100
@@ -1085,7 +1085,7 @@
     baseEnc = nullptr;
     baseEncFromFontFile = false;
     obj1 = fontDict->lookup("Encoding");
-    bool isZapfDingbats = name && name->ends_with("ZapfDingbats");
+    bool isZapfDingbats = name && GooString::endsWith(*name, "ZapfDingbats");
     if (isZapfDingbats) {
         baseEnc = zapfDingbatsEncoding;
         hasEncoding = true;
--- poppler/poppler/UTF.h.orig2	2025-01-09 15:46:59.275299177 +0100
+++ poppler/poppler/UTF.h	2025-01-09 15:47:32.502434901 +0100
@@ -74,7 +74,7 @@
 // check whether string starts with Big-Endian byte order mark and string length is even
 inline bool hasUnicodeByteOrderMarkAndLengthIsEven(const std::string &s)
 {
-    return s.starts_with(unicodeByteOrderMark) && s.length() % 2 == 0;
+    return hasUnicodeByteOrderMark(s) && s.length() % 2 == 0;
 }
 
 // is a unicode whitespace character
--- poppler/poppler/GlobalParamsWin.cc.orig	2025-01-10 09:54:56.256775789 +0100
+++ poppler/poppler/GlobalParamsWin.cc	2025-01-10 09:55:02.001792823 +0100
@@ -488,7 +488,7 @@
             path = fontFile->second;
             if (substituteFontName)
                 substituteFontName->Set(path.c_str());
-            if (path.ends_with(".ttc")) {
+            if (GooString::endsWith(path, ".ttc")) {
                 *type = sysFontTTC;
             } else {
                 *type = sysFontTTF;
