From 1393bd64581d6010a65d368e1031641391bdb154 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Caol=C3=A1n=20McNamara?= <caolanm@redhat.com>
Date: Mon, 23 Jan 2017 14:30:13 +0000
Subject: [PATCH 1/2] use a per-hashmgr persistent wide string scratch buffer

kcachegrind reports 894,015,631 -> 845,183,693
---
 src/hunspell/hashmgr.cxx | 40 ++++++++++++++++++----------------------
 src/hunspell/hashmgr.hxx |  1 +
 2 files changed, 19 insertions(+), 22 deletions(-)

diff --git a/src/hunspell/hashmgr.cxx b/src/hunspell/hashmgr.cxx
index 6d92e9b..8d6189b 100644
--- a/src/hunspell/hashmgr.cxx
+++ b/src/hunspell/hashmgr.cxx
@@ -345,11 +345,10 @@ int HashMgr::add_hidden_capitalized_word(const std::string& word,
     flags2[flagslen] = ONLYUPCASEFLAG;
     if (utf8) {
       std::string st;
-      wide::string w;
-      u8_u16(w, word);
-      mkallsmall_utf(w, langnum);
-      mkinitcap_utf(w, langnum);
-      u16_u8(st, w);
+      u8_u16(workbuf, word);
+      mkallsmall_utf(workbuf, langnum);
+      mkinitcap_utf(workbuf, langnum);
+      u16_u8(st, workbuf);
       return add_word(st, wcl, flags2, flagslen + 1, dp, true);
     } else {
       std::string new_word(word);
@@ -366,9 +365,8 @@ int HashMgr::add_hidden_capitalized_word(const std::string& word,
 int HashMgr::get_clen_and_captype(const std::string& word, int* captype) {
   int len;
   if (utf8) {
-    wide::string dest_utf;
-    len = u8_u16(dest_utf, word);
-    *captype = get_captype_utf8(dest_utf, langnum);
+    len = u8_u16(workbuf, word);
+    *captype = get_captype_utf8(workbuf, langnum);
   } else {
     len = word.size();
     *captype = get_captype(word, csconv);
@@ -688,13 +686,12 @@ int HashMgr::decode_flags(unsigned short** result, const std::string& flags, Fil
       break;
     }
     case FLAG_UNI: {  // UTF-8 characters
-      wide::string w;
-      u8_u16(w, flags);
-      len = w.size();
+      u8_u16(workbuf, flags);
+      len = workbuf.size();
       *result = (unsigned short*)malloc(len * sizeof(unsigned short));
       if (!*result)
         return -1;
-      memcpy(*result, &w[0], len * sizeof(short));
+      memcpy(*result, &workbuf[0], len * sizeof(short));
       break;
     }
     default: {  // Ispell's one-character flags (erfg -> e r f g)
@@ -760,12 +757,11 @@ bool HashMgr::decode_flags(std::vector<unsigned short>& result, const std::strin
       break;
     }
     case FLAG_UNI: {  // UTF-8 characters
-      wide::string w;
-      u8_u16(w, flags);
-      size_t len = w.size();
+      u8_u16(workbuf, flags);
+      size_t len = workbuf.size();
       size_t origsize = result.size();
       result.resize(origsize + len);
-      memcpy(&result[origsize], &w[0], len * sizeof(short));
+      memcpy(&result[origsize], &workbuf[0], len * sizeof(short));
       break;
     }
     default: {  // Ispell's one-character flags (erfg -> e r f g)
@@ -793,10 +789,9 @@ unsigned short HashMgr::decode_flag(const char* f) const {
       s = (unsigned short)i;
       break;
     case FLAG_UNI: {
-      wide::string w;
-      u8_u16(w, f);
-      if (!w.empty())
-          memcpy(&s, &w[0], 1 * sizeof(short));
+      u8_u16(workbuf, f);
+      if (!workbuf.empty())
+          memcpy(&s, &workbuf[0], 1 * sizeof(short));
       break;
     }
     default:
@@ -820,8 +815,9 @@ char* HashMgr::encode_flag(unsigned short f) const {
     ch = stream.str();
   } else if (flag_mode == FLAG_UNI) {
     const w_char* w_c = (const w_char*)&f;
-    wide::string w(w_c, w_c + 1);
-    u16_u8(ch, w);
+    workbuf.clear();
+    workbuf.push_back(*w_c);
+    u16_u8(ch, workbuf);
   } else {
     ch.push_back((unsigned char)(f));
   }
diff --git a/src/hunspell/hashmgr.hxx b/src/hunspell/hashmgr.hxx
index 312c8ba..78ffb44 100644
--- a/src/hunspell/hashmgr.hxx
+++ b/src/hunspell/hashmgr.hxx
@@ -97,6 +97,7 @@ class HashMgr {
   struct cs_info* csconv;
   std::string ignorechars;
   wide::string ignorechars_utf16;
+  mutable wide::string workbuf;
   int numaliasf;  // flag vector `compression' with aliases
   unsigned short** aliasf;
   unsigned short* aliasflen;
-- 
2.9.3

