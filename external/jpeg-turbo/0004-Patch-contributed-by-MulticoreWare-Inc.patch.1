From 01962d970af437f8196319ef41fb0ca34505264c Mon Sep 17 00:00:00 2001
From: dcommander <dcommander@632fc199-4ca6-4c93-a231-07263d6284db>
Date: Thu, 12 Dec 2013 17:58:42 +0000
Subject: [PATCH 4/9] Patch contributed by MulticoreWare, Inc.
 https://sourceforge.net/p/libjpeg-turbo/patches/40
 https://sourceforge.net/p/libjpeg-turbo/patches/_discuss/thread/3d9969a0/e494/attachment/20131206patch.patch

git-svn-id: http://svn.code.sf.net/p/libjpeg-turbo/code/branches/opencl@1094 632fc199-4ca6-4c93-a231-07263d6284db
---
 djpeg.c    |   67 ++
 jdapimin.c |  121 ++--
 jdapistd.c |   47 +-
 jdcoefct.c |  366 +++++++----
 jdhuff.c   |    4 +-
 jdmaster.c |    5 +-
 jdmerge.c  |   57 +-
 jdsample.c |   24 +-
 jocldec.c  | 2154 +++++++++++++++++++++++-------------------------------------
 jocldec.h  |   22 +-
 joclinit.c |  413 +++++++-----
 joclinit.h |   72 +-
 jpeglib.h  |   23 +
 wrbmp.c    |   14 +
 14 files changed, 1695 insertions(+), 1694 deletions(-)

diff --git a/djpeg.c b/djpeg.c
index 589c580..1641d7b 100644
--- a/djpeg.c
+++ b/djpeg.c
@@ -205,6 +205,9 @@ parse_switches (j_decompress_ptr cinfo, int argc, char **argv,
 
     if (keymatch(arg, "bmp", 1)) {
       /* BMP output format. */
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+      cinfo->opencl_rgb_flag = TRUE;
+#endif
       requested_fmt = FMT_BMP;
 
     } else if (keymatch(arg, "colors", 1) || keymatch(arg, "colours", 1) ||
@@ -468,6 +471,12 @@ main (int argc, char **argv)
 #ifdef USE_CCOMMAND
   argc = ccommand(&argv);
 #endif
+#ifdef PERFORMANCE_COUNTER
+  time = 0.0;
+#endif
+#ifdef PERFORMANCE_COUNTER_LINUX
+  interval = 0;
+#endif
 
   progname = argv[0];
   if (progname == NULL || progname[0] == 0)
@@ -625,12 +634,41 @@ main (int argc, char **argv)
   }
   dest_mgr->output_file = output_file;
 
+#ifdef PERFORMANCE_COUNTER
+  QueryPerformanceFrequency(&freq);
+  QueryPerformanceCounter(&start);
+#endif
+#ifdef PERFORMANCE_COUNTER_LINUX
+  gettimeofday(&start, NULL);
+#endif
+
   /* Start decompressor */
   (void) jpeg_start_decompress(&cinfo);
 
+#ifdef PERFORMANCE_COUNTER
+  QueryPerformanceCounter(&end);
+  time = (double)(end.QuadPart - start.QuadPart) / (double)freq.QuadPart;
+  printf("Start Decompress total time : %.10f ms\n", 1000*time);
+#endif
+#ifdef PERFORMANCE_COUNTER_LINUX
+  gettimeofday(&end, NULL);
+  interval = 1000000 * (end.tv_sec - start.tv_sec) + (end.tv_usec - start.tv_usec);
+  printf("Start Decompress total time : %.10f ms\n", interval / 1000.0);
+#endif
+
+
   /* Write output file header */
   (*dest_mgr->start_output) (&cinfo, dest_mgr);
 
+#ifdef PERFORMANCE_COUNTER
+  QueryPerformanceFrequency(&freq);
+  QueryPerformanceCounter(&start);
+#endif
+#ifdef PERFORMANCE_COUNTER_LINUX
+  gettimeofday(&start, NULL);
+#endif
+
+
   /* Process data */
   while (cinfo.output_scanline < cinfo.output_height) {
     num_scanlines = jpeg_read_scanlines(&cinfo, dest_mgr->buffer,
@@ -638,6 +676,16 @@ main (int argc, char **argv)
     (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);
   }
 
+#ifdef PERFORMANCE_COUNTER
+  QueryPerformanceCounter(&end); 
+  time = (double)(end.QuadPart - start.QuadPart) / (double)freq.QuadPart;
+  printf("decoder total time : %.10f ms\n", 1000*time); 
+#endif
+#ifdef PERFORMANCE_COUNTER_LINUX
+  gettimeofday(&end, NULL);
+  interval = 1000000 * (end.tv_sec - start.tv_sec) + (end.tv_usec - start.tv_usec);
+  printf("decoder total time : %.10f ms\n", interval / 1000.0); 
+#endif
 #ifdef PROGRESS_REPORT
   /* Hack: count final pass as done in case finish_output does an extra pass.
    * The library won't have updated completed_passes.
@@ -651,7 +699,26 @@ main (int argc, char **argv)
    */
   (*dest_mgr->finish_output) (&cinfo, dest_mgr);
   (void) jpeg_finish_decompress(&cinfo);
+#ifdef PERFORMANCE_COUNTER
+  QueryPerformanceFrequency(&freq);
+  QueryPerformanceCounter(&start);
+#endif
+#ifdef PERFORMANCE_COUNTER_LINUX
+  gettimeofday(&start, NULL);
+#endif
+
   jpeg_destroy_decompress(&cinfo);
+#ifdef PERFORMANCE_COUNTER
+  QueryPerformanceCounter(&end);
+  time = (double)(end.QuadPart - start.QuadPart) / (double)freq.QuadPart;
+  printf("Destroy total time : %.10f ms\n", 1000*time);
+#endif
+#ifdef PERFORMANCE_COUNTER_LINUX
+  gettimeofday(&end, NULL);
+  interval = 1000000 * (end.tv_sec - start.tv_sec) + (end.tv_usec - start.tv_usec);
+  printf("Destroy total time : %.10f ms\n", interval / 1000.0);
+#endif
+
 
   /* Close files, if we opened them */
   if (input_file != stdin)
diff --git a/jdapimin.c b/jdapimin.c
index 19495d0..cd099af 100644
--- a/jdapimin.c
+++ b/jdapimin.c
@@ -41,6 +41,8 @@ jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
   unsigned long    buffer_output_size = 0;
   cl_int err_code;
   int j;
+  OCL_STATUS *ocl_status;
+  cl_bool version_ocl ;
 #endif
 
   /* Guard against version mismatches between library and caller. */
@@ -94,76 +96,84 @@ jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
   cinfo->global_state = DSTATE_START;
 
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
-  if (CL_FALSE == jocl_cl_is_support_opencl() && CL_TRUE == jocl_cl_init()) {
-    buffer_output_size = jocl_cl_get_buffer_unit_size();
-    if (CL_TRUE == jocl_cl_is_nvidia_opencl()) {
-      jocl_global_data_ptr_output = (JSAMPROW)malloc(buffer_output_size);
-      memset(jocl_global_data_ptr_output, 0, buffer_output_size);
-      CL_SAFE_CALL0(jocl_global_data_mem_output = jocl_clCreateBuffer(jocl_cl_get_context(),
-        CL_MEM_WRITE_ONLY | CL_MEM_USE_HOST_PTR,
-        buffer_output_size, jocl_global_data_ptr_output, &err_code),return);
-      jocl_global_data_ptr_qutable = (float *)malloc(128 * sizeof(float));
-      memset(jocl_global_data_ptr_qutable, 0, 128 * sizeof(float));
-      CL_SAFE_CALL0(jocl_global_data_mem_qutable = jocl_clCreateBuffer(jocl_cl_get_context(),
-        CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
-        128 * sizeof(float), jocl_global_data_ptr_qutable, &err_code),return);
+  if (/*CL_FALSE == jocl_cl_is_support_opencl(ocl_status) &&*/ CL_TRUE == jocl_cl_init(&cinfo->jocl_openClinfo)) {
+        ocl_status = (OCL_STATUS *)cinfo->jocl_openClinfo;
+        version_ocl = jocl_cl_get_ocl_version(ocl_status);
+      if (CL_TRUE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+        ocl_status->jocl_global_data_ptr_qutable = (float *)malloc(128 * sizeof(float));
+        memset(ocl_status->jocl_global_data_ptr_qutable, 0, 128 * sizeof(float));
+        CL_SAFE_CALL0(ocl_status->jocl_global_data_mem_qutable = jocl_clCreateBuffer(jocl_cl_get_context(ocl_status),
+        CL_MEM_READ_ONLY | CL_MEM_ALLOC_HOST_PTR,
+        128 * sizeof(float), NULL, &err_code),return);
 
       for(j = 0; j < BUFFERNUMS; ++j) {
-        jocl_global_data_ptr_input[j]  = (JCOEFPTR)malloc(MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF));
-        memset(jocl_global_data_ptr_input[j], 0, MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF));
+    	  ocl_status->jocl_global_data_ptr_input[j]  = (JCOEFPTR)malloc(MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF));
+        memset(ocl_status->jocl_global_data_ptr_input[j], 0, MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF));
 
-        CL_SAFE_CALL0(jocl_global_data_mem_input[j] = jocl_clCreateBuffer(jocl_cl_get_context(),
-          CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR,
-          MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF), jocl_global_data_ptr_input[j], &err_code),return);
+        CL_SAFE_CALL0(ocl_status->jocl_global_data_mem_input[j] = jocl_clCreateBuffer(jocl_cl_get_context(ocl_status),
+          CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR,
+          MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF), NULL, &err_code),return);
       }
     }
     else {
-      CL_SAFE_CALL0(jocl_global_data_mem_output = jocl_clCreateBuffer(jocl_cl_get_context(),
-        CL_MEM_WRITE_ONLY | CL_MEM_ALLOC_HOST_PTR,
-        buffer_output_size, NULL, &err_code),return);
-      CL_SAFE_CALL0(jocl_global_data_ptr_output = (JSAMPROW)jocl_clEnqueueMapBuffer(
-        jocl_cl_get_command_queue(), jocl_global_data_mem_output, CL_TRUE,
-        CL_MAP_READ, 0, buffer_output_size, 
-        0, NULL, NULL, &err_code),return);
-      CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
-        jocl_cl_get_command_queue(), jocl_global_data_mem_output,
-        jocl_global_data_ptr_output, 0, NULL, NULL),return);
-      CL_SAFE_CALL0(jocl_global_data_mem_qutable = jocl_clCreateBuffer(jocl_cl_get_context(),
-        CL_MEM_READ_ONLY | CL_MEM_ALLOC_HOST_PTR,
+    	CL_SAFE_CALL0(ocl_status->jocl_global_data_mem_qutable = jocl_clCreateBuffer(jocl_cl_get_context(ocl_status),
+                CL_MEM_READ_ONLY | CL_MEM_ALLOC_HOST_PTR,
         128 * sizeof(float), NULL, &err_code),return);
-      CL_SAFE_CALL0(jocl_global_data_ptr_qutable = (float *)jocl_clEnqueueMapBuffer(
-        jocl_cl_get_command_queue(), jocl_global_data_mem_qutable, CL_TRUE,
-        CL_MAP_WRITE_INVALIDATE_REGION, 0, 128 * sizeof(float), 0, NULL, NULL, &err_code),return);
-      memset(jocl_global_data_ptr_qutable, 0, 128 * sizeof(float));
+      if(version_ocl) {
+        CL_SAFE_CALL0(ocl_status->jocl_global_data_ptr_qutable = (float *)jocl_clEnqueueMapBuffer(
+          jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_qutable, CL_TRUE,
+          CL_MAP_WRITE_INVALIDATE_REGION, 0, 128 * sizeof(float), 0, NULL, NULL, &err_code),return);
+      }
+      else {
+    	  CL_SAFE_CALL0(ocl_status->jocl_global_data_ptr_qutable = (float *)jocl_clEnqueueMapBuffer(
+    			  jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_qutable, CL_TRUE,
+    			  CL_MAP_WRITE, 0, 128 * sizeof(float), 0, NULL, NULL, &err_code),return);
+      }
+      memset(ocl_status->jocl_global_data_ptr_qutable, 0, 128 * sizeof(float));
       CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
-        jocl_cl_get_command_queue(), jocl_global_data_mem_qutable,
-        jocl_global_data_ptr_qutable, 0, NULL, NULL),return);
+    		  jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_qutable,
+    		  ocl_status->jocl_global_data_ptr_qutable, 0, NULL, NULL),return);
 
       for(j = 0; j < BUFFERNUMS; ++j) {
-        CL_SAFE_CALL0(jocl_global_data_mem_input[j] = jocl_clCreateBuffer(jocl_cl_get_context(),
-          CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR,
-          MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF), NULL, &err_code),return);
-        CL_SAFE_CALL0(jocl_global_data_ptr_input[j] = (JCOEFPTR)jocl_clEnqueueMapBuffer(
-          jocl_cl_get_command_queue(), jocl_global_data_mem_input[j], CL_TRUE,
-          CL_MAP_WRITE_INVALIDATE_REGION, 0, MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF),
-          0, NULL, NULL, &err_code),return);
-        memset(jocl_global_data_ptr_input[j],0,MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF));
-        CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
-          jocl_cl_get_command_queue(), jocl_global_data_mem_input[j],
-          jocl_global_data_ptr_input[j], 0, NULL, NULL),return);
+    	  CL_SAFE_CALL0(ocl_status->jocl_global_data_mem_input[j] = jocl_clCreateBuffer(jocl_cl_get_context(ocl_status),
+    			  CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR,
+    			  MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF), NULL, &err_code),return);
+    	  if(version_ocl) {
+    		  CL_SAFE_CALL0(ocl_status->jocl_global_data_ptr_input[j] = (JCOEFPTR)jocl_clEnqueueMapBuffer(
+    				  jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_input[j], CL_TRUE,
+    				  CL_MAP_WRITE_INVALIDATE_REGION, 0, MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF),
+    				  0, NULL, NULL, &err_code),return);
+    	  }
+    	  else {
+    		  CL_SAFE_CALL0(ocl_status->jocl_global_data_ptr_input[j] = (JCOEFPTR)jocl_clEnqueueMapBuffer(
+    				  jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_input[j], CL_TRUE,
+    				  CL_MAP_WRITE, 0, MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF),
+    				  0, NULL, NULL, &err_code),return);
+    	  }
+    	  memset(ocl_status->jocl_global_data_ptr_input[j],0,MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF));
+    	  CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
+    			  jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_input[j],
+    			  ocl_status->jocl_global_data_ptr_input[j], 0, NULL, NULL),return);
       }
     }
-    CL_SAFE_CALL0(jocl_global_data_mem_inter = jocl_clCreateBuffer(jocl_cl_get_context(), 
-	  CL_MEM_READ_WRITE, MCUNUMS * DCTSIZE2 * 6, NULL, &err_code),return);
-    if (CL_FALSE == jocldec_build_kernels(cinfo)) {
-      jocl_cl_set_opencl_failure();
-      jocl_cl_set_opencl_support_failure();
-    }
+      for(j = 0; j < BUFFERNUMS; ++j) {
+    	  CL_SAFE_CALL0(ocl_status->jocl_global_data_mem_inter[j] = jocl_clCreateBuffer(jocl_cl_get_context(ocl_status),
+    			  CL_MEM_READ_WRITE, MCUNUMS * DCTSIZE2 * 6, NULL, &err_code),return);
+    	  CL_SAFE_CALL0(ocl_status->jocl_global_data_mem_prior_inter[j] = jocl_clCreateBuffer(jocl_cl_get_context(ocl_status),
+    			  CL_MEM_READ_WRITE, MCUNUMS * 16, NULL, &err_code),return);
+      }
+
+      if (CL_FALSE == jocldec_build_kernels(cinfo)) {
+    	  jocl_cl_set_opencl_failure(ocl_status);
+    	  jocl_cl_set_opencl_support_failure(ocl_status);
+    	  cinfo->opencl_rgb_flag = FALSE;
+      }
   }
 #endif
 }
 
 
+
 /*
  * Destruction of a JPEG decompression object
  */
@@ -172,6 +182,11 @@ GLOBAL(void)
 jpeg_destroy_decompress (j_decompress_ptr cinfo)
 {
   jpeg_destroy((j_common_ptr) cinfo); /* use common routine */
+ #ifdef WITH_OPENCL_DECODING_SUPPORTED
+  	  jocl_release_ocl_resource(cinfo);
+  	  free(cinfo->jocl_openClinfo);
+ #endif
+
 }
 
 
diff --git a/jdapistd.c b/jdapistd.c
index 021f50b..6b477b5 100644
--- a/jdapistd.c
+++ b/jdapistd.c
@@ -45,6 +45,12 @@ LOCAL(boolean) output_pass_setup JPP((j_decompress_ptr cinfo));
 GLOBAL(boolean)
 jpeg_start_decompress (j_decompress_ptr cinfo)
 {
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  cl_int err_code;
+  unsigned long    buffer_output_size = 0;
+  OCL_STATUS *ocl_status = (OCL_STATUS *)cinfo->jocl_openClinfo;
+#endif
+
   if (cinfo->global_state == DSTATE_READY) {
     /* First call: initialize master control, select active modules */
     jinit_master_decompress(cinfo);
@@ -57,11 +63,41 @@ jpeg_start_decompress (j_decompress_ptr cinfo)
   }
 
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
+  if (CL_TRUE == jocl_cl_is_support_opencl(ocl_status))
+  {
+	  buffer_output_size = cinfo->MCUs_per_row * cinfo->total_iMCU_rows * cinfo->max_h_samp_factor *
+			  cinfo->max_v_samp_factor * NUM_COMPONENT * DCTSIZE2;
+	  if (CL_TRUE == jocl_cl_is_nvidia_opencl(ocl_status))
+	  {
+		  ocl_status->jocl_global_data_ptr_output = (JSAMPROW)malloc(buffer_output_size);
+		  memset(ocl_status->jocl_global_data_ptr_output, 0, buffer_output_size);
+		  CL_SAFE_CALL0(ocl_status->jocl_global_data_mem_output = jocl_clCreateBuffer(jocl_cl_get_context(ocl_status),
+				  CL_MEM_WRITE_ONLY | CL_MEM_ALLOC_HOST_PTR,
+				  buffer_output_size, NULL, &err_code),return err_code);
+	  }
+	  else
+	  {
+		  CL_SAFE_CALL0(ocl_status->jocl_global_data_mem_output = jocl_clCreateBuffer(jocl_cl_get_context(ocl_status),
+				  CL_MEM_WRITE_ONLY | CL_MEM_ALLOC_HOST_PTR,
+				  buffer_output_size, NULL, &err_code),return err_code);
+
+
+		  CL_SAFE_CALL0(ocl_status->jocl_global_data_ptr_output = (JSAMPROW)jocl_clEnqueueMapBuffer(
+				  jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_output, CL_TRUE,
+				  CL_MAP_READ, 0, buffer_output_size,0, NULL, NULL, &err_code),return err_code);
+
+		  CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
+				  jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_output,
+				  ocl_status->jocl_global_data_ptr_output, 0, NULL, NULL),return err_code);
+	  }
+  }
   /* Determine whether the OpenCL decoding will be used.*/
-  if(jocl_cl_is_support_opencl() && jocl_cl_is_opencl_decompress(cinfo))
-    jocl_cl_set_opencl_success();
-  else
-    jocl_cl_set_opencl_failure();
+  if(jocl_cl_get_fancy_status((OCL_STATUS* )cinfo->jocl_openClinfo) && jocl_cl_is_opencl_decompress(cinfo))
+	  jocl_cl_set_opencl_success((OCL_STATUS* )cinfo->jocl_openClinfo);
+  else {
+	  jocl_cl_set_opencl_failure((OCL_STATUS* )cinfo->jocl_openClinfo);
+	  cinfo->opencl_rgb_flag = FALSE;
+  }
 #endif
 
   if (cinfo->global_state == DSTATE_PRELOAD) {
@@ -178,6 +214,9 @@ jpeg_read_scanlines (j_decompress_ptr cinfo, JSAMPARRAY scanlines,
     return 0;
   }
 
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  jocl_cl_set_decode_support((OCL_STATUS* )cinfo->jocl_openClinfo);
+#endif
   /* Call progress monitor hook if present */
   if (cinfo->progress != NULL) {
     cinfo->progress->pass_counter = (long) cinfo->output_scanline;
diff --git a/jdcoefct.c b/jdcoefct.c
index 5ca9245..380ab02 100644
--- a/jdcoefct.c
+++ b/jdcoefct.c
@@ -172,14 +172,15 @@ decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
   int mcuy  = 0, index = 0;
   int block = cinfo->MCUs_per_row;
-  int i, j, upfactor,buffer_index;
+  int i, j, upfactor,buffer_index, buffer_index_next;
   int qutable[128];
+  OCL_STATUS * ocl_status =  (OCL_STATUS* )cinfo->jocl_openClinfo;
   float  qutable_float[128];
-  short* qutable_short_inter = (short *)jocl_global_data_ptr_qutable;
-  int*   qutable_int_inter = (int *)jocl_global_data_ptr_qutable;
+  short* qutable_short_inter = (short *)ocl_status->jocl_global_data_ptr_qutable;
+  int*   qutable_int_inter = (int *)ocl_status->jocl_global_data_ptr_qutable;
   cl_event buffer_event[BUFFERNUMS];
-
-  unsigned long buffer_output_size = jocl_cl_get_buffer_unit_size();
+  int mcunum_buffer = MCUNUMS / cinfo->MCUs_per_row *  cinfo->MCUs_per_row;
+  unsigned long buffer_output_size = jocl_cl_get_buffer_unit_size(ocl_status,cinfo->image_width,cinfo->image_height);
 
   /*offset_input is used to compute the offset of input and output for Kernel*/
   unsigned int offset_input = 0;
@@ -188,7 +189,10 @@ decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
   int decodeMCU = 0;
   int total_mcu_num = cinfo->total_iMCU_rows * rows_per_iMCU_row * cinfo->MCUs_per_row;
   int buffer_flag = 0;
-  /* int info;*/
+  cl_int err_code;
+  int num_buffer_inter = 10;
+  int num_buffer = BUFFERNUMS / num_buffer_inter;
+  cl_bool version_ocl = jocl_cl_get_ocl_version(ocl_status);
   /*IDCT FAST SHORT*/
   static const int aanscales[DCTSIZE2] = {
 	  /* precomputed values scaled up by 14 bits */
@@ -204,91 +208,100 @@ decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
   /*IDCT FAST FLOAT */
   static const double aanscalefactor[8] = {1.0, 1.387039845, 1.306562965, 1.175875602,
                                            1.0, 0.785694958, 0.541196100, 0.275899379};
+  /* Determine whether the OpenCL decoding will be used.*/
+  if (jocl_cl_is_support_opencl(ocl_status) && jocl_cl_get_decode_support(ocl_status)&& jocl_cl_is_opencl_decompress(cinfo))
+    jocl_cl_set_opencl_success(ocl_status);
+  else {
+    jocl_cl_set_opencl_failure(ocl_status);
+    cinfo->opencl_rgb_flag = FALSE;
+  }
 
-  if (CL_TRUE == jocl_cl_is_available()) { 
-    switch (cinfo->dct_method){
-	  case JDCT_IFAST:{
-	    /*IDCT FAST INT*/
-        for (i = 0; i < DCTSIZE2; ++i) {
-          qutable[i] = cinfo->quant_tbl_ptrs[0]->quantval[i];
-        }
-        if (cinfo->quant_tbl_ptrs[1]->quantval != NULL) {
+  if (CL_TRUE == jocl_cl_is_available(ocl_status)) {
+    if (cinfo->input_iMCU_row == 0) {
+      switch (cinfo->dct_method){
+	    case JDCT_IFAST:{
+	      /*IDCT FAST INT*/
           for (i = 0; i < DCTSIZE2; ++i) {
-            qutable[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[1]->quantval[i];
+            qutable[i] = cinfo->quant_tbl_ptrs[0]->quantval[i];
           }
-        }
-        else {
-          for (i = 0; i < DCTSIZE2; ++i) {
-            qutable[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[0]->quantval[i];
+          if (cinfo->quant_tbl_ptrs[1]->quantval != NULL) {
+            for (i = 0; i < DCTSIZE2; ++i) {
+              qutable[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[1]->quantval[i];
+            }
           }
-        }
-        for(i = 0; i < DCTSIZE ; ++i)
-          for(j = 0 ; j < DCTSIZE ; ++j) {
-            qutable_short_inter[j*8+i] = ((qutable[i*8+j] * aanscales[i*8+j]) +
-              (1 << ((12)-1))) >> 12;
-            qutable_short_inter[DCTSIZE2+j*8+i] = ((qutable[DCTSIZE2 + i*8+j] *
-              aanscales[i*8+j]) + (1 << ((12)-1))) >> 12;
+          else {
+            for (i = 0; i < DCTSIZE2; ++i) {
+              qutable[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[0]->quantval[i];
+            }
+          }
+          for(i = 0; i < DCTSIZE ; ++i)
+            for(j = 0 ; j < DCTSIZE ; ++j) {
+              qutable_short_inter[j*8+i] = ((qutable[i*8+j] * aanscales[i*8+j]) +
+                (1 << ((12)-1))) >> 12;
+              qutable_short_inter[DCTSIZE2+j*8+i] = ((qutable[DCTSIZE2 + i*8+j] *
+                aanscales[i*8+j]) + (1 << ((12)-1))) >> 12;
+	      }
+		  break;
 	    }
-		break;
-	  }
-	  case JDCT_FLOAT:{
-	    /*IDCT FAST FLOAT*/ 
-        for (i = 0; i < DCTSIZE2; ++i) {
-          qutable_float[i] = cinfo->quant_tbl_ptrs[0]->quantval[i];
-        }
-        if (cinfo->quant_tbl_ptrs[1]->quantval != NULL) {
+	    case JDCT_FLOAT:{
+	      /*IDCT FAST FLOAT*/ 
           for (i = 0; i < DCTSIZE2; ++i) {
-            qutable_float[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[1]->quantval[i];
+            qutable_float[i] = cinfo->quant_tbl_ptrs[0]->quantval[i];
           }
-        }
-        else {
-          for (i = 0; i < DCTSIZE2; ++i) {
-            qutable_float[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[0]->quantval[i];
+          if (cinfo->quant_tbl_ptrs[1]->quantval != NULL) {
+            for (i = 0; i < DCTSIZE2; ++i) {
+              qutable_float[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[1]->quantval[i];
+            }
           }
-        }
-	    for (i = 0; i < 8; i++) 
-          for (j = 0; j < 8; j++) {
-            jocl_global_data_ptr_qutable[j * 8 + i] = (float)(qutable_float[i * 8 + j] *
-              aanscalefactor[i] * aanscalefactor[j]);
-            jocl_global_data_ptr_qutable[DCTSIZE2 + j * 8 + i] = (float)(qutable_float[DCTSIZE2 + i * 8 + j] *
-              aanscalefactor[i] * aanscalefactor[j]);
+          else {
+            for (i = 0; i < DCTSIZE2; ++i) {
+              qutable_float[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[0]->quantval[i];
+            }
           }
-		break;
-	  }
-	  case JDCT_ISLOW: {
-	    /*IDCT SLOW INT*/
-        for (i = 0; i < DCTSIZE2; ++i) {
-          qutable[i] = cinfo->quant_tbl_ptrs[0]->quantval[i];
-        }
-        if (cinfo->quant_tbl_ptrs[1]->quantval != NULL) {
+	      for (i = 0; i < 8; i++) 
+            for (j = 0; j < 8; j++) {
+              ocl_status->jocl_global_data_ptr_qutable[j * 8 + i] = (float)(qutable_float[i * 8 + j] *
+                aanscalefactor[i] * aanscalefactor[j]);
+              ocl_status->jocl_global_data_ptr_qutable[DCTSIZE2 + j * 8 + i] = (float)(qutable_float[DCTSIZE2 + i * 8 + j] *
+                aanscalefactor[i] * aanscalefactor[j]);
+            }
+		  break;
+	    }
+	    case JDCT_ISLOW: {
+	      /*IDCT SLOW INT*/
           for (i = 0; i < DCTSIZE2; ++i) {
-            qutable[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[1]->quantval[i];
+            qutable[i] = cinfo->quant_tbl_ptrs[0]->quantval[i];
           }
-        }
-        else {
-          for (i = 0; i < DCTSIZE2; ++i) {
-            qutable[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[0]->quantval[i];
+          if (cinfo->quant_tbl_ptrs[1]->quantval != NULL) {
+            for (i = 0; i < DCTSIZE2; ++i) {
+              qutable[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[1]->quantval[i];
+            }
           }
-        }
-        for (i = 0; i < 8; i++)
-          for (j = 0; j < 8; j++) {
-            qutable_int_inter[j * 8 + i] = qutable[i * 8 + j];
-            qutable_int_inter[DCTSIZE2 + j * 8 + i] = qutable[DCTSIZE2 + i * 8 + j];
+          else {
+            for (i = 0; i < DCTSIZE2; ++i) {
+              qutable[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[0]->quantval[i];
+            }
           }
-	    break;
+          for (i = 0; i < 8; i++)
+            for (j = 0; j < 8; j++) {
+              qutable_int_inter[j * 8 + i] = qutable[i * 8 + j];
+              qutable_int_inter[DCTSIZE2 + j * 8 + i] = qutable[DCTSIZE2 + i * 8 + j];
+            }
+	      break;
+        }
+	  }
+      if (cinfo->max_v_samp_factor == 2) {
+        if (cinfo->max_h_samp_factor == 1)
+          upfactor = 5;
+        else
+          upfactor = 6;
+      } 
+      else if (cinfo->max_h_samp_factor == 2) {
+        upfactor = 4;
+      }
+      else {
+        upfactor = 3;
       }
-	}
-    if(cinfo->max_v_samp_factor == 2) {
-      if(cinfo->max_h_samp_factor == 1)
-        upfactor = 5;
-      else
-        upfactor = 6;
-    } 
-    else if (cinfo->max_h_samp_factor == 2) {
-      upfactor = 4;
-    }
-    else {
-      upfactor = 3;
     }
     for (; cinfo->input_iMCU_row < cinfo->total_iMCU_rows; 
       (cinfo->input_iMCU_row)++) {
@@ -297,60 +310,168 @@ decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
         yoffset++) {
         for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
           MCU_col_num++) {
-#ifdef PERFORMANCE_PPA
-  PPAStartCpuEventFunc(huffman);
+          if (upfactor == 6 && CL_TRUE == jocl_cl_get_fancy_status(ocl_status)) {
+            //printf("H2V2 fancy \n");
+            buffer_index = buffer_flag % num_buffer_inter;
+            if (buffer_index == (num_buffer_inter - 1)) buffer_index_next = 0;
+            else buffer_index_next = buffer_index + 1;
+            if (CL_FALSE == jocl_cl_is_nvidia_opencl(ocl_status)&& mcuy == 0) {
+		      if (buffer_flag > (num_buffer_inter - 1)) {
+               CL_SAFE_CALL0(err_code = jocl_clWaitForEvents(1, &buffer_event[buffer_index]),return CL_FALSE);
+              }
+            }
+#ifndef JOCL_CL_OS_WIN32
+            if (CL_FALSE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+              if (version_ocl) {
+                CL_SAFE_CALL0(ocl_status->jocl_global_data_ptr_input[buffer_index] = (JCOEFPTR)jocl_clEnqueueMapBuffer(
+                  jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_input[buffer_index], CL_TRUE,
+                  CL_MAP_WRITE_INVALIDATE_REGION, 0, MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF),
+                  0, NULL, NULL, &err_code),return CL_FALSE);
+              }
+              else {
+                CL_SAFE_CALL0(ocl_status->jocl_global_data_ptr_input[buffer_index] = (JCOEFPTR)jocl_clEnqueueMapBuffer(
+                  jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_input[buffer_index], CL_TRUE,
+                  CL_MAP_WRITE, 0, MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF),
+                  0, NULL, NULL, &err_code),return CL_FALSE);
+              }
+            }
 #endif
+          for (index = 0; index < cinfo->blocks_in_MCU; ++index)
+            coef->MCU_buffer[index] = (JBLOCKROW)(ocl_status->jocl_global_data_ptr_input[buffer_index] +
+              mcuy++ * DCTSIZE2);
+
+            /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
+            if (CL_TRUE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+              jzero_far((void FAR *) coef->MCU_buffer[0],
+	  	        (size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
+            }
+            if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
+              /* Suspension forced; update state counters and exit */
+              coef->MCU_vert_offset = yoffset;
+              coef->MCU_ctr = MCU_col_num;
+              return JPEG_SUSPENDED;
+            }
+ 
+            decodeMCU++;
+            mcudecoder++;
+            if (
+#ifdef OPENCL_PIPELINE
+              0 == decodeMCU % mcunum_buffer ||
+#endif
+              (decodeMCU == cinfo->total_iMCU_rows *
+              coef->MCU_rows_per_iMCU_row * (last_MCU_col+1))) {
+              jocldec_run_kernels_h2v2_fancy(cinfo,
+                                             upfactor,
+                                             mcudecoder,
+                                             block,
+                                             offset_input,
+                                             total_mcu_num,
+                                             decodeMCU,
+                                             buffer_index,
+                                             buffer_event,
+                                             mcunum_buffer);
+              offset_input += mcudecoder;
+              mcudecoder = 0;
+              mcuy = 0;
+              buffer_flag ++;
+            }
+          }
+          else {
             buffer_index = buffer_flag % BUFFERNUMS;
-
-            if(buffer_flag > (BUFFERNUMS - 1) && mcuy == 0) {
-             /*jocl_clGetEventInfo(buffer_event[buffer_index], CL_EVENT_COMMAND_EXECUTION_STATUS, sizeof(info),&info,NULL);*/
-             jocl_clWaitForEvents(1, &buffer_event[buffer_index]);
+            if (buffer_index == 9) buffer_index_next = 0;
+            else buffer_index_next = buffer_index + 1;
+            if (CL_FALSE == jocl_cl_is_nvidia_opencl(ocl_status) && (CL_FALSE == jocl_cl_get_fancy_status(ocl_status) ||
+              upfactor != 4)) {
+		      if (buffer_flag > (BUFFERNUMS - 1) && mcuy == 0) {
+               CL_SAFE_CALL0(err_code = jocl_clWaitForEvents(1, &buffer_event[buffer_index]), return CL_FALSE);
+              }
             }
-
-          if (CL_TRUE== jocl_cl_is_available()) {
 #ifndef JOCL_CL_OS_WIN32
-            if(CL_FALSE == jocl_cl_is_nvidia_opencl()) {
-              jocl_global_data_ptr_input[buffer_index] = (JCOEFPTR)jocl_clEnqueueMapBuffer(
-                jocl_cl_get_command_queue(), jocl_global_data_mem_input[buffer_index], CL_TRUE,
-                CL_MAP_WRITE_INVALIDATE_REGION, 0, MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF),
-                0, NULL, NULL, NULL);
+            if (CL_FALSE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+              if (version_ocl) {
+                CL_SAFE_CALL0(ocl_status->jocl_global_data_ptr_input[buffer_index] = (JCOEFPTR)jocl_clEnqueueMapBuffer(
+                  jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_input[buffer_index], CL_TRUE,
+                  CL_MAP_WRITE_INVALIDATE_REGION, 0, MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF),
+                  0, NULL, NULL, &err_code),return CL_FALSE);
+              }
+              else {
+                CL_SAFE_CALL0(ocl_status->jocl_global_data_ptr_input[buffer_index] = (JCOEFPTR)jocl_clEnqueueMapBuffer(
+                  jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_input[buffer_index], CL_TRUE,
+                  CL_MAP_WRITE, 0, MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF),
+                  0, NULL, NULL, &err_code),return CL_FALSE);
+              }
             }
 #endif
-
             for (index = 0; index < cinfo->blocks_in_MCU; ++index)
-              coef->MCU_buffer[index] = (JBLOCKROW)(jocl_global_data_ptr_input[buffer_index] +
+            coef->MCU_buffer[index] = (JBLOCKROW)(ocl_status->jocl_global_data_ptr_input[buffer_index] +
                 mcuy++ * DCTSIZE2);
-          }
-          if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
-            /* Suspension forced; update state counters and exit */
-            coef->MCU_vert_offset = yoffset;
-            coef->MCU_ctr = MCU_col_num;
-            return JPEG_SUSPENDED;
-          }
-          decodeMCU++;
-          mcudecoder++;
-#ifdef PERFORMANCE_PPA
-   PPAStopCpuEventFunc(huffman);
+
+            /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
+            if (CL_TRUE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+              jzero_far((void FAR *) coef->MCU_buffer[0],
+	  	        (size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
+            }
+            if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
+              /* Suspension forced; update state counters and exit */
+              coef->MCU_vert_offset = yoffset;
+              coef->MCU_ctr = MCU_col_num;
+              return JPEG_SUSPENDED;
+            }
+            if (CL_TRUE == jocl_cl_get_fancy_status(ocl_status) && upfactor == 4) {
+              if (mcuy == cinfo->blocks_in_MCU * MCUNUMS) {
+                if (CL_FALSE == jocl_cl_is_nvidia_opencl(ocl_status) && (buffer_flag > (BUFFERNUMS - 2))) {
+                  CL_SAFE_CALL0(err_code = jocl_clWaitForEvents(1, &buffer_event[buffer_index_next]),return CL_FALSE);
+                }
+                memcpy(ocl_status->jocl_global_data_ptr_input[buffer_index_next],ocl_status->jocl_global_data_ptr_input[buffer_index] +
+                 (MCUNUMS - 1)* cinfo->blocks_in_MCU * DCTSIZE2, cinfo->blocks_in_MCU * DCTSIZE2 * sizeof(JCOEF));
+              }
+            }
+            decodeMCU++;
+            mcudecoder++;
+            if (CL_FALSE == jocl_cl_get_fancy_status(ocl_status) || (upfactor != 4 && upfactor != 6)) {
+              if (
+#ifdef OPENCL_PIPELINE
+                decodeMCU % MCUNUMS==0 ||
 #endif
-          if (
+                (decodeMCU == cinfo->total_iMCU_rows *
+                coef->MCU_rows_per_iMCU_row * (last_MCU_col+1))) {
+                jocldec_run_kernels_full_image(cinfo,
+                                               upfactor,
+                                               mcudecoder,
+                                               block,
+                                               offset_input,
+                                               total_mcu_num,
+                                               decodeMCU,
+                                               buffer_index,
+                                               buffer_event);
+                offset_input += mcudecoder;
+                mcudecoder = 0;
+                mcuy = 0;
+                buffer_flag ++;
+              }
+            }
+		    else {
+              if (
 #ifdef OPENCL_PIPELINE
-            decodeMCU % MCUNUMS==0 ||
+                mcuy == cinfo->blocks_in_MCU * MCUNUMS ||
 #endif
-            (decodeMCU == cinfo->total_iMCU_rows *
-            coef->MCU_rows_per_iMCU_row * (last_MCU_col+1))) {
-            jocldec_run_kernels_full_image(cinfo,
-                                           upfactor,
-                                           mcudecoder,
-                                           block,
-                                           offset_input,
-                                           total_mcu_num,
-                                           decodeMCU,
-                                           buffer_index,
-                                           buffer_event);
-            offset_input += mcudecoder;
-            mcudecoder = 0;
-            mcuy = 0;
-            buffer_flag ++;
+                (decodeMCU == cinfo->total_iMCU_rows *
+                coef->MCU_rows_per_iMCU_row * (last_MCU_col+1))) {
+                jocldec_run_kernels_full_image(cinfo,
+                                               upfactor,
+                                               mcudecoder,
+                                               block,
+                                               offset_input,
+                                               total_mcu_num,
+                                               decodeMCU,
+                                               buffer_index,
+                                               buffer_event);
+                offset_input ++;
+                mcuy = cinfo->blocks_in_MCU;
+                mcudecoder = 1;
+                buffer_flag ++;
+              }
+		    }
           }
         }
         /* Completed an MCU row, but perhaps not an iMCU row */
@@ -434,7 +555,6 @@ decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
   return JPEG_SCAN_COMPLETED;
 }
 
-
 /*
  * Dummy consume-input routine for single-pass operation.
  */
@@ -466,6 +586,10 @@ consume_data (j_decompress_ptr cinfo)
   JBLOCKROW buffer_ptr;
   jpeg_component_info *compptr;
 
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  jocl_cl_set_opencl_failure((OCL_STATUS* )cinfo->jocl_openClinfo);
+  cinfo->opencl_rgb_flag = FALSE;
+#endif
   /* Align the virtual buffers for the components used in this scan. */
   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
     compptr = cinfo->cur_comp_info[ci];
diff --git a/jdhuff.c b/jdhuff.c
index 3ca4eab..4d7306f 100644
--- a/jdhuff.c
+++ b/jdhuff.c
@@ -611,7 +611,7 @@ decode_mcu_slow (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
            * if k >= DCTSIZE2, which could happen if the data is corrupted.
            */
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
-          if (!jocl_cl_is_available())
+          if (!jocl_cl_is_available((OCL_STATUS* )cinfo->jocl_openClinfo))
 #endif
           (*block)[jpeg_natural_order[k]] = (JCOEF) s;
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
@@ -703,7 +703,7 @@ decode_mcu_fast (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
           r = GET_BITS(s);
           s = HUFF_EXTEND(r, s);
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
-          if (!jocl_cl_is_available())
+          if (!jocl_cl_is_available((OCL_STATUS* )cinfo->jocl_openClinfo))
 #endif
           (*block)[jpeg_natural_order[k]] = (JCOEF) s;
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
diff --git a/jdmaster.c b/jdmaster.c
index 0ab5de7..d8f15ab 100644
--- a/jdmaster.c
+++ b/jdmaster.c
@@ -58,10 +58,7 @@ use_merged_upsample (j_decompress_ptr cinfo)
 
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
   if(FALSE == cinfo->do_fancy_upsampling)
-    jocl_cl_set_fancy_status();
-  if (CL_TRUE == jocl_cl_is_available()) { 
-    cinfo->do_fancy_upsampling = TRUE;
-  }
+    jocl_cl_set_fancy_status((OCL_STATUS* )cinfo->jocl_openClinfo);
 #endif
 
   if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)
diff --git a/jdmerge.c b/jdmerge.c
index 9830be2..54b8785 100644
--- a/jdmerge.c
+++ b/jdmerge.c
@@ -6,6 +6,7 @@
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
  * libjpeg-turbo Modifications:
  * Copyright (C) 2009, 2011, D. R. Commander.
+ * Copyright (C) 2012-2013, MulticoreWare Inc.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains code for merged upsampling/color conversion.
@@ -41,6 +42,12 @@
 #include "jsimd.h"
 #include "config.h"
 
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+#include "CL/opencl.h"
+#include "joclinit.h"
+#include "jocldec.h"
+#endif
+
 #ifdef UPSAMPLE_MERGING_SUPPORTED
 
 
@@ -257,11 +264,19 @@ merged_2v_upsample (j_decompress_ptr cinfo,
   my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
   JSAMPROW work_ptrs[2];
   JDIMENSION num_rows;		/* number of rows returned to caller */
-
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  OCL_STATUS * ocl_status =  (OCL_STATUS* )cinfo->jocl_openClinfo;
+#endif
   if (upsample->spare_full) {
     /* If we have a spare row saved from a previous cycle, just return it. */
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+	  if (CL_FALSE == jocl_cl_is_available((OCL_STATUS* )cinfo->jocl_openClinfo)) {
+#endif
     jcopy_sample_rows(& upsample->spare_row, 0, output_buf + *out_row_ctr, 0,
 		      1, upsample->out_row_width);
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  }
+#endif
     num_rows = 1;
     upsample->spare_full = FALSE;
   } else {
@@ -283,8 +298,30 @@ merged_2v_upsample (j_decompress_ptr cinfo,
       upsample->spare_full = TRUE;
     }
     /* Now do the upsampling. */
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+    if (CL_FALSE == jocl_cl_is_available(ocl_status)) {
+#endif
     (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+    }
+#endif
+  }
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  if (CL_TRUE == jocl_cl_is_available(ocl_status)) {
+    if (TRUE == cinfo->opencl_rgb_flag)
+      *output_buf = &ocl_status->jocl_global_data_ptr_output[cinfo->output_scanline *
+        cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE * NUM_COMPONENT];
+    else {
+      memcpy(*output_buf, ocl_status->jocl_global_data_ptr_output + cinfo->output_scanline *
+        cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE * NUM_COMPONENT, 
+        cinfo->image_width * NUM_COMPONENT);
+      if (num_rows == 2) {
+        *(output_buf + 1) =  &ocl_status->jocl_global_data_ptr_output[(cinfo->output_scanline + 1) *
+          cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE * NUM_COMPONENT];
+      }
+    }
   }
+#endif
 
   /* Adjust counts */
   *out_row_ctr += num_rows;
@@ -304,10 +341,26 @@ merged_1v_upsample (j_decompress_ptr cinfo,
 /* 1:1 vertical sampling case: much easier, never need a spare row. */
 {
   my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
-
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  OCL_STATUS * ocl_status =  (OCL_STATUS* )cinfo->jocl_openClinfo;
+  if (CL_FALSE == jocl_cl_is_available(ocl_status)) {
+#endif
   /* Just do the upsampling. */
   (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
 			 output_buf + *out_row_ctr);
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  }
+  if (CL_TRUE == jocl_cl_is_available(ocl_status)) {
+    if (TRUE == cinfo->opencl_rgb_flag)
+      *output_buf = &ocl_status->jocl_global_data_ptr_output[cinfo->output_scanline *
+        cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE * NUM_COMPONENT];
+    else {
+      memcpy(*output_buf, ocl_status->jocl_global_data_ptr_output + cinfo->output_scanline *
+        cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE * NUM_COMPONENT, 
+        cinfo->image_width * NUM_COMPONENT);
+    }
+  }
+#endif
   /* Adjust counts */
   (*out_row_ctr)++;
   (*in_row_group_ctr)++;
diff --git a/jdsample.c b/jdsample.c
index 4372540..b2895c0 100644
--- a/jdsample.c
+++ b/jdsample.c
@@ -110,7 +110,8 @@ sep_upsample (j_decompress_ptr cinfo,
 
   /* Fill the conversion buffer, if it's empty */
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
-  if (CL_FALSE == jocl_cl_is_available() && upsample->next_row_out >= cinfo->max_v_samp_factor) {
+  OCL_STATUS * ocl_status =  (OCL_STATUS* )cinfo->jocl_openClinfo;
+  if (CL_FALSE == jocl_cl_is_available(ocl_status) && upsample->next_row_out >= cinfo->max_v_samp_factor) {
 #else
   if (upsample->next_row_out >= cinfo->max_v_samp_factor) {
 #endif
@@ -127,7 +128,7 @@ sep_upsample (j_decompress_ptr cinfo,
   }
 
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
-     if (CL_TRUE == jocl_cl_is_available())
+     if (CL_TRUE == jocl_cl_is_available(ocl_status))
         upsample->next_row_out = 0;
 #endif
   /* Color-convert and emit rows */
@@ -145,15 +146,18 @@ sep_upsample (j_decompress_ptr cinfo,
     num_rows = out_rows_avail;
 
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
-  if (CL_TRUE == jocl_cl_is_available()) {
-    memcpy(*output_buf, jocl_global_data_ptr_output + cinfo->output_scanline * 
-      cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE * NUM_COMPONENT, 
-      cinfo->image_width * NUM_COMPONENT);
-    //*output_buf = &jocl_global_data_ptr_output[cinfo->output_scanline * 
-    //  cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE * NUM_COMPONENT];
-    if(num_rows == 2) {
-      *(output_buf + 1) =  &jocl_global_data_ptr_output[(cinfo->output_scanline + 1) * 
+  if (CL_TRUE == jocl_cl_is_available(ocl_status)) {
+    if (TRUE == cinfo->opencl_rgb_flag)
+      *output_buf = &ocl_status->jocl_global_data_ptr_output[cinfo->output_scanline *
         cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE * NUM_COMPONENT];
+    else {
+      memcpy(*output_buf, ocl_status->jocl_global_data_ptr_output + cinfo->output_scanline *
+        cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE * NUM_COMPONENT, 
+        cinfo->image_width * NUM_COMPONENT);
+      if (num_rows == 2) {
+        *(output_buf + 1) = &ocl_status->jocl_global_data_ptr_output[(cinfo->output_scanline + 1) *
+          cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE * NUM_COMPONENT];
+      }
     }
   }
   else
diff --git a/jocldec.c b/jocldec.c
index f27e6e4..6adb275 100644
--- a/jocldec.c
+++ b/jocldec.c
@@ -14,21 +14,24 @@
 
 #include "jinclude.h"
 #include "jpeglib.h"
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
 #include "CL/opencl.h"
 #include "joclinit.h"
 #include "jocldec.h"
-#include "jocldec_kernels.h"
+#include "joclidct.h"
 
-#ifdef WITH_OPENCL_DECODING_SUPPORTED
-cl_mem   jocl_global_data_mem_input[BUFFERNUMS];
-cl_mem   jocl_global_data_mem_output  = NULL;
-cl_mem   jocl_global_data_mem_qutable = NULL;
-cl_mem   jocl_global_data_mem_inter   = NULL;
-JCOEFPTR jocl_global_data_ptr_input[BUFFERNUMS];
-JSAMPROW jocl_global_data_ptr_output  = NULL;
-float*   jocl_global_data_ptr_qutable = NULL;
+#define  OPENCL_DEC_UPSAMPLE_RGB
+#include "jocldsample.h"
+#undef   OPENCL_DEC_UPSAMPLE_RGB
+
+#define  OPENCL_DEC_UPSAMPLE_BGR
+#include "jocldsample.h"
+#undef   OPENCL_DEC_UPSAMPLE_BGR
+
+#define  OPENCL_DEC_UPSAMPLE_RGBA
+#include "jocldsample.h"
+#undef   OPENCL_DEC_UPSAMPLE_RGBA
 
-static JOCL_CL_RUNDATA* jocldec_cl_rundata = NULL;
 
 cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
 {
@@ -40,6 +43,7 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
   static  const char **jocldec_cl_source;
   char    **jocldec_cl_source_inter;
   int     i, j;
+  OCL_STATUS *ocl_status = (OCL_STATUS *)cinfo->jocl_openClinfo;
   jocldec_cl_source_inter = (char**) malloc(7 * sizeof(char*));
   for(i=0; i<7; ++i) {
     jocldec_cl_source_inter[i] = (char*) malloc(60000 * sizeof(char));
@@ -54,9 +58,9 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
   jocldec_cl_source = jocldec_cl_source_inter;
 
   global_ws[0] = 256;
-  local_ws[0] = 64;
+  local_ws[0] = 128;
 
-  if (!jocldec_cl_rundata)  { 
+  if (!ocl_status->jocldec_cl_rundata)  {
     const char* kernel_names[] = {"IDCT_FAST_SHORT",
                                   "IDCT_SLOW_INT",
                                   "IDCT_FAST_FLOAT",
@@ -86,1438 +90,902 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                   "UPSAMPLE_H2V2_FANCY_BGR",
                                   "RESET_ZERO",
                                    NULL};
-    jocldec_cl_rundata = jocl_cl_compile_and_build(jocldec_cl_source, kernel_names);
-    /* IDCT FAST SHORT */
-    for(j = 0; j < BUFFERNUMS; ++j) {
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
+    if (ocl_status->jocldec_cl_rundata = jocl_cl_compile_and_build(ocl_status,jocldec_cl_source, kernel_names)) {
+#if 1
+      /* IDCT FAST SHORT */
+      for(j = 0; j < BUFFERNUMS; ++j) {
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[0],
+                                                     0,
+                                                     sizeof(cl_mem),
+                                                     &ocl_status->jocl_global_data_mem_input[j]),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[0],
+                                                     1,
+                                                     sizeof(cl_mem),
+                                                     &ocl_status->jocl_global_data_mem_inter[j]),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[0],
+                                                     2,
+                                                     sizeof(cl_mem),
+                                                     &ocl_status->jocl_global_data_mem_qutable),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[0],
+                                                     3,
+                                                     1024*sizeof(int),
+                                                     NULL),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[0],
+                                                     4,
+                                                     sizeof(int),
+                                                     &data_m),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(ocl_status),
+                                                     ocl_status->jocldec_cl_rundata->kernel[0],
+                                                     1,
+                                                     0,
+                                                     global_ws,
+                                                     local_ws,
+                                                     0,
+                                                     NULL,
+                                                     NULL),
+                                                     return CL_FALSE);
+        /* IDCT SLOW INT */
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[1],
+                                                     0,
+                                                     sizeof(cl_mem),
+                                                     &ocl_status->jocl_global_data_mem_input[j]),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[1],
+                                                     1,
+                                                     sizeof(cl_mem),
+                                                     &ocl_status->jocl_global_data_mem_inter[j]),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[1],
+                                                     2,
+                                                     sizeof(cl_mem),
+                                                     &ocl_status->jocl_global_data_mem_qutable),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[1],
+                                                     3,
+                                                     1024*sizeof(int),
+                                                     NULL),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[1],
+                                                     4,
+                                                     sizeof(int),
+                                                     &data_m),
+                                                     return CL_FALSE);
+        
+        CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(ocl_status),
+                                                     ocl_status->jocldec_cl_rundata->kernel[1],
+                                                     1,
+                                                     0,
+                                                     global_ws,
+                                                     local_ws,
+                                                     0,
+                                                     NULL,
+                                                     NULL),
+                                                     return CL_FALSE);
+        /* IDCT FAST FLOAT */
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[2],
+                                                     0,
+                                                     sizeof(cl_mem),
+                                                     &ocl_status->jocl_global_data_mem_input[j]),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[2],
+                                                     1,
+                                                     sizeof(cl_mem),
+                                                     &ocl_status->jocl_global_data_mem_inter[j]),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[2],
+                                                     2,
+                                                     sizeof(cl_mem),
+                                                     &ocl_status->jocl_global_data_mem_qutable),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[2],
+                                                     3,
+                                                     1024*sizeof(int),
+                                                     NULL),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[2],
+                                                     4,
+                                                     sizeof(float),
+                                                     &data_m),
+                                                     return CL_FALSE);
+        
+        CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(ocl_status),
+                                                     ocl_status->jocldec_cl_rundata->kernel[2],
+                                                     1,
+                                                     0,
+                                                     global_ws,
+                                                     local_ws,
+                                                     0,
+                                                     NULL,
+                                                     NULL),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[21],
+                                                    0,
+                                                    sizeof(cl_mem),
+                                                    &ocl_status->jocl_global_data_mem_input[j]),
+                                                    return CL_FALSE);
+        
+        CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(ocl_status),
+                                                    ocl_status->jocldec_cl_rundata->kernel[21],
+                                                    1,
+                                                    0,
+                                                    global_ws,
+                                                    local_ws,
+                                                    0,
+                                                    NULL,
+                                                    NULL),
+                                                    return CL_FALSE);
+      }
+      CL_SAFE_CALL0(err_code = jocl_clFinish(jocl_cl_get_command_queue(ocl_status)), return CL_FALSE);
+#endif
+    }
+  }
+  for(i=0; i<7; ++i) {
+    free(jocldec_cl_source_inter[i]);
+  }
+  free(jocldec_cl_source_inter);
+
+  return CL_TRUE;
+}
+
+cl_bool jocldec_run_kernels_full_image(
+                            j_decompress_ptr cinfo,
+                            int data_m,
+                            int mcu_num,
+                            unsigned int blocksWidth,
+                            unsigned int offset_mcu,
+                            int total_mcu_num,
+                            int decodeMCU,
+                            int buffer_index,
+                            cl_event* buffer_event)
+{
+  cl_int err_code;
+  size_t global_ws,local_ws;
+  int mcu_out,mcu_in;
+  int data_m_inter = data_m;
+  int size_map;
+  unsigned int offset_output;
+  cl_kernel jocldec_cl_kernel_use;
+  OCL_STATUS * ocl_status =  (OCL_STATUS* )cinfo->jocl_openClinfo;
+  int edge_mcu_h = 0;
+  int KernelArg2 = 0;
+  int KernelArg5 = 0;
+  int KernelArg6 = 0;
+
+  if (cinfo->image_width % 16 == 0)
+    edge_mcu_h = 7;
+  else
+    edge_mcu_h = (cinfo->image_width % 16 + 1)/ 2 - 1;
+
+  if (data_m==5) data_m_inter = 4;
+  switch(data_m) {
+    case 3: mcu_out   = 192;
+            mcu_in    = 192;
+            global_ws = (mcu_num * mcu_in /8+255)/256*256;
+            break;
+    case 5: mcu_out   = 384;
+            mcu_in    = 256;
+            global_ws = (mcu_num * mcu_in /8+255)/256*256;
+            break;
+    case 4: mcu_out   = 384;
+            mcu_in    = 256;
+            global_ws = (mcu_num * mcu_in /8+255)/256*256;
+            break;
+    case 6: mcu_out   = 768;
+            mcu_in    = 384;
+            global_ws = (mcu_num * mcu_in /8+255)/256*256;
+            break;
+  }
+  if (CL_TRUE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueWriteBuffer(jocl_cl_get_command_queue(ocl_status),
+      ocl_status->jocl_global_data_mem_input[buffer_index], CL_TRUE, 0,  MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF),
+      ocl_status->jocl_global_data_ptr_input[buffer_index], 0, NULL, NULL), return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueWriteBuffer(jocl_cl_get_command_queue(ocl_status),
+      ocl_status->jocl_global_data_mem_qutable, CL_TRUE, 0,  128 * sizeof(float), ocl_status->jocl_global_data_ptr_qutable,
+      0, NULL, NULL), return CL_FALSE);
+  }
+#ifndef JOCL_CL_OS_WIN32
+  if (CL_FALSE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
+      jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_input[buffer_index],
+      ocl_status->jocl_global_data_ptr_input[buffer_index], 0, NULL, NULL),return CL_FALSE);
+  }
+#endif
+  switch (cinfo->dct_method){
+    case JDCT_IFAST:
+      local_ws = 256;
+      jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[0];
+      break;
+    case JDCT_ISLOW:
+      local_ws = 128;
+      jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[1];
+      break;
+    case JDCT_FLOAT:
+      local_ws = 128;
+      jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[2];
+      break;
+  }
+  CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                               0,
+                                               sizeof(cl_mem),
+                                               &ocl_status->jocl_global_data_mem_input[buffer_index]),
+                                               return CL_FALSE);
+  if (0 == offset_mcu || CL_TRUE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &ocl_status->jocl_global_data_mem_inter[0]),
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 2,
+                                                 sizeof(cl_mem),
+                                                 &ocl_status->jocl_global_data_mem_qutable),
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 3,
+                                                 4096,
+                                                 NULL),
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 4,
+                                                 sizeof(int),
+                                                 &data_m_inter),
+                                                 return CL_FALSE);
+  }
+  CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(ocl_status),
+                                                 jocldec_cl_kernel_use,
+                                                 1,
+                                                 0,
+                                                 &global_ws,
+                                                 &local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 return CL_FALSE);
+  if (3 == data_m){
+	global_ws     = mcu_num * 64;
+    offset_output = offset_mcu * 64;
+    local_ws      = 64;
+    if (TRUE == cinfo->opencl_rgb_flag)
+      jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[3];
+    else
+      jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[15];
+    if (0 == offset_mcu || CL_TRUE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                    0,
                                                    sizeof(cl_mem),
-                                                   &jocl_global_data_mem_input[j]),
+                                                   &ocl_status->jocl_global_data_mem_inter[0]),
                                                    return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                    1,
                                                    sizeof(cl_mem),
-                                                   &jocl_global_data_mem_inter),
+                                                   &ocl_status->jocl_global_data_mem_output),
                                                    return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                    2,
-                                                   sizeof(cl_mem),
-                                                   &jocl_global_data_mem_qutable),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
-                                                   3,
-                                                   1024*sizeof(int),
+                                                   256*sizeof(unsigned char),
                                                    NULL),
                                                    return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
-                                                   4,
-                                                   sizeof(int),
-                                                   &data_m),
-                                                   return CL_FALSE);      
-      CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                   jocldec_cl_rundata->kernel[0],
-                                                   1,
-                                                   0,
-                                                   global_ws,
-                                                   local_ws,
-                                                   0,
-                                                   NULL,
-                                                   NULL),
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                   3,
+                                                   sizeof(unsigned int),
+                                                   &blocksWidth),
                                                    return CL_FALSE);
-      /* IDCT SLOW INT */
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
+    }
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 4,
+                                                 sizeof(unsigned int),
+                                                 &offset_output),
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(ocl_status),
+                                                 jocldec_cl_kernel_use,
+                                                 1,
+                                                 0,
+                                                 &global_ws,
+                                                 &local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 return CL_FALSE);
+  }  /*1v1 end*/
+  else if (5 == data_m){ 
+	offset_output = offset_mcu * 128;
+    global_ws     = mcu_num * 128;
+    local_ws      = 128;
+	KernelArg2 = 384 * sizeof(unsigned char);
+    if (TRUE == cinfo->opencl_rgb_flag)
+      jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[4];
+    else
+      jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[16];
+    if (0 == offset_mcu || CL_TRUE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                    0,
                                                    sizeof(cl_mem),
-                                                   &jocl_global_data_mem_input[j]),
+                                                   &ocl_status->jocl_global_data_mem_inter[0]),
                                                    return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                    1,
                                                    sizeof(cl_mem),
-                                                   &jocl_global_data_mem_inter),
+                                                   &ocl_status->jocl_global_data_mem_output),
                                                    return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                    2,
-                                                   sizeof(cl_mem),
-                                                   &jocl_global_data_mem_qutable),
+                                                   KernelArg2,
+                                                   NULL),
                                                    return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                    3,
-                                                   1024*sizeof(int),
+                                                   128*sizeof(unsigned char),
                                                    NULL),
                                                    return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                    4,
-                                                   sizeof(int),
-                                                   &data_m),
-                                                   return CL_FALSE);
-      
-      CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                   jocldec_cl_rundata->kernel[1],
-                                                   1,
-                                                   0,
-                                                   global_ws,
-                                                   local_ws,
-                                                   0,
-                                                   NULL,
+                                                   128*sizeof(unsigned char),
                                                    NULL),
                                                    return CL_FALSE);
-      /* IDCT FAST FLOAT */
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
-                                                   0,
-                                                   sizeof(cl_mem),
-                                                   &jocl_global_data_mem_input[j]),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
-                                                   1,
-                                                   sizeof(cl_mem),
-                                                   &jocl_global_data_mem_inter),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
-                                                   2,
-                                                   sizeof(cl_mem),
-                                                   &jocl_global_data_mem_qutable),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
-                                                   3,
-                                                   1024*sizeof(int),
-                                                   NULL),
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                   5,
+                                                   sizeof(unsigned int),
+                                                   &blocksWidth),
                                                    return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
-                                                   4,
-                                                   sizeof(float),
-                                                   &data_m),
+    }
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                   6,
+                                                   sizeof(unsigned int),
+                                                   &offset_output),
                                                    return CL_FALSE);
-      
-      CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                   jocldec_cl_rundata->kernel[2],
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(ocl_status),
+                                                   jocldec_cl_kernel_use,
                                                    1,
                                                    0,
-                                                   global_ws,
-                                                   local_ws,
+                                                   &global_ws,
+                                                   &local_ws,
                                                    0,
                                                    NULL,
                                                    NULL),
                                                    return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[21],
-                                                  0,
-                                                  sizeof(cl_mem),
-                                                  &jocl_global_data_mem_input[j]),
-                                                  return CL_FALSE);
-      
-      CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                  jocldec_cl_rundata->kernel[21],
-                                                  1,
-                                                  0,
-                                                  global_ws,
-                                                  local_ws,
-                                                  0,
-                                                  NULL,
-                                                  NULL),
-                                                  return CL_FALSE);
+  }/*1v2 end*/
+  else if ((4 == data_m ) || (6 == data_m )){
+    if (4 == data_m){
+      KernelArg2 = 384 * sizeof(unsigned char);
+	  KernelArg5 = 128 * sizeof(unsigned char);
+	  KernelArg6 = 128 * sizeof(unsigned char); 	  
+      local_ws   = 64;
+	  if (CL_TRUE == jocl_cl_get_fancy_status(ocl_status)){
+        if (decodeMCU != total_mcu_num)
+	      global_ws = (mcu_num - 1)* 64;
+        else
+	  	  global_ws = mcu_num * 64;
+        offset_output = offset_mcu * (MCUNUMS - 1) * 64;
+        if (TRUE == cinfo->opencl_rgb_flag)
+          jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[7];
+        else
+          jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[19];
+      }
+	  else{
+        offset_output = offset_mcu * 64;
+        global_ws = mcu_num * 64;
+        if (TRUE == cinfo->opencl_rgb_flag)
+          jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[5];
+        else
+          jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[17];
+      }
+    }/*end if(data_m == 4)*/
+    else if (6 == data_m){
+      KernelArg2 = 768 * sizeof(unsigned char);
+      KernelArg5 = 256 * sizeof(unsigned char);
+      KernelArg6 = 256 * sizeof(unsigned char);
+      offset_output = offset_mcu * 128;
+      global_ws     = mcu_num * 128;
+      local_ws      = 128;
+      if (TRUE == cinfo->opencl_rgb_flag)
+        jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[6];
+      else
+        jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[18];
+    }/*end if(data_m == 6)*/
+    if (0 == offset_mcu || CL_TRUE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+      if (CL_FALSE == jocl_cl_get_fancy_status(ocl_status)){
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     0,
+                                                     sizeof(cl_mem),
+                                                     &ocl_status->jocl_global_data_mem_inter[0]),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     1,
+                                                     sizeof(cl_mem),
+                                                     &ocl_status->jocl_global_data_mem_output),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     2,
+                                                     KernelArg2,
+                                                     NULL),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     3,
+                                                     64*sizeof(unsigned char),
+                                                     NULL),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     4,
+                                                     64*sizeof(unsigned char),
+                                                     NULL),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     5,
+                                                     KernelArg5,
+                                                     NULL),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     6,
+                                                     KernelArg6,
+                                                     NULL),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     7,
+                                                     sizeof(unsigned int),
+                                                     &blocksWidth),
+                                                     return CL_FALSE);
+      }
+      else {
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     0,
+                                                     sizeof(cl_mem),
+                                                     &ocl_status->jocl_global_data_mem_inter[0]),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     1,
+                                                     sizeof(cl_mem),
+                                                     &ocl_status->jocl_global_data_mem_output),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     2,
+                                                     sizeof(cl_mem),
+                                                     &ocl_status->jocl_global_data_mem_prior_inter[0]),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     3,
+                                                     KernelArg2,
+                                                     NULL),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     4,
+                                                     64*sizeof(unsigned char),
+                                                     NULL),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     5,
+                                                     64*sizeof(unsigned char),
+                                                     NULL),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     6,
+                                                     KernelArg5,
+                                                     NULL),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     7,
+                                                     KernelArg6,
+                                                     NULL),
+                                                     return CL_FALSE);
+        CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                     8,
+                                                     sizeof(unsigned int),
+                                                     &blocksWidth),
+                                                     return CL_FALSE);
+      }
     }
-    /* H1V1 RGB */
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
-                                                 2,
-                                                 192*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
-                                                 3,
+    if (CL_FALSE == jocl_cl_get_fancy_status(ocl_status)){
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                   8,
+                                                   sizeof(unsigned int),
+                                                   &offset_output),
+                                                   return CL_FALSE);
+    }else {
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 9,
                                                  sizeof(unsigned int),
-                                                 &blocksWidth),
+                                                 &offset_output),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
-                                                 4,
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 10,
                                                  sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);    
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[3],
+                                                 &edge_mcu_h),
+                                                 return CL_FALSE);
+    }
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(ocl_status),
+                                                 jocldec_cl_kernel_use,
                                                  1,
                                                  0,
-                                                 global_ws,
-                                                 local_ws,
+                                                 &global_ws,
+                                                 &local_ws,
                                                  0,
                                                  NULL,
                                                  NULL),
-												 return CL_FALSE);
-     /* H1V2 RGB */
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
-                                                 1,
+
+  }
+  if (CL_FALSE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+    global_ws = (mcu_num * mcu_in/8 + 255)/256*256;
+    local_ws  = 256;
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[21],
+                                                 0,
                                                  sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
-                                                 2,
-                                                 384*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
-                                                 3,
-                                                 128*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
-                                                 4,
-                                                 128*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);  
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
-                                                 5,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
-                                                 6,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
+                                                 &ocl_status->jocl_global_data_mem_input[buffer_index]),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[4],
+    
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(ocl_status),
+                                                 ocl_status->jocldec_cl_rundata->kernel[21],
                                                  1,
                                                  0,
-                                                 global_ws,
-                                                 local_ws,
+                                                 &global_ws,
+                                                 &local_ws,
                                                  0,
                                                  NULL,
-                                                 NULL),
-                                                 return CL_FALSE);
-    /* H2V1 RGB */
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5], 
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
-                                                 2,
-                                                 384*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
-                                                 3,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
-                                                 4,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE); 
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
-                                                 5,
-                                                 128*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
-                                                 6,
-                                                 128*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
-                                                 7,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
+                                                 &buffer_event[buffer_index]),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
-                                                 8,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[5],
-                                                 1,
-                                                 0,
-                                                 global_ws,
-                                                 local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
-                                                 return CL_FALSE);
-    /* H2V2 RGB */
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+  }    
+  size_map = cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE *
+    cinfo->image_height * NUM_COMPONENT;
+
+  if (decodeMCU != total_mcu_num) {
+    CL_SAFE_CALL0(err_code = jocl_clFlush(jocl_cl_get_command_queue(ocl_status)),return CL_FALSE);
+  }
+  else {
+    if (CL_FALSE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+      int index_event;
+      for(index_event = 0; index_event < buffer_index; index_event++)
+      {
+        jocl_clReleaseEvent(buffer_event[index_event]);
+      }
+    }
+    CL_SAFE_CALL0(err_code = jocl_clFinish(jocl_cl_get_command_queue(ocl_status)),return CL_FALSE);
+    if (CL_TRUE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+      CL_SAFE_CALL0(err_code = jocl_clEnqueueReadBuffer(jocl_cl_get_command_queue(ocl_status),
+        ocl_status->jocl_global_data_mem_output, CL_TRUE, 0, size_map, ocl_status->jocl_global_data_ptr_output,
+        0, NULL, NULL), return CL_FALSE);  	
+	}
+	else {
+      CL_SAFE_CALL0(ocl_status->jocl_global_data_ptr_output = (JSAMPROW)jocl_clEnqueueMapBuffer(
+        jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_output, CL_TRUE,
+        CL_MAP_READ, 0, size_map, 0, NULL, NULL, &err_code),return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
+        jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_output,
+        ocl_status->jocl_global_data_ptr_output, 0, NULL, NULL), return CL_FALSE);
+    }
+    CL_SAFE_CALL0(err_code = jocl_clFinish(jocl_cl_get_command_queue(ocl_status)),return CL_FALSE);
+  }
+  return CL_TRUE;
+}
+
+
+cl_bool jocldec_run_kernels_h2v2_fancy(
+                            j_decompress_ptr cinfo,
+                            int data_m,
+                            int mcu_num,
+                            unsigned int blocksWidth,
+                            unsigned int offset_mcu,
+                            int total_mcu_num,
+                            int decodeMCU,
+                            int buffer_index,
+                            cl_event* buffer_event,
+                            int mcunum_buffer)
+{
+  cl_int err_code;
+  size_t global_ws,local_ws;
+  int    mcu_out,mcu_in;
+  int    data_m_inter = data_m;
+  int    size_map;
+  unsigned int offset_output;
+  cl_kernel jocldec_cl_kernel_use;
+  unsigned int mcu_total = total_mcu_num * 128;
+  int KernelArg2 = 0;
+  int KernelArg5 = 0;
+  int KernelArg6 = 0;
+  int buffer_index_prior;
+  int edge_mcu_h = 0, edge_mcu_v = 0;
+  unsigned int mcu_offset_buffer;
+  OCL_STATUS * ocl_status =  (OCL_STATUS* )cinfo->jocl_openClinfo;
+
+  if (buffer_index == 0) buffer_index_prior = 9;
+  else buffer_index_prior = buffer_index - 1;
+  if (cinfo->image_width % 16 == 0)
+    edge_mcu_h = 7;
+  else
+    edge_mcu_h = (cinfo->image_width % 16 + 1)/ 2 - 1;
+
+  if (cinfo->image_height % 16 == 0)
+    edge_mcu_v = 8;
+  else
+    edge_mcu_v = (cinfo->image_height % 16 + 1)/ 2;
+
+  mcu_out   = 768;
+  mcu_in    = 384;
+  global_ws = (mcu_num * mcu_in /8+255)/256*256;
+
+  if (CL_TRUE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueWriteBuffer(jocl_cl_get_command_queue(ocl_status),
+      ocl_status->jocl_global_data_mem_input[buffer_index], CL_TRUE, 0,  MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF),
+      ocl_status->jocl_global_data_ptr_input[buffer_index], 0, NULL, NULL), return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueWriteBuffer(jocl_cl_get_command_queue(ocl_status),
+      ocl_status->jocl_global_data_mem_qutable, CL_TRUE, 0,  128 * sizeof(float), ocl_status->jocl_global_data_ptr_qutable,
+      0, NULL, NULL), return CL_FALSE);
+  }
+#ifndef JOCL_CL_OS_WIN32
+  if (CL_FALSE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
+      jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_input[buffer_index],
+      ocl_status->jocl_global_data_ptr_input[buffer_index], 0, NULL, NULL),return CL_FALSE);
+  }
+#endif
+  switch (cinfo->dct_method){
+    case JDCT_IFAST:
+      local_ws = 256;
+      jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[0];
+      break;
+    case JDCT_ISLOW:
+      local_ws = 128;
+      jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[1];
+      break;
+    case JDCT_FLOAT:
+      local_ws = 128;
+      jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[2];
+      break;
+  }
+  CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                               0,
+                                               sizeof(cl_mem),
+                                               &ocl_status->jocl_global_data_mem_input[buffer_index]),
+                                               return CL_FALSE);
+  CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                               1,
+                                               sizeof(cl_mem),
+                                               &ocl_status->jocl_global_data_mem_inter[buffer_index]),
+                                               return CL_FALSE);
+  if (0 == offset_mcu || CL_TRUE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  2,
-                                                 768*sizeof(unsigned char),
-                                                 NULL),
+                                                 sizeof(cl_mem),
+                                                 &ocl_status->jocl_global_data_mem_qutable),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  3,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
-                                                 4, 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE); 
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
-                                                 5, 256*sizeof(unsigned char),
-                                                 NULL),
-                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
-                                                 6,
-                                                 256*sizeof(unsigned char),
+                                                 4096,
                                                  NULL),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
-                                                 7,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
-                                                 8,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 4,
+                                                 sizeof(int),
+                                                 &data_m_inter),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[6],
+  }
+  CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(ocl_status),
+                                                 jocldec_cl_kernel_use,
                                                  1,
                                                  0,
-                                                 global_ws,
-                                                 local_ws,
+                                                 &global_ws,
+                                                 &local_ws,
                                                  0,
                                                  NULL,
                                                  NULL),
                                                  return CL_FALSE);
-    /* H2V1 RGB FANCY */
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7], 
+   if (CL_FALSE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+    global_ws = (mcu_num * mcu_in/8 + 255)/256*256;
+    local_ws  = 256;
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(ocl_status->jocldec_cl_rundata->kernel[21],
                                                  0,
                                                  sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
-                                                 2,
-                                                 384*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
-                                                 3,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
-                                                 4,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE); 
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
-                                                 5,
-                                                 128*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
-                                                 6,
-                                                 128*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
-                                                 7,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
+                                                 &ocl_status->jocl_global_data_mem_input[buffer_index]),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
-                                                 8,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[7],
+    
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(ocl_status),
+                                                 ocl_status->jocldec_cl_rundata->kernel[21],
                                                  1,
                                                  0,
-                                                 global_ws,
-                                                 local_ws,
+                                                 &global_ws,
+                                                 &local_ws,
                                                  0,
                                                  NULL,
-                                                 NULL),
+                                                 &buffer_event[buffer_index]),
                                                  return CL_FALSE);
-    /* H2V2 RGB FANCY */
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+  }
+  if (TRUE == cinfo->opencl_rgb_flag)
+    jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[8];
+  else
+    jocldec_cl_kernel_use = ocl_status->jocldec_cl_rundata->kernel[20];
+
+  if (offset_mcu > 0) {
+    KernelArg2 = 768 * sizeof(unsigned char);
+    KernelArg5 = 256 * sizeof(unsigned char);
+    KernelArg6 = 256 * sizeof(unsigned char);
+    offset_output = (offset_mcu - mcunum_buffer) * 128;
+    mcu_offset_buffer = (mcunum_buffer - cinfo->MCUs_per_row) * 128;
+    global_ws     = mcunum_buffer * 128;
+    local_ws      = 128;
+
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  0,
                                                  sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
+                                                 &ocl_status->jocl_global_data_mem_inter[buffer_index_prior]),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  1,
                                                  sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
+                                                 &ocl_status->jocl_global_data_mem_inter[buffer_index]),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  2,
-                                                 768*sizeof(unsigned char),
-                                                 NULL),
+                                                 sizeof(cl_mem),
+                                                 &ocl_status->jocl_global_data_mem_output),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  3,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
+                                                 sizeof(cl_mem),
+                                                 &ocl_status->jocl_global_data_mem_prior_inter[buffer_index_prior]),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  4,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE); 
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                 sizeof(cl_mem),
+                                                 &ocl_status->jocl_global_data_mem_prior_inter[buffer_index]),
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  5,
-                                                 256*sizeof(unsigned char),
+                                                 KernelArg2, 
                                                  NULL),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  6,
-                                                 256*sizeof(unsigned char),
+                                                 200*sizeof(unsigned char),
                                                  NULL),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  7,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
+                                                 200*sizeof(unsigned char),
+                                                 NULL),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  8,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[8],
-                                                 1,
-                                                 0,
-                                                 global_ws,
-                                                 local_ws,
-                                                 0,
-                                                 NULL,
+                                                 KernelArg5,
                                                  NULL),
                                                  return CL_FALSE);
-    /*H1V1_RGBA*/
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
-                                                 2,
-                                                 256*sizeof(unsigned char),
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 9,
+                                                 KernelArg6,
                                                  NULL),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
-                                                 3,
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 10,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
-                                                 4,
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 11,
                                                  sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[9],
-                                                 1,
-                                                 0,
-                                                 global_ws,
-                                                 local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
-                                                 return CL_FALSE);
-    
-    /*H1V2_RGBA*/
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
+                                                 &offset_output),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
-                                                 2,
-                                                 512*sizeof(unsigned char),
-                                                 NULL),
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 12,
+                                                 sizeof(unsigned int),
+                                                 &mcu_total),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
-                                                 3,
-                                                 128*sizeof(unsigned char),
-                                                 NULL),
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 13,
+                                                 sizeof(unsigned int),
+                                                 &edge_mcu_h),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
-                                                 4,
-                                                 128*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);  
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
-                                                 5,
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 14,
                                                  sizeof(unsigned int),
-                                                 &blocksWidth),
+                                                 &edge_mcu_v),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
-                                                 6,
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 15,
                                                  sizeof(unsigned int),
-                                                 &blocksWidth),
+                                                 &mcu_offset_buffer),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[10],
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(ocl_status),
+                                                 jocldec_cl_kernel_use,
                                                  1,
                                                  0,
-                                                 global_ws,
-                                                 local_ws,
+                                                 &global_ws,
+                                                 &local_ws,
                                                  0,
                                                  NULL,
                                                  NULL),
                                                  return CL_FALSE);
-    /*H2V1_RGBA*/
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11], 
+  }
+  if (decodeMCU == total_mcu_num) {
+    KernelArg2 = 768 * sizeof(unsigned char);
+    KernelArg5 = 256 * sizeof(unsigned char);
+    KernelArg6 = 256 * sizeof(unsigned char);
+    offset_output = offset_mcu * 128;
+    mcu_offset_buffer = (mcunum_buffer - cinfo->MCUs_per_row) * 128;
+    global_ws     = mcu_num * 128;
+    local_ws      = 128;
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  0,
                                                  sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
+                                                 &ocl_status->jocl_global_data_mem_inter[buffer_index]),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  1,
                                                  sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
+                                                 &ocl_status->jocl_global_data_mem_inter[buffer_index]),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  2,
-                                                 512*sizeof(unsigned char),
-                                                 NULL),
+                                                 sizeof(cl_mem),
+                                                 &ocl_status->jocl_global_data_mem_output),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  3,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
+                                                 sizeof(cl_mem),
+                                                 &ocl_status->jocl_global_data_mem_prior_inter[buffer_index]),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  4,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE); 
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                 sizeof(cl_mem),
+                                                 &ocl_status->jocl_global_data_mem_prior_inter[buffer_index_prior]),
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  5,
-                                                 128*sizeof(unsigned char),
+                                                 KernelArg2,
                                                  NULL),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  6,
-                                                 128*sizeof(unsigned char),
+                                                 200*sizeof(unsigned char),
                                                  NULL),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  7,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
-                                                 8,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);    
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                   jocldec_cl_rundata->kernel[11],
-                                                   1,
-                                                   0,
-                                                   global_ws,
-                                                   local_ws,
-                                                   0,
-                                                   NULL,
-                                                   NULL),
-                                                   return CL_FALSE);
-      
-    /*H2V2_RGBA*/
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
-                                                 2,
-                                                 1024*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
-                                                 3,
-                                                 64*sizeof(unsigned char),
+                                                 200*sizeof(unsigned char),
                                                  NULL),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
-                                                 4,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE); 
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
-                                                 5,
-                                                 256*sizeof(unsigned char),
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 8,
+                                                 KernelArg5,
                                                  NULL),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
-                                                 6,
-                                                 256*sizeof(unsigned char),
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 9,
+                                                 KernelArg6,
                                                  NULL),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
-                                                 7,
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 10,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
-                                                 8,
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 11,
                                                  sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[12],
-                                                 1,
-                                                 0,
-                                                 global_ws,
-                                                 local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
-                                                 return CL_FALSE);
-    /*H2V1_RGBA_FANCY*/
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13], 
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
-                                                 2,
-                                                 512*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
-                                                 3,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
-                                                 4,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE); 
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
-                                                 5,
-                                                 128*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
-                                                 6,
-                                                 128*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
-                                                 7,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
-                                                 8,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[13],
-                                                 1,
-                                                 0,
-                                                 global_ws,
-                                                 local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
-                                                 return CL_FALSE);
-    /*H2V2_RGBA_FANCY */
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
-                                                 2,
-                                                 1024*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
-                                                 3,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
-                                                 4,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE); 
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
-                                                 5,
-                                                 256*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
-                                                 6,
-                                                 256*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
-                                                 7,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
-                                                 8,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[14],
-                                                 1,
-                                                 0,
-                                                 global_ws,
-                                                 local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
-                                                 return CL_FALSE);
-    /* H1V1 BGR */
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
-                                                 2,
-                                                 192*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
-                                                 3,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
-                                                 4,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[15],
-                                                 1,
-                                                 0,
-                                                 global_ws,
-                                                 local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
-	 											 return CL_FALSE);
-    /* H1V2 BGR */
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
-                                                 2,
-                                                 384*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
-                                                 3,
-                                                 128*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
-                                                 4,
-                                                 128*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);  
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
-                                                 5,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
-                                                 6,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[16],
-                                                 1,
-                                                 0,
-                                                 global_ws,
-                                                 local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
-                                                 return CL_FALSE);
-    /* H2V1 BGR */
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17], 
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
-                                                 2,
-                                                 384*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
-                                                 3,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
-                                                 4,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE); 
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
-                                                 5,
-                                                 128*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
-                                                 6,
-                                                 128*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
-                                                 7,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
-                                                 8,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[17],
-                                                 1,
-                                                 0,
-                                                 global_ws,
-                                                 local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
-                                                 return CL_FALSE);
-    /* H2V2 BGR */
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
-                                                 2,
-                                                 768*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
-                                                 3,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
-                                                 4,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE); 
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
-                                                 5,
-                                                 256*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
-                                                 6,
-                                                 256*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
-                                                 7,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
-                                                 8,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[18],
-                                                 1,
-                                                 0,
-                                                 global_ws,
-                                                 local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
-                                                 return CL_FALSE);
-    /* H2V1 BGR FANCY  */
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19], 
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
-                                                 2,
-                                                 384*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
-                                                 3,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
-                                                 4,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE); 
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
-                                                 5,
-                                                 128*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
-                                                 6,
-                                                 128*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
-                                                 7,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
-                                                 8,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[19],
-                                                 1,
-                                                 0,
-                                                 global_ws,
-                                                 local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
-                                                 return CL_FALSE);
-    /* H2V2 BGR FANCY */
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_output),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
-                                                 2,
-                                                 768*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
-                                                 3,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
-                                                 4,
-                                                 64*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE); 
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
-                                                 5,
-                                                 256*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
-                                                 6,
-                                                 256*sizeof(unsigned char),
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
-                                                 7,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
-                                                 8,
-                                                 sizeof(unsigned int),
-                                                 &blocksWidth),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[20],
-                                                 1,
-                                                 0,
-                                                 global_ws,
-                                                 local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clFinish(jocl_cl_get_command_queue()), return CL_FALSE);
-  }
-  return CL_TRUE;
-}
-
-cl_bool jocldec_run_kernels_full_image(
-                            j_decompress_ptr cinfo,
-                            int data_m,
-                            int mcu_num,
-                            unsigned int blocksWidth,
-                            unsigned int offset_mcu,
-                            int total_mcu_num,
-                            int decodeMCU,
-                            int buffer_index,
-                            cl_event* buffer_event)
-{
-  cl_int err_code;
-  size_t global_ws,local_ws;
-  int    mcu_out,mcu_in;
-  int    data_m_inter = data_m;
-  int    size_map;
-  unsigned int offset_output;
-  cl_kernel jocldec_cl_kernel_use;
-
-  int KernelArg2 = 0;
-  int KernelArg5 = 0;
-  int KernelArg6 = 0;
-  /* int info; */
-
-  if (data_m==5) data_m_inter = 4;
-  switch(data_m) {
-    case 3: mcu_out   = 192;
-            mcu_in    = 192;
-            global_ws = (mcu_num * mcu_in /8+255)/256*256;
-            break;
-    case 5: mcu_out   = 384;
-            mcu_in    = 256;
-            global_ws = (mcu_num * mcu_in /8+255)/256*256;
-            break;
-    case 4: mcu_out   = 384;
-            mcu_in    = 256;
-            global_ws = (mcu_in / 8 + mcu_num * mcu_in / 8 +255)/256*256;
-            break;
-    case 6: mcu_out   = 768;
-            mcu_in    = 384;
-            global_ws = (mcu_num * mcu_in /8+255)/256*256;
-            break;
-  }
-  if(CL_TRUE == jocl_cl_is_nvidia_opencl()) {
-    CL_SAFE_CALL0(jocl_global_data_mem_input[buffer_index] = jocl_clCreateBuffer(jocl_cl_get_context(),
-      CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR,
-     MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF), jocl_global_data_ptr_input[buffer_index], &err_code),return CL_FALSE); 
-    CL_SAFE_CALL0(jocl_global_data_mem_qutable = jocl_clCreateBuffer(jocl_cl_get_context(),
-      CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
-      128 * sizeof(float), jocl_global_data_ptr_qutable, &err_code),return CL_FALSE);
-  }
-#ifndef JOCL_CL_OS_WIN32
-  if(CL_FALSE == jocl_cl_is_nvidia_opencl()) {
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
-      jocl_cl_get_command_queue(), jocl_global_data_mem_input[buffer_index],
-      jocl_global_data_ptr_input[buffer_index], 0, NULL, NULL),return CL_FALSE);
-  }
-#endif
-  switch (cinfo->dct_method){
-    case JDCT_IFAST:
-      local_ws = 256;
-      jocldec_cl_kernel_use = jocldec_cl_rundata->kernel[0];
-      break;
-    case JDCT_ISLOW:
-      local_ws = 128;
-      jocldec_cl_kernel_use = jocldec_cl_rundata->kernel[1];
-      break;
-    case JDCT_FLOAT:
-      local_ws = 128;
-      jocldec_cl_kernel_use = jocldec_cl_rundata->kernel[2];
-      break;
-  }
-  CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                               0,
-                                               sizeof(cl_mem),
-                                               &jocl_global_data_mem_input[buffer_index]),
-                                               return CL_FALSE);
-  if (0 == offset_mcu || CL_TRUE == jocl_cl_is_nvidia_opencl()) {
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                 2,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_qutable),
+                                                 &offset_output),
                                                  return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                 3,
-                                                 4096,
-                                                 NULL),
+                                                 12,
+                                                 sizeof(unsigned int),
+                                                 &mcu_total),
                                                  return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                 4,
-                                                 sizeof(int),
-                                                 &data_m_inter),
-                                                 return CL_FALSE);
-  }
-  CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_kernel_use,
-                                                 1,
-                                                 0,
-                                                 &global_ws,
-                                                 &local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
+                                                 13,
+                                                 sizeof(unsigned int),
+                                                 &edge_mcu_h),
                                                  return CL_FALSE);
-  if(3 == data_m){
-	global_ws     = mcu_num * 64;
-    offset_output = offset_mcu * 64;
-    local_ws      = 64;
-	switch (cinfo->out_color_space){
-	  case JCS_RGB:
-        jocldec_cl_kernel_use = jocldec_cl_rundata->kernel[3];
-        break;
-	  case JCS_EXT_RGBA:
-        jocldec_cl_kernel_use = jocldec_cl_rundata->kernel[9];
-        break;
-	  case JCS_EXT_BGR:
-        jocldec_cl_kernel_use = jocldec_cl_rundata->kernel[15];
-        break;
-	}/*end switch */
-    if (0 == offset_mcu || CL_TRUE == jocl_cl_is_nvidia_opencl()) {
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   0,
-                                                   sizeof(cl_mem),
-                                                   &jocl_global_data_mem_inter),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   1,
-                                                   sizeof(cl_mem),
-                                                   &jocl_global_data_mem_output),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   2,
-                                                   256*sizeof(unsigned char),
-                                                   NULL),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   3,
-                                                   sizeof(unsigned int),
-                                                   &blocksWidth),
-                                                   return CL_FALSE);
-    }
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                 4,
+                                                 14,
                                                  sizeof(unsigned int),
-                                                 &offset_output),
-                                                 return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_kernel_use,
-                                                 1,
-                                                 0,
-                                                 &global_ws,
-                                                 &local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
+                                                 &edge_mcu_v),
                                                  return CL_FALSE);
-  }  /*1v1 end*/
-  else if(5 == data_m){ 
-	offset_output = offset_mcu * 128;
-    global_ws     = mcu_num * 128;
-    local_ws      = 128;
-	switch (cinfo->out_color_space){
-	  case JCS_RGB:
-		KernelArg2 = 384 * sizeof(unsigned char);
-		jocldec_cl_kernel_use = jocldec_cl_rundata->kernel[4];
-	    break;
-	  case JCS_EXT_RGBA:
-	  	KernelArg2 = 512 * sizeof(unsigned char);
-	  	jocldec_cl_kernel_use = jocldec_cl_rundata->kernel[10];
-        break;
-	  case JCS_EXT_BGR:
-	  	KernelArg2 = 384 * sizeof(unsigned char);
-	  	jocldec_cl_kernel_use = jocldec_cl_rundata->kernel[16];
-        break;
-	}/*end switch */
-    if (0 == offset_mcu || CL_TRUE == jocl_cl_is_nvidia_opencl()) {
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   0,
-                                                   sizeof(cl_mem),
-                                                   &jocl_global_data_mem_inter),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   1,
-                                                   sizeof(cl_mem),
-                                                   &jocl_global_data_mem_output),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   2,
-                                                   KernelArg2,
-                                                   NULL),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   3,
-                                                   128*sizeof(unsigned char),
-                                                   NULL),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   4,
-                                                   128*sizeof(unsigned char),
-                                                   NULL),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   5,
-                                                   sizeof(unsigned int),
-                                                   &blocksWidth),
-                                                   return CL_FALSE);
-    }
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   6,
-                                                   sizeof(unsigned int),
-                                                   &offset_output),
-                                                   return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                   jocldec_cl_kernel_use,
-                                                   1,
-                                                   0,
-                                                   &global_ws,
-                                                   &local_ws,
-                                                   0,
-                                                   NULL,
-                                                   NULL),
-                                                   return CL_FALSE);
-  }/*1v2 end*/
-  else if((4 == data_m ) || (6 == data_m )){
-	switch (cinfo->out_color_space){
-	  case JCS_RGB:{
-	    if(4 == data_m){
-          KernelArg2 = 384 * sizeof(unsigned char);
-	  	  KernelArg5 = 128 * sizeof(unsigned char);
-	  	  KernelArg6 = 128 * sizeof(unsigned char);
-	  
-	  	  offset_output = offset_mcu * 64;
-          local_ws      = 64;
-	  	  if(CL_TRUE == jocl_cl_get_fancy_status()){
-	  	    global_ws = (mcu_num+1) * 64;
-	  	    jocldec_cl_kernel_use = jocldec_cl_rundata -> kernel[7];
-          }
-	  	  else{
-	  	    global_ws = mcu_num * 64;
-	  	    jocldec_cl_kernel_use = jocldec_cl_rundata -> kernel[5];
-	  	  }
-	    }/*end if(data_m == 4)*/
-	    else if(6 == data_m){
-	      KernelArg2 = 768 * sizeof(unsigned char);
-	  	  KernelArg5 = 256 * sizeof(unsigned char);
-	  	  KernelArg6 = 256 * sizeof(unsigned char);
-	  
-	  	  offset_output = offset_mcu * 128;
-          global_ws     = mcu_num * 128;
-          local_ws      = 128;
-	  	  if(1){
-	  	    jocldec_cl_kernel_use = jocldec_cl_rundata -> kernel[6];
-	  	  }
-	  	  else{
-	  	    jocldec_cl_kernel_use = jocldec_cl_rundata -> kernel[8];
-	  	  }      
-	    }/*end if(data_m == 6)*/
-	  }/*end of case JCS_RGB:*/
-	  break;
-	  case JCS_EXT_RGBA:{
-	    if(4 == data_m){
-          KernelArg2 = 512 * sizeof(unsigned char);
-	  	  KernelArg5 = 128 * sizeof(unsigned char);
-	  	  KernelArg6 = 128 * sizeof(unsigned char);
-	  
-	  	  offset_output = offset_mcu * 64;
-          global_ws     = mcu_num * 64;
-          local_ws      = 64;
-	  	  if(CL_TRUE == jocl_cl_get_fancy_status()){
-	  	    jocldec_cl_kernel_use = jocldec_cl_rundata -> kernel[13];
-	  	  }
-	  	  else{
-	  	    jocldec_cl_kernel_use = jocldec_cl_rundata -> kernel[11];
-	  	  }
-	    }/*end if(data_m == 4)*/
-	    else if(6 == data_m){
-	      KernelArg2 = 1024 * sizeof(unsigned char);
-	  	  KernelArg5 = 256 * sizeof(unsigned char);
-	  	  KernelArg6 = 256 * sizeof(unsigned char);
-	  
-	  	  offset_output = offset_mcu * 128;
-          global_ws     = mcu_num * 128;
-          local_ws      = 128;
-	  	  if(1){
-	  	    jocldec_cl_kernel_use = jocldec_cl_rundata -> kernel[12];
-	  	  }
-	  	  else{
-	  	    jocldec_cl_kernel_use = jocldec_cl_rundata -> kernel[14];
-	  	  }    
-	    }/* end if(data_m == 6) */ 
-	  }/*end of case JCS_EXT_RGBA:*/
-	  break;
-	  case JCS_EXT_BGR:{
-		if(4 == data_m){
-          KernelArg2 = 348 * sizeof(unsigned char);
-	  	  KernelArg5 = 128 * sizeof(unsigned char);
-	  	  KernelArg6 = 128 * sizeof(unsigned char);
-	  
-	  	  offset_output = offset_mcu * 64;
-          local_ws      = 64;
-	  	  if(CL_TRUE == jocl_cl_get_fancy_status()){
-		    global_ws = (mcu_num + 1) * 64;
-	  	    jocldec_cl_kernel_use = jocldec_cl_rundata -> kernel[19];
-	  	  }
-	  	  else{
-			global_ws = mcu_num * 64;
-	  	    jocldec_cl_kernel_use = jocldec_cl_rundata -> kernel[17];
-	  	  }
-        }/*end if(data_m == 4)*/
-        else if(6 == data_m){
-          KernelArg2 = 768 * sizeof(unsigned char);
-          KernelArg5 = 256 * sizeof(unsigned char);
-          KernelArg6 = 256 * sizeof(unsigned char);
-
-          offset_output = offset_mcu * 128;
-          global_ws     = mcu_num * 128;
-          local_ws      = 128;
-          if(1){
-            jocldec_cl_kernel_use = jocldec_cl_rundata -> kernel[18];
-          }
-          else{
-            jocldec_cl_kernel_use = jocldec_cl_rundata -> kernel[20];
-          }
-        }/* end if(data_m == 6)*/
-      }/*end of case JCS_EXT_BGR:*/
-      break;
-    }/*end switch */
-    if (0 == offset_mcu || CL_TRUE == jocl_cl_is_nvidia_opencl()) {
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   0,
-                                                   sizeof(cl_mem),
-                                                   &jocl_global_data_mem_inter),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   1,
-                                                   sizeof(cl_mem),
-                                                   &jocl_global_data_mem_output),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   2,
-                                                   KernelArg2,
-                                                   NULL),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   3,
-                                                   64*sizeof(unsigned char),
-                                                   NULL),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   4,
-                                                   64*sizeof(unsigned char),
-                                                   NULL),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   5,
-                                                   KernelArg5,
-                                                   NULL),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   6,
-                                                   KernelArg6,
-                                                   NULL),
-                                                   return CL_FALSE);
-      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                   7,
-                                                   sizeof(unsigned int),
-                                                   &blocksWidth),
-                                                   return CL_FALSE);
-    }
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                 8,
+                                                 15,
                                                  sizeof(unsigned int),
-                                                 &offset_output),
+                                                 &mcu_offset_buffer),
                                                  return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(ocl_status),
                                                  jocldec_cl_kernel_use,
                                                  1,
                                                  0,
@@ -1527,50 +995,72 @@ cl_bool jocldec_run_kernels_full_image(
                                                  NULL,
                                                  NULL),
                                                  return CL_FALSE);
-
   }
-  global_ws = (mcu_num * mcu_in/8 + 255)/256*256;
-  local_ws  = 256;
-  CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[21],
-                                               0,
-                                               sizeof(cl_mem),
-                                               &jocl_global_data_mem_input[buffer_index]),
-                                               return CL_FALSE);
-
-  CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                               jocldec_cl_rundata->kernel[21],
-                                               1,
-                                               0,
-                                               &global_ws,
-                                               &local_ws,
-                                               0,
-                                               NULL,
-                                               &buffer_event[buffer_index]),
-                                               return CL_FALSE);
- /* jocl_clGetEventInfo(*buffer_event, CL_EVENT_COMMAND_EXECUTION_STATUS, sizeof(info),&info,NULL); */
-
-  if(CL_TRUE == jocl_cl_is_nvidia_opencl()) {
-    CL_SAFE_CALL0(jocl_clReleaseMemObject(jocl_global_data_mem_input[buffer_index]),return CL_FALSE);
-    CL_SAFE_CALL0(jocl_clReleaseMemObject(jocl_global_data_mem_qutable),return CL_FALSE);
-  }
-  size_map = cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE *
-    cinfo->image_height * NUM_COMPONENT;
-
   if (decodeMCU != total_mcu_num) {
-    CL_SAFE_CALL0(err_code = jocl_clFlush(jocl_cl_get_command_queue()),return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clFlush(jocl_cl_get_command_queue(ocl_status)),return CL_FALSE);
   }
   else {
-    CL_SAFE_CALL0(err_code = jocl_clFinish(jocl_cl_get_command_queue()),return CL_FALSE);
-    CL_SAFE_CALL0(jocl_global_data_ptr_output = (JSAMPROW)jocl_clEnqueueMapBuffer(
-      jocl_cl_get_command_queue(), jocl_global_data_mem_output, CL_TRUE,
-      CL_MAP_READ, 0, size_map, 0, NULL, NULL, &err_code),return CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
-      jocl_cl_get_command_queue(), jocl_global_data_mem_output,
-      jocl_global_data_ptr_output, 0, NULL, NULL),return CL_FALSE);
+    size_map = cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE *
+      cinfo->image_height * NUM_COMPONENT;
 
-    CL_SAFE_CALL0(err_code = jocl_clFinish(jocl_cl_get_command_queue()),return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clFinish(jocl_cl_get_command_queue(ocl_status)),return CL_FALSE);
+    if (CL_TRUE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+      CL_SAFE_CALL0(err_code = jocl_clEnqueueReadBuffer(jocl_cl_get_command_queue(ocl_status),
+        ocl_status->jocl_global_data_mem_output, CL_TRUE, 0, size_map, ocl_status->jocl_global_data_ptr_output,
+        0, NULL, NULL), return CL_FALSE);  	
+	}
+	else {
+      CL_SAFE_CALL0(ocl_status->jocl_global_data_ptr_output = (JSAMPROW)jocl_clEnqueueMapBuffer(
+        jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_output, CL_TRUE,
+        CL_MAP_READ, 0, size_map, 0, NULL, NULL, &err_code),return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
+        jocl_cl_get_command_queue(ocl_status), ocl_status->jocl_global_data_mem_output,
+        ocl_status->jocl_global_data_ptr_output, 0, NULL, NULL), return CL_FALSE);
+    }
+    CL_SAFE_CALL0(err_code = jocl_clFinish(jocl_cl_get_command_queue(ocl_status)),return CL_FALSE);
   }
   return CL_TRUE;
 }
 
+void jocl_release_ocl_resource  (j_decompress_ptr cinfo)
+{
+  int j;
+  int num_buffer;
+    OCL_STATUS *ocl_status = (OCL_STATUS *)cinfo->jocl_openClinfo;
+  //if(cinfo->max_v_samp_factor == 2 && cinfo->max_h_samp_factor == 2)
+  //  num_buffer = 2;
+  //else
+    num_buffer = BUFFERNUMS;
+
+  if (CL_TRUE == jocl_cl_is_available(ocl_status) && jocl_cl_get_decode_support(ocl_status)) {
+
+
+    if (CL_TRUE == jocl_cl_is_nvidia_opencl(ocl_status)) {
+      free(ocl_status->jocl_global_data_ptr_output);
+      free(ocl_status->jocl_global_data_ptr_qutable);
+      for (j = 0; j < num_buffer; ++j) {
+        free(ocl_status->jocl_global_data_ptr_input[j]);
+      }
+    }
+    else {
+      jocl_clReleaseMemObject(ocl_status->jocl_global_data_mem_output);
+      jocl_clReleaseMemObject(ocl_status->jocl_global_data_mem_qutable);
+      for (j = 0; j < BUFFERNUMS; ++j) {
+        jocl_clReleaseMemObject(ocl_status->jocl_global_data_mem_inter[j]);
+        jocl_clReleaseMemObject(ocl_status->jocl_global_data_mem_prior_inter[j]);
+        jocl_clReleaseMemObject(ocl_status->jocl_global_data_mem_input[j]);
+      }
+    }
+    for (j = 0; j < 22; ++j) {
+      jocl_clReleaseKernel(ocl_status->jocldec_cl_rundata->kernel[j]);
+    }
+    jocl_clReleaseProgram(ocl_status->jocldec_cl_rundata->program);
+    jocl_clReleaseCommandQueue(jocl_cl_get_command_queue(ocl_status));
+    jocl_clReleaseContext(jocl_cl_get_context(ocl_status));
+    free(ocl_status->jocldec_cl_rundata->kernel);
+    free(ocl_status->jocldec_cl_rundata->work_group_size);
+    free(ocl_status->jocldec_cl_rundata);
+    ocl_status->jocldec_cl_rundata = NULL;
+  }
+}
 #endif
diff --git a/jocldec.h b/jocldec.h
index fffcff8..e3ad2ab 100644
--- a/jocldec.h
+++ b/jocldec.h
@@ -15,18 +15,21 @@
 #ifndef __JPEG_OPENCL_DECODING_H__
 #define __JPEG_OPENCL_DECODING_H__
 
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+#if 0
 /* Global OpenCL buffer and mapping variables. */
 extern cl_mem   jocl_global_data_mem_input[BUFFERNUMS];
 extern cl_mem   jocl_global_data_mem_output;
 extern cl_mem   jocl_global_data_mem_qutable;
-extern cl_mem   jocl_global_data_mem_inter;
+extern cl_mem   jocl_global_data_mem_inter[BUFFERNUMS];
+extern cl_mem   jocl_global_data_mem_prior_inter[BUFFERNUMS];
 extern float*   jocl_global_data_ptr_qutable;
 extern JCOEFPTR jocl_global_data_ptr_input[BUFFERNUMS];
 extern JSAMPROW jocl_global_data_ptr_output;
-
+#endif
 /* Compile OpenCL kernels. */
 cl_bool jocldec_build_kernels(j_decompress_ptr cinfo);
-
+void jocl_release_ocl_resource(j_decompress_ptr cinfo);
 /* Run decoding kernels for full image. */
 cl_bool jocldec_run_kernels_full_image(
   j_decompress_ptr cinfo,
@@ -38,4 +41,17 @@ cl_bool jocldec_run_kernels_full_image(
   int decodeMCU,                  /* The number of MCUs will be decoded */
   int buffer_flag,                /* The index of buffer will be used */
   cl_event* buffer_event);        /* The event of OpenCL sent by clEnqueueNDRangeKernel() */
+
+cl_bool jocldec_run_kernels_h2v2_fancy(
+  j_decompress_ptr cinfo,
+  int block_in_mcu,               /* Number of 8x8 blocks in one MCU */
+  int num_of_mcu,                 /* Number of MCUs in one whole image */
+  unsigned int mcu_in_width,      /* Number of MCUs in image width */
+  unsigned int offset_input,      /* The offset of buffer used to calculate the global ID */
+  int total_mcu_num,              /* The total MCU-number of an image */
+  int decodeMCU,                  /* The number of MCUs will be decoded */
+  int buffer_flag,                /* The index of buffer will be used */
+  cl_event* buffer_event,         /* The event of OpenCL sent by clEnqueueNDRangeKernel() */
+  int mcunum_buffer);
+#endif
 #endif
diff --git a/joclinit.c b/joclinit.c
index 783b252..746e75e 100644
--- a/joclinit.c
+++ b/joclinit.c
@@ -12,6 +12,8 @@
 #define __JOCL_CL_INIT_MAIN__
 #include "jinclude.h"
 #include "jpeglib.h"
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+
 #include "CL/opencl.h"
 #include "joclinit.h"
 #undef  __JOCL_CL_INIT_MAIN__
@@ -20,30 +22,8 @@
 #define CL_QUEUE_THREAD_HANDLE_AMD 0x403E
 #define CL_PARAM_NUM 20
 #endif
-/*
- * OCL_STATIS ocl_status
- * Store all the informations of OpenCL platform.
- */
 
-typedef struct
-{
-  cl_platform_id   platform_id;
-  cl_device_id     device_id;
-  cl_context       context;
-  cl_command_queue command_queue;
-  cl_bool          is_opencl_available;
-  cl_bool          is_opencl_support;
-  cl_bool          fancy_index;
-  unsigned long    mem_size;
-  char             platform_profile   [1024];
-  char             platform_version   [1024];
-  char             platform_name      [1024];
-  char             platform_vendor    [1024];
-  char             platform_extensions[1024];
-  char             device_name        [1024];
-} OCL_STATUS;
-
-static OCL_STATUS ocl_status = {NULL, NULL, NULL, NULL, CL_FALSE, CL_FALSE, CL_FALSE, 0};
+//static OCL_STATUS ocl_status = {NULL, NULL, NULL, NULL, CL_FALSE, CL_FALSE, CL_FALSE, CL_FALSE, CL_FALSE, CL_FALSE, 0};
 
 
 /*
@@ -166,13 +146,44 @@ const char* jocl_cl_errstring(cl_int err_code)
     return CL_FALSE;                                                           \
   }
 #endif
-cl_bool jocl_cl_init()
+cl_bool jocl_cl_init(void **jocl_openClinfo)
 {
+    char*  platformVendor;
+    char * deviceName ;
+    char *ocl_disable;
 #ifdef JOCL_CL_OS_WIN32
   void *handle = INVALID_HANDLE_VALUE;
   int ret;
 #endif
-  if (!ocl_status.is_opencl_available) {
+
+  OCL_STATUS * ocl_status;
+  if( NULL == *jocl_openClinfo)
+  {
+
+      *jocl_openClinfo =  (void *)malloc(sizeof(OCL_STATUS));
+      if( NULL == *jocl_openClinfo)
+      {
+          return -1;
+      }
+      memset(*jocl_openClinfo,0,sizeof(OCL_STATUS));
+      ocl_status = ((OCL_STATUS *)(*jocl_openClinfo));
+      ocl_status->is_opencl_available = CL_FALSE;
+      ocl_status->is_opencl_support = CL_FALSE;
+      ocl_status->fancy_index = CL_FALSE;
+
+  }
+  ocl_disable = getenv("LJT_DISABLE_OPENCL");
+  if(ocl_disable != NULL)
+  {
+      if( 0 == strcmp("TRUE",ocl_disable))
+      {
+          ocl_status->is_opencl_available = CL_FALSE;
+          ocl_status->is_opencl_support = CL_FALSE;
+          ocl_status->fancy_index = CL_FALSE;
+          return CL_FALSE;
+      }
+  }
+  if (!ocl_status->is_opencl_available) {
     cl_int          err_code;
     cl_uint         num_platform;
     cl_uint         num_device;
@@ -180,7 +191,9 @@ cl_bool jocl_cl_init()
     cl_device_id*   dids;
     cl_uint         index;
 	unsigned int    num_gpu_device = 0;
-
+    char*           version_ocl_inter = NULL;
+    char*           version_ocl = NULL;
+    int             version_length = 0;
 #ifdef JOCL_CL_OS_WIN32
     HINSTANCE       module;
     module = LoadLibraryW(L"OpenCL.dll");
@@ -204,16 +217,16 @@ cl_bool jocl_cl_init()
     CL_LOAD_FUNCTION(clReleaseDevice                  );*/
     CL_LOAD_FUNCTION(clCreateContext                  );
     /* CL_LOAD_FUNCTION(clCreateContextFromType       );
-    CL_LOAD_FUNCTION(clRetainContext                  );
+    CL_LOAD_FUNCTION(clRetainContext                  );*/
     CL_LOAD_FUNCTION(clReleaseContext                 );
-    CL_LOAD_FUNCTION(clGetContextInfo                 );*/
+    /* CL_LOAD_FUNCTION(clGetContextInfo              );*/
     CL_LOAD_FUNCTION(clCreateCommandQueue             );
-    /* CL_LOAD_FUNCTION(clRetainCommandQueue          );
-    CL_LOAD_FUNCTION(clReleaseCommandQueue            );*/
+    /* CL_LOAD_FUNCTION(clRetainCommandQueue          );*/
+    CL_LOAD_FUNCTION(clReleaseCommandQueue            );
     CL_LOAD_FUNCTION(clGetCommandQueueInfo            );
     CL_LOAD_FUNCTION(clCreateBuffer                   );
-    /* CL_LOAD_FUNCTION(clCreateSubBuffer             );
-    CL_LOAD_FUNCTION(clCreateImage                    );
+    CL_LOAD_FUNCTION(clCreateSubBuffer                );
+    /* CL_LOAD_FUNCTION(clCreateImage                 );
     CL_LOAD_FUNCTION(clRetainMemObject                );*/
     CL_LOAD_FUNCTION(clReleaseMemObject               );
     /* CL_LOAD_FUNCTION(clGetSupportedImageFormats    );*/
@@ -227,8 +240,8 @@ cl_bool jocl_cl_init()
     CL_LOAD_FUNCTION(clCreateProgramWithSource        );
     CL_LOAD_FUNCTION(clCreateProgramWithBinary        );
     /* CL_LOAD_FUNCTION(clCreateProgramWithBuiltInKernels);
-    CL_LOAD_FUNCTION(clRetainProgram                  );
-    CL_LOAD_FUNCTION(clReleaseProgram                 );*/
+    CL_LOAD_FUNCTION(clRetainProgram                  );*/
+    CL_LOAD_FUNCTION(clReleaseProgram                 );
     CL_LOAD_FUNCTION(clBuildProgram                   );
     /* CL_LOAD_FUNCTION(clCompileProgram              );
     CL_LOAD_FUNCTION(clLinkProgram                    );
@@ -237,8 +250,8 @@ cl_bool jocl_cl_init()
     CL_LOAD_FUNCTION(clGetProgramBuildInfo            );
     CL_LOAD_FUNCTION(clCreateKernel                   );
     /* CL_LOAD_FUNCTION(clCreateKernelsInProgram      );
-    CL_LOAD_FUNCTION(clRetainKernel                   );
-    CL_LOAD_FUNCTION(clReleaseKernel                  );*/
+    CL_LOAD_FUNCTION(clRetainKernel                   );*/
+    CL_LOAD_FUNCTION(clReleaseKernel                  );
     CL_LOAD_FUNCTION(clSetKernelArg                   );
     /*CL_LOAD_FUNCTION(clGetKernelInfo                );
     CL_LOAD_FUNCTION(clGetKernelArgInfo               );*/
@@ -253,8 +266,8 @@ cl_bool jocl_cl_init()
     CL_LOAD_FUNCTION(clGetEventProfilingInfo          );*/
     CL_LOAD_FUNCTION(clFlush                          );
     CL_LOAD_FUNCTION(clFinish                         );
-    /* CL_LOAD_FUNCTION(clEnqueueReadBuffer           );
-    CL_LOAD_FUNCTION(clEnqueueReadBufferRect          );*/
+    CL_LOAD_FUNCTION(clEnqueueReadBuffer              );
+    /* CL_LOAD_FUNCTION(clEnqueueReadBufferRect       );*/
     CL_LOAD_FUNCTION(clEnqueueWriteBuffer             );
     /* CL_LOAD_FUNCTION(clEnqueueWriteBufferRect      );
     CL_LOAD_FUNCTION(clEnqueueFillBuffer              );
@@ -284,50 +297,72 @@ cl_bool jocl_cl_init()
       CL_DEBUG_NOTE("NO CL PLATFORM!\n");
       return CL_FALSE;
     }
+    // Check for Environmental variable for opencl platform.
+   // if not present select the AMD platform if present
+   platformVendor=getenv("LJT_OPENCL_PLATFORMVENDOR");
+   if(NULL == platformVendor)
+       platformVendor = "Advanced Micro Devices, Inc.";
 
     pids = (cl_platform_id*)malloc(num_platform * sizeof(cl_platform_id));
 
     CL_SAFE_CALL1(err_code = jocl_clGetPlatformIDs(num_platform, pids, NULL),
       return CL_FALSE, pids);
 
+    //Select the platform
+    // if amd platform is not present select the last platform
     for (index = 0 ; index < num_platform ; ++index ) {
-      ocl_status.platform_id = pids[index];
-
-      CL_SAFE_CALL1(err_code = jocl_clGetPlatformInfo(ocl_status.platform_id,
-        CL_PLATFORM_VENDOR, sizeof(ocl_status.platform_vendor),
-        ocl_status.platform_vendor, NULL), return CL_FALSE, pids);
-
-      if (0 == strcmp(ocl_status.platform_vendor,
-        "Advanced Micro Devices, Inc."))
-        break;
+      ocl_status->platform_id = pids[index];
+
+      CL_SAFE_CALL1(err_code = jocl_clGetPlatformInfo(ocl_status->platform_id,
+        CL_PLATFORM_VENDOR, sizeof(ocl_status->platform_vendor),
+        ocl_status->platform_vendor, NULL), return CL_FALSE, pids);
+      if(NULL != platformVendor)
+      {
+        if (0 == strcmp(ocl_status->platform_vendor,
+            platformVendor))
+            break;
+      }
     }
 
     free(pids);
 
-    CL_SAFE_CALL0(err_code = jocl_clGetPlatformInfo(ocl_status.platform_id,
-      CL_PLATFORM_PROFILE, sizeof(ocl_status.platform_profile),
-      ocl_status.platform_profile, NULL), return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clGetPlatformInfo(ocl_status->platform_id,
+      CL_PLATFORM_PROFILE, sizeof(ocl_status->platform_profile),
+      ocl_status->platform_profile, NULL), return CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clGetPlatformInfo(ocl_status->platform_id,
+      CL_PLATFORM_VERSION, sizeof(ocl_status->platform_version),
+      ocl_status->platform_version, NULL), return CL_FALSE);
 
-    CL_SAFE_CALL0(err_code = jocl_clGetPlatformInfo(ocl_status.platform_id,
-      CL_PLATFORM_VERSION, sizeof(ocl_status.platform_version),
-      ocl_status.platform_version, NULL), return CL_FALSE);
+    version_ocl_inter = ocl_status->platform_version + 7;
+    for(; *version_ocl_inter != ' '; version_ocl_inter++) {
+      version_length++;
+    }
+    version_ocl = (char *) malloc((version_length + 1)* sizeof(char));
+    strncpy(version_ocl, ocl_status->platform_version + 7, version_length);
+    version_ocl[version_length] = '\0';
+
+    if(strcmp(version_ocl, "1.2") >= 0) {
+      ocl_status->is_version1_2_ocl = CL_TRUE;
+    }
+    free(version_ocl);
 
-    CL_SAFE_CALL0(err_code = jocl_clGetPlatformInfo(ocl_status.platform_id,
-      CL_PLATFORM_NAME, sizeof(ocl_status.platform_name),
-      ocl_status.platform_name, NULL), return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clGetPlatformInfo(ocl_status->platform_id,
+      CL_PLATFORM_NAME, sizeof(ocl_status->platform_name),
+      ocl_status->platform_name, NULL), return CL_FALSE);
 
-    CL_SAFE_CALL0(err_code = jocl_clGetPlatformInfo(ocl_status.platform_id,
-      CL_PLATFORM_EXTENSIONS, sizeof(ocl_status.platform_extensions),
-      ocl_status.platform_extensions, NULL), return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clGetPlatformInfo(ocl_status->platform_id,
+      CL_PLATFORM_EXTENSIONS, sizeof(ocl_status->platform_extensions),
+      ocl_status->platform_extensions, NULL), return CL_FALSE);
 
     CL_DEBUG_NOTE("Platform:\nprofile: %s\nversion: %s\nname: %s\n"
       "vendor: %s\nextensions: %s\n"
-      , ocl_status.platform_profile, ocl_status.platform_version
-      , ocl_status.platform_name, ocl_status.platform_vendor
-      , ocl_status.platform_extensions);
+      , ocl_status->platform_profile, ocl_status->platform_version
+      , ocl_status->platform_name, ocl_status->platform_vendor
+      , ocl_status->platform_extensions);
 
     /* ********* Get and select a device. ********* */
-    CL_SAFE_CALL0(err_code = jocl_clGetDeviceIDs(ocl_status.platform_id,
+    CL_SAFE_CALL0(err_code = jocl_clGetDeviceIDs(ocl_status->platform_id,
       CL_DEVICE_TYPE_ALL, 0, NULL, &num_device), return CL_FALSE);
     if ( num_device < 1 ) {
       CL_DEBUG_NOTE("NO DEVICE FOUND!\n");
@@ -336,54 +371,71 @@ cl_bool jocl_cl_init()
 
     dids = (cl_device_id*)malloc(num_device * sizeof(cl_device_id));
 
-    CL_SAFE_CALL1(err_code = jocl_clGetDeviceIDs(ocl_status.platform_id,
-      CL_DEVICE_TYPE_ALL, num_device, dids, NULL), return CL_FALSE, dids);
-
-	for ( index = 0 ; index < num_device ; ++index ) {
-	  cl_device_type d_type;
-	  ocl_status.device_id = dids[index];
-	  CL_SAFE_CALL1(err_code = jocl_clGetDeviceInfo(ocl_status.device_id,
-	  	CL_DEVICE_TYPE, sizeof(cl_device_type), &d_type, NULL),
-	  	return CL_FALSE, dids);
-	  if(CL_DEVICE_TYPE_GPU == d_type)
-	  	num_gpu_device++;
-	}
-	for (index = 0; index < num_device; ++index) {
-	  cl_device_type d_type;
-	  ocl_status.device_id = dids[index];
-	  CL_SAFE_CALL1(err_code = jocl_clGetDeviceInfo(ocl_status.device_id,
-	    CL_DEVICE_TYPE, sizeof(cl_device_type), &d_type, NULL),
-	    return CL_FALSE, dids);
-	  CL_SAFE_CALL0(err_code = jocl_clGetDeviceInfo(ocl_status.device_id,
-	    CL_DEVICE_NAME, sizeof(ocl_status.device_name), ocl_status.device_name, NULL),
-	    return CL_FALSE);
-	  if(CL_DEVICE_TYPE_GPU == d_type) {
-	    num_gpu_device--;
-	    if (0 == strcmp(ocl_status.device_name,
-	      "Devastator"))
-	      break;
-	  }
-	  if(num_gpu_device == 0)
-	    break;
-	}
-	CL_DEBUG_NOTE("Device:\nName: %s\n",ocl_status.device_name);
+    CL_SAFE_CALL1(err_code = jocl_clGetDeviceIDs(ocl_status->platform_id,
+    CL_DEVICE_TYPE_ALL, num_device, dids, NULL), return CL_FALSE, dids);
+    deviceName = platformVendor=getenv("LJT_OPENCLDEVICE");
+    if(NULL != deviceName)
+    {
+        // Select the device specified by user through environmental variable
+        // if not select the 0th device
+        for (index = (num_device-1); index >= 0; --index)
+        {
+            ocl_status->device_id = dids[index];
+            CL_SAFE_CALL0(err_code = jocl_clGetDeviceInfo(ocl_status->device_id,
+            CL_DEVICE_NAME, sizeof(ocl_status->device_name), ocl_status->device_name, NULL),
+            return CL_FALSE);
+            if (0 == strcmp(ocl_status->device_name,deviceName))
+            break;
+        }
+    }
+    else
+    {
+	    for ( index = 0 ; index < num_device ; ++index ) {
+	      cl_device_type d_type;
+	      ocl_status->device_id = dids[index];
+	      CL_SAFE_CALL1(err_code = jocl_clGetDeviceInfo(ocl_status->device_id,
+	  	    CL_DEVICE_TYPE, sizeof(cl_device_type), &d_type, NULL),
+	  	    return CL_FALSE, dids);
+	      if(CL_DEVICE_TYPE_GPU == d_type)
+	  	    num_gpu_device++;
+	    }
+	    for (index = 0; index < num_device; ++index) {
+	      cl_device_type d_type;
+	      ocl_status->device_id = dids[index];
+	      CL_SAFE_CALL1(err_code = jocl_clGetDeviceInfo(ocl_status->device_id,
+	        CL_DEVICE_TYPE, sizeof(cl_device_type), &d_type, NULL),
+	        return CL_FALSE, dids);
+	      CL_SAFE_CALL0(err_code = jocl_clGetDeviceInfo(ocl_status->device_id,
+	        CL_DEVICE_NAME, sizeof(ocl_status->device_name), ocl_status->device_name, NULL),
+	        return CL_FALSE);
+	      if(CL_DEVICE_TYPE_GPU == d_type) {
+	        num_gpu_device--;
+	        if (0 == strcmp(ocl_status->device_name,
+	          "Devastator"))
+	          break;
+	      }
+	      if(num_gpu_device == 0)
+	        break;
+	    }
+    }
+	CL_DEBUG_NOTE("Device:\nName: %s\n",ocl_status->device_name);
 	/* AMD A10-4600M APU with Radeon(tm) HD Graphics */
 
     free(dids);
-	CL_SAFE_CALL0(err_code = jocl_clGetDeviceInfo(ocl_status.device_id,
+	CL_SAFE_CALL0(err_code = jocl_clGetDeviceInfo(ocl_status->device_id,
 	  CL_DEVICE_MAX_MEM_ALLOC_SIZE, sizeof(cl_device_type),
-	  &ocl_status.mem_size, NULL), return CL_FALSE);
+	  &ocl_status->mem_size, NULL), return CL_FALSE);
 
     /* ********* Create a context. ********* */
-    ocl_status.context = CL_SAFE_CALL0(jocl_clCreateContext(NULL,
-      1, &ocl_status.device_id, NULL, NULL, &err_code), return CL_FALSE);
+    ocl_status->context = CL_SAFE_CALL0(jocl_clCreateContext(NULL,
+      1, &ocl_status->device_id, NULL, NULL, &err_code), return CL_FALSE);
 
     /* ********* Create a command queue. ********* */
-    ocl_status.command_queue = CL_SAFE_CALL0(jocl_clCreateCommandQueue(
-      ocl_status.context, ocl_status.device_id, 0, &err_code),
+    ocl_status->command_queue = CL_SAFE_CALL0(jocl_clCreateCommandQueue(
+      ocl_status->context, ocl_status->device_id, 0, &err_code),
       return CL_FALSE);
 #ifdef JOCL_CL_OS_WIN32
-    if( jocl_clGetCommandQueueInfo( ocl_status.command_queue,
+    if( jocl_clGetCommandQueueInfo( ocl_status->command_queue,
       CL_QUEUE_THREAD_HANDLE_AMD, sizeof(handle),
       &handle, NULL ) == CL_SUCCESS && handle != INVALID_HANDLE_VALUE ) {
       if(SetThreadPriority( handle, THREAD_PRIORITY_TIME_CRITICAL )) {
@@ -398,9 +450,9 @@ cl_bool jocl_cl_init()
     }  
 #endif
     /* *** OpenCL initialized successfully, modify the mark. *** */
-    ocl_status.is_opencl_available = CL_TRUE;
-    ocl_status.is_opencl_support = CL_TRUE;
-    ocl_status.fancy_index = CL_TRUE;
+    ocl_status->is_opencl_available = CL_TRUE;
+    ocl_status->is_opencl_support = CL_TRUE;
+    ocl_status->fancy_index = CL_TRUE;
     CL_DEBUG_NOTE("OpenCL is enabled.\n");
   }
   return CL_TRUE;
@@ -416,7 +468,8 @@ cl_bool jocl_cl_init()
  *   then create kernels that specified in kernel_name[].
  */
 
-JOCL_CL_RUNDATA* jocl_cl_compile_and_build(const char**  program_source,
+JOCL_CL_RUNDATA* jocl_cl_compile_and_build(void * jocl_openClinfo,
+                                           const char**  program_source,
                                            const char*  kernel_name[])
 {
   int i;
@@ -429,9 +482,10 @@ JOCL_CL_RUNDATA* jocl_cl_compile_and_build(const char**  program_source,
   int b_error, binary_status;
   char *binary;
   size_t length_binary;
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
   num_device = 1;
   /* Perform this operation only when OpenCL is available. */
-  if (ocl_status.is_opencl_available) {   
+  if (ocl_status->is_opencl_available) {
     JOCL_CL_RUNDATA* cl_data = NULL;
     cl_int  err_code;
     cl_uint index;
@@ -450,14 +504,14 @@ JOCL_CL_RUNDATA* jocl_cl_compile_and_build(const char**  program_source,
     cl_data = (JOCL_CL_RUNDATA*)
       malloc(sizeof(JOCL_CL_RUNDATA));
 
-    CL_SAFE_CALL1(err_code = jocl_clGetDeviceInfo(ocl_status.device_id,
+    CL_SAFE_CALL1(err_code = jocl_clGetDeviceInfo(ocl_status->device_id,
       CL_DEVICE_NAME, sizeof(deviceName), deviceName, NULL),
       return NULL, cl_data);
     sprintf(fileName, "%s_%s.bin", cl_name, deviceName);
 
     if(!(fp = fopen(fileName,"rb"))){
       CL_SAFE_CALL1(cl_data->program = jocl_clCreateProgramWithSource(
-        ocl_status.context, 7, program_source, length, &err_code),
+        ocl_status->context, 7, program_source, length, &err_code),
         return NULL, cl_data);
 
       /* Compile OpenCL code. If error, output the error informations. */
@@ -470,13 +524,13 @@ JOCL_CL_RUNDATA* jocl_cl_compile_and_build(const char**  program_source,
         cl_uint build_error = err_code;
       
         CL_SAFE_CALL1(err_code = jocl_clGetProgramBuildInfo(
-          cl_data->program, ocl_status.device_id, CL_PROGRAM_BUILD_LOG,
+          cl_data->program, ocl_status->device_id, CL_PROGRAM_BUILD_LOG,
           0, NULL, &sz_msg), return NULL, cl_data);
       
         /* Output the error informations. */
         err_msg = (char*)malloc(sz_msg);
         CL_SAFE_CALL2(err_code = jocl_clGetProgramBuildInfo(
-          cl_data->program, ocl_status.device_id, CL_PROGRAM_BUILD_LOG,
+          cl_data->program, ocl_status->device_id, CL_PROGRAM_BUILD_LOG,
           sz_msg, err_msg, NULL), return NULL, err_msg, cl_data);
       
         CL_DEBUG_NOTE("OpenCL Build Error:%s\n%s\n",
@@ -527,10 +581,10 @@ JOCL_CL_RUNDATA* jocl_cl_compile_and_build(const char**  program_source,
       memset(binary, 0, length_binary + 2);
       b_error |= fread(binary, 1, length_binary, fp) != length_binary;
       CL_SAFE_CALL1(cl_data->program = jocl_clCreateProgramWithBinary(
-        ocl_status.context, 1, &ocl_status.device_id, &length_binary,
+        ocl_status->context, 1, &ocl_status->device_id, &length_binary,
         (const unsigned char**) &binary, &binary_status,&err_code),
-        return NULL, cl_data);
-
+        NULL, cl_data);
+       
       /* Compile OpenCL code. If error, output the error informations. */
       CL_SAFE_CALL1(err_code = jocl_clBuildProgram(cl_data->program,
         0, NULL, NULL, NULL, NULL), return NULL, cl_data);
@@ -541,13 +595,13 @@ JOCL_CL_RUNDATA* jocl_cl_compile_and_build(const char**  program_source,
         cl_uint build_error = err_code;
       
         CL_SAFE_CALL1(err_code = jocl_clGetProgramBuildInfo(
-          cl_data->program, ocl_status.device_id, CL_PROGRAM_BUILD_LOG,
+          cl_data->program, ocl_status->device_id, CL_PROGRAM_BUILD_LOG,
           0, NULL, &sz_msg), return NULL, cl_data);
       
         /* Output the error informations. */
         err_msg = (char*)malloc(sz_msg);
         CL_SAFE_CALL2(err_code = jocl_clGetProgramBuildInfo(
-          cl_data->program, ocl_status.device_id, CL_PROGRAM_BUILD_LOG,
+          cl_data->program, ocl_status->device_id, CL_PROGRAM_BUILD_LOG,
           sz_msg, err_msg, NULL), return NULL, err_msg, cl_data);
 
         CL_DEBUG_NOTE("OpenCL Build Error:%s\n%s\n",
@@ -557,6 +611,7 @@ JOCL_CL_RUNDATA* jocl_cl_compile_and_build(const char**  program_source,
         free(cl_data);
         return NULL;
       }
+      free(binary);
       /* Build Successfully. */
       CL_DEBUG_NOTE("Compiling OpenCL code successfully.\n");
     }
@@ -571,7 +626,7 @@ JOCL_CL_RUNDATA* jocl_cl_compile_and_build(const char**  program_source,
         , return NULL, cl_data->kernel, cl_data->work_group_size, cl_data);
 
       CL_SAFE_CALL3(err_code = jocl_clGetKernelWorkGroupInfo(
-        cl_data->kernel[index], ocl_status.device_id,
+        cl_data->kernel[index], ocl_status->device_id,
         CL_KERNEL_WORK_GROUP_SIZE, sizeof(size_t),
         &cl_data->work_group_size[index], NULL),
         return NULL, cl_data->kernel, cl_data->work_group_size, cl_data);
@@ -597,34 +652,40 @@ JOCL_CL_RUNDATA* jocl_cl_compile_and_build(const char**  program_source,
  *   so I'm not going to comment them one by one.
  */
 
-cl_bool          jocl_cl_is_available(void)
+cl_bool          jocl_cl_is_available(void * jocl_openClinfo)
 {
-  return ocl_status.is_opencl_available;
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  return ocl_status->is_opencl_available;
 }
 
-cl_bool          jocl_cl_is_support_opencl(void)
+cl_bool          jocl_cl_is_support_opencl(void * jocl_openClinfo)
 {
-  return ocl_status.is_opencl_support;
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  return ocl_status->is_opencl_support;
 }
 
-cl_platform_id   jocl_cl_get_platform(void)
+cl_platform_id   jocl_cl_get_platform(void * jocl_openClinfo)
 {
-  return ocl_status.platform_id;
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  return ocl_status->platform_id;
 }
 
-cl_device_id     jocl_cl_get_device(void)
+cl_device_id     jocl_cl_get_device(void * jocl_openClinfo)
 {
-  return ocl_status.device_id;
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  return ocl_status->device_id;
 }
 
-cl_context       jocl_cl_get_context(void)
+cl_context       jocl_cl_get_context(void * jocl_openClinfo)
 {
-  return ocl_status.context;
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  return ocl_status->context;
 }
 
-cl_command_queue jocl_cl_get_command_queue(void)
+cl_command_queue jocl_cl_get_command_queue(void * jocl_openClinfo)
 {
-  return ocl_status.command_queue;
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  return ocl_status->command_queue;
 }
 
 /*
@@ -634,9 +695,10 @@ cl_command_queue jocl_cl_get_command_queue(void)
  *   Set the flag to disable OpenCL.
  */
 
-void jocl_cl_set_opencl_failure(void)
+void jocl_cl_set_opencl_failure(void * jocl_openClinfo)
 {
-  ocl_status.is_opencl_available = CL_FALSE;
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  ocl_status->is_opencl_available = CL_FALSE;
 }
 
 /*
@@ -645,9 +707,10 @@ void jocl_cl_set_opencl_failure(void)
  * If OpenCL is available, set the flag to enable OpenCL.
  */
 
-void jocl_cl_set_opencl_success(void)
+void jocl_cl_set_opencl_success(void * jocl_openClinfo)
 {
-  ocl_status.is_opencl_available = CL_TRUE;
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  ocl_status->is_opencl_available = CL_TRUE;
 }
 
 /*
@@ -657,9 +720,10 @@ void jocl_cl_set_opencl_success(void)
  *   Set the flag to disable OpenCL.
  */
 
-void jocl_cl_set_opencl_support_failure(void)
+void jocl_cl_set_opencl_support_failure(void * jocl_openClinfo)
 {
-  ocl_status.is_opencl_support = CL_FALSE;
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  ocl_status->is_opencl_support = CL_FALSE;
 }
 
 /*
@@ -669,9 +733,10 @@ void jocl_cl_set_opencl_support_failure(void)
  * 
  */
  
-cl_bool jocl_cl_is_nvidia_opencl(void)
+cl_bool jocl_cl_is_nvidia_opencl(void * jocl_openClinfo)
 {
-  if (0 == strcmp(ocl_status.platform_vendor,
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  if (0 == strcmp(ocl_status->platform_vendor,
         "NVIDIA Corporation"))
     return CL_TRUE;
   else {
@@ -692,10 +757,9 @@ cl_bool jocl_cl_is_nvidia_opencl(void)
 cl_bool jocl_cl_is_opencl_decompress(j_decompress_ptr cinfo)
 {
   unsigned int output_buffer;
-  unsigned long buffer_output_size = jocl_cl_get_buffer_unit_size();
+  unsigned long buffer_output_size = jocl_cl_get_buffer_unit_size((OCL_STATUS* )cinfo->jocl_openClinfo,cinfo->image_width,cinfo->image_height);
 
   /* output_buffer: the size of actual output */
-  /* input_buffer : the size of actual input  */
   output_buffer = cinfo->MCUs_per_row * cinfo->total_iMCU_rows * cinfo->max_h_samp_factor * 
     cinfo->max_v_samp_factor * NUM_COMPONENT * DCTSIZE2;
   /* Determine if the opencl version will be used */
@@ -709,10 +773,11 @@ cl_bool jocl_cl_is_opencl_decompress(j_decompress_ptr cinfo)
   if(cinfo->desired_number_of_colors != 256 || cinfo->quantize_colors == TRUE)
     return CL_FALSE;
   if(cinfo->two_pass_quantize == FALSE || cinfo->dither_mode != JDITHER_FS ||
-    (cinfo->dct_method != JDCT_ISLOW && cinfo->dct_method != JDCT_IFAST &&
-    cinfo->dct_method != JDCT_FLOAT))
+    (cinfo->dct_method != JDCT_ISLOW && cinfo->dct_method != JDCT_IFAST))
+    return CL_FALSE;
+  if(CL_TRUE == jocl_cl_get_fancy_status((OCL_STATUS* )cinfo->jocl_openClinfo) && cinfo->blocks_in_MCU == 6 &&
+    (cinfo->MCUs_per_row > MCUNUMS))
     return CL_FALSE;
-
   if((output_buffer > buffer_output_size))
      return CL_FALSE;
   
@@ -726,14 +791,16 @@ cl_bool jocl_cl_is_opencl_decompress(j_decompress_ptr cinfo)
  * If the -nosmooth is used.
  */
 
-cl_bool jocl_cl_get_fancy_status(void)
+cl_bool jocl_cl_get_fancy_status(void * jocl_openClinfo)
 {
-  return ocl_status.fancy_index;
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  return ocl_status->fancy_index;
 }
 
-void jocl_cl_set_fancy_status(void)
+void jocl_cl_set_fancy_status(void * jocl_openClinfo)
 {
-  ocl_status.fancy_index = CL_FALSE;
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  ocl_status->fancy_index = CL_FALSE;
 }
 
 /*
@@ -742,10 +809,11 @@ void jocl_cl_set_fancy_status(void)
  * Determine the buffer size.
  */
 
-unsigned long jocl_cl_get_buffer_unit_size(void)
+unsigned long jocl_cl_get_buffer_unit_size(void * jocl_openClinfo,unsigned int image_width,unsigned int image_height)
 {
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
   unsigned long buffer_output_size = 0;
-  unsigned long mem_size = ocl_status.mem_size;
+  unsigned long mem_size = ocl_status->mem_size;
   
   buffer_output_size = mem_size - (MCUNUMS * DCTSIZE2 * 18 * BUFFERNUMS);
   if (mem_size > (MAX_BUFFER_SIZE + (MCUNUMS * DCTSIZE2 * 18 * BUFFERNUMS)))
@@ -754,3 +822,54 @@ unsigned long jocl_cl_get_buffer_unit_size(void)
   }
   return buffer_output_size ;
 }
+
+/*
+ * jocl_cl_get_decode_support
+ * jocl_cl_set_decode_support
+ *
+ * Determine support opencl decoding.
+ */
+
+cl_bool jocl_cl_get_decode_support(void * jocl_openClinfo)
+{
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  return ocl_status->decode_support;
+}
+
+void jocl_cl_set_decode_support(void * jocl_openClinfo)
+{
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  ocl_status->decode_support = CL_TRUE;
+}
+
+/*
+ * jocl_cl_get_ocl_version
+ *
+ * Get OpenCL version.
+ */
+
+cl_bool jocl_cl_get_ocl_version(void * jocl_openClinfo)
+{
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  return ocl_status->is_version1_2_ocl;
+}
+
+/*
+ * jocl_cl_get_output_format
+ * jocl_cl_set_output_format
+ *
+ * Whether the output format is bmp.
+ */
+
+cl_bool jocl_cl_get_output_format(void * jocl_openClinfo)
+{
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  return ocl_status->output_format_bmp;
+}
+
+void jocl_cl_set_output_format(void * jocl_openClinfo)
+{
+  OCL_STATUS * ocl_status = ((OCL_STATUS *)jocl_openClinfo);
+  ocl_status->output_format_bmp = CL_TRUE;
+}
+#endif
diff --git a/joclinit.h b/joclinit.h
index bfa8a70..14f2e75 100644
--- a/joclinit.h
+++ b/joclinit.h
@@ -219,25 +219,65 @@ typedef struct
   size_t*    work_group_size;
 } JOCL_CL_RUNDATA;
 
+/*
+ * OCL_STATIS ocl_status
+ * Store all the informations of OpenCL platform.
+ */
+
+typedef struct
+{
+  cl_platform_id   platform_id;
+  cl_device_id     device_id;
+  cl_context       context;
+  cl_command_queue command_queue;
+  cl_bool          is_opencl_available;
+  cl_bool          is_opencl_support;
+  cl_bool          fancy_index;
+  cl_bool          decode_support;
+  cl_bool          output_format_bmp;
+  cl_bool          is_version1_2_ocl;
+  unsigned long    mem_size;
+  char             platform_profile   [1024];
+  char             platform_version   [1024];
+  char             platform_name      [1024];
+  char             platform_vendor    [1024];
+  char             platform_extensions[1024];
+  char             device_name        [1024];
+  cl_mem   jocl_global_data_mem_output      ;
+  cl_mem   jocl_global_data_mem_qutable     ;
+  cl_mem   jocl_global_data_mem_input      [BUFFERNUMS];
+  cl_mem   jocl_global_data_mem_inter      [BUFFERNUMS];
+  cl_mem   jocl_global_data_mem_prior_inter[BUFFERNUMS];
+  JCOEFPTR jocl_global_data_ptr_input      [BUFFERNUMS];
+  JSAMPROW jocl_global_data_ptr_output      ;
+  float*   jocl_global_data_ptr_qutable     ;
+  JOCL_CL_RUNDATA* jocldec_cl_rundata;
+} OCL_STATUS;
 
 const char*      jocl_cl_errstring                 (cl_int err_code);
-cl_bool          jocl_cl_init                      (void);
-JOCL_CL_RUNDATA* jocl_cl_compile_and_build         (const char** program_source,
+cl_bool          jocl_cl_init                      (void **jocl_openClinfo);
+JOCL_CL_RUNDATA* jocl_cl_compile_and_build         (void *jocl_openClinfo,
+                                                    const char** program_source,
                                                     const char*  kernel_name[]);
-cl_bool          jocl_cl_is_support_opencl         (void);
-cl_bool          jocl_cl_is_available              (void);
-cl_platform_id   jocl_cl_get_platform              (void);
-cl_device_id     jocl_cl_get_device                (void);
-cl_context       jocl_cl_get_context               (void);
-cl_command_queue jocl_cl_get_command_queue         (void);
-void             jocl_cl_set_opencl_failure        (void);
-void             jocl_cl_set_opencl_success        (void);
-void             jocl_cl_set_opencl_support_failure(void);
+cl_bool          jocl_cl_is_support_opencl         (void *jocl_openClinfo);
+cl_bool          jocl_cl_is_available              (void *jocl_openClinfo);
+cl_platform_id   jocl_cl_get_platform              (void *jocl_openClinfo);
+cl_device_id     jocl_cl_get_device                (void *jocl_openClinfo);
+cl_context       jocl_cl_get_context               (void *jocl_openClinfo);
+cl_command_queue jocl_cl_get_command_queue         (void *jocl_openClinfo);
+void             jocl_cl_set_opencl_failure        (void *jocl_openClinfo);
+void             jocl_cl_set_opencl_success        (void *jocl_openClinfo);
+void             jocl_cl_set_opencl_support_failure(void *jocl_openClinfo);
 cl_bool          jocl_cl_is_opencl_decompress      (j_decompress_ptr cinfo);
-cl_bool          jocl_cl_is_nvidia_opencl          (void);
-void             jocl_cl_set_fancy_status          (void);
-cl_bool          jocl_cl_get_fancy_status          (void);
-unsigned long	 jocl_cl_get_buffer_unit_size      (void);
+cl_bool          jocl_cl_is_nvidia_opencl          (void *jocl_openClinfo);
+void             jocl_cl_set_fancy_status          (void *jocl_openClinfo);
+cl_bool          jocl_cl_get_fancy_status          (void *jocl_openClinfo);
+unsigned long	 jocl_cl_get_buffer_unit_size      (void *jocl_openClinfo,unsigned int image_width,unsigned int image_height);
+cl_uint          jocl_cl_get_decode_support        (void *jocl_openClinfo);
+void             jocl_cl_set_decode_support        (void *jocl_openClinfo);
+cl_bool          jocl_cl_get_ocl_version           (void *jocl_openClinfo);
+cl_bool          jocl_cl_get_output_format         (void *jocl_openClinfo);
+void             jocl_cl_set_output_format         (void *jocl_openClinfo);
 
 /*
  * The macro definition for exception handling code.
@@ -303,4 +343,4 @@ unsigned long	 jocl_cl_get_buffer_unit_size      (void);
 
 
 /* The end of joclinit.h */
-#endif
\ No newline at end of file
+#endif
diff --git a/jpeglib.h b/jpeglib.h
index 91668ed..975aeb2 100644
--- a/jpeglib.h
+++ b/jpeglib.h
@@ -704,6 +704,10 @@ struct jpeg_decompress_struct {
   struct jpeg_upsampler * upsample;
   struct jpeg_color_deconverter * cconvert;
   struct jpeg_color_quantizer * cquantize;
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  boolean opencl_rgb_flag;
+  void *jocl_openClinfo;
+#endif
 };
 
 
@@ -1205,6 +1209,25 @@ struct jpeg_color_quantizer { long dummy; };
 #include "jerror.h"		/* fetch error codes too */
 #endif
 
+#ifdef JOCL_CL_OS_WIN32
+
+//#define PERFORMANCE_COUNTER
+#ifdef PERFORMANCE_COUNTER
+#include <windows.h>
+  LARGE_INTEGER start;   
+  LARGE_INTEGER end;   
+  LARGE_INTEGER freq; 
+  double time;
+#endif
+#else
+
+//#define PERFORMANCE_COUNTER_LINUX
+#ifdef PERFORMANCE_COUNTER_LINUX
+#include <sys/time.h>
+  struct timeval start, end;   
+  int interval;
+#endif
+#endif
 #ifdef __cplusplus
 #ifndef DONT_USE_EXTERN_C
 }
diff --git a/wrbmp.c b/wrbmp.c
index 3283b0f..0c489e5 100644
--- a/wrbmp.c
+++ b/wrbmp.c
@@ -4,6 +4,8 @@
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
+ * Modifications:
+ * Copyright (C) 2012-2013, MulticoreWare Inc.
  *
  * This file contains routines to write output images in Microsoft "BMP"
  * format (MS Windows 3.x and OS/2 1.x flavors).
@@ -87,6 +89,15 @@ put_pixel_rows (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,
   /* Transfer data.  Note destination values must be in BGR order
    * (even though Microsoft's own documents say the opposite).
    */
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  if (TRUE == cinfo->opencl_rgb_flag)
+  {
+    image_ptr[0] = dest->pub.buffer[0];
+    outptr = image_ptr[0];
+    if(dest->pad_bytes != 0) outptr += 3 * cinfo->output_width;
+  }
+  else {
+#endif
   inptr = dest->pub.buffer[0];
   outptr = image_ptr[0];
   for (col = cinfo->output_width; col > 0; col--) {
@@ -95,6 +106,9 @@ put_pixel_rows (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,
     outptr[0] = *inptr++;
     outptr += 3;
   }
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+ }
+#endif
 
   /* Zero out the pad bytes. */
   pad = dest->pad_bytes;
-- 
1.8.1.4

