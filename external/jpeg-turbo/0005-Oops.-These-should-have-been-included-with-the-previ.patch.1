From 97da3caf78d2df1d5a29f6e898ac2c1074985f06 Mon Sep 17 00:00:00 2001
From: dcommander <dcommander@632fc199-4ca6-4c93-a231-07263d6284db>
Date: Tue, 17 Dec 2013 09:12:05 +0000
Subject: [PATCH 5/9] Oops.  These should have been included with the previous
 commit.

git-svn-id: http://svn.code.sf.net/p/libjpeg-turbo/code/branches/opencl@1095 632fc199-4ca6-4c93-a231-07263d6284db
---
 jocldsample.h | 863 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 joclidct.h    | 354 ++++++++++++++++++++++++
 2 files changed, 1217 insertions(+)
 create mode 100644 jocldsample.h
 create mode 100644 joclidct.h

diff --git a/jocldsample.h b/jocldsample.h
new file mode 100644
index 0000000..416f9b1
--- /dev/null
+++ b/jocldsample.h
@@ -0,0 +1,863 @@
+/*
+ * jocldsample.h
+ *
+ * Copyright (C) 2012-2013, MulticoreWare Inc.
+ * In July 2013, Written by Peixuan Zhang <zhangpeixuan.cn@gmail.com>
+ * The OpenCL kernel code is written by
+ *   Chunli  Zhang <chunli@multicorewareinc.com> and
+ *   Peixuan Zhang <peixuan@multicorewareinc.com>
+ * Based on the OpenCL extension for IJG JPEG library,
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file contains the kernels of OpenCL decoding.
+ */
+
+#if defined(OPENCL_DEC_UPSAMPLE_RGB)
+static const char     * jocldec_cl_source2  =
+"__kernel void UPSAMPLE_H1V1_RGB        (__global uchar  *src,            \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
+static const char     * jocldec_cl_source3  =
+"__kernel void UPSAMPLE_H1V1_BGR        (__global uchar  *src,            \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
+static const char     * jocldec_cl_source4  =
+"__kernel void UPSAMPLE_H1V1_RGBA       (__global uchar  *src,            \n"
+#endif
+"                                        __global uchar4 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
+"{                                                                        \n"
+"  uint    globalIdx = get_global_id(0);                                  \n"
+"  uint    globalIdx1= get_global_id(0) + mcu_offset;                     \n"
+"  uint    localIdx  = get_local_id (0);                                  \n"
+"  uchar   dataInY   = src[globalIdx / 64 * 192 + localIdx];              \n"
+"  uchar   dataInCb  = src[globalIdx / 64 * 192 + 64 + localIdx];         \n"
+"  uchar   dataInCr  = src[globalIdx / 64 * 192 + 128 + localIdx];        \n"
+"  uchar   imgR, imgG, imgB;                                              \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  uchar   imgA = 255;;                                                   \n"
+#endif
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx1 >> 6) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 6) / mcu_width;                                     \n"
+"                                                                         \n"
+"  imgB = convert_uchar_sat(                                              \n"
+"    dataInY  + (((int)91881 * (dataInCr - 128) + (int)32768) >> 16));    \n"
+"  imgG = convert_uchar_sat(                                              \n"
+"    dataInY + ((((int)32768 - (int)22554 * (dataInCb - 128))             \n"
+"    - ((int)46802 * (dataInCr - 128))) >> 16));                          \n"
+"  imgR = convert_uchar_sat(                                              \n"
+"    dataInY  + ((116130 * (dataInCb - 128) + 32768) >> 16));             \n"
+"                                                                         \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGB)
+"  inter[localIdx * 3 + 0] = imgR;                                        \n"
+"  inter[localIdx * 3 + 1] = imgG;                                        \n"
+"  inter[localIdx * 3 + 2] = imgB;                                        \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
+"  inter[localIdx * 3 + 0] = imgB;                                        \n"
+"  inter[localIdx * 3 + 1] = imgG;                                        \n"
+"  inter[localIdx * 3 + 2] = imgR;                                        \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  inter[localIdx * 4 + 0] = imgR;                                        \n"
+"  inter[localIdx * 4 + 1] = imgG;                                        \n"
+"  inter[localIdx * 4 + 2] = imgB;                                        \n"
+"  inter[localIdx * 4 + 3] = imgA;                                        \n"
+#endif
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  if (localIdx < 64)                                                     \n"
+"    dst[y * mcu_width * 64 + x * 8 + localIdx % 8                        \n"
+"      + localIdx / 8 * mcu_width * 8] = vload4(localIdx, inter);         \n"
+#else
+"  if (localIdx < 48)                                                     \n"
+"    dst[y * mcu_width * 48 + x * 6 + localIdx % 6                        \n"
+"      + localIdx / 6 * mcu_width * 6] = vload4(localIdx, inter);         \n"
+#endif
+"}                                                                        \n"
+"                                                                         \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGB)
+"__kernel void UPSAMPLE_H1V2_RGB        (__global uchar  *src,            \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
+"__kernel void UPSAMPLE_H1V2_BGR        (__global uchar  *src,            \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"__kernel void UPSAMPLE_H1V2_RGBA       (__global uchar  *src,            \n"
+#endif
+"                                        __global uchar4 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
+"{                                                                        \n"
+"  uint    globalIdx = get_global_id(0);                                  \n"
+"  uint    globalIdx1= get_global_id(0) + mcu_offset;                     \n"
+"  uint    localIdx  =  get_local_id(0);                                  \n"
+"  uint    transOffset = ((localIdx >> 4) << 3) + (localIdx & 0x07);      \n"
+"  uchar   dataInY = src[globalIdx / 128 * 256 + localIdx];               \n"
+"  uchar   imgR, imgG, imgB;                                              \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  uchar   imgA = 255;;                                                   \n"
+#endif
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx1 >> 7) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 7) / mcu_width;                                     \n"
+"                                                                         \n"
+"  if (localIdx < 64)                                                     \n"
+"  {                                                                      \n"
+"    cb_cache[localIdx] = src[globalIdx / 128 * 256 + 128 + localIdx];    \n"
+"    cr_cache[localIdx] = src[globalIdx / 128 * 256 + 192 + localIdx];    \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  imgB = convert_uchar_sat(dataInY  +                                    \n"
+"    (((int)91881 * (cr_cache[transOffset] - 128) + (int)32768) >> 16));  \n"
+"  imgG = convert_uchar_sat(dataInY +                                     \n"
+"    ((((int)32768 - (int)22554 * (cb_cache[transOffset] - 128))          \n"
+"    - ((int)46802 * (cr_cache[transOffset] - 128))) >> 16));             \n"
+"  imgR = convert_uchar_sat(dataInY  +                                    \n"
+"    (((int)116130 * (cb_cache[transOffset] - 128) + (int)32768) >> 16)); \n"
+"                                                                         \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGB)
+"  inter[localIdx * 3 + 0] = imgR;                                        \n"
+"  inter[localIdx * 3 + 1] = imgG;                                        \n"
+"  inter[localIdx * 3 + 2] = imgB;                                        \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
+"  inter[localIdx * 3 + 0] = imgB;                                        \n"
+"  inter[localIdx * 3 + 1] = imgG;                                        \n"
+"  inter[localIdx * 3 + 2] = imgR;                                        \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  inter[localIdx * 4+ 0] = imgR;                                         \n"
+"  inter[localIdx * 4+ 1] = imgG;                                         \n"
+"  inter[localIdx * 4+ 2] = imgB;                                         \n"
+"  inter[localIdx * 4+ 3] = imgA;                                         \n"
+#endif
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  if (localIdx < 128)                                                    \n"
+"    dst[y * mcu_width * 128 + x * 8 + localIdx % 8 +                     \n"
+"      localIdx / 8 * mcu_width * 8] = vload4(localIdx, inter);           \n"
+#else
+"  if (localIdx < 96)                                                     \n"
+"    dst[y * mcu_width * 96 + x * 6 + localIdx % 6 +                      \n"
+"      localIdx / 6 * mcu_width * 6] = vload4(localIdx, inter);           \n"
+#endif
+"}                                                                        \n"
+"                                                                         \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGB)
+"__kernel void UPSAMPLE_H2V1_RGB        (__global uchar  *src,            \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
+"__kernel void UPSAMPLE_H2V1_BGR        (__global uchar  *src,            \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"__kernel void UPSAMPLE_H2V1_RGBA       (__global uchar  *src,            \n"
+#endif
+"                                        __global uchar8 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        __local  uchar2 *cb_upsample,    \n"
+"                                        __local  uchar2 *cr_upsample,    \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
+"{                                                                        \n"
+"  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    globalIdx1  = get_global_id(0) + mcu_offset;                   \n"
+"  uint    localIdx    = get_local_id (0);                                \n"
+"  uint    transOffset =                                                  \n"
+"    ((localIdx >> 2) << 2) - (localIdx >> 5) * 60 + localIdx;            \n"
+"  uchar2  dataInY  = vload2(globalIdx / 64 * 128 + localIdx, src);       \n"
+"  uchar   dataInCb = cb_cache[localIdx] =                                \n"
+"    src[globalIdx / 64 * 256 + 128 + localIdx];                          \n"
+"  uchar   dataInCr = cr_cache[localIdx] =                                \n"
+"    src[globalIdx / 64 * 256 + 192 + localIdx];                          \n"
+"  uchar2  imgR, imgG, imgB;                                              \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  uchar2  imgA  = 255;                                                   \n"
+#endif
+"  int     valueY,valueCb, valueCr;                                       \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx1 >> 6) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 6) / mcu_width;                                     \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  cb_upsample[localIdx].x = dataInCb;                                    \n"
+"  cb_upsample[localIdx].y = dataInCb;                                    \n"
+"  cr_upsample[localIdx].x = dataInCr;                                    \n"
+"  cr_upsample[localIdx].y = dataInCr;                                    \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  valueY = convert_int(dataInY.x);                                       \n"
+"  valueCb = convert_int(cb_upsample[transOffset].x);                     \n"
+"  valueCr = convert_int(cr_upsample[transOffset].x);                     \n"
+"                                                                         \n"
+"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.y);                                      \n"
+"  valueCb = convert_int(cb_upsample[transOffset].y);                     \n"
+"  valueCr = convert_int(cr_upsample[transOffset].y);                     \n"
+"                                                                         \n"
+"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGB)
+"  inter[transOffset * 6 + 0] = imgR.x;                                   \n"
+"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 6 + 2] = imgB.x;                                   \n"
+"  inter[transOffset * 6 + 3] = imgR.y;                                   \n"
+"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
+"  inter[transOffset * 6 + 5] = imgB.y;                                   \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
+"  inter[transOffset * 6 + 0] = imgB.x;                                   \n"
+"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 6 + 2] = imgR.x;                                   \n"
+"  inter[transOffset * 6 + 3] = imgB.y;                                   \n"
+"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
+"  inter[transOffset * 6 + 5] = imgR.y;                                   \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  inter[transOffset * 8 + 0] = imgR.x;                                   \n"
+"  inter[transOffset * 8 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 8 + 2] = imgB.x;                                   \n"
+"  inter[transOffset * 8 + 3] = imgA.x;                                   \n"
+"  inter[transOffset * 8 + 4] = imgR.y;                                   \n"
+"  inter[transOffset * 8 + 5] = imgG.y;                                   \n"
+"  inter[transOffset * 8 + 6] = imgB.y;                                   \n"
+"  inter[transOffset * 8 + 7] = imgA.y;                                   \n"
+#endif
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  if (localIdx < 64)                                                     \n"
+"    dst[y * mcu_width * 64 + x * 8 + localIdx % 8 +                      \n"
+"      localIdx / 8 * mcu_width * 8] = vload8(localIdx, inter);           \n"
+#else
+"  if (localIdx < 48)                                                     \n"
+"    dst[y * mcu_width * 48 + x * 6 + localIdx % 6 +                      \n"
+"      localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);           \n"
+#endif
+"}                                                                        \n"
+"                                                                         \n"
+"__kernel __attribute__((reqd_work_group_size(128,1,1)))                  \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGB)
+"         void UPSAMPLE_H2V2_RGB        (__global uchar  *src,            \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
+"         void UPSAMPLE_H2V2_BGR        (__global uchar  *src,            \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"         void UPSAMPLE_H2V2_RGBA       (__global uchar  *src,            \n"
+#endif
+"                                        __global uchar8 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        __local  uchar2 *cb_upsample,    \n"
+"                                        __local  uchar2 *cr_upsample,    \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
+"{                                                                        \n"
+"  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    globalIdx1  = get_global_id(0) + mcu_offset;                   \n"
+"  uint    localIdx    = get_local_id (0);                                \n"
+"  uint    transOffset = localIdx - (localIdx >> 5) * 60 +                \n"
+"    (localIdx >> 2 << 2) + (localIdx >> 6) * 56;                         \n"
+"  uchar2  dataInY     = vload2(globalIdx/128 * 192 + localIdx, src);     \n"
+"  uchar2  imgR, imgG, imgB;                                              \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  uchar2  imgA = 255;                                                    \n"
+#endif
+"  int     valueY, valueCb, valueCr;                                      \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx1 >> 7) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 7) / mcu_width;                                     \n"
+"                                                                         \n"
+"  if (localIdx < 64)                                                     \n"
+"  {                                                                      \n"
+"    cb_cache[localIdx] = src[globalIdx/128 * 384 + 256 + localIdx];      \n"
+"    cr_cache[localIdx] = src[globalIdx/128 * 384 + 320 + localIdx];      \n"
+"    cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0] =         \n"
+"      cb_cache[localIdx];                                                \n"
+"    cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4] =         \n"
+"      cb_cache[localIdx];                                                \n"
+"    cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0] =         \n"
+"      cr_cache[localIdx];                                                \n"
+"    cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4] =         \n"
+"      cr_cache[localIdx];                                                \n"
+"  }                                                                      \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.x);                                      \n"
+"  valueCb = convert_int(cb_upsample[localIdx].x);                        \n"
+"  valueCr = convert_int(cr_upsample[localIdx].x);                        \n"
+"                                                                         \n"
+"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.y);                                      \n"
+"  valueCb = convert_int(cb_upsample[localIdx].y);                        \n"
+"  valueCr = convert_int(cr_upsample[localIdx].y);                        \n"
+"                                                                         \n"
+"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGB)
+"  inter[transOffset * 6 + 0] = imgR.x;                                   \n"
+"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 6 + 2] = imgB.x;                                   \n"
+"  inter[transOffset * 6 + 3] = imgR.y;                                   \n"
+"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
+"  inter[transOffset * 6 + 5] = imgB.y;                                   \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
+"  inter[transOffset * 6 + 0] = imgB.x;                                   \n"
+"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 6 + 2] = imgR.x;                                   \n"
+"  inter[transOffset * 6 + 3] = imgB.y;                                   \n"
+"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
+"  inter[transOffset * 6 + 5] = imgR.y;                                   \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  inter[transOffset * 8 + 0] = imgR.x;                                   \n"
+"  inter[transOffset * 8 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 8 + 2] = imgB.x;                                   \n"
+"  inter[transOffset * 8 + 3] = imgA.x;                                   \n"
+"  inter[transOffset * 8 + 4] = imgR.y;                                   \n"
+"  inter[transOffset * 8 + 5] = imgG.y;                                   \n"
+"  inter[transOffset * 8 + 6] = imgB.y;                                   \n"
+"  inter[transOffset * 8 + 7] = imgA.y;                                   \n"
+#endif
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  if (localIdx < 128)                                                    \n"
+"    dst[y * mcu_width * 128 + x * 8 + localIdx % 8                       \n"
+"      + localIdx / 8 * mcu_width * 8] = vload8(localIdx, inter);         \n"
+#else
+"  if (localIdx < 96)                                                     \n"
+"    dst[y * mcu_width * 96 + x * 6 + localIdx % 6                        \n"
+"      + localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);         \n"
+#endif
+"}                                                                        \n";
+#if defined(OPENCL_DEC_UPSAMPLE_RGB)
+static const char     * jocldec_cl_source5  =
+"#define MCUNUMS  800                                                     \n"
+"__kernel void UPSAMPLE_H2V1_FANCY_RGB  (__global uchar  *src,            \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
+static const char     * jocldec_cl_source6  =
+"#define MCUNUMS  800                                                     \n"
+"__kernel void UPSAMPLE_H2V1_FANCY_BGR  (__global uchar  *src,            \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
+static const char     * jocldec_cl_source7  =
+"#define MCUNUMS  800                                                     \n"
+"__kernel void UPSAMPLE_H2V1_FANCY_RGBA (__global uchar  *src,            \n"
+#endif
+"                                        __global uchar8 *dst,            \n"
+"                                        __global uchar  *dst_inter,      \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        __local  uchar2 *cb_upsample,    \n"
+"                                        __local  uchar2 *cr_upsample,    \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset,     \n"
+"                                        const    uint    edge_mcu)       \n"
+"{                                                                        \n"
+"  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    globalIdx1  = get_global_id(0) + mcu_offset;                   \n"
+"  uint    localIdx    = get_local_id (0);                                \n"
+"  uint    transOffset =                                                  \n"
+"    ((localIdx >> 2) << 2) - (localIdx >> 5) * 60 + localIdx;            \n"
+"  uchar   dataInCbLeft, dataInCrLeft, dataInCbRight, dataInCrRight;      \n"
+"  uchar2  dataInY  = vload2(globalIdx / 64 * 128 + localIdx, src);       \n"
+"  uchar   dataInCb = cb_cache[localIdx] =                                \n"
+"    src[globalIdx / 64 * 256 + 128 + localIdx];                          \n"
+"  uchar   dataInCr = cr_cache[localIdx] =                                \n"
+"    src[globalIdx / 64 * 256 + 192 + localIdx];                          \n"
+"  uchar2  imgR, imgG, imgB;                                              \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  uchar2  imgA = 255;                                                    \n"
+#endif
+"  int     valueY,valueCb, valueCr;                                       \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx1 >> 6) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 6) / mcu_width;                                     \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  if (!(localIdx & 0x07) && !(globalIdx1 / 64 % mcu_width)) {            \n"
+"    dataInCbLeft  = dataInCb -1;                                         \n"
+"    dataInCrLeft  = dataInCr -1;                                         \n"
+"  }                                                                      \n"
+"  else if (!(localIdx & 0x07) && (globalIdx1 / 64 % mcu_width)           \n"
+"    && (globalIdx / 64)) {                                               \n"
+"    dataInCbLeft  = src[globalIdx / 64 * 256 - 121 + localIdx];          \n"
+"    dataInCrLeft  = src[globalIdx / 64 * 256 + localIdx - 57];           \n"
+"  }                                                                      \n"
+"  else if (!(localIdx & 0x07) && (globalIdx1 / 64 % mcu_width)           \n"
+"    && !(globalIdx / 64)) {                                              \n"
+"    dataInCbLeft  = dst_inter[localIdx / 8];                             \n"
+"    dataInCrLeft  = dst_inter[localIdx / 8 + 8];                         \n"
+"  }                                                                      \n"
+"  else {                                                                 \n"
+"    dataInCbLeft  = cb_cache[localIdx-1];                                \n"
+"    dataInCrLeft  = cr_cache[localIdx-1];                                \n"
+"  }                                                                      \n"
+"  if ((localIdx & 0x07) == edge_mcu &&                                   \n"
+"           (globalIdx1 / 64 % mcu_width) == (mcu_width - 1)) {           \n"
+"    dataInCbRight = dataInCb -2;                                         \n"
+"    dataInCrRight = dataInCr -2;                                         \n"
+"  }                                                                      \n"
+"  else if ((localIdx & 0x07) == 7 &&                                     \n"
+"           (globalIdx1 / 64 % mcu_width) != (mcu_width - 1)) {           \n"
+"    dataInCbRight = src[globalIdx / 64 * 256 + localIdx + 57 + 320];     \n"
+"    dataInCrRight = src[globalIdx / 64 * 256 + localIdx + 57 + 384];     \n"
+"  }                                                                      \n"
+"  else {                                                                 \n"
+"    dataInCbRight = cb_cache[localIdx+1];                                \n"
+"    dataInCrRight = cr_cache[localIdx+1];                                \n"
+"  }                                                                      \n"
+"                                                                         \n"
+"  cb_upsample[localIdx].x = (dataInCb * 3 + dataInCbLeft  + 1) >> 2;     \n"
+"  cb_upsample[localIdx].y = (dataInCb * 3 + dataInCbRight + 2) >> 2;     \n"
+"  cr_upsample[localIdx].x = (dataInCr * 3 + dataInCrLeft  + 1) >> 2;     \n"
+"  cr_upsample[localIdx].y = (dataInCr * 3 + dataInCrRight + 2) >> 2;     \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  valueY = convert_int(dataInY.x);                                       \n"
+"  valueCb = convert_int(cb_upsample[transOffset].x);                     \n"
+"  valueCr = convert_int(cr_upsample[transOffset].x);                     \n"
+"                                                                         \n"
+"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.y);                                      \n"
+"  valueCb = convert_int(cb_upsample[transOffset].y);                     \n"
+"  valueCr = convert_int(cr_upsample[transOffset].y);                     \n"
+"                                                                         \n"
+"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGB)
+"  inter[transOffset * 6 + 0] = imgR.x;                                   \n"
+"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 6 + 2] = imgB.x;                                   \n"
+"  inter[transOffset * 6 + 3] = imgR.y;                                   \n"
+"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
+"  inter[transOffset * 6 + 5] = imgB.y;                                   \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
+"  inter[transOffset * 6 + 0] = imgB.x;                                   \n"
+"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 6 + 2] = imgR.x;                                   \n"
+"  inter[transOffset * 6 + 3] = imgB.y;                                   \n"
+"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
+"  inter[transOffset * 6 + 5] = imgR.y;                                   \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  inter[transOffset * 8 + 0] = imgR.x;                                   \n"
+"  inter[transOffset * 8 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 8 + 2] = imgB.x;                                   \n"
+"  inter[transOffset * 8 + 3] = imgA.x;                                   \n"
+"  inter[transOffset * 8 + 4] = imgR.y;                                   \n"
+"  inter[transOffset * 8 + 5] = imgG.y;                                   \n"
+"  inter[transOffset * 8 + 6] = imgB.y;                                   \n"
+"  inter[transOffset * 8 + 7] = imgA.y;                                   \n"
+#endif
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if(globalIdx == 0) {                                                   \n"
+"    dst_inter[0] = src[(MCUNUMS - 2) * 256 + 128 + 7];                   \n"
+"    dst_inter[1] = src[(MCUNUMS - 2) * 256 + 128 + 15];                  \n"
+"    dst_inter[2] = src[(MCUNUMS - 2) * 256 + 128 + 23];                  \n"
+"    dst_inter[3] = src[(MCUNUMS - 2) * 256 + 128 + 31];                  \n"
+"    dst_inter[4] = src[(MCUNUMS - 2) * 256 + 128 + 39];                  \n"
+"    dst_inter[5] = src[(MCUNUMS - 2) * 256 + 128 + 47];                  \n"
+"    dst_inter[6] = src[(MCUNUMS - 2) * 256 + 128 + 55];                  \n"
+"    dst_inter[7] = src[(MCUNUMS - 2) * 256 + 128 + 63];                  \n"
+"    dst_inter[8] = src[(MCUNUMS - 2) * 256 + 192 + 7];                   \n"
+"    dst_inter[9] = src[(MCUNUMS - 2) * 256 + 192 + 15];                  \n"
+"    dst_inter[10] = src[(MCUNUMS - 2) * 256 + 192 + 23];                 \n"
+"    dst_inter[11] = src[(MCUNUMS - 2) * 256 + 192 + 31];                 \n"
+"    dst_inter[12] = src[(MCUNUMS - 2) * 256 + 192 + 39];                 \n"
+"    dst_inter[13] = src[(MCUNUMS - 2) * 256 + 192 + 47];                 \n"
+"    dst_inter[14] = src[(MCUNUMS - 2) * 256 + 192 + 55];                 \n"
+"    dst_inter[15] = src[(MCUNUMS - 2) * 256 + 192 + 63];                 \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  if (localIdx < 64)                                                     \n"
+"    dst[y * mcu_width * 64 + x * 8 + localIdx % 8 +                      \n"
+"      localIdx / 8 * mcu_width * 8] = vload8(localIdx, inter);           \n"
+#else
+"  if (localIdx < 48)                                                     \n"
+"    dst[y * mcu_width * 48 + x * 6 + localIdx % 6 +                      \n"
+"      localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);           \n"
+#endif
+"}                                                                        \n"
+"__kernel __attribute__((reqd_work_group_size(128,1,1)))                  \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGB)
+"        void UPSAMPLE_H2V2_FANCY_RGB (__global uchar  *src,              \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
+"        void UPSAMPLE_H2V2_FANCY_BGR (__global uchar  *src,              \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"__kernel void UPSAMPLE_H2V2_FANCY_RGBA (__global uchar  *src,            \n"
+#endif
+"                                      __global uchar  *src1,             \n"
+"                                      __global uchar8 *dst,              \n"
+"                                      __global uchar  *src_prior,        \n"
+"                                      __global uchar  *dst_prior,        \n"
+"                                      __local  uchar  *inter,            \n"
+"                                      __local  uchar  *cb_cache,         \n"
+"                                      __local  uchar  *cr_cache,         \n"
+"                                      __local  uchar2 *cb_upsample,      \n"
+"                                      __local  uchar2 *cr_upsample,      \n"
+"                                      const    uint    mcu_width,        \n"
+"                                      const    uint    mcu_offset,       \n"
+"                                      const    uint    mcu_total,        \n"
+"                                      const    uint    edge_mcu_h,       \n"
+"                                      const    uint    edge_mcu_v,       \n"
+"                                      const    uint    mcu_offset_buffer)\n"
+"{                                                                        \n"
+"  uint   globalIdx   = get_global_id(0);                                 \n"
+"  uint   globalIdx1  = get_global_id(0) + mcu_offset;                    \n"
+"  uint   globalMCUIdx= globalIdx1/128;                                   \n"
+"  uint   localIdx    = get_local_id (0);                                 \n"
+"  uint   localIdx1   = get_local_id (0) - 64;                            \n"
+"  uint   groupIdx    = get_group_id (0);                                 \n"
+"  uint   transOffset = localIdx - (localIdx >> 5) * 60 +                 \n"
+"    (localIdx >> 2 << 2) + (localIdx >> 6) * 56;                         \n"
+"  uchar2 dataInY     = vload2(globalIdx/128 * 192 + localIdx, src);      \n"
+"  uchar2 imgR, imgG, imgB;                                               \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  uchar2 imgA = 255;                                                     \n"
+#endif
+"  int    valueY, valueCb, valueCr;                                       \n"
+"  uint   x, y;                                                           \n"
+"  int    dataInTopCb, dataInBottomCb, dataInRightCb, dataInLeftCb;       \n"
+"  int    dataInLeftTopCb, dataInRightTopCb;                              \n"
+"  int    dataInLeftBottomCb, dataInRightBottomCb;                        \n"
+"  int    dataInTopCr, dataInBottomCr, dataInRightCr, dataInLeftCr;       \n"
+"  int    dataInLeftTopCr, dataInRightTopCr;                              \n"
+"  int    dataInLeftBottomCr, dataInRightBottomCr;                        \n"
+"  uint   trans8to10 = (localIdx / 8) * 10 + (localIdx % 8) + 11;         \n"
+"  uint   trans8to10_1 = ((localIdx - 64) / 8) * 10 + (localIdx % 8) + 11;\n"
+"  uint   upsample_offset = localIdx + localIdx%8/4*28+localIdx/32*32;    \n"
+"  uint   upsample_offset1 = localIdx1 + localIdx1%8/4*28+localIdx1/32*32;\n"
+"  uint   group_ptr_offset = groupIdx * 384;                              \n"
+"  uchar  dataInCb ,dataInCr;                                             \n"
+"                                                                         \n"
+"  x = globalMCUIdx % mcu_width;                                          \n"
+"  y = globalMCUIdx / mcu_width;                                          \n"
+"  if (localIdx < 64)                                                     \n"
+"  {                                                                      \n"
+"    cb_cache[trans8to10] = src[group_ptr_offset + 256 + localIdx];       \n"
+"    cr_cache[trans8to10] = src[group_ptr_offset + 320 + localIdx];       \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 8)                                                      \n"
+"  {                                                                      \n"
+"    if (!(globalMCUIdx / mcu_width))                                     \n"
+"    {                                                                    \n"
+"      cb_cache[localIdx + 1] = cb_cache[localIdx + 11];                  \n"
+"      cr_cache[localIdx + 1] = cr_cache[localIdx + 11];                  \n"
+"    }                                                                    \n"
+"    else if (globalIdx / 128 < mcu_width)                                \n"
+"    {                                                                    \n"
+"      cb_cache[localIdx + 1] = src_prior[groupIdx * 16 + localIdx];      \n"
+"      cr_cache[localIdx + 1] = src_prior[groupIdx * 16 + 8 + localIdx];  \n"
+"    }                                                                    \n"
+"    else                                                                 \n"
+"    {                                                                    \n"
+"      cb_cache[localIdx + 1] = src[(globalIdx/128 - mcu_width) * 384     \n"
+"        + 256 + 56 + localIdx];                                          \n"
+"      cr_cache[localIdx + 1] = src[(globalIdx/128 - mcu_width) * 384     \n"
+"        + 320 + 56 + localIdx];                                          \n"
+"    }                                                                    \n"
+"    if ((globalMCUIdx / mcu_width) == (mcu_total /128 /mcu_width - 1))   \n"
+"    {                                                                    \n"
+"      cb_cache[localIdx + 11 + edge_mcu_v * 10]                          \n"
+"                      = cb_cache[localIdx + 1 + edge_mcu_v * 10];        \n"
+"      cr_cache[localIdx + 11 + edge_mcu_v * 10]                          \n"
+"                      = cr_cache[localIdx + 1 + edge_mcu_v * 10];        \n"
+"    }                                                                    \n"
+"    else if (globalIdx >= mcu_offset_buffer)                             \n"
+"    {                                                                    \n"
+"      cb_cache[localIdx + 91] = src1[globalIdx / 128 % mcu_width * 384   \n"
+"        + 256 + localIdx];                                               \n"
+"      cr_cache[localIdx + 91] = src1[globalIdx / 128 % mcu_width * 384   \n"
+"        + 320 + localIdx];                                               \n"
+"    }                                                                    \n"
+"    else                                                                 \n"
+"    {                                                                    \n"
+"      cb_cache[localIdx + 91] = src[(globalIdx/128 + mcu_width) * 384    \n"
+"        + 256 + localIdx];                                               \n"
+"      cr_cache[localIdx + 91] = src[(globalIdx/128 + mcu_width) * 384    \n"
+"        + 320 + localIdx];                                               \n"
+"    }                                                                    \n"
+"    if (!(globalMCUIdx % mcu_width))                                     \n"
+"    {                                                                    \n"
+"      cb_cache[localIdx * 10 + 10] = cb_cache[localIdx * 10 + 11];       \n"
+"      cr_cache[localIdx * 10 + 10] = cr_cache[localIdx * 10 + 11];       \n"
+"    }                                                                    \n"
+"    else                                                                 \n"
+"    {                                                                    \n"
+"      cb_cache[localIdx * 10 + 10] = src[group_ptr_offset - 121 +        \n"
+"        localIdx * 8];                                                   \n"
+"      cr_cache[localIdx * 10 + 10] = src[group_ptr_offset - 57 +         \n"
+"        localIdx * 8];                                                   \n"
+"    }                                                                    \n"
+"    if ((globalMCUIdx % mcu_width) == (mcu_width - 1))                   \n"
+"    {                                                                    \n"
+"      cb_cache[localIdx * 10 + 12 + edge_mcu_h]                          \n"
+"                       = cb_cache[localIdx * 10 + 11 + edge_mcu_h];      \n"
+"      cr_cache[localIdx * 10 + 12 + edge_mcu_h]                          \n"
+"                       = cr_cache[localIdx * 10 + 11 + edge_mcu_h];      \n"
+"    }                                                                    \n"
+"    else                                                                 \n"
+"    {                                                                    \n"
+"      cb_cache[localIdx * 10 + 19] = src[group_ptr_offset + 640          \n"
+"        + localIdx * 8];                                                 \n"
+"      cr_cache[localIdx * 10 + 19] = src[group_ptr_offset + 704          \n"
+"        + localIdx * 8];                                                 \n"
+"    }                                                                    \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx == 0)                                                     \n"
+"  {                                                                      \n"
+"    if (!(globalIdx / 128 % mcu_width))                                  \n"
+"    {                                                                    \n"
+"      cb_cache[0] = cb_cache[1];                                         \n"
+"      cr_cache[0] = cr_cache[1];                                         \n"
+"    }                                                                    \n"
+"    else if(!(globalMCUIdx / mcu_width))                                 \n"
+"    {                                                                    \n"
+"      cb_cache[0] = src[group_ptr_offset - 121];                         \n"
+"      cr_cache[0] = src[group_ptr_offset - 57];                          \n"
+"    }                                                                    \n"
+"    else if (globalIdx / 128 < mcu_width)                                \n"
+"    {                                                                    \n"
+"      cb_cache[0] = src_prior[groupIdx * 16 - 9];                        \n"
+"      cr_cache[0] = src_prior[groupIdx * 16 - 1];                        \n"
+"    }                                                                    \n"
+"    else                                                                 \n"
+"    {                                                                    \n"
+"      cb_cache[0] = src[(globalIdx/128 - mcu_width - 1)* 384 + 256 + 63];\n"
+"      cr_cache[0] = src[(globalIdx/128 - mcu_width - 1)* 384 + 320 + 63];\n"
+"    }                                                                    \n"
+"    if(!(globalIdx / 128 % mcu_width))                                   \n"
+"    {                                                                    \n"
+"      cb_cache[90] = cb_cache[91];                                       \n"
+"      cr_cache[90] = cr_cache[91];                                       \n"
+"    }                                                                    \n"
+"    else if((globalMCUIdx/ mcu_width) == (mcu_total /128 /mcu_width - 1))\n"
+"    {                                                                    \n"
+"      cb_cache[10 + edge_mcu_v * 10] = src[group_ptr_offset - 384 + 256  \n"
+"        + edge_mcu_v * 8 - 1];                                           \n"
+"      cr_cache[10 + edge_mcu_v * 10] = src[group_ptr_offset - 384 + 320  \n"
+"        + edge_mcu_v * 8 - 1];                                           \n"
+"    }                                                                    \n"
+"    else if(globalIdx >= mcu_offset_buffer)                              \n"
+"    {                                                                    \n"
+"      cb_cache[90] = src1[globalIdx / 128 % mcu_width * 384 - 121];      \n"
+"      cr_cache[90] = src1[globalIdx / 128 % mcu_width * 384 - 57];       \n"
+"    }                                                                    \n"
+"    else                                                                 \n"
+"    {                                                                    \n"
+"      cb_cache[90] = src[(globalIdx/128 + mcu_width - 1)* 384 + 256 + 7];\n"
+"      cr_cache[90] = src[(globalIdx/128 + mcu_width - 1)* 384 + 320 + 7];\n"
+"    }                                                                    \n"
+"    if ((globalMCUIdx % mcu_width) == (mcu_width - 1))                   \n"
+"    {                                                                    \n"
+"      cb_cache[edge_mcu_h + 2] = cb_cache[edge_mcu_h + 1];               \n"
+"      cr_cache[edge_mcu_h + 2] = cr_cache[edge_mcu_h + 1];               \n"
+"    }                                                                    \n"
+"    else if (!(globalMCUIdx / mcu_width))                                \n"
+"    {                                                                    \n"
+"      cb_cache[9] = src[group_ptr_offset + 640];                         \n"
+"      cr_cache[9] = src[group_ptr_offset + 704];                         \n"
+"    }                                                                    \n"
+"    else if (globalIdx / 128 < mcu_width)                                \n"
+"    {                                                                    \n"
+"      cb_cache[9] = src_prior[groupIdx * 16 + 16];                       \n"
+"      cr_cache[9] = src_prior[groupIdx * 16 + 24];                       \n"
+"    }                                                                    \n"
+"    else                                                                 \n"
+"    {                                                                    \n"
+"      cb_cache[9] = src[(globalIdx/128 - mcu_width + 1)* 384 + 256 + 56];\n"
+"      cr_cache[9] = src[(globalIdx/128 - mcu_width + 1)* 384 + 320 + 56];\n"
+"    }                                                                    \n"
+"    if ((globalMCUIdx % mcu_width) == (mcu_width - 1))                   \n"
+"    {                                                                    \n"
+"      cb_cache[edge_mcu_h + 92]  = cb_cache[edge_mcu_h + 91];            \n"
+"      cr_cache[edge_mcu_h + 92]  = cr_cache[edge_mcu_h + 91];            \n"
+"    }                                                                    \n"
+"    else if((globalMCUIdx/ mcu_width) == (mcu_total /128 /mcu_width - 1))\n"
+"    {                                                                    \n"
+"      cb_cache[19 + edge_mcu_v * 10] = src[group_ptr_offset + 384 + 256  \n"
+"        + edge_mcu_v * 8 - 8];                                           \n"
+"      cr_cache[19 + edge_mcu_v * 10] = src[group_ptr_offset + 384 + 320  \n"
+"        + edge_mcu_v * 8 - 8];                                           \n"
+"    }                                                                    \n"
+"    else if(globalIdx >= mcu_offset_buffer)                              \n"
+"    {                                                                    \n"
+"      cb_cache[99]  = src1[globalIdx / 128 % mcu_width * 384 + 640];     \n"
+"      cr_cache[99]  = src1[globalIdx / 128 % mcu_width * 384 + 704];     \n"
+"    }                                                                    \n"
+"    else                                                                 \n"
+"    {                                                                    \n"
+"      cb_cache[99]  = src[(globalIdx/128 + mcu_width + 1) * 384 + 256];  \n"
+"      cr_cache[99]  = src[(globalIdx/128 + mcu_width + 1) * 384 + 320];  \n"
+"    }                                                                    \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if(localIdx < 8 && globalIdx >= mcu_offset_buffer) {                   \n"
+"    dst_prior[groupIdx % mcu_width * 16 + localIdx]                      \n"
+"      = cb_cache[localIdx + 81];                                         \n"
+"    dst_prior[groupIdx % mcu_width * 16 + 8 + localIdx]                  \n"
+"      = cr_cache[localIdx + 81];                                         \n"
+"  }                                                                      \n"
+"  if (localIdx < 64)                                                     \n"
+"  {                                                                      \n"
+"    dataInCb            = cb_cache[trans8to10];                          \n"
+"                                                                         \n"
+"    dataInTopCb         = cb_cache[trans8to10 -10];                      \n"
+"    dataInBottomCb      = cb_cache[trans8to10 +10];                      \n"
+"    dataInRightCb       = cb_cache[trans8to10 + 1];                      \n"
+"    dataInLeftCb        = cb_cache[trans8to10 - 1];                      \n"
+"    dataInLeftTopCb     = cb_cache[trans8to10 -11];                      \n"
+"    dataInRightTopCb    = cb_cache[trans8to10 - 9];                      \n"
+"    dataInLeftBottomCb  = cb_cache[trans8to10 + 9];                      \n"
+"    dataInRightBottomCb = cb_cache[trans8to10 +11];                      \n"
+"  cb_upsample[upsample_offset + 0].x =                                   \n"
+"    ((dataInCb * 3 + dataInTopCb) * 3 +                                  \n"
+"    dataInLeftCb * 3 + dataInLeftTopCb + 8) >> 4;                        \n"
+"  cb_upsample[upsample_offset + 0].y =                                   \n"
+"    ((dataInCb * 3 + dataInTopCb) * 3 +                                  \n"
+"    dataInRightCb * 3 + dataInRightTopCb + 7) >> 4;                      \n"
+"                                                                         \n"
+"  cb_upsample[upsample_offset + 4].x =                                   \n"
+"    ((dataInCb * 3 + dataInBottomCb) * 3 +                               \n"
+"    dataInLeftCb * 3 + dataInLeftBottomCb + 8) >> 4;                     \n"
+"  cb_upsample[upsample_offset + 4].y =                                   \n"
+"    ((dataInCb * 3 + dataInBottomCb) * 3 +                               \n"
+"    dataInRightCb * 3 + dataInRightBottomCb + 7) >> 4;                   \n"
+"                                                                         \n"
+"  }                                                                      \n"
+"  else                                                                   \n"
+"  {                                                                      \n"
+"    dataInCr            = cr_cache[trans8to10_1];                        \n"
+"                                                                         \n"
+"    dataInTopCr         = cr_cache[trans8to10_1 -10];                    \n"
+"    dataInBottomCr      = cr_cache[trans8to10_1 +10];                    \n"
+"    dataInRightCr       = cr_cache[trans8to10_1 + 1];                    \n"
+"    dataInLeftCr        = cr_cache[trans8to10_1 - 1];                    \n"
+"    dataInLeftTopCr     = cr_cache[trans8to10_1 -11];                    \n"
+"    dataInRightTopCr    = cr_cache[trans8to10_1 - 9];                    \n"
+"    dataInLeftBottomCr  = cr_cache[trans8to10_1 + 9];                    \n"
+"    dataInRightBottomCr = cr_cache[trans8to10_1 +11];                    \n"
+"                                                                         \n"
+"  cr_upsample[upsample_offset1 + 0].x =                                  \n"
+"    ((dataInCr * 3 + dataInTopCr) * 3 +                                  \n"
+"    dataInLeftCr * 3 + dataInLeftTopCr + 8) >> 4;                        \n"
+"  cr_upsample[upsample_offset1 + 0].y =                                  \n"
+"    ((dataInCr * 3 + dataInTopCr) * 3 +                                  \n"
+"    dataInRightCr * 3 + dataInRightTopCr + 7) >> 4;                      \n"
+"                                                                         \n"
+"  cr_upsample[upsample_offset1 + 4].x =                                  \n"
+"    ((dataInCr * 3 + dataInBottomCr) * 3 +                               \n"
+"    dataInLeftCr * 3 + dataInLeftBottomCr + 8) >> 4;                     \n"
+"  cr_upsample[upsample_offset1 + 4].y =                                  \n"
+"    ((dataInCr * 3 + dataInBottomCr) * 3 +                               \n"
+"    dataInRightCr * 3 + dataInRightBottomCr + 7) >> 4;                   \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.x);                                      \n"
+"  valueCb = convert_int(cb_upsample[localIdx].x);                        \n"
+"  valueCr = convert_int(cr_upsample[localIdx].x);                        \n"
+"                                                                         \n"
+"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.y);                                      \n"
+"  valueCb = convert_int(cb_upsample[localIdx].y);                        \n"
+"  valueCr = convert_int(cr_upsample[localIdx].y);                        \n"
+"                                                                         \n"
+"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGB)
+"  inter[transOffset * 6 + 0] = imgR.x;                                   \n"
+"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 6 + 2] = imgB.x;                                   \n"
+"  inter[transOffset * 6 + 3] = imgR.y;                                   \n"
+"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
+"  inter[transOffset * 6 + 5] = imgB.y;                                   \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_BGR)
+"  inter[transOffset * 6 + 0] = imgB.x;                                   \n"
+"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 6 + 2] = imgR.x;                                   \n"
+"  inter[transOffset * 6 + 3] = imgB.y;                                   \n"
+"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
+"  inter[transOffset * 6 + 5] = imgR.y;                                   \n"
+#elif defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  inter[transOffset * 8 + 0] = imgR.x;                                   \n"
+"  inter[transOffset * 8 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 8 + 2] = imgB.x;                                   \n"
+"  inter[transOffset * 8 + 3] = imgA.x;                                   \n"
+"  inter[transOffset * 8 + 4] = imgR.y;                                   \n"
+"  inter[transOffset * 8 + 5] = imgG.y;                                   \n"
+"  inter[transOffset * 8 + 6] = imgB.y;                                   \n"
+"  inter[transOffset * 8 + 7] = imgA.y;                                   \n"
+#endif
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+#if defined(OPENCL_DEC_UPSAMPLE_RGBA)
+"  if (localIdx < 128)                                                    \n"
+"    dst[y * mcu_width * 128 + x * 8 + localIdx % 8                       \n"
+"      + localIdx / 8 * mcu_width * 8] = vload8(localIdx, inter);         \n"
+#else
+"  if (localIdx < 96)                                                     \n"
+"    dst[y * mcu_width * 96 + x * 6 + localIdx % 6                        \n"
+"      + localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);         \n"
+#endif
+"}                                                                        \n";
diff --git a/joclidct.h b/joclidct.h
new file mode 100644
index 0000000..dd5edb9
--- /dev/null
+++ b/joclidct.h
@@ -0,0 +1,354 @@
+/*
+ * joclidct.h
+ *
+ * Copyright (C) 2012-2013, MulticoreWare Inc.
+ * In July 2013, Written by Peixuan Zhang <zhangpeixuan.cn@gmail.com>
+ * The OpenCL kernel code is written by
+ *   Chunli  Zhang <chunli@multicorewareinc.com> and
+ *   Peixuan Zhang <peixuan@multicorewareinc.com>
+ * Based on the OpenCL extension for IJG JPEG library,
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file contains the kernels of OpenCL decoding.
+ */
+
+static const char     * jocldec_cl_source1  =
+"#define DESCALE(x,n) ((x) >> n)                                          \n"
+"__kernel void IDCT_FAST_SHORT     (__global   short8 *src,               \n"
+"                                   __global   uchar8 *dst,               \n"
+"                                   __constant short8 *quant_tables,      \n"
+"                                   __local    short  *inter,             \n"
+"                                   const      uint    block_offset)      \n"
+"{                                                                        \n"
+"  uint   globalIdx = get_global_id(0);                                   \n"
+"  uint   localIdx  = get_local_id (0);                                   \n"
+"  uint   unitIdx   = localIdx  & 0x07; // MOD 8                          \n"
+"  uint   blockIdx  = unitIdx + ((localIdx >> 3) << 6);                   \n"
+"  uint   quantbIdx =                                                     \n"
+"    ((block_offset - 3) < ((globalIdx >>3) % block_offset)) << 3;        \n"
+"  short8 dataShort;                                                      \n"
+"  uchar8 dataUchar;                                                      \n"
+"  short  tmp0 , tmp1 , tmp2 , tmp3 , tmp4, tmp5, tmp6, tmp7;             \n"
+"  short  tmp10, tmp11, tmp12, tmp13, z5  , z10 , z11 , z12 , z13;        \n"
+"                                                                         \n"
+"  dataShort = src[globalIdx] * quant_tables[quantbIdx + unitIdx];        \n"
+"                                                                         \n"
+"  if (dataShort.s1 == 0 && dataShort.s2 == 0 && dataShort.s3 == 0 &&     \n"
+"      dataShort.s4 == 0 && dataShort.s5 == 0 && dataShort.s6 == 0 &&     \n"
+"      dataShort.s7 == 0)                                                 \n"
+"    inter[blockIdx +  0] = inter[blockIdx +  8] = inter[blockIdx + 16] = \n"
+"    inter[blockIdx + 24] = inter[blockIdx + 32] = inter[blockIdx + 40] = \n"
+"    inter[blockIdx + 48] = inter[blockIdx + 56] = dataShort.s0;          \n"
+"  else                                                                   \n"
+"  {                                                                      \n"
+"    tmp10 = dataShort.s0  + dataShort.s4;                                \n"
+"    tmp11 = dataShort.s0  - dataShort.s4;                                \n"
+"    tmp13 = dataShort.s2  + dataShort.s6;                                \n"
+"    tmp12 = DESCALE((dataShort.s2 - dataShort.s6) * 362, 8) - tmp13;     \n"
+"    tmp0  = tmp10 + tmp13;                                               \n"
+"    tmp3  = tmp10 - tmp13;                                               \n"
+"    tmp1  = tmp11 + tmp12;                                               \n"
+"    tmp2  = tmp11 - tmp12;                                               \n"
+"    z13   = dataShort.s5  + dataShort.s3;                                \n"
+"    z10   = dataShort.s5  - dataShort.s3;                                \n"
+"    z11   = dataShort.s1  + dataShort.s7;                                \n"
+"    z12   = dataShort.s1  - dataShort.s7;                                \n"
+"    tmp7  = z11   + z13;                                                 \n"
+"    tmp11 = DESCALE((z11 - z13) * 362, 8);                               \n"
+"    z5    = DESCALE((z10 + z12) * 473, 8);                               \n"
+"    tmp10 = DESCALE(z12 * 277, 8) - z5;                                  \n"
+"    tmp12 = DESCALE(-z10 * 669, 8)+ z5;                                  \n"
+"    tmp6  = tmp12 - tmp7;                                                \n"
+"    tmp5  = tmp11 - tmp6;                                                \n"
+"    tmp4  = tmp10 + tmp5;                                                \n"
+"                                                                         \n"
+"    inter[blockIdx +  0] = tmp0 + tmp7;                                  \n"
+"    inter[blockIdx +  8] = tmp1 + tmp6;                                  \n"
+"    inter[blockIdx + 16] = tmp2 + tmp5;                                  \n"
+"    inter[blockIdx + 24] = tmp3 - tmp4;                                  \n"
+"    inter[blockIdx + 32] = tmp3 + tmp4;                                  \n"
+"    inter[blockIdx + 40] = tmp2 - tmp5;                                  \n"
+"    inter[blockIdx + 48] = tmp1 - tmp6;                                  \n"
+"    inter[blockIdx + 56] = tmp0 - tmp7;                                  \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  dataShort = vload8(localIdx, inter);                                   \n"
+"                                                                         \n"
+"  if (dataShort.s1 == 0 && dataShort.s2 == 0 && dataShort.s3 == 0 &&     \n"
+"      dataShort.s4 == 0 && dataShort.s5 == 0 && dataShort.s6 == 0 &&     \n"
+"      dataShort.s7 == 0)                                                 \n"
+"    dataUchar = convert_uchar_sat((dataShort.s0 >> 5) + 128);            \n"
+"  else                                                                   \n"
+"  {                                                                      \n"
+"    tmp10 = dataShort.s0 + dataShort.s4;                                 \n"
+"    tmp11 = dataShort.s0 - dataShort.s4;                                 \n"
+"    tmp13 = dataShort.s2 + dataShort.s6;                                 \n"
+"    tmp12 = DESCALE((dataShort.s2 - dataShort.s6) * 362, 8) - tmp13;     \n"
+"    z13   = dataShort.s5 + dataShort.s3;                                 \n"
+"    z10   = dataShort.s5 - dataShort.s3;                                 \n"
+"    z11   = dataShort.s1 + dataShort.s7;                                 \n"
+"    z12   = dataShort.s1 - dataShort.s7;                                 \n"
+"    tmp0  = tmp10 + tmp13;                                               \n"
+"    tmp3  = tmp10 - tmp13;                                               \n"
+"    tmp1  = tmp11 + tmp12;                                               \n"
+"    tmp2  = tmp11 - tmp12;                                               \n"
+"    tmp7  = z11 + z13;                                                   \n"
+"    tmp11 = DESCALE((z11 - z13) * 362, 8);                               \n"
+"    z5    = DESCALE((z10 + z12) * 473, 8);                               \n"
+"    tmp10 = DESCALE(z12 * 277, 8) - z5;                                  \n"
+"    tmp12 = DESCALE(-z10 * 669, 8) + z5;                                 \n"
+"    tmp6  = tmp12 - tmp7;                                                \n"
+"    tmp5  = tmp11 - tmp6;                                                \n"
+"    tmp4  = tmp10 + tmp5;                                                \n"
+"                                                                         \n"
+"    dataShort.s0 = (tmp0 + tmp7) >>5;                                    \n"
+"    dataShort.s7 = (tmp0 - tmp7) >>5;                                    \n"
+"    dataShort.s1 = (tmp1 + tmp6) >>5;                                    \n"
+"    dataShort.s6 = (tmp1 - tmp6) >>5;                                    \n"
+"    dataShort.s2 = (tmp2 + tmp5) >>5;                                    \n"
+"    dataShort.s5 = (tmp2 - tmp5) >>5;                                    \n"
+"    dataShort.s4 = (tmp3 + tmp4) >>5;                                    \n"
+"    dataShort.s3 = (tmp3 - tmp4) >>5;                                    \n"
+"    dataShort    = dataShort + (short)128;                               \n"
+"    dataUchar    = convert_uchar8_sat(dataShort);                        \n"
+"  }                                                                      \n"
+"  dst[globalIdx] = dataUchar;                                            \n"
+"}                                                                        \n"
+"__kernel void IDCT_SLOW_INT       (__global   short8 *src,               \n"
+"                                   __global   uchar8 *dst,               \n"
+"                                   __constant int8   *quant_tables,      \n"
+"                                   __local    int    *inter,             \n"
+"                                   const      uint    block_offset)      \n"
+"{                                                                        \n"
+"  uint   globalIdx = get_global_id(0);                                   \n"
+"  uint   localIdx  = get_local_id (0);                                   \n"
+"  uint   unitIdx   = localIdx  & 0x07; // MOD 8                          \n"
+"  uint   blockIdx  = unitIdx + ((localIdx >> 3) << 6);                   \n"
+"  uint   quantbIdx =                                                     \n"
+"    ((block_offset - 3) < ((globalIdx >>3) % block_offset)) << 3;        \n"
+"  int8   dataInt;                                                        \n"
+"  uchar8 dataUchar;                                                      \n"
+"  int    tmp0 , tmp1 , tmp2 , tmp3 ;                                     \n"
+"  int    tmp10, tmp11, tmp12, tmp13;                                     \n"
+"  int    z1, z2, z3, z4, z5;                                             \n"
+"                                                                         \n"
+"  dataInt = convert_int8(src[globalIdx]) *                               \n"
+"    quant_tables[quantbIdx + unitIdx];                                   \n"
+"                                                                         \n"
+"  if (dataInt.s1 == 0 && dataInt.s2 == 0 && dataInt.s3 == 0 &&           \n"
+"      dataInt.s4 == 0 && dataInt.s5 == 0 && dataInt.s6 == 0 &&           \n"
+"      dataInt.s7 == 0)                                                   \n"
+"    inter[blockIdx +  0] = inter[blockIdx +  8] = inter[blockIdx + 16] = \n"
+"    inter[blockIdx + 24] = inter[blockIdx + 32] = inter[blockIdx + 40] = \n"
+"    inter[blockIdx + 48] = inter[blockIdx + 56] = dataInt.s0 * 4;        \n"
+"  else                                                                   \n"
+"  {                                                                      \n"
+"    z1    = (dataInt.s2 + dataInt.s6) * 4433;                            \n"
+"    tmp2  = z1 - dataInt.s6 * 15137;                                     \n"
+"    tmp3  = z1 + dataInt.s2 * 6270;                                      \n"
+"    tmp0  = (dataInt.s0 + dataInt.s4)<<13;                               \n"
+"    tmp1  = (dataInt.s0 - dataInt.s4)<<13;                               \n"
+"    tmp10 = tmp0 + tmp3;                                                 \n"
+"    tmp13 = tmp0 - tmp3;                                                 \n"
+"    tmp11 = tmp1 + tmp2;                                                 \n"
+"    tmp12 = tmp1 - tmp2;                                                 \n"
+"    z1    = dataInt.s7 + dataInt.s1;                                     \n"
+"    z2    = dataInt.s5 + dataInt.s3;                                     \n"
+"    z3    = dataInt.s7 + dataInt.s3;                                     \n"
+"    z4    = dataInt.s5 + dataInt.s1;                                     \n"
+"    z5    = (z3 + z4) * 9633;                                            \n"
+"                                                                         \n"
+"    tmp0  = dataInt.s7 * 2446;                                           \n"
+"    tmp1  = dataInt.s5 * 16819;                                          \n"
+"    tmp2  = dataInt.s3 * 25172;                                          \n"
+"    tmp3  = dataInt.s1 * 12299;                                          \n"
+"                                                                         \n"
+"    z1    = -z1 * 7373;                                                  \n"
+"    z2    = -z2 * 20995;                                                 \n"
+"    z3    = -z3 * 16069 + z5;                                            \n"
+"    z4    = -z4 * 3196  + z5;                                            \n"
+"                                                                         \n"
+"    tmp0 += z1 + z3;                                                     \n"
+"    tmp1 += z2 + z4;                                                     \n"
+"    tmp2 += z2 + z3;                                                     \n"
+"    tmp3 += z1 + z4;                                                     \n"
+"                                                                         \n"
+"    inter[blockIdx +  0] = ((tmp10 + tmp3)+(1<<10))>>11;                 \n"
+"    inter[blockIdx + 56] = ((tmp10 - tmp3)+(1<<10))>>11;                 \n"
+"    inter[blockIdx +  8] = ((tmp11 + tmp2)+(1<<10))>>11;                 \n"
+"    inter[blockIdx + 48] = ((tmp11 - tmp2)+(1<<10))>>11;                 \n"
+"    inter[blockIdx + 16] = ((tmp12 + tmp1)+(1<<10))>>11;                 \n"
+"    inter[blockIdx + 40] = ((tmp12 - tmp1)+(1<<10))>>11;                 \n"
+"    inter[blockIdx + 24] = ((tmp13 + tmp0)+(1<<10))>>11;                 \n"
+"    inter[blockIdx + 32] = ((tmp13 - tmp0)+(1<<10))>>11;                 \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  dataInt = vload8(localIdx, inter);                                     \n"
+"                                                                         \n"
+"  if (dataInt.s1 == 0 && dataInt.s2 == 0 && dataInt.s3 == 0 &&           \n"
+"      dataInt.s4 == 0 && dataInt.s5 == 0 && dataInt.s6 == 0 &&           \n"
+"      dataInt.s7 == 0) {                                                 \n"
+"    dataInt.s0 =  dataInt.s1 = dataInt.s2 = dataInt.s3 =dataInt.s4 =     \n"
+"    dataInt.s5 = dataInt.s6 = dataInt.s7 = (dataInt.s0 + 16) >> 5;       \n"
+"    dataUchar = convert_uchar8_sat(dataInt + 128);                       \n"
+"  }                                                                      \n"
+"  else                                                                   \n"
+"  {                                                                      \n"
+"    z1 = (dataInt.s2 + dataInt.s6) * 4433;                               \n"
+"    tmp2 = z1 - dataInt.s6 * 15137;                                      \n"
+"    tmp3 = z1 + dataInt.s2 * 6270;                                       \n"
+"    tmp0 = (dataInt.s0 + dataInt.s4) << 13;                              \n"
+"    tmp1 = (dataInt.s0 - dataInt.s4) << 13;                              \n"
+"                                                                         \n"
+"    tmp10 = tmp0 + tmp3;                                                 \n"
+"    tmp13 = tmp0 - tmp3;                                                 \n"
+"    tmp11 = tmp1 + tmp2;                                                 \n"
+"    tmp12 = tmp1 - tmp2;                                                 \n"
+"                                                                         \n"
+"    z1 = dataInt.s7 + dataInt.s1;                                        \n"
+"    z2 = dataInt.s5 + dataInt.s3;                                        \n"
+"    z3 = dataInt.s7 + dataInt.s3;                                        \n"
+"    z4 = dataInt.s5 + dataInt.s1;                                        \n"
+"                                                                         \n"
+"    z5 = (z3 + z4)* 9633;                                                \n"
+"                                                                         \n"
+"    tmp0 = dataInt.s7 * 2446;                                            \n"
+"    tmp1 = dataInt.s5 * 16819;                                           \n"
+"    tmp2 = dataInt.s3 * 25172;                                           \n"
+"    tmp3 = dataInt.s1 * 12299;                                           \n"
+"                                                                         \n"
+"    z1 = -z1 * 7373;                                                     \n"
+"    z2 = -z2 * 20995;                                                    \n"
+"    z3 = -z3 * 16069 + z5;                                               \n"
+"    z4 = -z4 * 3196 + z5;                                                \n"
+"                                                                         \n"
+"    tmp0 += z1 + z3;                                                     \n"
+"    tmp1 += z2 + z4;                                                     \n"
+"    tmp2 += z2 + z3;                                                     \n"
+"    tmp3 += z1 + z4;                                                     \n"
+"                                                                         \n"
+"    dataInt.s0 = ((tmp10 + tmp3)+(1<<17))>> 18;                          \n"
+"    dataInt.s7 = ((tmp10 - tmp3)+(1<<17))>> 18;                          \n"
+"    dataInt.s1 = ((tmp11 + tmp2)+(1<<17))>> 18;                          \n"
+"    dataInt.s6 = ((tmp11 - tmp2)+(1<<17))>> 18;                          \n"
+"    dataInt.s2 = ((tmp12 + tmp1)+(1<<17))>> 18;                          \n"
+"    dataInt.s5 = ((tmp12 - tmp1)+(1<<17))>> 18;                          \n"
+"    dataInt.s4 = ((tmp13 - tmp0)+(1<<17))>> 18;                          \n"
+"    dataInt.s3 = ((tmp13 + tmp0)+(1<<17))>> 18;                          \n"
+"    dataUchar    = convert_uchar8_sat(dataInt + 128);                    \n"
+"  }                                                                      \n"
+"  dst[globalIdx] = dataUchar;                                            \n"
+"}                                                                        \n"
+"__kernel void IDCT_FAST_FLOAT     (__global   short8 *src,               \n"
+"                                   __global   uchar8 *dst,               \n"
+"                                   __constant float8 *quant_tables,      \n"
+"                                   __local    float  *inter,             \n"
+"                                   const      uint    block_offset)      \n"
+"{                                                                        \n"
+"  uint   globalIdx = get_global_id(0);                                   \n"
+"  uint   localIdx  = get_local_id (0);                                   \n"
+"  uint   unitIdx   = localIdx  & 0x07; // MOD 8                          \n"
+"  uint   blockIdx  = unitIdx + ((localIdx >> 3) << 6);                   \n"
+"  uint   quantbIdx =                                                     \n"
+"    ((block_offset - 3) < ((globalIdx >>3) % block_offset)) << 3;        \n"
+"  float8 dataFloat;                                                      \n"
+"  int8 dataInt;                                                          \n"
+"  uchar8 dataUchar;                                                      \n"
+"  float  tmp0 , tmp1 , tmp2 , tmp3 , tmp4, tmp5, tmp6, tmp7;             \n"
+"  float  tmp10, tmp11, tmp12, tmp13, z5  , z10 , z11 , z12 , z13;        \n"
+"                                                                         \n"
+"  dataFloat = convert_float8(src[globalIdx]) *                           \n"
+"    quant_tables[quantbIdx + unitIdx];                                   \n"
+"                                                                         \n"
+"  if (dataFloat.s1 == 0 && dataFloat.s2 == 0 && dataFloat.s3 == 0 &&     \n"
+"      dataFloat.s4 == 0 && dataFloat.s5 == 0 && dataFloat.s6 == 0 &&     \n"
+"      dataFloat.s7 == 0)                                                 \n"
+"    inter[blockIdx +  0] = inter[blockIdx +  8] = inter[blockIdx + 16] = \n"
+"    inter[blockIdx + 24] = inter[blockIdx + 32] = inter[blockIdx + 40] = \n"
+"    inter[blockIdx + 48] = inter[blockIdx + 56] = dataFloat.s0;          \n"
+"  else                                                                   \n"
+"  {                                                                      \n"
+"    tmp10 = dataFloat.s0  + dataFloat.s4;                                \n"
+"    tmp11 = dataFloat.s0  - dataFloat.s4;                                \n"
+"    tmp13 = dataFloat.s2  + dataFloat.s6;                                \n"
+"    tmp12 = (dataFloat.s2 - dataFloat.s6) * 1.414213562f - tmp13;        \n"
+"    tmp0  = tmp10 + tmp13;                                               \n"
+"    tmp3  = tmp10 - tmp13;                                               \n"
+"    tmp1  = tmp11 + tmp12;                                               \n"
+"    tmp2  = tmp11 - tmp12;                                               \n"
+"    z13   = dataFloat.s5  + dataFloat.s3;                                \n"
+"    z10   = dataFloat.s5  - dataFloat.s3;                                \n"
+"    z11   = dataFloat.s1  + dataFloat.s7;                                \n"
+"    z12   = dataFloat.s1  - dataFloat.s7;                                \n"
+"    tmp7  = z11 + z13;                                                   \n"
+"    tmp11 = (z11 - z13) * 1.414213562f;                                  \n"
+"    z5    = (z10 + z12) * 1.847759065f;                                  \n"
+"    tmp10 = z12 * 1.082392200f - z5;                                     \n"
+"    tmp12 = -z10 * 2.613125930f + z5;                                    \n"
+"    tmp6  = tmp12 - tmp7;                                                \n"
+"    tmp5  = tmp11 - tmp6;                                                \n"
+"    tmp4  = tmp10 + tmp5;                                                \n"
+"                                                                         \n"
+"    inter[blockIdx +  0] = tmp0 + tmp7;                                  \n"
+"    inter[blockIdx +  8] = tmp1 + tmp6;                                  \n"
+"    inter[blockIdx + 16] = tmp2 + tmp5;                                  \n"
+"    inter[blockIdx + 24] = tmp3 - tmp4;                                  \n"
+"    inter[blockIdx + 32] = tmp3 + tmp4;                                  \n"
+"    inter[blockIdx + 40] = tmp2 - tmp5;                                  \n"
+"    inter[blockIdx + 48] = tmp1 - tmp6;                                  \n"
+"    inter[blockIdx + 56] = tmp0 - tmp7;                                  \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  dataFloat = vload8(localIdx, inter);                                   \n"
+"                                                                         \n"
+"  tmp10 = dataFloat.s0 + dataFloat.s4;                                   \n"
+"  tmp11 = dataFloat.s0 - dataFloat.s4;                                   \n"
+"  tmp13 = dataFloat.s2 + dataFloat.s6;                                   \n"
+"  tmp12 = (dataFloat.s2 - dataFloat.s6) * 1.414213562f - tmp13;          \n"
+"  z13   = dataFloat.s5 + dataFloat.s3;                                   \n"
+"  z10   = dataFloat.s5 - dataFloat.s3;                                   \n"
+"  z11   = dataFloat.s1 + dataFloat.s7;                                   \n"
+"  z12   = dataFloat.s1 - dataFloat.s7;                                   \n"
+"  tmp0  = tmp10 + tmp13;                                                 \n"
+"  tmp3  = tmp10 - tmp13;                                                 \n"
+"  tmp1  = tmp11 + tmp12;                                                 \n"
+"  tmp2  = tmp11 - tmp12;                                                 \n"
+"  tmp7  = z11 + z13;                                                     \n"
+"  tmp11 = (z11 - z13) * 1.414213562f;                                    \n"
+"  z5    = (z10 + z12) * 1.847759065f;                                    \n"
+"  tmp10 = z12 * 1.082392200f - z5;                                       \n"
+"  tmp12 = -z10 * 2.613125930f + z5;                                      \n"
+"  tmp6  = tmp12 - tmp7;                                                  \n"
+"  tmp5  = tmp11 - tmp6;                                                  \n"
+"  tmp4  = tmp10 + tmp5;                                                  \n"
+"                                                                         \n"
+"  dataFloat.s0 = tmp0 + tmp7;                                            \n"
+"  dataFloat.s7 = tmp0 - tmp7;                                            \n"
+"  dataFloat.s1 = tmp1 + tmp6;                                            \n"
+"  dataFloat.s6 = tmp1 - tmp6;                                            \n"
+"  dataFloat.s2 = tmp2 + tmp5;                                            \n"
+"  dataFloat.s5 = tmp2 - tmp5;                                            \n"
+"  dataFloat.s4 = tmp3 + tmp4;                                            \n"
+"  dataFloat.s3 = tmp3 - tmp4;                                            \n"
+"  dataInt      = convert_int8_rtz(dataFloat);                            \n"
+"  dataInt.s0   = (dataInt.s0 + 4)>>3;                                    \n"
+"  dataInt.s1   = (dataInt.s1 + 4)>>3;                                    \n"
+"  dataInt.s2   = (dataInt.s2 + 4)>>3;                                    \n"
+"  dataInt.s3   = (dataInt.s3 + 4)>>3;                                    \n"
+"  dataInt.s4   = (dataInt.s4 + 4)>>3;                                    \n"
+"  dataInt.s5   = (dataInt.s5 + 4)>>3;                                    \n"
+"  dataInt.s6   = (dataInt.s6 + 4)>>3;                                    \n"
+"  dataInt.s7   = (dataInt.s7 + 4)>>3;                                    \n"
+"  dataUchar    = convert_uchar8_sat(dataInt + 128);                      \n"
+"  dst[globalIdx] = dataUchar;                                            \n"
+"}                                                                        \n"
+"__kernel void RESET_ZERO    (__global short8 *src)                       \n"
+"{                                                                        \n"
+"  uint   globalIdx = get_global_id(0);                                   \n"
+"  short8 tempIn;                                                         \n"
+"  tempIn = 0;                                                            \n"
+"  src[globalIdx] = tempIn;                                               \n"
+"}                                                                        \n";
-- 
1.8.1.4

