From 13080058330745ce1cce650a18d6ba5975e5fe2d Mon Sep 17 00:00:00 2001
From: dcommander <dcommander@632fc199-4ca6-4c93-a231-07263d6284db>
Date: Wed, 7 Aug 2013 09:40:08 +0000
Subject: [PATCH 1/9] Patch contributed by MulticoreWare, Inc.
 https://sourceforge.net/p/libjpeg-turbo/patches/40
 https://sourceforge.net/p/libjpeg-turbo/patches/_discuss/thread/3d9969a0/f718/attachment/opencl_20130806.patch

git-svn-id: http://svn.code.sf.net/p/libjpeg-turbo/code/branches/opencl@998 632fc199-4ca6-4c93-a231-07263d6284db
---
 CMakeLists.txt            |    19 +
 Makefile.am               |     3 +
 configure.ac              |    23 +
 jconfig.h.in              |    11 +
 jdapimin.c                |    74 +
 jdapistd.c                |    14 +
 jdcoefct.c                |   205 +
 jdhuff.c                  |    20 +
 jdmaster.c                |    13 +
 jdsample.c                |    21 +
 jocldec.c                 |  2131 +++++++
 jocldec.h                 |    39 +
 jocldec_kernels.h         |  2704 +++++++++
 joclinit.c                |   676 +++
 joclinit.h                |   302 +
 jpegint.h                 |     4 +
 jutils.c                  |    16 +
 win/jconfig.h.in          |    10 +
 28 files changed, 23480 insertions(+)
 create mode 100644 jocldec.c
 create mode 100644 jocldec.h
 create mode 100644 jocldec_kernels.h
 create mode 100644 joclinit.c
 create mode 100644 joclinit.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index d3c0972..d19b984 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -42,6 +42,7 @@ endif()
 message(STATUS "VERSION = ${VERSION}, BUILD = ${BUILD}")
 
 option(WITH_SIMD "Include SIMD extensions" TRUE)
+option(WITH_OPENCL_DEC "Include OpenCL decoding extensions" TRUE)
 option(WITH_ARITH_ENC "Include arithmetic encoding support" TRUE)
 option(WITH_ARITH_DEC "Include arithmetic decoding support" TRUE)
 option(WITH_JPEG7 "Emulate libjpeg v7 API/ABI (this makes libjpeg-turbo backward incompatible with libjpeg v6b)" FALSE)
@@ -49,6 +50,20 @@ option(WITH_JPEG8 "Emulate libjpeg v8 API/ABI (this makes libjpeg-turbo backward
 option(WITH_MEM_SRCDST "Include in-memory source/destination manager functions when emulating the libjpeg v6b or v7 API/ABI" TRUE)
 option(WITH_JAVA "Build Java wrapper for the TurboJPEG library" FALSE)
 
+if(WITH_OPENCL_DEC)
+  set(WITH_OPENCL_DECODING_SUPPORTED 1)
+  message(STATUS "OpenCL decoding support enabled")
+else()
+  message(STATUS "OpenCL decoding support disabled")
+endif()
+
+if(WIN32)
+  set(JOCL_CL_OS_WIN32 1)
+  message(STATUS "The system is Windows")
+else()
+  message(STATUS "The system is not Windows")
+endif()
+
 if(WITH_ARITH_ENC)
   set(C_ARITH_CODING_SUPPORTED 1)
   message(STATUS "Arithmetic encoding support enabled")
@@ -165,6 +180,10 @@ set(JPEG_SOURCES jcapimin.c jcapistd.c jccoefct.c jccolor.c jcdctmgr.c jchuff.c
   jfdctflt.c jfdctfst.c jfdctint.c jidctflt.c jidctfst.c jidctint.c jidctred.c
   jquant1.c jquant2.c jutils.c jmemmgr.c jmemnobs.c)
 
+if(WITH_OPENCL_DEC)
+  set(JPEG_SOURCES ${JPEG_SOURCES} joclinit.c jocldec.c)
+endif()
+
 if(WITH_ARITH_ENC OR WITH_ARITH_DEC)
   set(JPEG_SOURCES ${JPEG_SOURCES} jaricom.c)
 endif()
diff --git a/Makefile.am b/Makefile.am
index 79594bf..c1df805 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -35,6 +35,9 @@ if WITH_ARITH_DEC
 libjpeg_la_SOURCES += jdarith.c
 endif
 
+if WITH_OPENCL_DEC
+libjpeg_la_SOURCES += jocldec.c joclinit.c
+endif
 
 SUBDIRS = java
 
diff --git a/configure.ac b/configure.ac
index f90a75a..66135ee 100644
--- a/configure.ac
+++ b/configure.ac
@@ -25,6 +25,15 @@ AC_PROG_INSTALL
 AC_PROG_LIBTOOL
 AC_PROG_LN_S
 
+#check dlopen
+AC_SEARCH_LIBS(dlopen, dl)
+old_ldflags="${LDFLAGS}"
+LDFLAGS="${LDFLAGS} -Wl,-export-dynamic"
+AC_TRY_LINK(, [int i;], found_export_dynamic=yes, found_export_dynamic=no)
+if test $found_export_dynamic = no; then
+  LDFLAGS="${old_ldflags}"
+fi
+
 # When the prefix is /opt/libjpeg-turbo, we assume that an "official" binary is
 # being created, and thus we install things into specific locations.
 
@@ -306,6 +315,20 @@ AM_CONDITIONAL([WITH_ARITH_DEC], [test "x$with_arith_dec" != "xno"])
 AM_CONDITIONAL([WITH_ARITH],
   [test "x$with_arith_dec" != "xno" -o "x$with_arith_enc" != "xno"])
 
+# OpenCL decoding support
+AC_MSG_CHECKING([whether to include opencl decoding support])
+AC_ARG_WITH([opencl-dec],
+  AC_HELP_STRING([--with-opencl-dec],
+    [Include opencl decoding support]))
+if test "x$with_opencl_dec" = "xyes"; then
+  AC_DEFINE([WITH_OPENCL_DECODING_SUPPORTED], [1], [Support OpenCL decoding])
+  AC_MSG_RESULT(yes)
+  RPM_CONFIG_ARGS="$RPM_CONFIG_ARGS --with-opencl-dec"
+else
+  AC_MSG_RESULT(no)
+fi
+AM_CONDITIONAL([WITH_OPENCL_DEC], [test "x$with_opencl_dec" = "xyes"])
+
 # TurboJPEG support
 AC_MSG_CHECKING([whether to build TurboJPEG C wrapper])
 AC_ARG_WITH([turbojpeg],
diff --git a/jconfig.h.in b/jconfig.h.in
index 6b80ce2..9c655f4 100644
--- a/jconfig.h.in
+++ b/jconfig.h.in
@@ -12,6 +12,9 @@
 /* Support arithmetic decoding */
 #undef D_ARITH_CODING_SUPPORTED
 
+/* Support opencl decoding */
+#undef WITH_OPENCL_DECODING_SUPPORTED
+
 /* Support in-memory source/destination managers */
 #undef MEM_SRCDST_SUPPORTED
 
@@ -58,3 +61,11 @@
 
 /* Define to `unsigned int' if <sys/types.h> does not define. */
 #undef size_t
+
+/* Define envionment variables of OpenCL decoding. */
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+#define OPENCL_PIPELINE           /* Pipeline or no pipeline */
+#define MAX_IMAGE_WIDTH   4096    /* Using to set the buffer size */
+#define MAX_IMAGE_HEIGHT  4096    /* Using to set the buffer size */
+#define NUM_COMPONENT     3       /* The number of component */
+#endif
diff --git a/jdapimin.c b/jdapimin.c
index cadb59f..d78a70d 100644
--- a/jdapimin.c
+++ b/jdapimin.c
@@ -3,6 +3,8 @@
  *
  * Copyright (C) 1994-1998, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
+ * Modifications:
+ * Copyright (C) 2012-2013, MulticoreWare Inc.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains application interface code for the decompression half
@@ -20,6 +22,11 @@
 #include "jinclude.h"
 #include "jpeglib.h"
 
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+#include "CL/opencl.h"
+#include "joclinit.h"
+#include "jocldec.h"
+#endif
 
 /*
  * Initialization of a JPEG decompression object.
@@ -30,6 +37,9 @@ GLOBAL(void)
 jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
 {
   int i;
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  cl_int err_code;
+#endif
 
   /* Guard against version mismatches between library and caller. */
   cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
@@ -80,6 +90,70 @@ jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
 
   /* OK, I'm ready */
   cinfo->global_state = DSTATE_START;
+
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  if (CL_FALSE == jocl_cl_is_available() && CL_TRUE == jocl_cl_init()) {
+    if(CL_TRUE == jocl_cl_is_nvidia_opencl()) {
+      jocl_global_data_ptr_input  = (JCOEFPTR)malloc(MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4);
+      memset(jocl_global_data_ptr_input, 0, MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4);
+      jocl_global_data_ptr_output = (JSAMPROW)malloc(MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 6);
+      memset(jocl_global_data_ptr_output, 0, MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 6);
+      jocl_global_data_ptr_qutable = (float *)malloc(4096);
+      memset(jocl_global_data_ptr_qutable, 0, 4096);
+
+      CL_SAFE_CALL0(jocl_global_data_mem_input = jocl_clCreateBuffer(jocl_cl_get_context(),
+        CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR,
+        MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4, jocl_global_data_ptr_input, &err_code),return);
+      CL_SAFE_CALL0(jocl_global_data_mem_output = jocl_clCreateBuffer(jocl_cl_get_context(),
+        CL_MEM_WRITE_ONLY | CL_MEM_USE_HOST_PTR,
+        MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 6, jocl_global_data_ptr_output, &err_code),return);
+      CL_SAFE_CALL0(jocl_global_data_mem_qutable = jocl_clCreateBuffer(jocl_cl_get_context(),
+        CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
+        4096, jocl_global_data_ptr_qutable, &err_code),return);
+	  }
+	  else {
+      CL_SAFE_CALL0(jocl_global_data_mem_input = jocl_clCreateBuffer(jocl_cl_get_context(),
+        CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR,
+        MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4, NULL, &err_code),return);
+      CL_SAFE_CALL0(jocl_global_data_ptr_input = (JCOEFPTR)jocl_clEnqueueMapBuffer(
+        jocl_cl_get_command_queue(), jocl_global_data_mem_input, CL_TRUE,
+        CL_MAP_WRITE_INVALIDATE_REGION, 0, MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4,
+        0, NULL, NULL, &err_code),return);
+      memset(jocl_global_data_ptr_input,0,MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4);
+      CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
+        jocl_cl_get_command_queue(), jocl_global_data_mem_input,
+        jocl_global_data_ptr_input, 0, NULL, NULL),);
+      CL_SAFE_CALL0(jocl_global_data_mem_output = jocl_clCreateBuffer(jocl_cl_get_context(),
+        CL_MEM_WRITE_ONLY | CL_MEM_ALLOC_HOST_PTR,
+        MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 6, NULL, &err_code),return);
+      CL_SAFE_CALL0(jocl_global_data_ptr_output = (JSAMPROW)jocl_clEnqueueMapBuffer(
+        jocl_cl_get_command_queue(), jocl_global_data_mem_output, CL_TRUE,
+        CL_MAP_READ, 0, MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 6, 
+        0, NULL, NULL, &err_code),return);
+      CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
+        jocl_cl_get_command_queue(), jocl_global_data_mem_output,
+        jocl_global_data_ptr_output, 0, NULL, NULL),);
+      CL_SAFE_CALL0(jocl_global_data_mem_qutable = jocl_clCreateBuffer(jocl_cl_get_context(),
+        CL_MEM_READ_ONLY | CL_MEM_ALLOC_HOST_PTR,
+        4096, NULL, &err_code),return);
+      CL_SAFE_CALL0(jocl_global_data_ptr_qutable = (float *)jocl_clEnqueueMapBuffer(
+        jocl_cl_get_command_queue(), jocl_global_data_mem_qutable, CL_TRUE,
+        CL_MAP_WRITE_INVALIDATE_REGION, 0, 4096, 0, NULL, NULL, &err_code),return);
+      memset(jocl_global_data_ptr_qutable, 0, 4096);
+      CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
+        jocl_cl_get_command_queue(), jocl_global_data_mem_qutable ,
+        jocl_global_data_ptr_qutable, 0, NULL, NULL),);
+    }
+    CL_SAFE_CALL0(jocl_global_data_mem_inter = jocl_clCreateBuffer(jocl_cl_get_context(), 
+      CL_MEM_READ_WRITE,MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 8 ,
+      NULL, &err_code),return);
+    if (CL_FALSE == jocldec_build_kernels(cinfo)) {
+      jocl_cl_set_opencl_failure();
+      jocl_cl_set_opencl_support_failure();
+      return;
+    }
+  }
+#endif
 }
 
 
diff --git a/jdapistd.c b/jdapistd.c
index a50fda5..021f50b 100644
--- a/jdapistd.c
+++ b/jdapistd.c
@@ -5,6 +5,7 @@
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * libjpeg-turbo Modifications:
  * Copyright (C) 2010, D. R. Commander.
+ * Copyright (C) 2012-2013, MulticoreWare Inc.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains application interface code for the decompression half
@@ -21,6 +22,10 @@
 #include "jpeglib.h"
 #include "jpegcomp.h"
 
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+#include "CL/opencl.h"
+#include "joclinit.h"
+#endif
 
 /* Forward declarations */
 LOCAL(boolean) output_pass_setup JPP((j_decompress_ptr cinfo));
@@ -50,6 +55,15 @@ jpeg_start_decompress (j_decompress_ptr cinfo)
     }
     cinfo->global_state = DSTATE_PRELOAD;
   }
+
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  /* Determine whether the OpenCL decoding will be used.*/
+  if(jocl_cl_is_support_opencl() && jocl_cl_is_opencl_decompress(cinfo))
+    jocl_cl_set_opencl_success();
+  else
+    jocl_cl_set_opencl_failure();
+#endif
+
   if (cinfo->global_state == DSTATE_PRELOAD) {
     /* If file has multiple scans, absorb them all into the coef buffer */
     if (cinfo->inputctl->has_multiple_scans) {
diff --git a/jdcoefct.c b/jdcoefct.c
index d38db6c..c0ce989 100644
--- a/jdcoefct.c
+++ b/jdcoefct.c
@@ -5,6 +5,7 @@
  * Copyright (C) 1994-1997, Thomas G. Lane.
  * libjpeg-turbo Modifications:
  * Copyright (C) 2010, D. R. Commander.
+ * Copyright (C) 2012-2013, MulticoreWare Inc.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains the coefficient buffer controller for decompression.
@@ -21,6 +22,12 @@
 #include "jpeglib.h"
 #include "jpegcomp.h"
 
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+#include "CL/opencl.h"
+#include "joclinit.h"
+#include "jocldec.h"
+#endif
+
 /* Block smoothing is only applicable for progressive JPEG, so: */
 #ifndef D_PROGRESSIVE_SUPPORTED
 #undef BLOCK_SMOOTHING_SUPPORTED
@@ -162,6 +169,201 @@ decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
   jpeg_component_info *compptr;
   inverse_DCT_method_ptr inverse_DCT;
 
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  int mcuy  = 0, index = 0;
+  int block = cinfo->MCUs_per_row;
+  int i, j, upfactor;
+  int qutable[128];
+  float qutable_float[128];
+  short* qutable_short_inter = (short *)jocl_global_data_ptr_qutable;
+  int* qutable_int_inter = (int *)jocl_global_data_ptr_qutable;
+
+  /*offset_input is used to compute the offset of input and output for Kernel*/
+  unsigned int offset_input = 0;
+  /*kernel execution times  = cinfo->total_iMCU_rows/mcuNums*/
+  unsigned int mcuNums      = 800;
+  unsigned int mcudecoder   = 0;
+  int rows_per_iMCU_row     = coef->MCU_rows_per_iMCU_row;
+  int decodeMCU = 0;
+  int total_mcu_num = cinfo->total_iMCU_rows * rows_per_iMCU_row * cinfo->MCUs_per_row;
+  /*IDCT FAST SHORT*/
+  static const int aanscales[DCTSIZE2] = {
+	  /* precomputed values scaled up by 14 bits */
+	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
+	  22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,
+	  21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,
+	  19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,
+	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
+	  12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,
+	   8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,
+	   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247
+  };
+  /*IDCT FAST FLOAT */
+  static const double aanscalefactor[8] = {1.0, 1.387039845, 1.306562965, 1.175875602,
+                                           1.0, 0.785694958, 0.541196100, 0.275899379};
+
+
+  if (CL_TRUE == jocl_cl_is_available()) { 
+    switch (cinfo->dct_method){
+	  case JDCT_IFAST:{
+	    /*IDCT FAST INT*/
+        for (i = 0; i < DCTSIZE2; ++i) {
+          qutable[i] = cinfo->quant_tbl_ptrs[0]->quantval[i];
+        }
+        if (cinfo->quant_tbl_ptrs[1]->quantval != NULL) {
+          for (i = 0; i < DCTSIZE2; ++i) {
+            qutable[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[1]->quantval[i];
+          }
+        }
+        else {
+          for (i = 0; i < DCTSIZE2; ++i) {
+            qutable[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[0]->quantval[i];
+          }
+        }
+        for(i = 0; i < DCTSIZE ; ++i)
+          for(j = 0 ; j < DCTSIZE ; ++j) {
+            qutable_short_inter[j*8+i] = ((qutable[i*8+j] * aanscales[i*8+j]) +
+              (1 << ((12)-1))) >> 12;
+            qutable_short_inter[DCTSIZE2+j*8+i] = ((qutable[DCTSIZE2 + i*8+j] *
+              aanscales[i*8+j]) + (1 << ((12)-1))) >> 12;
+	    }
+		break;
+	  }
+	  case JDCT_FLOAT:{
+	    /*IDCT FAST FLOAT*/ 
+        for (i = 0; i < DCTSIZE2; ++i) {
+          qutable_float[i] = cinfo->quant_tbl_ptrs[0]->quantval[i];
+        }
+        if (cinfo->quant_tbl_ptrs[1]->quantval != NULL) {
+          for (i = 0; i < DCTSIZE2; ++i) {
+            qutable_float[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[1]->quantval[i];
+          }
+        }
+        else {
+          for (i = 0; i < DCTSIZE2; ++i) {
+            qutable_float[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[0]->quantval[i];
+          }
+        }
+	    for (i = 0; i < 8; i++) 
+          for (j = 0; j < 8; j++) {
+            jocl_global_data_ptr_qutable[j * 8 + i] = (float)(qutable_float[i * 8 + j] *
+              aanscalefactor[i] * aanscalefactor[j]);
+            jocl_global_data_ptr_qutable[DCTSIZE2 + j * 8 + i] = (float)(qutable_float[DCTSIZE2 + i * 8 + j] *
+              aanscalefactor[i] * aanscalefactor[j]);
+          }
+		break;
+	  }
+	  case JDCT_ISLOW: {
+	    /*IDCT SLOW INT*/
+        for (i = 0; i < DCTSIZE2; ++i) {
+          qutable[i] = cinfo->quant_tbl_ptrs[0]->quantval[i];
+        }
+        if (cinfo->quant_tbl_ptrs[1]->quantval != NULL) {
+          for (i = 0; i < DCTSIZE2; ++i) {
+            qutable[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[1]->quantval[i];
+          }
+        }
+        else {
+          for (i = 0; i < DCTSIZE2; ++i) {
+            qutable[i + DCTSIZE2] = cinfo->quant_tbl_ptrs[0]->quantval[i];
+          }
+        }
+        for (i = 0; i < 8; i++)
+          for (j = 0; j < 8; j++) {
+            qutable_int_inter[j * 8 + i] = qutable[i * 8 + j];
+            qutable_int_inter[DCTSIZE2 + j * 8 + i] = qutable[DCTSIZE2 + i * 8 + j];
+          }
+	    break;
+      }
+	}
+    if(cinfo->max_v_samp_factor == 2) {
+      if(cinfo->max_h_samp_factor == 1)
+        upfactor = 5;
+      else
+        upfactor = 6;
+    } 
+    else if (cinfo->max_h_samp_factor == 2) {
+      upfactor = 4;
+    }
+    else {
+      upfactor = 3;
+    }
+    for (; cinfo->input_iMCU_row < cinfo->total_iMCU_rows; 
+      (cinfo->input_iMCU_row)++) {
+      /* Loop to process as much as one whole iMCU row */
+      for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
+        yoffset++) {
+        for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
+          MCU_col_num++) {
+          if (CL_TRUE== jocl_cl_is_available()) {
+#ifndef JOCL_CL_OS_WIN32       
+            jocl_global_data_ptr_input = (JCOEFPTR)jocl_clEnqueueMapBuffer(
+              jocl_cl_get_command_queue(), jocl_global_data_mem_input, CL_TRUE,
+              CL_MAP_WRITE_INVALIDATE_REGION, 0, MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4,
+              0, NULL, NULL, NULL);
+#endif
+            for (index = 0; index<cinfo->blocks_in_MCU; ++index)
+              coef->MCU_buffer[index] = (JBLOCKROW)(jocl_global_data_ptr_input +
+                mcuy++ * DCTSIZE2);
+          }
+          if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
+            /* Suspension forced; update state counters and exit */
+            coef->MCU_vert_offset = yoffset;
+            coef->MCU_ctr = MCU_col_num;
+            return JPEG_SUSPENDED;
+          }
+          decodeMCU++;
+          mcudecoder++;
+
+          if(CL_TRUE == jocl_cl_is_nvidia_opencl()) {
+            if (     
+              (decodeMCU == cinfo->total_iMCU_rows *
+              coef->MCU_rows_per_iMCU_row * (last_MCU_col+1))) {
+              jocldec_run_kernels_full_image(cinfo,
+                                             upfactor,
+                                             mcudecoder,
+                                             block,
+                                             offset_input,
+                                             total_mcu_num,
+                                             decodeMCU);
+              offset_input += mcudecoder;
+              mcudecoder = 0;
+            }
+          }
+          else {
+            if (
+#ifdef OPENCL_PIPELINE
+              decodeMCU % mcuNums==0 ||
+#endif        
+              (decodeMCU == cinfo->total_iMCU_rows *
+              coef->MCU_rows_per_iMCU_row * (last_MCU_col+1))) {
+              jocldec_run_kernels_full_image(cinfo,
+                                             upfactor,
+                                             mcudecoder,
+                                             block,
+                                             offset_input,
+                                             total_mcu_num,
+                                             decodeMCU);
+              offset_input += mcudecoder;
+              mcudecoder = 0;
+            }
+          }
+        }
+        /* Completed an MCU row, but perhaps not an iMCU row */
+        coef->MCU_ctr = 0;
+	  }
+      if (cinfo->input_iMCU_row != (cinfo->total_iMCU_rows - 1)) {
+	    start_iMCU_row(cinfo);
+	  }
+    }
+	/* Completed the iMCU row, advance counters for next one */
+	if ( ++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows) {
+      (*cinfo->inputctl->finish_input_pass) (cinfo);
+      return JPEG_ROW_COMPLETED;
+    }
+  }
+  else {
+#endif
   /* Loop to process as much as one whole iMCU row */
   for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
        yoffset++) {
@@ -220,6 +422,9 @@ decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
     start_iMCU_row(cinfo);
     return JPEG_ROW_COMPLETED;
   }
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  }
+#endif
   /* Completed the scan */
   (*cinfo->inputctl->finish_input_pass) (cinfo);
   return JPEG_SCAN_COMPLETED;
diff --git a/jdhuff.c b/jdhuff.c
index dba5f18..3ca4eab 100644
--- a/jdhuff.c
+++ b/jdhuff.c
@@ -5,6 +5,7 @@
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * libjpeg-turbo Modifications:
  * Copyright (C) 2009-2011, D. R. Commander.
+ * Copyright (C) 2012-2013, MulticoreWare Inc.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains Huffman entropy decoding routines.
@@ -22,6 +23,11 @@
 #include "jdhuff.h"		/* Declarations shared with jdphuff.c */
 #include "jpegcomp.h"
 
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+#include "CL/opencl.h"
+#include "joclinit.h"
+#endif
+
 
 /*
  * Expanded entropy decoder object for Huffman decoding.
@@ -604,7 +610,14 @@ decode_mcu_slow (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
            * Note: the extra entries in jpeg_natural_order[] will save us
            * if k >= DCTSIZE2, which could happen if the data is corrupted.
            */
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+          if (!jocl_cl_is_available())
+#endif
           (*block)[jpeg_natural_order[k]] = (JCOEF) s;
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+          else
+            (*block)[jpeg_natural_order_ocl[k]] = (JCOEF) s;
+#endif
         } else {
           if (r != 15)
             break;
@@ -689,7 +702,14 @@ decode_mcu_fast (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
           FILL_BIT_BUFFER_FAST
           r = GET_BITS(s);
           s = HUFF_EXTEND(r, s);
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+          if (!jocl_cl_is_available())
+#endif
           (*block)[jpeg_natural_order[k]] = (JCOEF) s;
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+          else
+            (*block)[jpeg_natural_order_ocl[k]] = (JCOEF) s;
+#endif
         } else {
           if (r != 15) break;
           k += 15;
diff --git a/jdmaster.c b/jdmaster.c
index e1f9f9e..1449049 100644
--- a/jdmaster.c
+++ b/jdmaster.c
@@ -6,6 +6,7 @@
  * Modified 2002-2009 by Guido Vollbeding.
  * libjpeg-turbo Modifications:
  * Copyright (C) 2009-2011, D. R. Commander.
+ * Copyright (C) 2012-2013, MulticoreWare Inc.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains master control logic for the JPEG decompressor.
@@ -19,6 +20,11 @@
 #include "jpeglib.h"
 #include "jpegcomp.h"
 
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+#include "CL/opencl.h"
+#include "joclinit.h"
+#include "jocldec.h"
+#endif
 
 /* Private state */
 
@@ -49,6 +55,13 @@ use_merged_upsample (j_decompress_ptr cinfo)
 {
 #ifdef UPSAMPLE_MERGING_SUPPORTED
   /* Merging is the equivalent of plain box-filter upsampling */
+
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  if (CL_TRUE == jocl_cl_is_available()) { 
+    cinfo->do_fancy_upsampling = TRUE;
+  }
+#endif
+
   if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)
     return FALSE;
   /* jdmerge.c only supports YCC=>RGB color conversion */
diff --git a/jdsample.c b/jdsample.c
index 361b589..7970d7c 100644
--- a/jdsample.c
+++ b/jdsample.c
@@ -6,6 +6,7 @@
  * libjpeg-turbo Modifications:
  * Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
  * Copyright (C) 2010, D. R. Commander.
+ * Copyright (C) 2012-2013, MulticoreWare Inc.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains upsampling routines.
@@ -26,6 +27,11 @@
 #include "jpeglib.h"
 #include "jsimd.h"
 #include "jpegcomp.h"
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+#include "CL/opencl.h"
+#include "joclinit.h"
+#include "jocldec.h"
+#endif
 
 
 /* Pointer to routine to upsample a single component */
@@ -103,7 +109,11 @@ sep_upsample (j_decompress_ptr cinfo,
   JDIMENSION num_rows;
 
   /* Fill the conversion buffer, if it's empty */
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  if (CL_FALSE == jocl_cl_is_available() && upsample->next_row_out >= cinfo->max_v_samp_factor) {
+#else
   if (upsample->next_row_out >= cinfo->max_v_samp_factor) {
+#endif
     for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 	 ci++, compptr++) {
       /* Invoke per-component upsample method.  Notice we pass a POINTER
@@ -116,6 +126,10 @@ sep_upsample (j_decompress_ptr cinfo,
     upsample->next_row_out = 0;
   }
 
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+     if (CL_TRUE == jocl_cl_is_available())
+        upsample->next_row_out = 0;
+#endif
   /* Color-convert and emit rows */
 
   /* How many we have in the buffer: */
@@ -130,6 +144,13 @@ sep_upsample (j_decompress_ptr cinfo,
   if (num_rows > out_rows_avail)
     num_rows = out_rows_avail;
 
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+  if (CL_TRUE== jocl_cl_is_available()) {
+    *output_buf = &jocl_global_data_ptr_output[cinfo->output_scanline * 
+      cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE * NUM_COMPONENT];
+  }
+  else
+#endif
   (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,
 				     (JDIMENSION) upsample->next_row_out,
 				     output_buf + *out_row_ctr,
diff --git a/jocldec.c b/jocldec.c
new file mode 100644
index 0000000..2dd94e3
--- /dev/null
+++ b/jocldec.c
@@ -0,0 +1,2131 @@
+/*
+ * jocldec.c
+ *
+ * Copyright (C) 2012-2013, MulticoreWare Inc.
+ * In July 2013, Written by Peixuan Zhang <zhangpeixuan.cn@gmail.com>
+ * The OpenCL kernel code is written by
+ *   Chunli  Zhang <chunli@multicorewareinc.com> and
+ *   Peixuan Zhang <peixuan@multicorewareinc.com>
+ * Based on the OpenCL extension for IJG JPEG library,
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file contains the decoding JPEG code with OpenCL.
+ */
+
+#include "jinclude.h"
+#include "jpeglib.h"
+#include "CL/opencl.h"
+#include "joclinit.h"
+#include "jocldec.h"
+#include "jocldec_kernels.h"
+
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+cl_mem   jocl_global_data_mem_input   = NULL;
+cl_mem   jocl_global_data_mem_output  = NULL;
+cl_mem   jocl_global_data_mem_qutable = NULL;
+cl_mem   jocl_global_data_mem_inter   = NULL;
+JCOEFPTR jocl_global_data_ptr_input   = NULL;
+JSAMPROW jocl_global_data_ptr_output  = NULL;
+float*   jocl_global_data_ptr_qutable = NULL;
+
+static JOCL_CL_RUNDATA* jocldec_cl_rundata = NULL;
+
+cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
+{
+  cl_int  err_code;
+  cl_uint data_m = 6;
+  cl_uint blocksWidth  = 64;
+  int     offset_input = 0;
+  size_t  global_ws[1], local_ws[1];
+
+  static  const char **jocldec_cl_source;
+  char    **jocldec_cl_source_inter;
+  int     i;
+  jocldec_cl_source_inter = (char**) malloc(7 * sizeof(char*));
+  for(i=0; i<7; ++i) {
+    jocldec_cl_source_inter[i] = (char*) malloc(60000 * sizeof(char));
+  }
+  strcpy(jocldec_cl_source_inter[0], jocldec_cl_source1);
+  strcpy(jocldec_cl_source_inter[1], jocldec_cl_source2);
+  strcpy(jocldec_cl_source_inter[2], jocldec_cl_source3);
+  strcpy(jocldec_cl_source_inter[3], jocldec_cl_source4);
+  strcpy(jocldec_cl_source_inter[4], jocldec_cl_source5);
+  strcpy(jocldec_cl_source_inter[5], jocldec_cl_source6);
+  strcpy(jocldec_cl_source_inter[6], jocldec_cl_source7);
+  jocldec_cl_source = jocldec_cl_source_inter;
+
+  global_ws[0] = 256;
+  local_ws[0] = 64;
+
+  if (!jocldec_cl_rundata)  { 
+    const char* kernel_names[] = {"IDCT_FAST_SHORT",
+                                  "IDCT_SLOW_INT",
+                                  "IDCT_FAST_FLOAT",
+
+                                  "UPSAMPLE_H1V1_RGB",
+                                  "UPSAMPLE_H1V2_RGB",
+                                  "UPSAMPLE_H2V1_RGB",
+                                  "UPSAMPLE_H2V2_RGB",
+
+                                  "UPSAMPLE_H2V1_FANCY_RGB",
+                                  "UPSAMPLE_H2V2_FANCY_RGB",
+
+                                  "UPSAMPLE_H1V1_RGBA",
+                                  "UPSAMPLE_H1V2_RGBA",
+                                  "UPSAMPLE_H2V1_RGBA",
+                                  "UPSAMPLE_H2V2_RGBA",
+
+                                  "UPSAMPLE_H2V1_FANCY_RGBA",
+                                  "UPSAMPLE_H2V2_FANCY_RGBA",
+
+                                  "UPSAMPLE_H1V1_BGR",
+                                  "UPSAMPLE_H1V2_BGR",
+                                  "UPSAMPLE_H2V1_BGR",
+                                  "UPSAMPLE_H2V2_BGR",
+
+                                  "UPSAMPLE_H2V1_FANCY_BGR",
+                                  "UPSAMPLE_H2V2_FANCY_BGR",
+                                   NULL};
+    jocldec_cl_rundata = jocl_cl_compile_and_build(jocldec_cl_source, kernel_names);
+    /* IDCT FAST SHORT */
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_input),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
+                                                 2,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_qutable),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
+                                                 3,
+                                                 4096*sizeof(int),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
+                                                 4,
+                                                 sizeof(int),
+                                                 &data_m),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[0],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+    /* IDCT SLOW INT */
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_input),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
+                                                 2,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_qutable),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
+                                                 3,
+                                                 4096*sizeof(int),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
+                                                 4,
+                                                 sizeof(int),
+                                                 &data_m),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[1],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+    /* IDCT FAST FLOAT */
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_input),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
+                                                 2,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_qutable),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
+                                                 3,
+                                                 4096*sizeof(float),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
+                                                 4,
+                                                 sizeof(float),
+                                                 &data_m),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[2],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+    /* H1V1 RGB */
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
+                                                 2,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
+                                                 3,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+    
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[3],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),);
+    /* H1V2 RGB */
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
+                                                 2,
+                                                 384*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
+                                                 3,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
+                                                 4,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);  
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
+                                                 5,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[4],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+   /* H2V1 RGB */
+   CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5], 
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
+                                                 2,
+                                                 384*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
+                                                 3,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
+                                                 4,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE); 
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
+                                                 5,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
+                                                 6,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
+                                                 7,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[5],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+    /* H2V2 RGB */
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                 2,
+                                                 768*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                 3,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                 4, 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE); 
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                 5, 256*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                 6,
+                                                 256*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                 7,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[6],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+    /* H2V1 RGB FANCY */
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7], 
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
+                                                 2,
+                                                 384*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
+                                                 3,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
+                                                 4,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE); 
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
+                                                 5,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
+                                                 6,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
+                                                 7,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[7],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+    /* H2V2 RGB FANCY */
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                 2,
+                                                 768*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                 3,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                 4, 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE); 
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                 5, 256*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                 6,
+                                                 256*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                 7,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[8],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+    /*H1V1_RGBA*/
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
+                                                 2,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
+                                                 3,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[9],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),);
+
+    /*H1V2_RGBA*/
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
+                                                 2,
+                                                 384*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
+                                                 3,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
+                                                 4,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);  
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
+                                                 5,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[10],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+    /*H2V1_RGBA*/
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11], 
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                 2,
+                                                 384*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                 3,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                 4,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE); 
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                 5,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                 6,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                 7,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+    
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[11],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+
+    /*H2V2_RGBA*/
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                 2,
+                                                 768*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                 3,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                 4, 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE); 
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                 5, 256*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                 6,
+                                                 256*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                 7,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[12],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+    /*H2V1_RGBA_FANCY*/
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13], 
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
+                                                 2,
+                                                 384*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
+                                                 3,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
+                                                 4,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE); 
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
+                                                 5,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
+                                                 6,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
+                                                 7,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[13],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+    /*H2V2_RGBA_FANCY */
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                 2,
+                                                 768*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                 3,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                 4, 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE); 
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                 5, 256*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                 6,
+                                                 256*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                 7,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[14],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+    /* H1V1 BGR */
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
+                                                 2,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
+                                                 3,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[15],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),);
+    /* H1V2 BGR */
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
+                                                 2,
+                                                 384*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
+                                                 3,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
+                                                 4,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);  
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
+                                                 5,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[16],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+    /* H2V1 BGR */
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17], 
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
+                                                 2,
+                                                 384*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
+                                                 3,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
+                                                 4,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE); 
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
+                                                 5,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
+                                                 6,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
+                                                 7,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[17],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+    /* H2V2 BGR */
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                 2,
+                                                 768*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                 3,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                 4, 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE); 
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                 5, 256*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                 6,
+                                                 256*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                 7,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[18],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+    /* H2V1 BGR FANCY  */
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19], 
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
+                                                 2,
+                                                 384*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
+                                                 3,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
+                                                 4,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE); 
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
+                                                 5,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
+                                                 6,
+                                                 128*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
+                                                 7,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[19],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+    /* H2V2 BGR FANCY */
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_output),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                 2,
+                                                 768*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                 3,
+                                                 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                 4, 64*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE); 
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                 5, 256*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                 6,
+                                                 256*sizeof(unsigned char),
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                 7,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_rundata->kernel[20],
+                                                 1,
+                                                 0,
+                                                 global_ws,
+                                                 local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clFinish(jocl_cl_get_command_queue()),CL_FALSE);
+  }
+  return CL_TRUE;
+}
+
+cl_bool jocldec_run_kernels_full_image(
+                            j_decompress_ptr cinfo,
+                            int data_m,
+                            int mcu_num,
+                            unsigned int blocksWidth,
+                            unsigned int offset_mcu,
+                            int total_mcu_num,
+                            int decodeMCU)
+{
+  cl_int err_code;
+  size_t global_ws,local_ws;
+  int    mcu_out,mcu_in;
+  int    data_m_inter = data_m;
+  int    data_index = 0,sign = 0;
+  int    size_map;
+  unsigned int offset_output,offset_input;
+  cl_kernel jocldec_cl_kernel_use;
+
+  if (data_m==5) data_m_inter = 4;
+  switch(data_m) {
+    case 3: mcu_out   = 192;
+            mcu_in    = 192;
+            global_ws = (mcu_num * mcu_in /8+255)/256*256;
+            break;
+    case 5: mcu_out   = 384;
+            mcu_in    = 256;
+            global_ws = (mcu_num * mcu_in /8+255)/256*256;
+            break;
+    case 4: mcu_out   = 384;
+            mcu_in    = 256;
+            global_ws = (mcu_in / 8 + mcu_num * mcu_in / 8 +255)/256*256;
+            break;
+    case 6: mcu_out   = 768;
+            mcu_in    = 384;
+            global_ws = (mcu_num * mcu_in /8+255)/256*256;
+            break;
+  }
+  if(CL_TRUE == jocl_cl_is_nvidia_opencl()) {
+    CL_SAFE_CALL0(jocl_global_data_mem_input = jocl_clCreateBuffer(jocl_cl_get_context(),
+      CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR,
+      MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4, jocl_global_data_ptr_input, &err_code),return CL_FALSE);
+    CL_SAFE_CALL0(jocl_global_data_mem_qutable = jocl_clCreateBuffer(jocl_cl_get_context(),
+      CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
+      4096, jocl_global_data_ptr_qutable, &err_code),return CL_FALSE);
+}
+#ifndef JOCL_CL_OS_WIN32
+  CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
+    jocl_cl_get_command_queue(), jocl_global_data_mem_input,
+    jocl_global_data_ptr_input, 0, NULL, NULL),return CL_FALSE);
+#endif
+  offset_input = offset_mcu * mcu_in/8;
+    switch (cinfo->dct_method){
+      case JDCT_IFAST:
+        local_ws = 256;
+        jocldec_cl_kernel_use = jocldec_cl_rundata->kernel[0];
+        break;
+      case JDCT_ISLOW:
+        local_ws = 128;
+        jocldec_cl_kernel_use = jocldec_cl_rundata->kernel[1];
+        break;
+      case JDCT_FLOAT:
+        local_ws = 128;
+        jocldec_cl_kernel_use = jocldec_cl_rundata->kernel[2];
+        break;
+  }
+  if (0 == offset_mcu) {
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 0,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_input),
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 1,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_inter),
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 2,
+                                                 sizeof(cl_mem),
+                                                 &jocl_global_data_mem_qutable),
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 3,
+                                                 1024*sizeof(int),
+                                                 NULL),
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 4,
+                                                 sizeof(int),
+                                                 &data_m_inter),
+                                                 return CL_FALSE);
+  }
+  CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_kernel_use,
+                                                 1,
+                                                 &offset_input,
+                                                 &global_ws,
+                                                 &local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 return CL_FALSE);
+
+  switch(cinfo->out_color_space) {
+    case JCS_RGB:{
+      if (data_m == 3) {
+      /*1v1 start*/
+        global_ws     = mcu_num * 64;
+        offset_output = offset_mcu * 64;
+        local_ws      = 64;
+        if (0 == offset_mcu) {
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
+                                                       0,
+                                                       sizeof(cl_mem),
+                                                       &jocl_global_data_mem_inter),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
+                                                       1,
+                                                       sizeof(cl_mem),
+                                                       &jocl_global_data_mem_output),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
+                                                       2,
+                                                       256*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
+                                                       3,
+                                                       sizeof(unsigned int),
+                                                       &blocksWidth),
+                                                       return CL_FALSE);
+        }
+        CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                       jocldec_cl_rundata->kernel[3],
+                                                       1,
+                                                       &offset_output,
+                                                       &global_ws,
+                                                       &local_ws,
+                                                       0,
+                                                       NULL,
+                                                       NULL),
+                                                       return CL_FALSE);
+        /*1v1 end*/
+      }  /* if (data_m == 3) */
+      else if (data_m == 5) {
+        /*1v2 start*/
+        offset_output = offset_mcu * 128;
+        global_ws     = mcu_num * 128;
+        local_ws      = 128;
+        if (0 == offset_mcu) {
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
+                                                       0,
+                                                       sizeof(cl_mem),
+                                                       &jocl_global_data_mem_inter),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
+                                                       1,
+                                                       sizeof(cl_mem),
+                                                       &jocl_global_data_mem_output),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
+                                                       2,
+                                                       384*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
+                                                       3,
+                                                       128*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
+                                                       4,
+                                                       128*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
+                                                       5,
+                                                       sizeof(unsigned int),
+                                                       &blocksWidth),
+                                                       return CL_FALSE);
+        }
+        CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                       jocldec_cl_rundata->kernel[4],
+                                                       1,
+                                                       &offset_output,
+                                                       &global_ws,
+                                                       &local_ws,
+                                                       0,
+                                                       NULL,
+                                                       NULL),
+                                                       return CL_FALSE);
+        /*1v2 end*/
+      } /* else if (data_m == 5) */
+      else if (data_m == 4) {
+        /*2v1 start fancy*/
+        offset_output = offset_mcu * 64;
+        local_ws      = 64; 
+        if(1) {
+          global_ws = (mcu_num + 1) * 64;
+          if (0 == offset_mcu) {
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
+                                                         0,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_inter),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
+                                                         1,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_output),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
+                                                         2,
+                                                         384*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
+                                                         3,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
+                                                         4,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
+                                                         5,
+                                                         128*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
+                                                         6,
+                                                         128*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
+                                                         7,
+                                                         sizeof(unsigned int),
+                                                         &blocksWidth),
+                                                         return CL_FALSE);
+          }
+          CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                         jocldec_cl_rundata->kernel[7],
+                                                         1,
+                                                         &offset_output,
+                                                         &global_ws,
+                                                         &local_ws,
+                                                         0,
+                                                         NULL,
+                                                         NULL),
+                                                         return CL_FALSE);
+          /*2v1 end fancy*/
+        }
+        else {
+          global_ws = mcu_num * 64;
+          /*no_fancy*/
+          if (0 == offset_mcu) {
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
+                                                         0,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_inter),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
+                                                         1,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_output),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
+                                                         2,
+                                                         384*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
+                                                         3,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
+                                                         4,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
+                                                         5,
+                                                         128*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
+                                                         6,
+                                                         128*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
+                                                         7,
+                                                         sizeof(unsigned int),
+                                                         &blocksWidth),
+                                                         return CL_FALSE);
+          }
+          CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                         jocldec_cl_rundata->kernel[5],
+                                                         1,
+                                                         &offset_output,
+                                                         &global_ws,
+                                                         &local_ws,
+                                                         0,
+                                                         NULL,
+                                                         NULL),
+                                                         return CL_FALSE);
+           /*2v1 nofancy end*/
+        }
+      } /* else if (data_m == 4) */
+      else if (data_m == 6) {
+        offset_output = offset_mcu * 128;
+        global_ws     = mcu_num * 128;
+        local_ws      = 128; 
+        if(1) {
+          if (0 == offset_mcu) {
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                         0,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_inter),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                         1,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_output),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                         2,
+                                                         768*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                         3,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                         4,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                         5,
+                                                         256*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                         6,
+                                                         256*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                         7,
+                                                         sizeof(unsigned int),
+                                                         &blocksWidth),
+                                                         return CL_FALSE);
+          }
+          CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                         jocldec_cl_rundata->kernel[6],
+                                                         1,
+                                                         &offset_output,
+                                                         &global_ws,
+                                                         &local_ws,
+                                                         0,
+                                                         NULL,
+                                                         NULL),
+                                                         return CL_FALSE);
+        }
+        else {
+          if (0 == offset_mcu) {
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                         0,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_inter),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                         1,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_output),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                         2,
+                                                         768*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                         3,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                         4,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                         5,
+                                                         256*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                         6,
+                                                         256*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                         7,
+                                                         sizeof(unsigned int),
+                                                         &blocksWidth),
+                                                         return CL_FALSE);
+          }
+          CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                         jocldec_cl_rundata->kernel[8],
+                                                         1,
+                                                         &offset_output,
+                                                         &global_ws,
+                                                         &local_ws,
+                                                         0,
+                                                         NULL,
+                                                         NULL),
+                                                         return CL_FALSE);
+        }
+      }
+      break;
+    }
+    case JCS_EXT_RGBA:{
+      if (data_m == 3) {
+        /*h1v1 rgba start*/
+        global_ws     = mcu_num * 64;
+        offset_output = offset_mcu * 64;
+        local_ws      = 64;
+        if (0 == offset_mcu) {
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
+                                                       0,
+                                                       sizeof(cl_mem),
+                                                       &jocl_global_data_mem_inter),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
+                                                       1,
+                                                       sizeof(cl_mem),
+                                                       &jocl_global_data_mem_output),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
+                                                       2,
+                                                       256*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
+                                                       3,
+                                                       sizeof(unsigned int),
+                                                       &blocksWidth),
+                                                       return CL_FALSE);
+        }
+        CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                       jocldec_cl_rundata->kernel[9],
+                                                       1,
+                                                       &offset_output,
+                                                       &global_ws,
+                                                       &local_ws,
+                                                       0,
+                                                       NULL,
+                                                       NULL),
+                                                       return CL_FALSE);
+        /*1v1 end*/
+      }  /* if (data_m == 3) */
+      else if (data_m == 5) {
+        /*h1v2 rgba start*/
+        offset_output = offset_mcu * 128;
+        global_ws     = mcu_num * 128;
+        local_ws      = 128;
+        if (0 == offset_mcu) {
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
+                                                       0,
+                                                       sizeof(cl_mem),
+                                                       &jocl_global_data_mem_inter),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
+                                                       1,
+                                                       sizeof(cl_mem),
+                                                       &jocl_global_data_mem_output),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
+                                                       2,
+                                                       512*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
+                                                       3,
+                                                       128*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
+                                                       4,
+                                                       128*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
+                                                       5,
+                                                       sizeof(unsigned int),
+                                                       &blocksWidth),
+                                                       return CL_FALSE);
+        }
+        CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                       jocldec_cl_rundata->kernel[10],
+                                                       1,
+                                                       &offset_output,
+                                                       &global_ws,
+                                                       &local_ws,
+                                                       0,
+                                                       NULL,
+                                                       NULL),
+                                                       return CL_FALSE);
+        /*h1v2 end*/
+      } /* else if (data_m == 5) */
+      else if (data_m == 4) {
+        /*h2v1 rgba start fancy*/
+        offset_output = offset_mcu * 64;
+        global_ws     = mcu_num * 64;
+        local_ws      = 64; 
+        if(1) {
+          if (0 == offset_mcu) {
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
+                                                         0,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_inter),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
+                                                         1,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_output),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
+                                                         2,
+                                                         512*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
+                                                         3,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
+                                                         4,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
+                                                         5,
+                                                         128*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
+                                                         6,
+                                                         128*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
+                                                         7,
+                                                         sizeof(unsigned int),
+                                                         &blocksWidth),
+                                                         return CL_FALSE);
+          }
+          CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                         jocldec_cl_rundata->kernel[13],
+                                                         1,
+                                                         &offset_output,
+                                                         &global_ws,
+                                                         &local_ws,
+                                                         0,
+                                                         NULL,
+                                                         NULL),
+                                                         return CL_FALSE);
+          /*2v1 end fancy*/
+        }
+        else {
+          /*h2v1 rgba no_fancy*/
+          if (0 == offset_mcu) {
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                         0,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_inter),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                         1,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_output),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                         2,
+                                                         512*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                         3,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                         4,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                         5,
+                                                         128*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                         6,
+                                                         128*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                         7,
+                                                         sizeof(unsigned int),
+                                                         &blocksWidth),
+                                                         return CL_FALSE);
+          }
+          CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                         jocldec_cl_rundata->kernel[11],
+                                                         1,
+                                                         &offset_output,
+                                                         &global_ws,
+                                                         &local_ws,
+                                                         0,
+                                                         NULL,
+                                                         NULL),
+                                                         return CL_FALSE);
+           /*2v1 nofancy end*/
+        }
+      } /* else if (data_m == 4) */
+      else if (data_m == 6) {
+        offset_output = offset_mcu * 128;
+        global_ws     = mcu_num * 128;
+        local_ws      = 128; 
+        /*h2v2 rgba*/
+        if(1){
+         if (0 == offset_mcu) {
+           CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                       0,
+                                                       sizeof(cl_mem),
+                                                       &jocl_global_data_mem_inter),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                       1,
+                                                       sizeof(cl_mem),
+                                                       &jocl_global_data_mem_output),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                       2,
+                                                       1024*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                       3,
+                                                       64*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                       4,
+                                                       64*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                       5,
+                                                       256*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                       6,
+                                                       256*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                       7,
+                                                       sizeof(unsigned int),
+                                                       &blocksWidth),
+                                                       return CL_FALSE);
+        }
+        CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                       jocldec_cl_rundata->kernel[12],
+                                                       1,
+                                                       &offset_output,
+                                                       &global_ws,
+                                                       &local_ws,
+                                                       0,
+                                                       NULL,
+                                                       NULL),
+                                                       return CL_FALSE);
+        }
+        else{
+          if (0 == offset_mcu) {
+            /* h2v2 rgba fancy */
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                         0,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_inter),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                         1,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_output),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                         2,
+                                                         1024*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                         3,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                         4,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                         5,
+                                                         256*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                         6,
+                                                         256*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                         7,
+                                                         sizeof(unsigned int),
+                                                         &blocksWidth),
+                                                         return CL_FALSE);
+          }  
+          CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                         jocldec_cl_rundata->kernel[14],
+                                                         1,
+                                                         &offset_output,
+                                                         &global_ws,
+                                                         &local_ws,
+                                                         0,
+                                                         NULL,
+                                                         NULL),
+                                                         return CL_FALSE);
+
+        }
+      }
+      break;
+    }
+    case JCS_EXT_BGR:{
+      if (data_m == 3) {
+        /*1v1 start*/
+        global_ws     = mcu_num * 64;
+        offset_output = offset_mcu * 64;
+        local_ws      = 64;
+        if (0 == offset_mcu) {
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
+                                                       0,
+                                                       sizeof(cl_mem),
+                                                       &jocl_global_data_mem_inter),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
+                                                       1,
+                                                       sizeof(cl_mem),
+                                                       &jocl_global_data_mem_output),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
+                                                       2,
+                                                       256*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
+                                                       3,
+                                                       sizeof(unsigned int),
+                                                       &blocksWidth),
+                                                       return CL_FALSE);
+        }
+        CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                       jocldec_cl_rundata->kernel[15],
+                                                       1,
+                                                       &offset_output,
+                                                       &global_ws,
+                                                       &local_ws,
+                                                       0,
+                                                       NULL,
+                                                       NULL),
+                                                       return CL_FALSE);
+        /*1v1 end*/
+      }  /* if (data_m == 3) */
+      else if (data_m == 5) {
+        /*1v2 start*/
+        offset_output = offset_mcu * 128;
+        global_ws     = mcu_num * 128;
+        local_ws      = 128;
+        if (0 == offset_mcu) {
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
+                                                       0,
+                                                       sizeof(cl_mem),
+                                                       &jocl_global_data_mem_inter),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
+                                                       1,
+                                                       sizeof(cl_mem),
+                                                       &jocl_global_data_mem_output),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
+                                                       2,
+                                                       384*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
+                                                       3,
+                                                       128*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
+                                                       4,
+                                                       128*sizeof(unsigned char),
+                                                       NULL),
+                                                       return CL_FALSE);
+          CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
+                                                       5,
+                                                       sizeof(unsigned int),
+                                                       &blocksWidth),
+                                                       return CL_FALSE);
+        }
+        CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                       jocldec_cl_rundata->kernel[16],
+                                                       1,
+                                                       &offset_output,
+                                                       &global_ws,
+                                                       &local_ws,
+                                                       0,
+                                                       NULL,
+                                                       NULL),
+                                                       return CL_FALSE);
+        /*1v2 end*/
+      } /* else if (data_m == 5) */
+      else if (data_m == 4) {
+        /*2v1 start fancy*/
+        offset_output = offset_mcu * 64;
+        local_ws      = 64; 
+        if(1) {
+          global_ws = (mcu_num + 1) * 64;
+          if (0 == offset_mcu) {
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
+                                                         0,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_inter),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
+                                                         1,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_output),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
+                                                         2,
+                                                         384*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
+                                                         3,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
+                                                         4,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
+                                                         5,
+                                                         128*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
+                                                         6,
+                                                         128*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
+                                                         7,
+                                                         sizeof(unsigned int),
+                                                         &blocksWidth),
+                                                         return CL_FALSE);
+          }
+          CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                         jocldec_cl_rundata->kernel[19],
+                                                         1,
+                                                         &offset_output,
+                                                         &global_ws,
+                                                         &local_ws,
+                                                         0,
+                                                         NULL,
+                                                         NULL),
+                                                         return CL_FALSE);
+          /*2v1 end fancy*/
+        }
+        else {
+          global_ws = mcu_num * 64;
+          /*no_fancy*/
+          if (0 == offset_mcu) {
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
+                                                         0,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_inter),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
+                                                         1,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_output),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
+                                                         2,
+                                                         384*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
+                                                         3,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
+                                                         4,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
+                                                         5,
+                                                         128*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
+                                                         6,
+                                                         128*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
+                                                         7,
+                                                         sizeof(unsigned int),
+                                                         &blocksWidth),
+                                                         return CL_FALSE);
+          }  
+          CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                         jocldec_cl_rundata->kernel[17],
+                                                         1,
+                                                         &offset_output,
+                                                         &global_ws,
+                                                         &local_ws,
+                                                         0,
+                                                         NULL,
+                                                         NULL),
+                                                         return CL_FALSE);
+           /*2v1 nofancy end*/
+        }
+      } /* else if (data_m == 4) */
+      else if (data_m == 6) {
+        offset_output = offset_mcu * 128;
+        global_ws     = mcu_num * 128;
+        local_ws      = 128; 
+        if(1) {
+          if (0 == offset_mcu) {
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                         0,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_inter),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                         1,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_output),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                         2,
+                                                         768*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                         3,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                         4,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                         5,
+                                                         256*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                         6,
+                                                         256*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                         7,
+                                                         sizeof(unsigned int),
+                                                         &blocksWidth),
+                                                         return CL_FALSE);
+          }
+          CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                         jocldec_cl_rundata->kernel[18],
+                                                         1,
+                                                         &offset_output,
+                                                         &global_ws,
+                                                         &local_ws,
+                                                         0,
+                                                         NULL,
+                                                         NULL),
+                                                         return CL_FALSE);
+        }
+        else {
+          if (0 == offset_mcu) {
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                         0,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_inter),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                         1,
+                                                         sizeof(cl_mem),
+                                                         &jocl_global_data_mem_output),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                         2,
+                                                         768*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                         3,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                         4,
+                                                         64*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                         5,
+                                                         256*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                         6,
+                                                         256*sizeof(unsigned char),
+                                                         NULL),
+                                                         return CL_FALSE);
+            CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                         7,
+                                                         sizeof(unsigned int),
+                                                         &blocksWidth),
+                                                         return CL_FALSE);
+          }  
+          CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                         jocldec_cl_rundata->kernel[20],
+                                                         1,
+                                                         &offset_output,
+                                                         &global_ws,
+                                                         &local_ws,
+                                                         0,
+                                                         NULL,
+                                                         NULL),
+                                                         return CL_FALSE);
+        }
+      }
+      break;
+    }
+  }
+  size_map = cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE *
+    cinfo->image_height * NUM_COMPONENT;
+
+  if (decodeMCU != total_mcu_num) {
+    CL_SAFE_CALL0(err_code = jocl_clFlush(jocl_cl_get_command_queue()),return CL_FALSE);
+  }
+  else {
+    CL_SAFE_CALL0(err_code = jocl_clFinish(jocl_cl_get_command_queue()),return CL_FALSE);
+    CL_SAFE_CALL0(jocl_global_data_ptr_output = (JSAMPROW)jocl_clEnqueueMapBuffer(
+      jocl_cl_get_command_queue(), jocl_global_data_mem_output, CL_TRUE,
+      CL_MAP_READ, 0, size_map, 0, NULL, NULL, &err_code),return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
+      jocl_cl_get_command_queue(), jocl_global_data_mem_output,
+      jocl_global_data_ptr_output, 0, NULL, NULL),return CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clFinish(jocl_cl_get_command_queue()),return CL_FALSE);
+  }
+  return CL_TRUE;
+}
+#endif
diff --git a/jocldec.h b/jocldec.h
new file mode 100644
index 0000000..4994801
--- /dev/null
+++ b/jocldec.h
@@ -0,0 +1,39 @@
+/*
+ * jocldec.h
+ *
+ * Copyright (C) 2012-2013, MulticoreWare Inc.
+ * In July 2013, Written by Peixuan Zhang <zhangpeixuan.cn@gmail.com>
+ * The OpenCL kernel code is written by
+ *   Chunli  Zhang <chunli@multicorewareinc.com> and
+ *   Peixuan Zhang <peixuan@multicorewareinc.com>
+ * Based on the OpenCL extension for IJG JPEG library,
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file contains the decoding JPEG code with OpenCL.
+ */
+
+#ifndef __JPEG_OPENCL_DECODING_H__
+#define __JPEG_OPENCL_DECODING_H__
+
+/* Global OpenCL buffer and mapping variables. */
+extern cl_mem   jocl_global_data_mem_input;
+extern cl_mem   jocl_global_data_mem_output;
+extern cl_mem   jocl_global_data_mem_qutable;
+extern cl_mem   jocl_global_data_mem_inter;
+extern float*   jocl_global_data_ptr_qutable;
+extern JCOEFPTR jocl_global_data_ptr_input;
+extern JSAMPROW jocl_global_data_ptr_output;
+
+/* Compile OpenCL kernels. */
+cl_bool jocldec_build_kernels(j_decompress_ptr cinfo);
+
+/* Run decoding kernels for full image. */
+cl_bool jocldec_run_kernels_full_image(
+  j_decompress_ptr cinfo,
+  int block_in_mcu,               /* Number of 8x8 blocks in one MCU */
+  int num_of_mcu,                 /* Number of MCUs in one whole image */
+  unsigned int mcu_in_width,      /* Number of MCUs in image width */
+  unsigned int offset_input,      /* The offset of buffer used to calculate the global ID */
+  int total_mcu_num,              /* The total MCU-number of an image */
+  int decodeMCU);                 /* The number of MCUs will be decoded */
+#endif
diff --git a/jocldec_kernels.h b/jocldec_kernels.h
new file mode 100644
index 0000000..50fc7fa
--- /dev/null
+++ b/jocldec_kernels.h
@@ -0,0 +1,2704 @@
+/*
+ * jocldec_kernels.h
+ *
+ * Copyright (C) 2012-2013, MulticoreWare Inc.
+ * In July 2013, Written by Peixuan Zhang <zhangpeixuan.cn@gmail.com>
+ * The OpenCL kernel code is written by
+ *   Chunli  Zhang <chunli@multicorewareinc.com> and
+ *   Peixuan Zhang <peixuan@multicorewareinc.com>
+ * Based on the OpenCL extension for IJG JPEG library,
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file contains the kernels of OpenCL decoding.
+ */
+
+#ifndef __KERNEL_OPENCL_DEC_H__
+#define __KERNEL_OPENCL_DEC_H__
+
+static const char     * jocldec_cl_source1  =
+"#define DESCALE(x,n) ((x) >> n)                                          \n"
+"__kernel void IDCT_FAST_SHORT     (__global   short8 *src,               \n"
+"                                   __global   uchar8 *dst,               \n"
+"                                   __constant short8 *quant_tables,      \n"
+"                                   __local    short  *inter,             \n"
+"                                   const      uint    block_offset)      \n"
+"{                                                                        \n"
+"  uint   globalIdx = get_global_id(0);                                   \n"
+"  uint   localIdx  = get_local_id (0);                                   \n"
+"  uint   unitIdx   = localIdx  & 0x07; // MOD 8                          \n"
+"  uint   blockIdx  = unitIdx + ((localIdx >> 3) << 6);                   \n"
+"  uint   quantbIdx =                                                     \n"
+"    ((block_offset - 3) < ((globalIdx >>3) % block_offset)) << 3;        \n"
+"  short8 dataShort;                                                      \n"
+"  uchar8 dataUchar;                                                      \n"
+"  short  tmp0 , tmp1 , tmp2 , tmp3 , tmp4, tmp5, tmp6, tmp7;             \n"
+"  short  tmp10, tmp11, tmp12, tmp13, z5  , z10 , z11 , z12 , z13;        \n"
+"                                                                         \n"
+"  dataShort = src[globalIdx] * quant_tables[quantbIdx + unitIdx];        \n"
+"                                                                         \n"
+"  if (dataShort.s1 == 0 && dataShort.s2 == 0 && dataShort.s3 == 0 &&     \n"
+"      dataShort.s4 == 0 && dataShort.s5 == 0 && dataShort.s6 == 0 &&     \n"
+"      dataShort.s7 == 0)                                                 \n"
+"    inter[blockIdx +  0] = inter[blockIdx +  8] = inter[blockIdx + 16] = \n"
+"    inter[blockIdx + 24] = inter[blockIdx + 32] = inter[blockIdx + 40] = \n"
+"    inter[blockIdx + 48] = inter[blockIdx + 56] = dataShort.s0;          \n"
+"  else                                                                   \n"
+"  {                                                                      \n"
+"    tmp10 = dataShort.s0  + dataShort.s4;                                \n"
+"    tmp11 = dataShort.s0  - dataShort.s4;                                \n"
+"    tmp13 = dataShort.s2  + dataShort.s6;                                \n"
+"    tmp12 = DESCALE((dataShort.s2 - dataShort.s6) * 362, 8) - tmp13;     \n"
+"    tmp0  = tmp10 + tmp13;                                               \n"
+"    tmp3  = tmp10 - tmp13;                                               \n"
+"    tmp1  = tmp11 + tmp12;                                               \n"
+"    tmp2  = tmp11 - tmp12;                                               \n"
+"    z13   = dataShort.s5  + dataShort.s3;                                \n"
+"    z10   = dataShort.s5  - dataShort.s3;                                \n"
+"    z11   = dataShort.s1  + dataShort.s7;                                \n"
+"    z12   = dataShort.s1  - dataShort.s7;                                \n"
+"    tmp7  = z11   + z13;                                                 \n"
+"    tmp11 = DESCALE((z11 - z13) * 362, 8);                               \n"
+"    z5    = DESCALE((z10 + z12) * 473, 8);                               \n"
+"    tmp10 = DESCALE(z12 * 277, 8) - z5;                                  \n"
+"    tmp12 = DESCALE(-z10 * 669, 8)+ z5;                                  \n"
+"    tmp6  = tmp12 - tmp7;                                                \n"
+"    tmp5  = tmp11 - tmp6;                                                \n"
+"    tmp4  = tmp10 + tmp5;                                                \n"
+"                                                                         \n"
+"    inter[blockIdx +  0] = tmp0 + tmp7;                                  \n"
+"    inter[blockIdx +  8] = tmp1 + tmp6;                                  \n"
+"    inter[blockIdx + 16] = tmp2 + tmp5;                                  \n"
+"    inter[blockIdx + 24] = tmp3 - tmp4;                                  \n"
+"    inter[blockIdx + 32] = tmp3 + tmp4;                                  \n"
+"    inter[blockIdx + 40] = tmp2 - tmp5;                                  \n"
+"    inter[blockIdx + 48] = tmp1 - tmp6;                                  \n"
+"    inter[blockIdx + 56] = tmp0 - tmp7;                                  \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  dataShort = vload8(localIdx, inter);                                   \n"
+"                                                                         \n"
+"  if (dataShort.s1 == 0 && dataShort.s2 == 0 && dataShort.s3 == 0 &&     \n"
+"      dataShort.s4 == 0 && dataShort.s5 == 0 && dataShort.s6 == 0 &&     \n"
+"      dataShort.s7 == 0)                                                 \n"
+"    dataUchar = convert_uchar_sat((dataShort.s0 >> 5) + 128);            \n"
+"  else                                                                   \n"
+"  {                                                                      \n"
+"    tmp10 = dataShort.s0 + dataShort.s4;                                 \n"
+"    tmp11 = dataShort.s0 - dataShort.s4;                                 \n"
+"    tmp13 = dataShort.s2 + dataShort.s6;                                 \n"
+"    tmp12 = DESCALE((dataShort.s2 - dataShort.s6) * 362, 8) - tmp13;     \n"
+"    z13   = dataShort.s5 + dataShort.s3;                                 \n"
+"    z10   = dataShort.s5 - dataShort.s3;                                 \n"
+"    z11   = dataShort.s1 + dataShort.s7;                                 \n"
+"    z12   = dataShort.s1 - dataShort.s7;                                 \n"
+"    tmp0  = tmp10 + tmp13;                                               \n"
+"    tmp3  = tmp10 - tmp13;                                               \n"
+"    tmp1  = tmp11 + tmp12;                                               \n"
+"    tmp2  = tmp11 - tmp12;                                               \n"
+"    tmp7  = z11 + z13;                                                   \n"
+"    tmp11 = DESCALE((z11 - z13) * 362, 8);                               \n"
+"    z5    = DESCALE((z10 + z12) * 473, 8);                               \n"
+"    tmp10 = DESCALE(z12 * 277, 8) - z5;                                  \n"
+"    tmp12 = DESCALE(-z10 * 669, 8) + z5;                                 \n"
+"    tmp6  = tmp12 - tmp7;                                                \n"
+"    tmp5  = tmp11 - tmp6;                                                \n"
+"    tmp4  = tmp10 + tmp5;                                                \n"
+"                                                                         \n"
+"    dataShort.s0 = (tmp0 + tmp7) >>5;                                    \n"
+"    dataShort.s7 = (tmp0 - tmp7) >>5;                                    \n"
+"    dataShort.s1 = (tmp1 + tmp6) >>5;                                    \n"
+"    dataShort.s6 = (tmp1 - tmp6) >>5;                                    \n"
+"    dataShort.s2 = (tmp2 + tmp5) >>5;                                    \n"
+"    dataShort.s5 = (tmp2 - tmp5) >>5;                                    \n"
+"    dataShort.s4 = (tmp3 + tmp4) >>5;                                    \n"
+"    dataShort.s3 = (tmp3 - tmp4) >>5;                                    \n"
+"    dataShort    = dataShort + (short)128;                               \n"
+"    dataUchar    = convert_uchar8_sat(dataShort);                        \n"
+"  }                                                                      \n"
+"  dst[globalIdx] = dataUchar;                                            \n"
+"}                                                                        \n"
+"__kernel void IDCT_SLOW_INT       (__global   short8 *src,               \n"
+"                                   __global   uchar8 *dst,               \n"
+"                                   __constant int8   *quant_tables,      \n"
+"                                   __local    int    *inter,             \n"
+"                                   const      uint    block_offset)      \n"
+"{                                                                        \n"
+"  uint   globalIdx = get_global_id(0);                                   \n"
+"  uint   localIdx  = get_local_id (0);                                   \n"
+"  uint   unitIdx   = localIdx  & 0x07; // MOD 8                          \n"
+"  uint   blockIdx  = unitIdx + ((localIdx >> 3) << 6);                   \n"
+"  uint   quantbIdx =                                                     \n"
+"    ((block_offset - 3) < ((globalIdx >>3) % block_offset)) << 3;        \n"
+"  int8   dataInt;                                                        \n"
+"  uchar8 dataUchar;                                                      \n"
+"  int    tmp0 , tmp1 , tmp2 , tmp3 ;                                     \n"
+"  int    tmp10, tmp11, tmp12, tmp13;                                     \n"
+"  int    z1, z2, z3, z4, z5;                                             \n"
+"                                                                         \n"
+"  dataInt = convert_int8(src[globalIdx]) *                               \n"
+"    quant_tables[quantbIdx + unitIdx];                                   \n"
+"                                                                         \n"
+"  if (dataInt.s1 == 0 && dataInt.s2 == 0 && dataInt.s3 == 0 &&           \n"
+"      dataInt.s4 == 0 && dataInt.s5 == 0 && dataInt.s6 == 0 &&           \n"
+"      dataInt.s7 == 0)                                                   \n"
+"    inter[blockIdx +  0] = inter[blockIdx +  8] = inter[blockIdx + 16] = \n"
+"    inter[blockIdx + 24] = inter[blockIdx + 32] = inter[blockIdx + 40] = \n"
+"    inter[blockIdx + 48] = inter[blockIdx + 56] = dataInt.s0 * 4;        \n"
+"  else                                                                   \n"
+"  {                                                                      \n"
+"    z1    = (dataInt.s2 + dataInt.s6) * 4433;                            \n"
+"    tmp2  = z1 - dataInt.s6 * 15137;                                     \n"
+"    tmp3  = z1 + dataInt.s2 * 6270;                                      \n"
+"    tmp0  = (dataInt.s0 + dataInt.s4)<<13;                               \n"
+"    tmp1  = (dataInt.s0 - dataInt.s4)<<13;                               \n"
+"    tmp10 = tmp0 + tmp3;                                                 \n"
+"    tmp13 = tmp0 - tmp3;                                                 \n"
+"    tmp11 = tmp1 + tmp2;                                                 \n"
+"    tmp12 = tmp1 - tmp2;                                                 \n"
+"    z1    = dataInt.s7 + dataInt.s1;                                     \n"
+"    z2    = dataInt.s5 + dataInt.s3;                                     \n"
+"    z3    = dataInt.s7 + dataInt.s3;                                     \n"
+"    z4    = dataInt.s5 + dataInt.s1;                                     \n"
+"    z5    = (z3 + z4) * 9633;                                            \n"
+"                                                                         \n"
+"    tmp0  = dataInt.s7 * 2446;                                           \n"
+"    tmp1  = dataInt.s5 * 16819;                                          \n"
+"    tmp2  = dataInt.s3 * 25172;                                          \n"
+"    tmp3  = dataInt.s1 * 12299;                                          \n"
+"                                                                         \n"
+"    z1    = -z1 * 7373;                                                  \n"
+"    z2    = -z2 * 20995;                                                 \n"
+"    z3    = -z3 * 16069 + z5;                                            \n"
+"    z4    = -z4 * 3196  + z5;                                            \n"
+"                                                                         \n"
+"    tmp0 += z1 + z3;                                                     \n"
+"    tmp1 += z2 + z4;                                                     \n"
+"    tmp2 += z2 + z3;                                                     \n"
+"    tmp3 += z1 + z4;                                                     \n"
+"                                                                         \n"
+"    inter[blockIdx +  0] = ((tmp10 + tmp3)+(1<<10))>>11;                 \n"
+"    inter[blockIdx + 56] = ((tmp10 - tmp3)+(1<<10))>>11;                 \n"
+"    inter[blockIdx +  8] = ((tmp11 + tmp2)+(1<<10))>>11;                 \n"
+"    inter[blockIdx + 48] = ((tmp11 - tmp2)+(1<<10))>>11;                 \n"
+"    inter[blockIdx + 16] = ((tmp12 + tmp1)+(1<<10))>>11;                 \n"
+"    inter[blockIdx + 40] = ((tmp12 - tmp1)+(1<<10))>>11;                 \n"
+"    inter[blockIdx + 24] = ((tmp13 + tmp0)+(1<<10))>>11;                 \n"
+"    inter[blockIdx + 32] = ((tmp13 - tmp0)+(1<<10))>>11;                 \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  dataInt = vload8(localIdx, inter);                                     \n"
+"                                                                         \n"
+"  if (dataInt.s1 == 0 && dataInt.s2 == 0 && dataInt.s3 == 0 &&           \n"
+"      dataInt.s4 == 0 && dataInt.s5 == 0 && dataInt.s6 == 0 &&           \n"
+"      dataInt.s7 == 0) {                                                 \n"
+"    dataInt.s0 =  dataInt.s1 = dataInt.s2 = dataInt.s3 =dataInt.s4 =     \n"
+"    dataInt.s5 = dataInt.s6 = dataInt.s7 = (dataInt.s0 + 16) >> 5;       \n"
+"    dataUchar = convert_uchar8_sat(dataInt + 128);                       \n"
+"  }                                                                      \n"
+"  else                                                                   \n"
+"  {                                                                      \n"
+"    z1 = (dataInt.s2 + dataInt.s6) * 4433;                               \n"
+"    tmp2 = z1 - dataInt.s6 * 15137;                                      \n"
+"    tmp3 = z1 + dataInt.s2 * 6270;                                       \n"
+"    tmp0 = (dataInt.s0 + dataInt.s4) << 13;                              \n"
+"    tmp1 = (dataInt.s0 - dataInt.s4) << 13;                              \n"
+"                                                                         \n"
+"    tmp10 = tmp0 + tmp3;                                                 \n"
+"    tmp13 = tmp0 - tmp3;                                                 \n"
+"    tmp11 = tmp1 + tmp2;                                                 \n"
+"    tmp12 = tmp1 - tmp2;                                                 \n"
+"                                                                         \n"
+"    z1 = dataInt.s7 + dataInt.s1;                                        \n"
+"    z2 = dataInt.s5 + dataInt.s3;                                        \n"
+"    z3 = dataInt.s7 + dataInt.s3;                                        \n"
+"    z4 = dataInt.s5 + dataInt.s1;                                        \n"
+"                                                                         \n"
+"    z5 = (z3 + z4)* 9633;                                                \n"
+"                                                                         \n"
+"    tmp0 = dataInt.s7 * 2446;                                            \n"
+"    tmp1 = dataInt.s5 * 16819;                                           \n"
+"    tmp2 = dataInt.s3 * 25172;                                           \n"
+"    tmp3 = dataInt.s1 * 12299;                                           \n"
+"                                                                         \n"
+"    z1 = -z1 * 7373;                                                     \n"
+"    z2 = -z2 * 20995;                                                    \n"
+"    z3 = -z3 * 16069 + z5;                                               \n"
+"    z4 = -z4 * 3196 + z5;                                                \n"
+"                                                                         \n"
+"    tmp0 += z1 + z3;                                                     \n"
+"    tmp1 += z2 + z4;                                                     \n"
+"    tmp2 += z2 + z3;                                                     \n"
+"    tmp3 += z1 + z4;                                                     \n"
+"                                                                         \n"
+"    dataInt.s0 = ((tmp10 + tmp3)+(1<<17))>> 18;                          \n"
+"    dataInt.s7 = ((tmp10 - tmp3)+(1<<17))>> 18;                          \n"
+"    dataInt.s1 = ((tmp11 + tmp2)+(1<<17))>> 18;                          \n"
+"    dataInt.s6 = ((tmp11 - tmp2)+(1<<17))>> 18;                          \n"
+"    dataInt.s2 = ((tmp12 + tmp1)+(1<<17))>> 18;                          \n"
+"    dataInt.s5 = ((tmp12 - tmp1)+(1<<17))>> 18;                          \n"
+"    dataInt.s4 = ((tmp13 - tmp0)+(1<<17))>> 18;                          \n"
+"    dataInt.s3 = ((tmp13 + tmp0)+(1<<17))>> 18;                          \n"
+"    dataUchar    = convert_uchar8_sat(dataInt + 128);                    \n"
+"  }                                                                      \n"
+"  dst[globalIdx] = dataUchar;                                            \n"
+"}                                                                        \n"
+"__kernel void IDCT_FAST_FLOAT     (__global   short8 *src,               \n"
+"                                   __global   uchar8 *dst,               \n"
+"                                   __constant float8 *quant_tables,      \n"
+"                                   __local    float  *inter,             \n"
+"                                   const      uint    block_offset)      \n"
+"{                                                                        \n"
+"  uint   globalIdx = get_global_id(0);                                   \n"
+"  uint   localIdx  = get_local_id (0);                                   \n"
+"  uint   unitIdx   = localIdx  & 0x07; // MOD 8                          \n"
+"  uint   blockIdx  = unitIdx + ((localIdx >> 3) << 6);                   \n"
+"  uint   quantbIdx =                                                     \n"
+"    ((block_offset - 3) < ((globalIdx >>3) % block_offset)) << 3;        \n"
+"  float8 dataFloat;                                                      \n"
+"  int8 dataInt;                                                          \n"
+"  uchar8 dataUchar;                                                      \n"
+"  float  tmp0 , tmp1 , tmp2 , tmp3 , tmp4, tmp5, tmp6, tmp7;             \n"
+"  float  tmp10, tmp11, tmp12, tmp13, z5  , z10 , z11 , z12 , z13;        \n"
+"                                                                         \n"
+"  dataFloat = convert_float8(src[globalIdx]) *                           \n"
+"    quant_tables[quantbIdx + unitIdx];                                   \n"
+"                                                                         \n"
+"  if (dataFloat.s1 == 0 && dataFloat.s2 == 0 && dataFloat.s3 == 0 &&     \n"
+"      dataFloat.s4 == 0 && dataFloat.s5 == 0 && dataFloat.s6 == 0 &&     \n"
+"      dataFloat.s7 == 0)                                                 \n"
+"    inter[blockIdx +  0] = inter[blockIdx +  8] = inter[blockIdx + 16] = \n"
+"    inter[blockIdx + 24] = inter[blockIdx + 32] = inter[blockIdx + 40] = \n"
+"    inter[blockIdx + 48] = inter[blockIdx + 56] = dataFloat.s0;          \n"
+"  else                                                                   \n"
+"  {                                                                      \n"
+"    tmp10 = dataFloat.s0  + dataFloat.s4;                                \n"
+"    tmp11 = dataFloat.s0  - dataFloat.s4;                                \n"
+"    tmp13 = dataFloat.s2  + dataFloat.s6;                                \n"
+"    tmp12 = (dataFloat.s2 - dataFloat.s6) * 1.414213562f - tmp13;        \n"
+"    tmp0  = tmp10 + tmp13;                                               \n"
+"    tmp3  = tmp10 - tmp13;                                               \n"
+"    tmp1  = tmp11 + tmp12;                                               \n"
+"    tmp2  = tmp11 - tmp12;                                               \n"
+"    z13   = dataFloat.s5  + dataFloat.s3;                                \n"
+"    z10   = dataFloat.s5  - dataFloat.s3;                                \n"
+"    z11   = dataFloat.s1  + dataFloat.s7;                                \n"
+"    z12   = dataFloat.s1  - dataFloat.s7;                                \n"
+"    tmp7  = z11 + z13;                                                   \n"
+"    tmp11 = (z11 - z13) * 1.414213562f;                                  \n"
+"    z5    = (z10 + z12) * 1.847759065f;                                  \n"
+"    tmp10 = z12 * 1.082392200f - z5;                                     \n"
+"    tmp12 = -z10 * 2.613125930f + z5;                                    \n"
+"    tmp6  = tmp12 - tmp7;                                                \n"
+"    tmp5  = tmp11 - tmp6;                                                \n"
+"    tmp4  = tmp10 + tmp5;                                                \n"
+"                                                                         \n"
+"    inter[blockIdx +  0] = tmp0 + tmp7;                                  \n"
+"    inter[blockIdx +  8] = tmp1 + tmp6;                                  \n"
+"    inter[blockIdx + 16] = tmp2 + tmp5;                                  \n"
+"    inter[blockIdx + 24] = tmp3 - tmp4;                                  \n"
+"    inter[blockIdx + 32] = tmp3 + tmp4;                                  \n"
+"    inter[blockIdx + 40] = tmp2 - tmp5;                                  \n"
+"    inter[blockIdx + 48] = tmp1 - tmp6;                                  \n"
+"    inter[blockIdx + 56] = tmp0 - tmp7;                                  \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  dataFloat = vload8(localIdx, inter);                                   \n"
+"                                                                         \n"
+"  tmp10 = dataFloat.s0 + dataFloat.s4;                                   \n"
+"  tmp11 = dataFloat.s0 - dataFloat.s4;                                   \n"
+"  tmp13 = dataFloat.s2 + dataFloat.s6;                                   \n"
+"  tmp12 = (dataFloat.s2 - dataFloat.s6) * 1.414213562f - tmp13;          \n"
+"  z13   = dataFloat.s5 + dataFloat.s3;                                   \n"
+"  z10   = dataFloat.s5 - dataFloat.s3;                                   \n"
+"  z11   = dataFloat.s1 + dataFloat.s7;                                   \n"
+"  z12   = dataFloat.s1 - dataFloat.s7;                                   \n"
+"  tmp0  = tmp10 + tmp13;                                                 \n"
+"  tmp3  = tmp10 - tmp13;                                                 \n"
+"  tmp1  = tmp11 + tmp12;                                                 \n"
+"  tmp2  = tmp11 - tmp12;                                                 \n"
+"  tmp7  = z11 + z13;                                                     \n"
+"  tmp11 = (z11 - z13) * 1.414213562f;                                    \n"
+"  z5    = (z10 + z12) * 1.847759065f;                                    \n"
+"  tmp10 = z12 * 1.082392200f - z5;                                       \n"
+"  tmp12 = -z10 * 2.613125930f + z5;                                      \n"
+"  tmp6  = tmp12 - tmp7;                                                  \n"
+"  tmp5  = tmp11 - tmp6;                                                  \n"
+"  tmp4  = tmp10 + tmp5;                                                  \n"
+"                                                                         \n"
+"  dataFloat.s0 = tmp0 + tmp7;                                            \n"
+"  dataFloat.s7 = tmp0 - tmp7;                                            \n"
+"  dataFloat.s1 = tmp1 + tmp6;                                            \n"
+"  dataFloat.s6 = tmp1 - tmp6;                                            \n"
+"  dataFloat.s2 = tmp2 + tmp5;                                            \n"
+"  dataFloat.s5 = tmp2 - tmp5;                                            \n"
+"  dataFloat.s4 = tmp3 + tmp4;                                            \n"
+"  dataFloat.s3 = tmp3 - tmp4;                                            \n"
+"  dataInt      = convert_int8_rtz(dataFloat);                            \n"
+"  dataInt.s0   = (dataInt.s0 + 4)>>3;                                    \n"
+"  dataInt.s1   = (dataInt.s1 + 4)>>3;                                    \n"
+"  dataInt.s2   = (dataInt.s2 + 4)>>3;                                    \n"
+"  dataInt.s3   = (dataInt.s3 + 4)>>3;                                    \n"
+"  dataInt.s4   = (dataInt.s4 + 4)>>3;                                    \n"
+"  dataInt.s5   = (dataInt.s5 + 4)>>3;                                    \n"
+"  dataInt.s6   = (dataInt.s6 + 4)>>3;                                    \n"
+"  dataInt.s7   = (dataInt.s7 + 4)>>3;                                    \n"
+"  dataUchar    = convert_uchar8_sat(dataInt + 128);                      \n"
+"  dst[globalIdx] = dataUchar;                                            \n"
+"}                                                                        \n";
+
+static const char     * jocldec_cl_source2  =
+"__kernel void UPSAMPLE_H1V1_RGB            (__global uchar  *src,        \n"
+"                                        __global uchar4 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+"  uint    globalIdx = get_global_id(0);                                  \n"
+"  uint    localIdx  = get_local_id (0);                                  \n"
+"  uchar   dataInY   = src[globalIdx / 64 * 192 + localIdx];              \n"
+"  uchar   dataInCb  = src[globalIdx / 64 * 192 + 64 + localIdx];         \n"
+"  uchar   dataInCr  = src[globalIdx / 64 * 192 + 128 + localIdx];        \n"
+"  uchar   imgR, imgG, imgB;                                              \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx >> 6) % mcu_width;                                      \n"
+"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"                                                                         \n"
+"  imgB = convert_uchar_sat(                                              \n"
+"    dataInY  + (((int)91881 * (dataInCr - 128) + (int)32768) >> 16));    \n"
+"  imgG = convert_uchar_sat(                                              \n"
+"    dataInY + ((((int)32768 - (int)22554 * (dataInCb - 128))             \n"
+"    - ((int)46802 * (dataInCr - 128))) >> 16));                          \n"
+"  imgR = convert_uchar_sat(                                              \n"
+"    dataInY  + ((116130 * (dataInCb - 128) + 32768) >> 16));             \n"
+"                                                                         \n"
+"  inter[localIdx * 3 + 0] = imgB;                                        \n"
+"  inter[localIdx * 3 + 1] = imgG;                                        \n"
+"  inter[localIdx * 3 + 2] = imgR;                                        \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 48)                                                     \n"
+"    dst[y * mcu_width * 48 + x * 6 + localIdx % 6                        \n"
+"      + localIdx / 6 * mcu_width * 6] = vload4(localIdx, inter);         \n"
+"}                                                                        \n"
+"                                                                         \n"
+"__kernel void UPSAMPLE_H1V2_RGB            (__global uchar  *src,        \n"
+"                                        __global uchar4 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+"  uint    globalIdx = get_global_id(0);                                  \n"
+"  uint    localIdx =  get_local_id(0);                                   \n"
+"  uint    transOffset = ((localIdx >> 4) << 3) + (localIdx & 0x07);      \n"
+"  uchar   dataInY = src[globalIdx / 128 * 256 + localIdx];               \n"
+"  uchar   imgR, imgG, imgB;                                              \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx >> 7) % mcu_width;                                      \n"
+"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"                                                                         \n"
+"  if (localIdx < 64)                                                     \n"
+"  {                                                                      \n"
+"    cb_cache[localIdx] = src[globalIdx / 128 * 256 + 128 + localIdx];    \n"
+"    cr_cache[localIdx] = src[globalIdx / 128 * 256 + 192 + localIdx];    \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  imgB = convert_uchar_sat(dataInY  +                                    \n"
+"    (((int)91881 * (cr_cache[transOffset] - 128) + (int)32768) >> 16));  \n"
+"  imgG = convert_uchar_sat(dataInY +                                     \n"
+"    ((((int)32768 - (int)22554 * (cb_cache[transOffset] - 128))          \n"
+"    - ((int)46802 * (cr_cache[transOffset] - 128))) >> 16));             \n"
+"  imgR = convert_uchar_sat(dataInY  +                                    \n"
+"    (((int)116130 * (cb_cache[transOffset] - 128) + (int)32768) >> 16)); \n"
+"                                                                         \n"
+"  inter[localIdx * 3 + 0] = imgB;                                        \n"
+"  inter[localIdx * 3 + 1] = imgG;                                        \n"
+"  inter[localIdx * 3 + 2] = imgR;                                        \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 96)                                                     \n"
+"    dst[y * mcu_width * 96 + x * 6 + localIdx % 6 +                      \n"
+"      localIdx / 6 * mcu_width * 6] = vload4(localIdx, inter);           \n"
+"}                                                                        \n"
+"                                                                         \n"
+"__kernel void UPSAMPLE_H2V1_RGB            (__global uchar  *src,        \n"
+"                                        __global uchar8 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        __local  uchar2 *cb_upsample,    \n"
+"                                        __local  uchar2 *cr_upsample,    \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+"  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    localIdx    = get_local_id (0);                                \n"
+"  uint    transOffset =                                                  \n"
+"    ((localIdx >> 2) << 2) - (localIdx >> 5) * 60 + localIdx;            \n"
+"  uchar2  dataInY  = vload2(globalIdx / 64 * 128 + localIdx, src);       \n"
+"  uchar   dataInCb = cb_cache[localIdx] =                                \n"
+"    src[globalIdx / 64 * 256 + 128 + localIdx];                          \n"
+"  uchar   dataInCr = cr_cache[localIdx] =                                \n"
+"    src[globalIdx / 64 * 256 + 192 + localIdx];                          \n"
+"  uchar2  imgR, imgG, imgB;                                              \n"
+"  int     valueY,valueCb, valueCr;                                       \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx >> 6) % mcu_width;                                      \n"
+"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  cb_upsample[localIdx].x = dataInCb;                                    \n"
+"  cb_upsample[localIdx].y = dataInCb;                                    \n"
+"  cr_upsample[localIdx].x = dataInCr;                                    \n"
+"  cr_upsample[localIdx].y = dataInCr;                                    \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  valueY = convert_int(dataInY.x);                                       \n"
+"  valueCb = convert_int(cb_upsample[transOffset].x);                     \n"
+"  valueCr = convert_int(cr_upsample[transOffset].x);                     \n"
+"                                                                         \n"
+"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.y);                                      \n"
+"  valueCb = convert_int(cb_upsample[transOffset].y);                     \n"
+"  valueCr = convert_int(cr_upsample[transOffset].y);                     \n"
+"                                                                         \n"
+"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  inter[transOffset * 6 + 0] = imgB.x;                                   \n"
+"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 6 + 2] = imgR.x;                                   \n"
+"  inter[transOffset * 6 + 3] = imgB.y;                                   \n"
+"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
+"  inter[transOffset * 6 + 5] = imgR.y;                                   \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 48)                                                     \n"
+"    dst[y * mcu_width * 48 + x * 6 + localIdx % 6 +                      \n"
+"      localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);           \n"
+"}                                                                        \n"
+"                                                                         \n"
+"__kernel void UPSAMPLE_H2V2_RGB        (__global uchar  *src,            \n"
+"                                        __global uchar8 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        __local  uchar2 *cb_upsample,    \n"
+"                                        __local  uchar2 *cr_upsample,    \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+"  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    localIdx    = get_local_id (0);                                \n"
+"  uint    transOffset = localIdx - (localIdx >> 5) * 60 +                \n"
+"    (localIdx >> 2 << 2) + (localIdx >> 6) * 56;                         \n"
+"  uchar2  dataInY     = vload2(globalIdx/128 * 192 + localIdx, src);     \n"
+"  uchar2  imgR, imgG, imgB;                                              \n"
+"  int     valueY, valueCb, valueCr;                                      \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx >> 7) % mcu_width;                                      \n"
+"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"                                                                         \n"
+"  if (localIdx < 64)                                                     \n"
+"  {                                                                      \n"
+"    cb_cache[localIdx] = src[globalIdx/128 * 384 + 256 + localIdx];      \n"
+"    cr_cache[localIdx] = src[globalIdx/128 * 384 + 320 + localIdx];      \n"
+"    cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0] =         \n"
+"      cb_cache[localIdx];                                                \n"
+"    cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4] =         \n"
+"      cb_cache[localIdx];                                                \n"
+"    cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0] =         \n"
+"      cr_cache[localIdx];                                                \n"
+"    cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4] =         \n"
+"      cr_cache[localIdx];                                                \n"
+"  }                                                                      \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.x);                                      \n"
+"  valueCb = convert_int(cb_upsample[localIdx].x);                        \n"
+"  valueCr = convert_int(cr_upsample[localIdx].x);                        \n"
+"                                                                         \n"
+"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.y);                                      \n"
+"  valueCb = convert_int(cb_upsample[localIdx].y);                        \n"
+"  valueCr = convert_int(cr_upsample[localIdx].y);                        \n"
+"                                                                         \n"
+"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  inter[transOffset * 6 + 0] = imgB.x;                                   \n"
+"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 6 + 2] = imgR.x;                                   \n"
+"  inter[transOffset * 6 + 3] = imgB.y;                                   \n"
+"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
+"  inter[transOffset * 6 + 5] = imgR.y;                                   \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 96)                                                     \n"
+"    dst[y * mcu_width * 96 + x * 6 + localIdx % 6                        \n"
+"      + localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);         \n"
+"                                                                         \n"
+"}                                                                        \n";
+
+static const char     * jocldec_cl_source3  =
+"__kernel void UPSAMPLE_H2V1_FANCY_RGB   (__global uchar  *src,           \n"
+"                                        __global uchar8 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        __local  uchar2 *cb_upsample,    \n"
+"                                        __local  uchar2 *cr_upsample,    \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+"  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    localIdx    = get_local_id (0);                                \n"
+"  uint    transOffset =                                                  \n"
+"    ((localIdx >> 2) << 2) - (localIdx >> 5) * 60 + localIdx;            \n"
+"  uchar   dataInCbLeft, dataInCrLeft, dataInCbRight, dataInCrRight;      \n"
+"  uchar2  dataInY  = vload2(globalIdx / 64 * 128 + localIdx, src);       \n"
+"  uchar   dataInCb = cb_cache[localIdx] =                                \n"
+"    src[globalIdx / 64 * 256 + 128 + localIdx];                          \n"
+"  uchar   dataInCr = cr_cache[localIdx] =                                \n"
+"    src[globalIdx / 64 * 256 + 192 + localIdx];                          \n"
+"  uchar2  imgR, imgG, imgB;                                              \n"
+"  int     valueY,valueCb, valueCr;                                       \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx >> 6) % mcu_width;                                      \n"
+"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  if (!(localIdx & 0x07) && !(globalIdx / 64 % mcu_width)) {             \n"
+"    dataInCbLeft  = dataInCb -1;                                         \n"
+"    dataInCrLeft  = dataInCr -1;                                         \n"
+"    dataInCbRight = cb_cache[localIdx+1];                                \n"
+"    dataInCrRight = cr_cache[localIdx+1];                                \n"
+"  }                                                                      \n"
+"  else if (!(localIdx & 0x07) && (globalIdx / 64 % mcu_width)) {         \n"
+"    dataInCbLeft  = src[globalIdx / 64 * 256 -64 + localIdx - 57];       \n"
+"    dataInCrLeft  = src[globalIdx / 64 * 256 + localIdx - 57];           \n"
+"    dataInCbRight = cb_cache[localIdx+1];                                \n"
+"    dataInCrRight = cr_cache[localIdx+1];                                \n"
+"  }                                                                      \n"
+"  else if ((localIdx & 0x07) == 7 &&                                     \n"
+"           (globalIdx / 64 % mcu_width) == (mcu_width - 1)) {            \n"
+"    dataInCbLeft  = cb_cache[localIdx-1];                                \n"
+"    dataInCrLeft  = cr_cache[localIdx-1];                                \n"
+"    dataInCbRight = dataInCb -2;                                         \n"
+"    dataInCrRight = dataInCr -2;                                         \n"
+"  }                                                                      \n"
+"  else if ((localIdx & 0x07) == 7 &&                                     \n"
+"           (globalIdx / 64 % mcu_width) != (mcu_width - 1)) {            \n"
+"    dataInCbLeft  = cb_cache[localIdx-1];                                \n"
+"    dataInCrLeft  = cr_cache[localIdx-1];                                \n"
+"    dataInCbRight = src[globalIdx / 64 * 256 + localIdx + 57 + 320];     \n"
+"    dataInCrRight = src[globalIdx / 64 * 256 + localIdx + 57 + 384];     \n"
+"  }                                                                      \n"
+"  else {                                                                 \n"
+"    dataInCbLeft  = cb_cache[localIdx-1];                                \n"
+"    dataInCrLeft  = cr_cache[localIdx-1];                                \n"
+"    dataInCbRight = cb_cache[localIdx+1];                                \n"
+"    dataInCrRight = cr_cache[localIdx+1];                                \n"
+"  }                                                                      \n"
+"                                                                         \n"
+"  cb_upsample[localIdx].x = (dataInCb * 3 + dataInCbLeft  + 1) >> 2;     \n"
+"  cb_upsample[localIdx].y = (dataInCb * 3 + dataInCbRight + 2) >> 2;     \n"
+"  cr_upsample[localIdx].x = (dataInCr * 3 + dataInCrLeft  + 1) >> 2;     \n"
+"  cr_upsample[localIdx].y = (dataInCr * 3 + dataInCrRight + 2) >> 2;     \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  valueY = convert_int(dataInY.x);                                       \n"
+"  valueCb = convert_int(cb_upsample[transOffset].x);                     \n"
+"  valueCr = convert_int(cr_upsample[transOffset].x);                     \n"
+"                                                                         \n"
+"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.y);                                      \n"
+"  valueCb = convert_int(cb_upsample[transOffset].y);                     \n"
+"  valueCr = convert_int(cr_upsample[transOffset].y);                     \n"
+"                                                                         \n"
+"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  inter[transOffset * 6 + 0] = imgB.x;                                   \n"
+"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 6 + 2] = imgR.x;                                   \n"
+"  inter[transOffset * 6 + 3] = imgB.y;                                   \n"
+"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
+"  inter[transOffset * 6 + 5] = imgR.y;                                   \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 48)                                                     \n"
+"    dst[y * mcu_width * 48 + x * 6 + localIdx % 6 +                      \n"
+"      localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);           \n"
+"}                                                                        \n"
+"__kernel void UPSAMPLE_H2V2_FANCY_RGB      (__global uchar  *src,        \n"
+"                                        __global uchar8 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        __local  uchar2 *cb_upsample,    \n"
+"                                        __local  uchar2 *cr_upsample,    \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+/*"  uint   globalIdx   = get_global_id(0);                                 \n"
+"  uint   localIdx    = get_local_id (0);                                 \n"
+"  uint   transOffset = localIdx - (localIdx >> 5) * 60 +                 \n"
+"    (localIdx >> 2 << 2) + (localIdx >> 6) * 56;                         \n"
+"  uchar2 dataInY     = vload2(globalIdx/128 * 192 + localIdx, src);      \n"
+"  uchar2 imgR, imgG, imgB;                                               \n"
+"  int    valueY, valueCb, valueCr;                                       \n"
+"  uint   x, y;                                                           \n"
+"  int    dataInTopCb, dataInBottomCb, dataInRightCb, dataInLeftCb;       \n"
+"  int    dataInLeftTopCb, dataInRightTopCb;                              \n"
+"  int    dataInLeftBottomCb, dataInRightBottomCb;                        \n"
+"  int    dataInTopCr, dataInBottomCr, dataInRightCr, dataInLeftCr;       \n"
+"  int    dataInLeftTopCr, dataInRightTopCr;                              \n"
+"  int    dataInLeftBottomCr, dataInRightBottomCr;                        \n"
+"                                                                         \n"
+"  uchar   dataInCb ,dataInCr;                                            \n"
+"  x = (globalIdx >> 7) % mcu_width;                                      \n"
+"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"                                                                         \n"
+"  if (localIdx < 64)                                                     \n"
+"  {                                                                      \n"
+"    cb_cache[localIdx] = src[globalIdx/128 * 384 + 256 + localIdx];      \n"
+"    cr_cache[localIdx] = src[globalIdx/128 * 384 + 320 + localIdx];      \n"
+"  }                                                                      \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 64)                                                     \n"
+"  {                                                                      \n"
+"  dataInCb = cb_cache[localIdx];                                         \n"
+"  dataInCr = cr_cache[localIdx];                                         \n"
+"                                                                         \n"
+"  dataInTopCb    = src[globalIdx/128 * 384 + 256 + localIdx - 8];        \n"
+"  dataInBottomCb = src[globalIdx/128 * 384 + 256 + localIdx + 8];        \n"
+"  dataInRightCb  = src[globalIdx/128 * 384 + 256 + localIdx + 1];        \n"
+"  dataInLeftCb   = src[globalIdx/128 * 384 + 256 + localIdx - 1];        \n"
+"  dataInLeftTopCb = src[globalIdx/128 * 384 + 256 + localIdx - 9];       \n"
+"  dataInRightTopCb = src[globalIdx/128 * 384 + 256 + localIdx - 7];      \n"
+"  dataInLeftBottomCb = src[globalIdx/128 * 384 + 256 + localIdx + 7];    \n"
+"  dataInRightBottomCb = src[globalIdx/128 * 384 + 256 + localIdx + 9];   \n"
+"                                                                         \n"
+"  dataInTopCr    = src[globalIdx/128 * 384 + 320 + localIdx - 8];        \n"
+"  dataInBottomCr = src[globalIdx/128 * 384 + 320 + localIdx + 8];        \n"
+"  dataInRightCr  = src[globalIdx/128 * 384 + 320 + localIdx + 1];        \n"
+"  dataInLeftCr   = src[globalIdx/128 * 384 + 320 + localIdx - 1];        \n"
+"  dataInLeftTopCr = src[globalIdx/128 * 384 + 320 + localIdx - 9];       \n"
+"  dataInRightTopCr = src[globalIdx/128 * 384 + 320 + localIdx - 7];      \n"
+"  dataInLeftBottomCr = src[globalIdx/128 * 384 + 320 + localIdx + 7];    \n"
+"  dataInRightBottomCr = src[globalIdx/128 * 384 + 320 + localIdx + 9];   \n"
+"                                                                         \n"
+"  if (globalIdx == 0) {                                                  \n"
+"    dataInTopCb        = dataInCb;                                       \n"
+"    dataInLeftCb       = dataInCb;                                       \n"
+"    dataInLeftTopCb    = dataInCb;                                       \n"
+"    dataInRightTopCb   = dataInRightCb;                                  \n"
+"    dataInLeftBottomCb = dataInBottomCb;                                 \n"
+"                                                                         \n"
+"    dataInTopCr        = dataInCr;                                       \n"
+"    dataInLeftCr       = dataInCr;                                       \n"
+"    dataInLeftTopCr    = dataInCr;                                       \n"
+"    dataInRightTopCr   = dataInRightCr;                                  \n"
+"    dataInLeftBottomCr = dataInBottomCr;                                 \n"
+"  }                                                                      \n"
+"  else if (globalIdx == get_global_size(0) - 65) {                       \n"
+"    dataInBottomCb      = dataInCb;                                      \n"
+"    dataInRightCb       = dataInCb;                                      \n"
+"    dataInRightTopCb    = dataInTopCb;                                   \n"
+"    dataInLeftBottomCb  = dataInLeftCb;                                  \n"
+"    dataInRightBottomCb = dataInBottomCb;                                \n"
+"                                                                         \n"
+"    dataInBottomCr      = dataInCr;                                      \n"
+"    dataInRightCr       = dataInCr;                                      \n"
+"    dataInRightTopCr    = dataInRightCr;                                 \n"
+"    dataInLeftBottomCr  = dataInLeftCr;                                  \n"
+"    dataInRightBottomCr = dataInBottomCr;                                \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 % mcu_width) &&                             \n"
+"    ((globalIdx / 128 / mcu_width) ==                                    \n"
+"    (get_global_size(0) /128 /mcu_width - 1)) && (localIdx == 56))  {    \n"
+"    dataInBottomCb      = dataInCb;                                      \n"
+"    dataInLeftCb        = dataInCb;                                      \n"
+"    dataInLeftTopCb     = dataInTopCb;                                   \n"
+"    dataInLeftBottomCb  = dataInBottomCb;                                \n"
+"    dataInRightBottomCb = dataInRightCb;                                 \n"
+"                                                                         \n"
+"    dataInBottomCr      = dataInCr;                                      \n"
+"    dataInLeftCr        = dataInCr;                                      \n"
+"    dataInLeftTopCr     = dataInTopCr;                                   \n"
+"    dataInLeftBottomCr  = dataInBottomCr;                                \n"
+"    dataInRightBottomCr = dataInRightCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) == (mcu_width - 1) &&           \n"
+"    (!(globalIdx / 128 / mcu_width)) && (localIdx == 7)){                \n"
+"    dataInTopCb         = dataInCb;                                      \n"
+"    dataInRightCb       = dataInCb;                                      \n"
+"    dataInLeftTopCb     = dataInLeftCb;                                  \n"
+"    dataInRightTopCb    = dataInTopCb;                                   \n"
+"    dataInRightBottomCb = dataInBottomCb;                                \n"
+"                                                                         \n"
+"    dataInTopCr         = dataInCr;                                      \n"
+"    dataInRightCr       = dataInCr;                                      \n"
+"    dataInLeftTopCr     = dataInLeftCr;                                  \n"
+"    dataInRightTopCr    = dataInTopCr;                                   \n"
+"    dataInRightBottomCr = dataInBottomCr;                                \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) != (mcu_width - 1) &&           \n"
+"    (!(globalIdx / 128 / mcu_width)) && (localIdx == 7)){                \n"
+"    dataInTopCb         = dataInCb;                                      \n"
+"    dataInRightCb       = src[(globalIdx/128 + 1) * 384 + 256];          \n"
+"    dataInLeftTopCb     = dataInLeftCb;                                  \n"
+"    dataInRightTopCb    = dataInRightCb;                                 \n"
+"    dataInRightBottomCb = src[(globalIdx/128 + 1) * 384 + 264];          \n"
+"                                                                         \n"
+"    dataInTopCr         = dataInCr;                                      \n"
+"    dataInRightCr       = src[(globalIdx/128 + 1) * 384 + 320];          \n"
+"    dataInLeftTopCr     = dataInLeftCr;                                  \n"
+"    dataInRightTopCr    = dataInRightCr;                                 \n"
+"    dataInRightBottomCr = src[(globalIdx/128 + 1) * 384 + 328];          \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 / mcu_width) &&                             \n"
+"    (localIdx == 0) && globalIdx){                                       \n"
+"    dataInTopCb        = dataInCb;                                       \n"
+"    dataInLeftCb       = src[(globalIdx/128 - 1) * 384 + 263];           \n"
+"    dataInLeftTopCb    = dataInLeftCb;                                   \n"
+"    dataInRightTopCb   = dataInRightCb;                                  \n"
+"    dataInLeftBottomCb = src[(globalIdx/128 - 1) * 384 + 271];           \n"
+"                                                                         \n"
+"    dataInTopCr        = dataInCr;                                       \n"
+"    dataInLeftCr       = src[(globalIdx/128 - 1) * 384 + 327];           \n"
+"    dataInLeftTopCr    = dataInLeftCr;                                   \n"
+"    dataInRightTopCr   = dataInRightCr;                                  \n"
+"    dataInLeftBottomCr = src[(globalIdx/128 - 1) * 384 + 335];           \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 % mcu_width) &&                             \n"
+"    (globalIdx / 128 / mcu_width) !=                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 56))  {     \n"
+"    dataInBottomCb      = src[(globalIdx/128 + mcu_width) * 384 + 256];  \n"
+"    dataInLeftCb        = dataInCb;                                      \n"
+"    dataInLeftTopCb     = dataInTopCb;                                   \n"
+"    dataInLeftBottomCb  = dataInBottomCb;                                \n"
+"    dataInRightBottomCb = src[(globalIdx/128 + mcu_width) * 384 + 257];  \n"
+"                                                                         \n"
+"    dataInBottomCr      = src[(globalIdx/128 + mcu_width) * 384 + 320];  \n"
+"    dataInLeftCr        = dataInCr;                                      \n"
+"    dataInLeftTopCr     = dataInTopCr;                                   \n"
+"    dataInLeftBottomCr  = dataInBottomCr;                                \n"
+"    dataInRightBottomCr = src[(globalIdx/128 + mcu_width) * 384 + 321];  \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 % mcu_width) &&                             \n"
+"    (globalIdx / 128 / mcu_width) && (localIdx == 0))  {                 \n"
+"    dataInTopCb        = src[(globalIdx/128 - mcu_width) * 384 + 312];   \n"
+"    dataInLeftCb       = dataInCb;                                       \n"
+"    dataInLeftTopCb    = dataInTopCb;                                    \n"
+"    dataInRightTopCb   = src[(globalIdx/128 - mcu_width) * 384 + 313];   \n"
+"    dataInLeftBottomCb = dataInBottomCb;                                 \n"
+"                                                                         \n"
+"    dataInTopCr        = src[(globalIdx/128 - mcu_width) * 384 + 376];   \n"
+"    dataInLeftCr       = dataInCr;                                       \n"
+"    dataInLeftTopCr    = dataInTopCr;                                    \n"
+"    dataInRightTopCr   = src[(globalIdx/128 - mcu_width) * 384 + 377];   \n"
+"    dataInLeftBottomCr = dataInBottomCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) == (mcu_width - 1) &&           \n"
+"    (globalIdx / 128 / mcu_width) !=                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 63)){       \n"
+"    dataInBottomCb      = src[(globalIdx/128 + mcu_width) * 384 + 263];  \n"
+"    dataInRightCb       = dataInCb;                                      \n"
+"    dataInRightTopCb    = dataInTopCb;                                   \n"
+"    dataInLeftBottomCb  = src[(globalIdx/128 + mcu_width) * 384 + 262];  \n"
+"    dataInRightBottomCb = dataInBottomCb;                                \n"
+"                                                                         \n"
+"    dataInBottomCr      = src[(globalIdx/128 + mcu_width) * 384 + 327];  \n"
+"    dataInRightCr       = dataInCr;                                      \n"
+"    dataInRightTopCr    = dataInTopCr;                                   \n"
+"    dataInLeftBottomCr  = src[(globalIdx/128 + mcu_width) * 384 + 326];  \n"
+"    dataInRightBottomCr = dataInBottomCr;                                \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) == (mcu_width - 1) &&           \n"
+"     (globalIdx / 128 / mcu_width) && (localIdx == 7)) {                 \n"
+"    dataInTopCb         = src[(globalIdx/128 - mcu_width) * 384 + 319];  \n"
+"    dataInRightCb       = dataInCb;                                      \n"
+"    dataInLeftTopCb     = src[(globalIdx/128 - mcu_width) * 384 + 318];  \n"
+"    dataInRightTopCb    = dataInTopCb;                                   \n"
+"    dataInRightBottomCb = dataInBottomCb;                                \n"
+"                                                                         \n"
+"    dataInTopCr         = src[(globalIdx/128 - mcu_width) * 384 + 383];  \n"
+"    dataInRightCr       = dataInCr;                                      \n"
+"    dataInLeftTopCr     = src[(globalIdx/128 - mcu_width) * 384 + 382];  \n"
+"    dataInRightTopCr    = dataInTopCr;                                   \n"
+"    dataInRightBottomCr = dataInBottomCr;                                \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) != (mcu_width - 1) &&           \n"
+"    (globalIdx / 128 / mcu_width) ==                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 63))  {     \n"
+"    dataInBottomCb      = dataInCb;                                      \n"
+"    dataInRightCb       = src[(globalIdx/128 + 1) * 384 + 312];          \n"
+"    dataInRightTopCb    = src[(globalIdx/128 + 1) * 384 + 304];          \n"
+"    dataInLeftBottomCb  = dataInLeftCb;                                  \n"
+"    dataInRightBottomCb = dataInRightCb;                                 \n"
+"                                                                         \n"
+"    dataInBottomCr = dataInCr;                                           \n"
+"    dataInRightCr       = src[(globalIdx/128 + 1) * 384 + 376];          \n"
+"    dataInRightTopCr    = src[(globalIdx/128 + 1) * 384 + 368];          \n"
+"    dataInLeftBottomCr  = dataInLeftCr;                                  \n"
+"    dataInRightBottomCr = dataInRightCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) &&                              \n"
+"    (globalIdx / 128 / mcu_width) ==                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 56))  {     \n"
+"    dataInBottomCb      = dataInCb;                                      \n"
+"    dataInLeftCb        = src[(globalIdx/128 - 1) * 384 + 319];          \n"
+"    dataInLeftTopCb     = src[(globalIdx/128 - 1) * 384 + 311];          \n"
+"    dataInLeftBottomCb  = dataInLeftCb;                                  \n"
+"    dataInRightBottomCb = dataInRightCb;                                 \n"
+"                                                                         \n"
+"    dataInBottomCr      = dataInCr;                                      \n"
+"    dataInLeftCr        = src[(globalIdx/128 - 1) * 384 + 383];          \n"
+"    dataInLeftTopCr     = src[(globalIdx/128 - 1) * 384 + 375];          \n"
+"    dataInLeftBottomCr  = dataInLeftCr;                                  \n"
+"    dataInRightBottomCr = dataInRightCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width)&&                               \n"
+"    (globalIdx / 128 / mcu_width) !=                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 56))  {     \n"
+"    dataInBottomCb      = src[(globalIdx/128 + mcu_width) * 384 + 256];  \n"
+"    dataInLeftCb        = src[(globalIdx/128 - 1) * 384 + 319];          \n"
+"    dataInLeftTopCb     = src[(globalIdx/128 - 1) * 384 + 311];          \n"
+"    dataInLeftBottomCb  = src[(globalIdx/128 + mcu_width- 1)* 384 + 263];\n"
+"    dataInRightBottomCb = src[(globalIdx/128 + mcu_width) * 384 + 257];  \n"
+"                                                                         \n"
+"    dataInBottomCr      = src[(globalIdx/128 + mcu_width) * 384 + 320];  \n"
+"    dataInLeftCr        = src[(globalIdx/128 - 1) * 384 + 383];          \n"
+"    dataInLeftTopCr     = src[(globalIdx/128 - 1) * 384 + 375];          \n"
+"    dataInLeftBottomCr  = src[(globalIdx/128 + mcu_width- 1)* 384 + 327];\n"
+"    dataInRightBottomCr = src[(globalIdx/128 + mcu_width) * 384 + 321];  \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) != (mcu_width - 1) &&           \n"
+"    (globalIdx / 128 / mcu_width) !=                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 63))  {     \n"
+"    dataInBottomCb      = src[(globalIdx/128 + mcu_width) * 384 + 263];  \n"
+"    dataInRightCb       = src[(globalIdx/128 + 1) * 384 + 312];          \n"
+"    dataInRightTopCb    = src[(globalIdx/128 + 1) * 384 + 304];          \n"
+"    dataInLeftBottomCb  = src[(globalIdx/128 + mcu_width) * 384 + 262];  \n"
+"    dataInRightBottomCb = src[(globalIdx/128 + mcu_width+ 1)* 384 + 256];\n"
+"                                                                         \n"
+"    dataInBottomCr      = src[(globalIdx/128 + mcu_width) * 384 + 327];  \n"
+"    dataInRightCr       = src[(globalIdx/128 + 1) * 384 + 376];          \n"
+"    dataInRightTopCr    = src[(globalIdx/128 + 1) * 384 + 368];          \n"
+"    dataInLeftBottomCr  = src[(globalIdx/128 + mcu_width) * 384 + 326];  \n"
+"    dataInRightBottomCr = src[(globalIdx/128 + mcu_width+ 1)* 384 + 320];\n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) != (mcu_width - 1) &&           \n"
+"     (globalIdx / 128 / mcu_width) && (localIdx == 7)){                  \n"
+"    dataInTopCb         = src[(globalIdx/128 - mcu_width) * 384 + 319];  \n"
+"    dataInRightCb       = src[(globalIdx/128 + 1) * 384 + 256];          \n"
+"    dataInLeftTopCb     = src[(globalIdx/128 - mcu_width) * 384 + 318];  \n"
+"    dataInRightTopCb    = src[(globalIdx/128 - mcu_width+ 1)* 384 + 312];\n"
+"    dataInRightBottomCb = src[(globalIdx/128 + 1) * 384 + 264];          \n"
+"                                                                         \n"
+"    dataInTopCr         = src[(globalIdx/128 - mcu_width) * 384 + 383];  \n"
+"    dataInRightCr       = src[(globalIdx/128 + 1) * 384 + 320];          \n"
+"    dataInLeftTopCr     = src[(globalIdx/128 - mcu_width) * 384 + 382];  \n"
+"    dataInRightTopCr    = src[(globalIdx/128 - mcu_width+ 1)* 384 + 376];\n"
+"    dataInRightBottomCr = src[(globalIdx/128 + 1) * 384 + 320 + 8];      \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 / mcu_width) && (localIdx == 0) &&           \n"
+"     (globalIdx / 128 % mcu_width)){                                     \n"
+"    dataInTopCb         = src[(globalIdx/128 - mcu_width) * 384 + 312];  \n"
+"    dataInLeftCb        = src[(globalIdx/128 - 1) * 384 + 256 + 7];      \n"
+"    dataInLeftTopCb     = src[(globalIdx/128 - mcu_width- 1)* 384 + 319];\n"
+"    dataInRightTopCb    = src[(globalIdx/128 - mcu_width) * 384 + 313];  \n"
+"    dataInLeftBottomCb  = src[(globalIdx/128 - 1) * 384 + 271];          \n"
+"                                                                         \n"
+"    dataInTopCr         = src[(globalIdx/128 - mcu_width) * 384 + 376];  \n"
+"    dataInLeftCr        = src[(globalIdx/128 - 1) * 384 + 327];          \n"
+"    dataInLeftTopCr     = src[(globalIdx/128 - mcu_width- 1)* 384 + 383];\n"
+"    dataInRightTopCr    = src[(globalIdx/128 - mcu_width) * 384 + 377];  \n"
+"    dataInLeftBottomCr  = src[(globalIdx/128 - 1) * 384 + 320 + 15];     \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) == (mcu_width - 1) &&           \n"
+"      (localIdx % 8 == 7) && localIdx != 7 && localIdx != 63) {          \n"
+"    dataInRightCb       = dataInCb;                                      \n"
+"    dataInRightTopCb    = dataInTopCb;                                   \n"
+"    dataInRightBottomCb = dataInBottomCb;                                \n"
+"                                                                         \n"
+"    dataInRightCr       = dataInCr;                                      \n"
+"    dataInRightTopCr    = dataInTopCr;                                   \n"
+"    dataInRightBottomCr = dataInBottomCr;                                \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 / mcu_width) && !(localIdx / 8)&&           \n"
+"      localIdx != 7 && localIdx != 0 ){                                  \n"
+"    dataInTopCb      = dataInCb;                                         \n"
+"    dataInLeftTopCb  = dataInLeftCb;                                     \n"
+"    dataInRightTopCb = dataInRightCb;                                    \n"
+"                                                                         \n"
+"    dataInTopCr      = dataInCr;                                         \n"
+"    dataInLeftTopCr  = dataInLeftCr;                                     \n"
+"    dataInRightTopCr = dataInRightCr;                                    \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 % mcu_width) && !(localIdx & 0x07) &&       \n"
+"    (localIdx != 0) && (localIdx != 56))  {                              \n"
+"    dataInLeftCb       = dataInCb;                                       \n"
+"    dataInLeftTopCb    = dataInTopCb;                                    \n"
+"    dataInLeftBottomCb = dataInBottomCb;                                 \n"
+"                                                                         \n"
+"    dataInLeftCr       = dataInCr;                                       \n"
+"    dataInLeftTopCr    = dataInTopCr;                                    \n"
+"    dataInLeftBottomCr = dataInBottomCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((localIdx / 8 == 7) &&                                        \n"
+"    (globalIdx / 128 / mcu_width) ==                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) &&                          \n"
+"    (localIdx != 56) && (localIdx != 63))  {                             \n"
+"    dataInBottomCb      = dataInCb;                                      \n"
+"    dataInLeftBottomCb  = dataInLeftCb;                                  \n"
+"    dataInRightBottomCb = dataInRightCb;                                 \n"
+"                                                                         \n"
+"    dataInBottomCr      = dataInCr;                                      \n"
+"    dataInLeftBottomCr  = dataInLeftCr;                                  \n"
+"    dataInRightBottomCr = dataInRightCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) && !(localIdx & 0x07) &&        \n"
+"    (localIdx != 0) && (localIdx != 56))  {                              \n"
+"    dataInLeftCb       = src[(globalIdx/128- 1)*384 +256 +localIdx + 7]; \n"
+"    dataInLeftTopCb    = src[(globalIdx/128- 1)*384 +256 +localIdx - 1]; \n"
+"    dataInLeftBottomCb = src[(globalIdx/128- 1)*384 +256 +localIdx + 15];\n"
+"                                                                         \n"
+"    dataInLeftCr       = src[(globalIdx/128- 1)*384 +320 +localIdx + 7]; \n"
+"    dataInLeftTopCr    = src[(globalIdx/128- 1)*384 +320 +localIdx - 1]; \n"
+"    dataInLeftBottomCr = src[(globalIdx/128- 1)*384 +320 +localIdx + 15];\n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 / mcu_width) && !(localIdx / 8) &&           \n"
+"      localIdx != 7 && localIdx != 0 ){                                  \n"
+"    dataInTopCb       = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 312 + localIdx];                           \n"
+"    dataInLeftTopCb   = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 311 + localIdx];                           \n"
+"    dataInRightTopCb  = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 313 + localIdx];                           \n"
+"                                                                         \n"
+"    dataInTopCr       = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 376 + localIdx];                           \n"
+"    dataInLeftTopCr   = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 375 + localIdx];                           \n"
+"    dataInRightTopCr  = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 377 + localIdx];                           \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) != (mcu_width - 1) &&           \n"
+"      (localIdx % 8 == 7) &&                                             \n"
+"      localIdx != 7 && localIdx != 63) {                                 \n"
+"    dataInRightCb       = src[(globalIdx/128+ 1) * 384 + 249 + localIdx];\n"
+"    dataInRightTopCb    = src[(globalIdx/128+ 1) * 384 + 241 + localIdx];\n"
+"    dataInRightBottomCb = src[(globalIdx/128+ 1) * 384 + 257 + localIdx];\n"
+"                                                                         \n"
+"    dataInRightCr       = src[(globalIdx/128+ 1) * 384 + 313 + localIdx];\n"
+"    dataInRightTopCr    = src[(globalIdx/128+ 1) * 384 + 305 + localIdx];\n"
+"    dataInRightBottomCr = src[(globalIdx/128+ 1) * 384 + 321 + localIdx];\n"
+"  }                                                                      \n"
+"  else if ((localIdx / 8 == 7) &&                                        \n"
+"    (globalIdx / 128 / mcu_width) !=                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) &&                          \n"
+"    (localIdx != 56) && (localIdx != 63))  {                             \n"
+"    dataInBottomCb      = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 200 + localIdx];                         \n"
+"    dataInLeftBottomCb  = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 199 + localIdx];                         \n"
+"    dataInRightBottomCb = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 201 + localIdx];                         \n"
+"                                                                         \n"
+"    dataInBottomCr      = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 264 + localIdx];                         \n"
+"    dataInLeftBottomCr  = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 263 + localIdx];                         \n"
+"    dataInRightBottomCr = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 265 + localIdx];                         \n"
+"  }                                                                      \n"
+"                                                                         \n"
+"  cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0].x =         \n"
+"    ((dataInCb * 3 + dataInTopCb) * 3 +                                  \n"
+"    dataInLeftCb * 3 + dataInLeftTopCb + 8) >> 4;                        \n"
+"  cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0].y =         \n"
+"    ((dataInCb * 3 + dataInTopCb) * 3 +                                  \n"
+"    dataInRightCb * 3 + dataInRightTopCb + 7) >> 4;                      \n"
+"                                                                         \n"
+"  cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4].x =         \n"
+"    ((dataInCb * 3 + dataInBottomCb) * 3 +                               \n"
+"    dataInLeftCb * 3 + dataInLeftBottomCb + 8) >> 4;                     \n"
+"  cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4].y =         \n"
+"    ((dataInCb * 3 + dataInBottomCb) * 3 +                               \n"
+"    dataInRightCb * 3 + dataInRightBottomCb + 7) >> 4;                   \n"
+"                                                                         \n"
+"  cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0].x =         \n"
+"    ((dataInCr * 3 + dataInTopCr) * 3 +                                  \n"
+"    dataInLeftCr * 3 + dataInLeftTopCr + 8) >> 4;                        \n"
+"  cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0].y =         \n"
+"    ((dataInCr * 3 + dataInTopCr) * 3 +                                  \n"
+"    dataInRightCr * 3 + dataInRightTopCr + 7) >> 4;                      \n"
+"                                                                         \n"
+"  cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4].x =         \n"
+"    ((dataInCr * 3 + dataInBottomCr) * 3 +                               \n"
+"    dataInLeftCr * 3 + dataInLeftBottomCr + 8) >> 4;                     \n"
+"  cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4].y =         \n"
+"    ((dataInCr * 3 + dataInBottomCr) * 3 +                               \n"
+"    dataInRightCr * 3 + dataInRightBottomCr + 7) >> 4;                   \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.x);                                      \n"
+"  valueCb = convert_int(cb_upsample[localIdx].x);                        \n"
+"  valueCr = convert_int(cr_upsample[localIdx].x);                        \n"
+"                                                                         \n"
+"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.y);                                      \n"
+"  valueCb = convert_int(cb_upsample[localIdx].y);                        \n"
+"  valueCr = convert_int(cr_upsample[localIdx].y);                        \n"
+"                                                                         \n"
+"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  inter[transOffset * 6 + 0] = imgB.x;                                   \n"
+"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 6 + 2] = imgR.x;                                   \n"
+"  inter[transOffset * 6 + 3] = imgB.y;                                   \n"
+"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
+"  inter[transOffset * 6 + 5] = imgR.y;                                   \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 96)                                                     \n"
+"    dst[y * mcu_width * 96 + x * 6 + localIdx % 6                        \n"
+"      + localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);         \n"
+"                                                                         \n"*/
+"}                                                                        \n";
+
+static const char     * jocldec_cl_source4  =
+"__kernel void UPSAMPLE_H1V1_RGBA           (__global uchar  *src,        \n"
+"                                        __global uchar4 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+"  uint    globalIdx = get_global_id(0);                                  \n"
+"  uint    localIdx  = get_local_id (0);                                  \n"
+"  uchar   dataInY   = src[globalIdx / 64 * 192 + localIdx];              \n"
+"  uchar   dataInCb  = src[globalIdx / 64 * 192 + 64 + localIdx];         \n"
+"  uchar   dataInCr  = src[globalIdx / 64 * 192 + 128 + localIdx];        \n"
+"  uchar   imgR, imgG, imgB, imgA;                                        \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx >> 6) % mcu_width;                                      \n"
+"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"                                                                         \n"
+"  imgB = convert_uchar_sat(                                              \n"
+"    dataInY  + (((int)91881 * (dataInCr - 128) + (int)32768) >> 16));    \n"
+"  imgG = convert_uchar_sat(                                              \n"
+"    dataInY + ((((int)32768 - (int)22554 * (dataInCb - 128))             \n"
+"    - ((int)46802 * (dataInCr - 128))) >> 16));                          \n"
+"  imgR = convert_uchar_sat(                                              \n"
+"    dataInY  + ((116130 * (dataInCb - 128) + 32768) >> 16));             \n"
+"                                                                         \n"
+"  imgA = 255;                                                            \n"
+"                                                                         \n"
+"  inter[localIdx * 4 + 0] = imgB;                                        \n"
+"  inter[localIdx * 4 + 1] = imgG;                                        \n"
+"  inter[localIdx * 4 + 2] = imgR;                                        \n"
+"  inter[localIdx * 4 + 3] = imgA;                                        \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 64)                                                     \n"
+"    dst[y * mcu_width * 64 + x * 8 + localIdx % 8                        \n"
+"      + localIdx / 8 * mcu_width * 8] = vload4(localIdx, inter);         \n"
+"}                                                                        \n"
+"__kernel void UPSAMPLE_H1V2_RGBA       (__global uchar  *src,            \n"
+"                                        __global uchar4 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+"  uint    globalIdx = get_global_id(0);                                  \n"
+"  uint    localIdx =  get_local_id(0);                                   \n"
+"  uint    transOffset = ((localIdx >> 4) << 3) + (localIdx & 0x07);      \n"
+"  uchar   dataInY = src[globalIdx / 128 * 256 + localIdx];               \n"
+"  uchar   imgR, imgG, imgB,imgA;                                         \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx >> 7) % mcu_width;                                      \n"
+"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"                                                                         \n"
+"  if (localIdx < 64)                                                     \n"
+"  {                                                                      \n"
+"    cb_cache[localIdx] = src[globalIdx / 128 * 256 + 128 + localIdx];    \n"
+"    cr_cache[localIdx] = src[globalIdx / 128 * 256 + 192 + localIdx];    \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  imgB = convert_uchar_sat(dataInY  +                                    \n"
+"    (((int)91881 * (cr_cache[transOffset] - 128) + (int)32768) >> 16));  \n"
+"  imgG = convert_uchar_sat(dataInY +                                     \n"
+"    ((((int)32768 - (int)22554 * (cb_cache[transOffset] - 128))          \n"
+"    - ((int)46802 * (cr_cache[transOffset] - 128))) >> 16));             \n"
+"  imgR = convert_uchar_sat(dataInY  +                                    \n"
+"    (((int)116130 * (cb_cache[transOffset] - 128) + (int)32768) >> 16)); \n"
+"                                                                         \n"
+"  inter[localIdx * 4+ 0] = imgB;                                         \n"
+"  inter[localIdx * 4+ 1] = imgG;                                         \n"
+"  inter[localIdx * 4+ 2] = imgR;                                         \n"
+"  inter[localIdx * 4+ 3] = imgA;                                         \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 128)                                                    \n"
+"    dst[y * mcu_width * 128 + x * 8 + localIdx % 8 +                     \n"
+"      localIdx / 8 * mcu_width * 8] = vload4(localIdx, inter);           \n"
+"}                                                                        \n"
+"                                                                         \n"
+"__kernel void UPSAMPLE_H2V1_RGBA            (__global uchar  *src,       \n"
+"                                        __global uchar8 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        __local  uchar2 *cb_upsample,    \n"
+"                                        __local  uchar2 *cr_upsample,    \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+"  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    localIdx    = get_local_id (0);                                \n"
+"  uint    transOffset =                                                  \n"
+"    ((localIdx >> 2) << 2) - (localIdx >> 5) * 60 + localIdx;            \n"
+"  uchar   dataInCbLeft, dataInCrLeft, dataInCbRight, dataInCrRight;      \n"
+"  uchar2  dataInY  = vload2(globalIdx / 64 * 128 + localIdx, src);       \n"
+"  uchar   dataInCb = cb_cache[localIdx] =                                \n"
+"    src[globalIdx / 64 * 256 + 128 + localIdx];                          \n"
+"  uchar   dataInCr = cr_cache[localIdx] =                                \n"
+"    src[globalIdx / 64 * 256 + 192 + localIdx];                          \n"
+"  uchar2  imgR, imgG, imgB,imgA;                                         \n"
+"  int     valueY,valueCb, valueCr;                                       \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx >> 6) % mcu_width;                                      \n"
+"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  cb_upsample[localIdx].x = dataInCb;                                    \n"
+"  cb_upsample[localIdx].y = dataInCb;                                    \n"
+"  cr_upsample[localIdx].x = dataInCr;                                    \n"
+"  cr_upsample[localIdx].y = dataInCr;                                    \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  valueY = convert_int(dataInY.x);                                       \n"
+"  valueCb = convert_int(cb_upsample[transOffset].x);                     \n"
+"  valueCr = convert_int(cr_upsample[transOffset].x);                     \n"
+"                                                                         \n"
+"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.y);                                      \n"
+"  valueCb = convert_int(cb_upsample[transOffset].y);                     \n"
+"  valueCr = convert_int(cr_upsample[transOffset].y);                     \n"
+"                                                                         \n"
+"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  inter[transOffset * 8 + 0] = imgB.x;                                   \n"
+"  inter[transOffset * 8 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 8 + 2] = imgR.x;                                   \n"
+"  inter[transOffset * 8 + 3] = imgA.x;                                   \n"
+"  inter[transOffset * 8 + 4] = imgB.y;                                   \n"
+"  inter[transOffset * 8 + 5] = imgG.y;                                   \n"
+"  inter[transOffset * 8 + 6] = imgR.y;                                   \n"
+"  inter[transOffset * 8 + 7] = imgA.y;                                   \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 64)                                                     \n"
+"    dst[y * mcu_width * 64 + x * 8 + localIdx % 8 +                      \n"
+"      localIdx / 8 * mcu_width * 8] = vload8(localIdx, inter);           \n"
+"}                                                                        \n"
+"                                                                         \n"
+"__kernel void UPSAMPLE_H2V2_RGBA            (__global uchar  *src,       \n"
+"                                        __global uchar8 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        __local  uchar2 *cb_upsample,    \n"
+"                                        __local  uchar2 *cr_upsample,    \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+"  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    localIdx    = get_local_id (0);                                \n"
+"  uint    transOffset = localIdx - (localIdx >> 5) * 60 +                \n"
+"    (localIdx >> 2 << 2) + (localIdx >> 6) * 56;                         \n"
+"  uchar2  dataInY     = vload2(globalIdx/128 * 192 + localIdx, src);     \n"
+"  uchar2  imgR, imgG, imgB,imgA;                                         \n"
+"  int     valueY, valueCb, valueCr;                                      \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx >> 7) % mcu_width;                                      \n"
+"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"                                                                         \n"
+"  if (localIdx < 64)                                                     \n"
+"  {                                                                      \n"
+"    cb_cache[localIdx] = src[globalIdx/128 * 384 + 256 + localIdx];      \n"
+"    cr_cache[localIdx] = src[globalIdx/128 * 384 + 320 + localIdx];      \n"
+"    cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0] =         \n"
+"      cb_cache[localIdx];                                                \n"
+"    cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4] =         \n"
+"      cb_cache[localIdx];                                                \n"
+"    cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0] =         \n"
+"      cr_cache[localIdx];                                                \n"
+"    cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4] =         \n"
+"      cr_cache[localIdx];                                                \n"
+"  }                                                                      \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.x);                                      \n"
+"  valueCb = convert_int(cb_upsample[localIdx].x);                        \n"
+"  valueCr = convert_int(cr_upsample[localIdx].x);                        \n"
+"  imgA = 255;                                                            \n"
+"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.y);                                      \n"
+"  valueCb = convert_int(cb_upsample[localIdx].y);                        \n"
+"  valueCr = convert_int(cr_upsample[localIdx].y);                        \n"
+"                                                                         \n"
+"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  inter[transOffset * 8 + 0] = imgB.x;                                   \n"
+"  inter[transOffset * 8 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 8 + 2] = imgR.x;                                   \n"
+"  inter[transOffset * 8 + 3] = imgA.x;                                   \n"
+"  inter[transOffset * 8 + 4] = imgB.y;                                   \n"
+"  inter[transOffset * 8 + 5] = imgG.y;                                   \n"
+"  inter[transOffset * 8 + 6] = imgR.y;                                   \n"
+"  inter[transOffset * 8 + 7] = imgA.y;                                   \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 128)                                                    \n"
+"    dst[y * mcu_width * 128 + x * 8 + localIdx % 8                       \n"
+"      + localIdx / 8 * mcu_width * 8] = vload8(localIdx, inter);         \n"
+"                                                                         \n"
+"}                                                                        \n";
+
+static const char     * jocldec_cl_source5  =
+"__kernel void UPSAMPLE_H2V1_FANCY_RGBA      (__global uchar  *src,       \n"
+"                                        __global uchar8 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        __local  uchar2 *cb_upsample,    \n"
+"                                        __local  uchar2 *cr_upsample,    \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+"  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    localIdx    = get_local_id (0);                                \n"
+"  uint    transOffset =                                                  \n"
+"    ((localIdx >> 2) << 2) - (localIdx >> 5) * 60 + localIdx;            \n"
+"  uchar   dataInCbLeft, dataInCrLeft, dataInCbRight, dataInCrRight;      \n"
+"  uchar2  dataInY  = vload2(globalIdx / 64 * 128 + localIdx, src);       \n"
+"  uchar   dataInCb = cb_cache[localIdx] =                                \n"
+"    src[globalIdx / 64 * 256 + 128 + localIdx];                          \n"
+"  uchar   dataInCr = cr_cache[localIdx] =                                \n"
+"    src[globalIdx / 64 * 256 + 192 + localIdx];                          \n"
+"  uchar2  imgR, imgG, imgB,imgA;                                         \n"
+"  int     valueY,valueCb, valueCr;                                       \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx >> 6) % mcu_width;                                      \n"
+"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  if (!(localIdx & 0x07) && !(globalIdx / 64 % mcu_width)) {             \n"
+"    dataInCbLeft  = dataInCb -1;                                         \n"
+"    dataInCrLeft  = dataInCr -1;                                         \n"
+"    dataInCbRight = cb_cache[localIdx+1];                                \n"
+"    dataInCrRight = cr_cache[localIdx+1];                                \n"
+"  }                                                                      \n"
+"  else if (!(localIdx & 0x07) && (globalIdx / 64 % mcu_width)) {         \n"
+"    dataInCbLeft  = src[globalIdx / 64 * 256 -64 + localIdx - 57];       \n"
+"    dataInCrLeft  = src[globalIdx / 64 * 256 + localIdx - 57];           \n"
+"    dataInCbRight = cb_cache[localIdx+1];                                \n"
+"    dataInCrRight = cr_cache[localIdx+1];                                \n"
+"  }                                                                      \n"
+"  else if ((localIdx & 0x07) == 7 &&                                     \n"
+"           (globalIdx / 64 % mcu_width) == (mcu_width - 1)) {            \n"
+"    dataInCbLeft  = cb_cache[localIdx-1];                                \n"
+"    dataInCrLeft  = cr_cache[localIdx-1];                                \n"
+"    dataInCbRight = dataInCb -2;                                         \n"
+"    dataInCrRight = dataInCr -2;                                         \n"
+"  }                                                                      \n"
+"  else if ((localIdx & 0x07) == 7 &&                                     \n"
+"           (globalIdx / 64 % mcu_width) != (mcu_width - 1)) {            \n"
+"    dataInCbLeft  = cb_cache[localIdx-1];                                \n"
+"    dataInCrLeft  = cr_cache[localIdx-1];                                \n"
+"    dataInCbRight = src[globalIdx / 64 * 256 + localIdx + 57 + 320];     \n"
+"    dataInCrRight = src[globalIdx / 64 * 256 + localIdx + 57 + 384];     \n"
+"  }                                                                      \n"
+"  else {                                                                 \n"
+"    dataInCbLeft  = cb_cache[localIdx-1];                                \n"
+"    dataInCrLeft  = cr_cache[localIdx-1];                                \n"
+"    dataInCbRight = cb_cache[localIdx+1];                                \n"
+"    dataInCrRight = cr_cache[localIdx+1];                                \n"
+"  }                                                                      \n"
+"                                                                         \n"
+"  cb_upsample[localIdx].x = (dataInCb * 3 + dataInCbLeft  + 1) >> 2;     \n"
+"  cb_upsample[localIdx].y = (dataInCb * 3 + dataInCbRight + 2) >> 2;     \n"
+"  cr_upsample[localIdx].x = (dataInCr * 3 + dataInCrLeft  + 1) >> 2;     \n"
+"  cr_upsample[localIdx].y = (dataInCr * 3 + dataInCrRight + 2) >> 2;     \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  imgA = 255;                                                            \n"
+"  valueY = convert_int(dataInY.x);                                       \n"
+"  valueCb = convert_int(cb_upsample[transOffset].x);                     \n"
+"  valueCr = convert_int(cr_upsample[transOffset].x);                     \n"
+"                                                                         \n"
+"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.y);                                      \n"
+"  valueCb = convert_int(cb_upsample[transOffset].y);                     \n"
+"  valueCr = convert_int(cr_upsample[transOffset].y);                     \n"
+"                                                                         \n"
+"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  inter[transOffset * 8 + 0] = imgB.x;                                   \n"
+"  inter[transOffset * 8 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 8 + 2] = imgR.x;                                   \n"
+"  inter[transOffset * 8 + 3] = imgA.x;                                   \n"
+"  inter[transOffset * 8 + 4] = imgB.y;                                   \n"
+"  inter[transOffset * 8 + 5] = imgG.y;                                   \n"
+"  inter[transOffset * 8 + 6] = imgR.y;                                   \n"
+"  inter[transOffset * 8 + 7] = imgA.y;                                   \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 64)                                                     \n"
+"    dst[y * mcu_width * 64 + x * 8 + localIdx % 8 +                      \n"
+"      localIdx / 8 * mcu_width * 8] = vload8(localIdx, inter);           \n"
+"}                                                                        \n"
+"__kernel void UPSAMPLE_H2V2_FANCY_RGBA     (__global uchar  *src,        \n"
+"                                        __global uchar8 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        __local  uchar2 *cb_upsample,    \n"
+"                                        __local  uchar2 *cr_upsample,    \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+/*"  uint   globalIdx   = get_global_id(0);                                 \n"
+"  uint   localIdx    = get_local_id (0);                                 \n"
+"  uint   transOffset = localIdx - (localIdx >> 5) * 60 +                 \n"
+"    (localIdx >> 2 << 2) + (localIdx >> 6) * 56;                         \n"
+"  uchar2 dataInY     = vload2(globalIdx/128 * 192 + localIdx, src);      \n"
+"  uchar2 imgR, imgG, imgB,imgA;                                          \n"
+"  int    valueY, valueCb, valueCr;                                       \n"
+"  uint   x, y;                                                           \n"
+"  int    dataInTopCb, dataInBottomCb, dataInRightCb, dataInLeftCb;       \n"
+"  int    dataInLeftTopCb, dataInRightTopCb;                              \n"
+"  int    dataInLeftBottomCb, dataInRightBottomCb;                        \n"
+"  int    dataInTopCr, dataInBottomCr, dataInRightCr, dataInLeftCr;       \n"
+"  int    dataInLeftTopCr, dataInRightTopCr;                              \n"
+"  int    dataInLeftBottomCr, dataInRightBottomCr;                        \n"
+"                                                                         \n"
+"  uchar   dataInCb ,dataInCr;                                            \n"
+"  x = (globalIdx >> 7) % mcu_width;                                      \n"
+"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"                                                                         \n"
+"  if (localIdx < 64)                                                     \n"
+"  {                                                                      \n"
+"    cb_cache[localIdx] = src[globalIdx/128 * 384 + 256 + localIdx];      \n"
+"    cr_cache[localIdx] = src[globalIdx/128 * 384 + 320 + localIdx];      \n"
+"  }                                                                      \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 64)                                                     \n"
+"  {                                                                      \n"
+"  dataInCb = cb_cache[localIdx];                                         \n"
+"  dataInCr = cr_cache[localIdx];                                         \n"
+"                                                                         \n"
+"  dataInTopCb    = src[globalIdx/128 * 384 + 256 + localIdx - 8];        \n"
+"  dataInBottomCb = src[globalIdx/128 * 384 + 256 + localIdx + 8];        \n"
+"  dataInRightCb  = src[globalIdx/128 * 384 + 256 + localIdx + 1];        \n"
+"  dataInLeftCb   = src[globalIdx/128 * 384 + 256 + localIdx - 1];        \n"
+"  dataInLeftTopCb = src[globalIdx/128 * 384 + 256 + localIdx - 9];       \n"
+"  dataInRightTopCb = src[globalIdx/128 * 384 + 256 + localIdx - 7];      \n"
+"  dataInLeftBottomCb = src[globalIdx/128 * 384 + 256 + localIdx + 7];    \n"
+"  dataInRightBottomCb = src[globalIdx/128 * 384 + 256 + localIdx + 9];   \n"
+"                                                                         \n"
+"  dataInTopCr    = src[globalIdx/128 * 384 + 320 + localIdx - 8];        \n"
+"  dataInBottomCr = src[globalIdx/128 * 384 + 320 + localIdx + 8];        \n"
+"  dataInRightCr  = src[globalIdx/128 * 384 + 320 + localIdx + 1];        \n"
+"  dataInLeftCr   = src[globalIdx/128 * 384 + 320 + localIdx - 1];        \n"
+"  dataInLeftTopCr = src[globalIdx/128 * 384 + 320 + localIdx - 9];       \n"
+"  dataInRightTopCr = src[globalIdx/128 * 384 + 320 + localIdx - 7];      \n"
+"  dataInLeftBottomCr = src[globalIdx/128 * 384 + 320 + localIdx + 7];    \n"
+"  dataInRightBottomCr = src[globalIdx/128 * 384 + 320 + localIdx + 9];   \n"
+"                                                                         \n"
+"  if (globalIdx == 0) {                                                  \n"
+"    dataInTopCb        = dataInCb;                                       \n"
+"    dataInLeftCb       = dataInCb;                                       \n"
+"    dataInLeftTopCb    = dataInCb;                                       \n"
+"    dataInRightTopCb   = dataInRightCb;                                  \n"
+"    dataInLeftBottomCb = dataInBottomCb;                                 \n"
+"                                                                         \n"
+"    dataInTopCr        = dataInCr;                                       \n"
+"    dataInLeftCr       = dataInCr;                                       \n"
+"    dataInLeftTopCr    = dataInCr;                                       \n"
+"    dataInRightTopCr   = dataInRightCr;                                  \n"
+"    dataInLeftBottomCr = dataInBottomCr;                                 \n"
+"  }                                                                      \n"
+"  else if (globalIdx == get_global_size(0) - 65) {                       \n"
+"    dataInBottomCb      = dataInCb;                                      \n"
+"    dataInRightCb       = dataInCb;                                      \n"
+"    dataInRightTopCb    = dataInTopCb;                                   \n"
+"    dataInLeftBottomCb  = dataInLeftCb;                                  \n"
+"    dataInRightBottomCb = dataInBottomCb;                                \n"
+"                                                                         \n"
+"    dataInBottomCr      = dataInCr;                                      \n"
+"    dataInRightCr       = dataInCr;                                      \n"
+"    dataInRightTopCr    = dataInRightCr;                                 \n"
+"    dataInLeftBottomCr  = dataInLeftCr;                                  \n"
+"    dataInRightBottomCr = dataInBottomCr;                                \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 % mcu_width) &&                             \n"
+"    ((globalIdx / 128 / mcu_width) ==                                    \n"
+"    (get_global_size(0) /128 /mcu_width - 1)) && (localIdx == 56))  {    \n"
+"    dataInBottomCb      = dataInCb;                                      \n"
+"    dataInLeftCb        = dataInCb;                                      \n"
+"    dataInLeftTopCb     = dataInTopCb;                                   \n"
+"    dataInLeftBottomCb  = dataInBottomCb;                                \n"
+"    dataInRightBottomCb = dataInRightCb;                                 \n"
+"                                                                         \n"
+"    dataInBottomCr      = dataInCr;                                      \n"
+"    dataInLeftCr        = dataInCr;                                      \n"
+"    dataInLeftTopCr     = dataInTopCr;                                   \n"
+"    dataInLeftBottomCr  = dataInBottomCr;                                \n"
+"    dataInRightBottomCr = dataInRightCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) == (mcu_width - 1) &&           \n"
+"    (!(globalIdx / 128 / mcu_width)) && (localIdx == 7)){                \n"
+"    dataInTopCb         = dataInCb;                                      \n"
+"    dataInRightCb       = dataInCb;                                      \n"
+"    dataInLeftTopCb     = dataInLeftCb;                                  \n"
+"    dataInRightTopCb    = dataInTopCb;                                   \n"
+"    dataInRightBottomCb = dataInBottomCb;                                \n"
+"                                                                         \n"
+"    dataInTopCr         = dataInCr;                                      \n"
+"    dataInRightCr       = dataInCr;                                      \n"
+"    dataInLeftTopCr     = dataInLeftCr;                                  \n"
+"    dataInRightTopCr    = dataInTopCr;                                   \n"
+"    dataInRightBottomCr = dataInBottomCr;                                \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) != (mcu_width - 1) &&           \n"
+"    (!(globalIdx / 128 / mcu_width)) && (localIdx == 7)){                \n"
+"    dataInTopCb         = dataInCb;                                      \n"
+"    dataInRightCb       = src[(globalIdx/128 + 1) * 384 + 256];          \n"
+"    dataInLeftTopCb     = dataInLeftCb;                                  \n"
+"    dataInRightTopCb    = dataInRightCb;                                 \n"
+"    dataInRightBottomCb = src[(globalIdx/128 + 1) * 384 + 264];          \n"
+"                                                                         \n"
+"    dataInTopCr         = dataInCr;                                      \n"
+"    dataInRightCr       = src[(globalIdx/128 + 1) * 384 + 320];          \n"
+"    dataInLeftTopCr     = dataInLeftCr;                                  \n"
+"    dataInRightTopCr    = dataInRightCr;                                 \n"
+"    dataInRightBottomCr = src[(globalIdx/128 + 1) * 384 + 328];          \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 / mcu_width) &&                             \n"
+"    (localIdx == 0) && globalIdx){                                       \n"
+"    dataInTopCb        = dataInCb;                                       \n"
+"    dataInLeftCb       = src[(globalIdx/128 - 1) * 384 + 263];           \n"
+"    dataInLeftTopCb    = dataInLeftCb;                                   \n"
+"    dataInRightTopCb   = dataInRightCb;                                  \n"
+"    dataInLeftBottomCb = src[(globalIdx/128 - 1) * 384 + 271];           \n"
+"                                                                         \n"
+"    dataInTopCr        = dataInCr;                                       \n"
+"    dataInLeftCr       = src[(globalIdx/128 - 1) * 384 + 327];           \n"
+"    dataInLeftTopCr    = dataInLeftCr;                                   \n"
+"    dataInRightTopCr   = dataInRightCr;                                  \n"
+"    dataInLeftBottomCr = src[(globalIdx/128 - 1) * 384 + 335];           \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 % mcu_width) &&                             \n"
+"    (globalIdx / 128 / mcu_width) !=                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 56))  {     \n"
+"    dataInBottomCb      = src[(globalIdx/128 + mcu_width) * 384 + 256];  \n"
+"    dataInLeftCb        = dataInCb;                                      \n"
+"    dataInLeftTopCb     = dataInTopCb;                                   \n"
+"    dataInLeftBottomCb  = dataInBottomCb;                                \n"
+"    dataInRightBottomCb = src[(globalIdx/128 + mcu_width) * 384 + 257];  \n"
+"                                                                         \n"
+"    dataInBottomCr      = src[(globalIdx/128 + mcu_width) * 384 + 320];  \n"
+"    dataInLeftCr        = dataInCr;                                      \n"
+"    dataInLeftTopCr     = dataInTopCr;                                   \n"
+"    dataInLeftBottomCr  = dataInBottomCr;                                \n"
+"    dataInRightBottomCr = src[(globalIdx/128 + mcu_width) * 384 + 321];  \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 % mcu_width) &&                             \n"
+"    (globalIdx / 128 / mcu_width) && (localIdx == 0))  {                 \n"
+"    dataInTopCb        = src[(globalIdx/128 - mcu_width) * 384 + 312];   \n"
+"    dataInLeftCb       = dataInCb;                                       \n"
+"    dataInLeftTopCb    = dataInTopCb;                                    \n"
+"    dataInRightTopCb   = src[(globalIdx/128 - mcu_width) * 384 + 313];   \n"
+"    dataInLeftBottomCb = dataInBottomCb;                                 \n"
+"                                                                         \n"
+"    dataInTopCr        = src[(globalIdx/128 - mcu_width) * 384 + 376];   \n"
+"    dataInLeftCr       = dataInCr;                                       \n"
+"    dataInLeftTopCr    = dataInTopCr;                                    \n"
+"    dataInRightTopCr   = src[(globalIdx/128 - mcu_width) * 384 + 377];   \n"
+"    dataInLeftBottomCr = dataInBottomCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) == (mcu_width - 1) &&           \n"
+"    (globalIdx / 128 / mcu_width) !=                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 63)){       \n"
+"    dataInBottomCb      = src[(globalIdx/128 + mcu_width) * 384 + 263];  \n"
+"    dataInRightCb       = dataInCb;                                      \n"
+"    dataInRightTopCb    = dataInTopCb;                                   \n"
+"    dataInLeftBottomCb  = src[(globalIdx/128 + mcu_width) * 384 + 262];  \n"
+"    dataInRightBottomCb = dataInBottomCb;                                \n"
+"                                                                         \n"
+"    dataInBottomCr      = src[(globalIdx/128 + mcu_width) * 384 + 327];  \n"
+"    dataInRightCr       = dataInCr;                                      \n"
+"    dataInRightTopCr    = dataInTopCr;                                   \n"
+"    dataInLeftBottomCr  = src[(globalIdx/128 + mcu_width) * 384 + 326];  \n"
+"    dataInRightBottomCr = dataInBottomCr;                                \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) == (mcu_width - 1) &&           \n"
+"     (globalIdx / 128 / mcu_width) && (localIdx == 7)) {                 \n"
+"    dataInTopCb         = src[(globalIdx/128 - mcu_width) * 384 + 319];  \n"
+"    dataInRightCb       = dataInCb;                                      \n"
+"    dataInLeftTopCb     = src[(globalIdx/128 - mcu_width) * 384 + 318];  \n"
+"    dataInRightTopCb    = dataInTopCb;                                   \n"
+"    dataInRightBottomCb = dataInBottomCb;                                \n"
+"                                                                         \n"
+"    dataInTopCr         = src[(globalIdx/128 - mcu_width) * 384 + 383];  \n"
+"    dataInRightCr       = dataInCr;                                      \n"
+"    dataInLeftTopCr     = src[(globalIdx/128 - mcu_width) * 384 + 382];  \n"
+"    dataInRightTopCr    = dataInTopCr;                                   \n"
+"    dataInRightBottomCr = dataInBottomCr;                                \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) != (mcu_width - 1) &&           \n"
+"    (globalIdx / 128 / mcu_width) ==                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 63))  {     \n"
+"    dataInBottomCb      = dataInCb;                                      \n"
+"    dataInRightCb       = src[(globalIdx/128 + 1) * 384 + 312];          \n"
+"    dataInRightTopCb    = src[(globalIdx/128 + 1) * 384 + 304];          \n"
+"    dataInLeftBottomCb  = dataInLeftCb;                                  \n"
+"    dataInRightBottomCb = dataInRightCb;                                 \n"
+"                                                                         \n"
+"    dataInBottomCr = dataInCr;                                           \n"
+"    dataInRightCr       = src[(globalIdx/128 + 1) * 384 + 376];          \n"
+"    dataInRightTopCr    = src[(globalIdx/128 + 1) * 384 + 368];          \n"
+"    dataInLeftBottomCr  = dataInLeftCr;                                  \n"
+"    dataInRightBottomCr = dataInRightCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) &&                              \n"
+"    (globalIdx / 128 / mcu_width) ==                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 56))  {     \n"
+"    dataInBottomCb      = dataInCb;                                      \n"
+"    dataInLeftCb        = src[(globalIdx/128 - 1) * 384 + 319];          \n"
+"    dataInLeftTopCb     = src[(globalIdx/128 - 1) * 384 + 311];          \n"
+"    dataInLeftBottomCb  = dataInLeftCb;                                  \n"
+"    dataInRightBottomCb = dataInRightCb;                                 \n"
+"                                                                         \n"
+"    dataInBottomCr      = dataInCr;                                      \n"
+"    dataInLeftCr        = src[(globalIdx/128 - 1) * 384 + 383];          \n"
+"    dataInLeftTopCr     = src[(globalIdx/128 - 1) * 384 + 375];          \n"
+"    dataInLeftBottomCr  = dataInLeftCr;                                  \n"
+"    dataInRightBottomCr = dataInRightCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width)&&                               \n"
+"    (globalIdx / 128 / mcu_width) !=                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 56))  {     \n"
+"    dataInBottomCb      = src[(globalIdx/128 + mcu_width) * 384 + 256];  \n"
+"    dataInLeftCb        = src[(globalIdx/128 - 1) * 384 + 319];          \n"
+"    dataInLeftTopCb     = src[(globalIdx/128 - 1) * 384 + 311];          \n"
+"    dataInLeftBottomCb  = src[(globalIdx/128 + mcu_width- 1)* 384 + 263];\n"
+"    dataInRightBottomCb = src[(globalIdx/128 + mcu_width) * 384 + 257];  \n"
+"                                                                         \n"
+"    dataInBottomCr      = src[(globalIdx/128 + mcu_width) * 384 + 320];  \n"
+"    dataInLeftCr        = src[(globalIdx/128 - 1) * 384 + 383];          \n"
+"    dataInLeftTopCr     = src[(globalIdx/128 - 1) * 384 + 375];          \n"
+"    dataInLeftBottomCr  = src[(globalIdx/128 + mcu_width- 1)* 384 + 327];\n"
+"    dataInRightBottomCr = src[(globalIdx/128 + mcu_width) * 384 + 321];  \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) != (mcu_width - 1) &&           \n"
+"    (globalIdx / 128 / mcu_width) !=                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 63))  {     \n"
+"    dataInBottomCb      = src[(globalIdx/128 + mcu_width) * 384 + 263];  \n"
+"    dataInRightCb       = src[(globalIdx/128 + 1) * 384 + 312];          \n"
+"    dataInRightTopCb    = src[(globalIdx/128 + 1) * 384 + 304];          \n"
+"    dataInLeftBottomCb  = src[(globalIdx/128 + mcu_width) * 384 + 262];  \n"
+"    dataInRightBottomCb = src[(globalIdx/128 + mcu_width+ 1)* 384 + 256];\n"
+"                                                                         \n"
+"    dataInBottomCr      = src[(globalIdx/128 + mcu_width) * 384 + 327];  \n"
+"    dataInRightCr       = src[(globalIdx/128 + 1) * 384 + 376];          \n"
+"    dataInRightTopCr    = src[(globalIdx/128 + 1) * 384 + 368];          \n"
+"    dataInLeftBottomCr  = src[(globalIdx/128 + mcu_width) * 384 + 326];  \n"
+"    dataInRightBottomCr = src[(globalIdx/128 + mcu_width+ 1)* 384 + 320];\n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) != (mcu_width - 1) &&           \n"
+"     (globalIdx / 128 / mcu_width) && (localIdx == 7)){                  \n"
+"    dataInTopCb         = src[(globalIdx/128 - mcu_width) * 384 + 319];  \n"
+"    dataInRightCb       = src[(globalIdx/128 + 1) * 384 + 256];          \n"
+"    dataInLeftTopCb     = src[(globalIdx/128 - mcu_width) * 384 + 318];  \n"
+"    dataInRightTopCb    = src[(globalIdx/128 - mcu_width+ 1)* 384 + 312];\n"
+"    dataInRightBottomCb = src[(globalIdx/128 + 1) * 384 + 264];          \n"
+"                                                                         \n"
+"    dataInTopCr         = src[(globalIdx/128 - mcu_width) * 384 + 383];  \n"
+"    dataInRightCr       = src[(globalIdx/128 + 1) * 384 + 320];          \n"
+"    dataInLeftTopCr     = src[(globalIdx/128 - mcu_width) * 384 + 382];  \n"
+"    dataInRightTopCr    = src[(globalIdx/128 - mcu_width+ 1)* 384 + 376];\n"
+"    dataInRightBottomCr = src[(globalIdx/128 + 1) * 384 + 320 + 8];      \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 / mcu_width) && (localIdx == 0) &&           \n"
+"     (globalIdx / 128 % mcu_width)){                                     \n"
+"    dataInTopCb         = src[(globalIdx/128 - mcu_width) * 384 + 312];  \n"
+"    dataInLeftCb        = src[(globalIdx/128 - 1) * 384 + 256 + 7];      \n"
+"    dataInLeftTopCb     = src[(globalIdx/128 - mcu_width- 1)* 384 + 319];\n"
+"    dataInRightTopCb    = src[(globalIdx/128 - mcu_width) * 384 + 313];  \n"
+"    dataInLeftBottomCb  = src[(globalIdx/128 - 1) * 384 + 271];          \n"
+"                                                                         \n"
+"    dataInTopCr         = src[(globalIdx/128 - mcu_width) * 384 + 376];  \n"
+"    dataInLeftCr        = src[(globalIdx/128 - 1) * 384 + 327];          \n"
+"    dataInLeftTopCr     = src[(globalIdx/128 - mcu_width- 1)* 384 + 383];\n"
+"    dataInRightTopCr    = src[(globalIdx/128 - mcu_width) * 384 + 377];  \n"
+"    dataInLeftBottomCr  = src[(globalIdx/128 - 1) * 384 + 320 + 15];     \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) == (mcu_width - 1) &&           \n"
+"      (localIdx % 8 == 7) && localIdx != 7 && localIdx != 63) {          \n"
+"    dataInRightCb       = dataInCb;                                      \n"
+"    dataInRightTopCb    = dataInTopCb;                                   \n"
+"    dataInRightBottomCb = dataInBottomCb;                                \n"
+"                                                                         \n"
+"    dataInRightCr       = dataInCr;                                      \n"
+"    dataInRightTopCr    = dataInTopCr;                                   \n"
+"    dataInRightBottomCr = dataInBottomCr;                                \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 / mcu_width) && !(localIdx / 8)&&           \n"
+"      localIdx != 7 && localIdx != 0 ){                                  \n"
+"    dataInTopCb      = dataInCb;                                         \n"
+"    dataInLeftTopCb  = dataInLeftCb;                                     \n"
+"    dataInRightTopCb = dataInRightCb;                                    \n"
+"                                                                         \n"
+"    dataInTopCr      = dataInCr;                                         \n"
+"    dataInLeftTopCr  = dataInLeftCr;                                     \n"
+"    dataInRightTopCr = dataInRightCr;                                    \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 % mcu_width) && !(localIdx & 0x07) &&       \n"
+"    (localIdx != 0) && (localIdx != 56))  {                              \n"
+"    dataInLeftCb       = dataInCb;                                       \n"
+"    dataInLeftTopCb    = dataInTopCb;                                    \n"
+"    dataInLeftBottomCb = dataInBottomCb;                                 \n"
+"                                                                         \n"
+"    dataInLeftCr       = dataInCr;                                       \n"
+"    dataInLeftTopCr    = dataInTopCr;                                    \n"
+"    dataInLeftBottomCr = dataInBottomCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((localIdx / 8 == 7) &&                                        \n"
+"    (globalIdx / 128 / mcu_width) ==                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) &&                          \n"
+"    (localIdx != 56) && (localIdx != 63))  {                             \n"
+"    dataInBottomCb      = dataInCb;                                      \n"
+"    dataInLeftBottomCb  = dataInLeftCb;                                  \n"
+"    dataInRightBottomCb = dataInRightCb;                                 \n"
+"                                                                         \n"
+"    dataInBottomCr      = dataInCr;                                      \n"
+"    dataInLeftBottomCr  = dataInLeftCr;                                  \n"
+"    dataInRightBottomCr = dataInRightCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) && !(localIdx & 0x07) &&        \n"
+"    (localIdx != 0) && (localIdx != 56))  {                              \n"
+"    dataInLeftCb       = src[(globalIdx/128- 1)*384 +256 +localIdx + 7]; \n"
+"    dataInLeftTopCb    = src[(globalIdx/128- 1)*384 +256 +localIdx - 1]; \n"
+"    dataInLeftBottomCb = src[(globalIdx/128- 1)*384 +256 +localIdx + 15];\n"
+"                                                                         \n"
+"    dataInLeftCr       = src[(globalIdx/128- 1)*384 +320 +localIdx + 7]; \n"
+"    dataInLeftTopCr    = src[(globalIdx/128- 1)*384 +320 +localIdx - 1]; \n"
+"    dataInLeftBottomCr = src[(globalIdx/128- 1)*384 +320 +localIdx + 15];\n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 / mcu_width) && !(localIdx / 8) &&           \n"
+"      localIdx != 7 && localIdx != 0 ){                                  \n"
+"    dataInTopCb       = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 312 + localIdx];                           \n"
+"    dataInLeftTopCb   = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 311 + localIdx];                           \n"
+"    dataInRightTopCb  = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 313 + localIdx];                           \n"
+"                                                                         \n"
+"    dataInTopCr       = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 376 + localIdx];                           \n"
+"    dataInLeftTopCr   = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 375 + localIdx];                           \n"
+"    dataInRightTopCr  = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 377 + localIdx];                           \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) != (mcu_width - 1) &&           \n"
+"      (localIdx % 8 == 7) &&                                             \n"
+"      localIdx != 7 && localIdx != 63) {                                 \n"
+"    dataInRightCb       = src[(globalIdx/128+ 1) * 384 + 249 + localIdx];\n"
+"    dataInRightTopCb    = src[(globalIdx/128+ 1) * 384 + 241 + localIdx];\n"
+"    dataInRightBottomCb = src[(globalIdx/128+ 1) * 384 + 257 + localIdx];\n"
+"                                                                         \n"
+"    dataInRightCr       = src[(globalIdx/128+ 1) * 384 + 313 + localIdx];\n"
+"    dataInRightTopCr    = src[(globalIdx/128+ 1) * 384 + 305 + localIdx];\n"
+"    dataInRightBottomCr = src[(globalIdx/128+ 1) * 384 + 321 + localIdx];\n"
+"  }                                                                      \n"
+"  else if ((localIdx / 8 == 7) &&                                        \n"
+"    (globalIdx / 128 / mcu_width) !=                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) &&                          \n"
+"    (localIdx != 56) && (localIdx != 63))  {                             \n"
+"    dataInBottomCb      = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 200 + localIdx];                         \n"
+"    dataInLeftBottomCb  = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 199 + localIdx];                         \n"
+"    dataInRightBottomCb = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 201 + localIdx];                         \n"
+"                                                                         \n"
+"    dataInBottomCr      = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 264 + localIdx];                         \n"
+"    dataInLeftBottomCr  = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 263 + localIdx];                         \n"
+"    dataInRightBottomCr = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 265 + localIdx];                         \n"
+"  }                                                                      \n"
+"                                                                         \n"
+"  cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0].x =         \n"
+"    ((dataInCb * 3 + dataInTopCb) * 3 +                                  \n"
+"    dataInLeftCb * 3 + dataInLeftTopCb + 8) >> 4;                        \n"
+"  cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0].y =         \n"
+"    ((dataInCb * 3 + dataInTopCb) * 3 +                                  \n"
+"    dataInRightCb * 3 + dataInRightTopCb + 7) >> 4;                      \n"
+"                                                                         \n"
+"  cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4].x =         \n"
+"    ((dataInCb * 3 + dataInBottomCb) * 3 +                               \n"
+"    dataInLeftCb * 3 + dataInLeftBottomCb + 8) >> 4;                     \n"
+"  cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4].y =         \n"
+"    ((dataInCb * 3 + dataInBottomCb) * 3 +                               \n"
+"    dataInRightCb * 3 + dataInRightBottomCb + 7) >> 4;                   \n"
+"                                                                         \n"
+"  cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0].x =         \n"
+"    ((dataInCr * 3 + dataInTopCr) * 3 +                                  \n"
+"    dataInLeftCr * 3 + dataInLeftTopCr + 8) >> 4;                        \n"
+"  cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0].y =         \n"
+"    ((dataInCr * 3 + dataInTopCr) * 3 +                                  \n"
+"    dataInRightCr * 3 + dataInRightTopCr + 7) >> 4;                      \n"
+"                                                                         \n"
+"  cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4].x =         \n"
+"    ((dataInCr * 3 + dataInBottomCr) * 3 +                               \n"
+"    dataInLeftCr * 3 + dataInLeftBottomCr + 8) >> 4;                     \n"
+"  cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4].y =         \n"
+"    ((dataInCr * 3 + dataInBottomCr) * 3 +                               \n"
+"    dataInRightCr * 3 + dataInRightBottomCr + 7) >> 4;                   \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.x);                                      \n"
+"  valueCb = convert_int(cb_upsample[localIdx].x);                        \n"
+"  valueCr = convert_int(cr_upsample[localIdx].x);                        \n"
+"                                                                         \n"
+"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.y);                                      \n"
+"  valueCb = convert_int(cb_upsample[localIdx].y);                        \n"
+"  valueCr = convert_int(cr_upsample[localIdx].y);                        \n"
+"                                                                         \n"
+"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  inter[transOffset * 8 + 0] = imgB.x;                                   \n"
+"  inter[transOffset * 8 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 8 + 2] = imgR.x;                                   \n"
+"  inter[transOffset * 8 + 3] = imgA.x;                                   \n"
+"  inter[transOffset * 8 + 4] = imgB.y;                                   \n"
+"  inter[transOffset * 8 + 5] = imgG.y;                                   \n"
+"  inter[transOffset * 8 + 6] = imgR.y;                                   \n"
+"  inter[transOffset * 8 + 7] = imgA.y;                                   \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 128)                                                    \n"
+"    dst[y * mcu_width * 128 + x * 8 + localIdx % 8                       \n"
+"      + localIdx / 8 * mcu_width * 8] = vload8(localIdx, inter);         \n"
+"                                                                         \n"*/
+"}                                                                        \n";
+static const char     * jocldec_cl_source6  =
+"__kernel void UPSAMPLE_H1V1_BGR            (__global uchar  *src,        \n"
+"                                        __global uchar4 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+"  uint    globalIdx = get_global_id(0);                                  \n"
+"  uint    localIdx  = get_local_id (0);                                  \n"
+"  uchar   dataInY   = src[globalIdx / 64 * 192 + localIdx];              \n"
+"  uchar   dataInCb  = src[globalIdx / 64 * 192 + 64 + localIdx];         \n"
+"  uchar   dataInCr  = src[globalIdx / 64 * 192 + 128 + localIdx];        \n"
+"  uchar   imgR, imgG, imgB;                                              \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx >> 6) % mcu_width;                                      \n"
+"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"                                                                         \n"
+"  imgB = convert_uchar_sat(                                              \n"
+"    dataInY  + (((int)91881 * (dataInCr - 128) + (int)32768) >> 16));    \n"
+"  imgG = convert_uchar_sat(                                              \n"
+"    dataInY + ((((int)32768 - (int)22554 * (dataInCb - 128))             \n"
+"    - ((int)46802 * (dataInCr - 128))) >> 16));                          \n"
+"  imgR = convert_uchar_sat(                                              \n"
+"    dataInY  + ((116130 * (dataInCb - 128) + 32768) >> 16));             \n"
+"                                                                         \n"
+"  inter[localIdx * 3 + 0] = imgR;                                        \n"
+"  inter[localIdx * 3 + 1] = imgG;                                        \n"
+"  inter[localIdx * 3 + 2] = imgB;                                        \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 48)                                                     \n"
+"    dst[y * mcu_width * 48 + x * 6 + localIdx % 6                        \n"
+"      + localIdx / 6 * mcu_width * 6] = vload4(localIdx, inter);         \n"
+"}                                                                        \n"
+"                                                                         \n"
+"__kernel void UPSAMPLE_H1V2_BGR            (__global uchar  *src,        \n"
+"                                        __global uchar4 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+"  uint    globalIdx = get_global_id(0);                                  \n"
+"  uint    localIdx =  get_local_id(0);                                   \n"
+"  uint    transOffset = ((localIdx >> 4) << 3) + (localIdx & 0x07);      \n"
+"  uchar   dataInY = src[globalIdx / 128 * 256 + localIdx];               \n"
+"  uchar   imgR, imgG, imgB;                                              \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx >> 7) % mcu_width;                                      \n"
+"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"                                                                         \n"
+"  if (localIdx < 64)                                                     \n"
+"  {                                                                      \n"
+"    cb_cache[localIdx] = src[globalIdx / 128 * 256 + 128 + localIdx];    \n"
+"    cr_cache[localIdx] = src[globalIdx / 128 * 256 + 192 + localIdx];    \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  imgB = convert_uchar_sat(dataInY  +                                    \n"
+"    (((int)91881 * (cr_cache[transOffset] - 128) + (int)32768) >> 16));  \n"
+"  imgG = convert_uchar_sat(dataInY +                                     \n"
+"    ((((int)32768 - (int)22554 * (cb_cache[transOffset] - 128))          \n"
+"    - ((int)46802 * (cr_cache[transOffset] - 128))) >> 16));             \n"
+"  imgR = convert_uchar_sat(dataInY  +                                    \n"
+"    (((int)116130 * (cb_cache[transOffset] - 128) + (int)32768) >> 16)); \n"
+"                                                                         \n"
+"  inter[localIdx * 3 + 0] = imgR;                                        \n"
+"  inter[localIdx * 3 + 1] = imgG;                                        \n"
+"  inter[localIdx * 3 + 2] = imgB;                                        \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 96)                                                     \n"
+"    dst[y * mcu_width * 96 + x * 6 + localIdx % 6 +                      \n"
+"      localIdx / 6 * mcu_width * 6] = vload4(localIdx, inter);           \n"
+"}                                                                        \n"
+"                                                                         \n"
+"__kernel void UPSAMPLE_H2V1_BGR            (__global uchar  *src,        \n"
+"                                        __global uchar8 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        __local  uchar2 *cb_upsample,    \n"
+"                                        __local  uchar2 *cr_upsample,    \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+"  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    localIdx    = get_local_id (0);                                \n"
+"  uint    transOffset =                                                  \n"
+"    ((localIdx >> 2) << 2) - (localIdx >> 5) * 60 + localIdx;            \n"
+"  uchar2  dataInY  = vload2(globalIdx / 64 * 128 + localIdx, src);       \n"
+"  uchar   dataInCb = cb_cache[localIdx] =                                \n"
+"    src[globalIdx / 64 * 256 + 128 + localIdx];                          \n"
+"  uchar   dataInCr = cr_cache[localIdx] =                                \n"
+"    src[globalIdx / 64 * 256 + 192 + localIdx];                          \n"
+"  uchar2  imgR, imgG, imgB;                                              \n"
+"  int     valueY,valueCb, valueCr;                                       \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx >> 6) % mcu_width;                                      \n"
+"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  cb_upsample[localIdx].x = dataInCb;                                    \n"
+"  cb_upsample[localIdx].y = dataInCb;                                    \n"
+"  cr_upsample[localIdx].x = dataInCr;                                    \n"
+"  cr_upsample[localIdx].y = dataInCr;                                    \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  valueY = convert_int(dataInY.x);                                       \n"
+"  valueCb = convert_int(cb_upsample[transOffset].x);                     \n"
+"  valueCr = convert_int(cr_upsample[transOffset].x);                     \n"
+"                                                                         \n"
+"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.y);                                      \n"
+"  valueCb = convert_int(cb_upsample[transOffset].y);                     \n"
+"  valueCr = convert_int(cr_upsample[transOffset].y);                     \n"
+"                                                                         \n"
+"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  inter[transOffset * 6 + 0] = imgR.x;                                   \n"
+"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 6 + 2] = imgB.x;                                   \n"
+"  inter[transOffset * 6 + 3] = imgR.y;                                   \n"
+"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
+"  inter[transOffset * 6 + 5] = imgB.y;                                   \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 48)                                                     \n"
+"    dst[y * mcu_width * 48 + x * 6 + localIdx % 6 +                      \n"
+"      localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);           \n"
+"}                                                                        \n"
+"                                                                         \n"
+"__kernel void UPSAMPLE_H2V2_BGR        (__global uchar  *src,            \n"
+"                                        __global uchar8 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        __local  uchar2 *cb_upsample,    \n"
+"                                        __local  uchar2 *cr_upsample,    \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+"  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    localIdx    = get_local_id (0);                                \n"
+"  uint    transOffset = localIdx - (localIdx >> 5) * 60 +                \n"
+"    (localIdx >> 2 << 2) + (localIdx >> 6) * 56;                         \n"
+"  uchar2  dataInY     = vload2(globalIdx/128 * 192 + localIdx, src);     \n"
+"  uchar2  imgR, imgG, imgB;                                              \n"
+"  int     valueY, valueCb, valueCr;                                      \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx >> 7) % mcu_width;                                      \n"
+"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"                                                                         \n"
+"  if (localIdx < 64)                                                     \n"
+"  {                                                                      \n"
+"    cb_cache[localIdx] = src[globalIdx/128 * 384 + 256 + localIdx];      \n"
+"    cr_cache[localIdx] = src[globalIdx/128 * 384 + 320 + localIdx];      \n"
+"    cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0] =         \n"
+"      cb_cache[localIdx];                                                \n"
+"    cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4] =         \n"
+"      cb_cache[localIdx];                                                \n"
+"    cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0] =         \n"
+"      cr_cache[localIdx];                                                \n"
+"    cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4] =         \n"
+"      cr_cache[localIdx];                                                \n"
+"  }                                                                      \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.x);                                      \n"
+"  valueCb = convert_int(cb_upsample[localIdx].x);                        \n"
+"  valueCr = convert_int(cr_upsample[localIdx].x);                        \n"
+"                                                                         \n"
+"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.y);                                      \n"
+"  valueCb = convert_int(cb_upsample[localIdx].y);                        \n"
+"  valueCr = convert_int(cr_upsample[localIdx].y);                        \n"
+"                                                                         \n"
+"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  inter[transOffset * 6 + 0] = imgR.x;                                   \n"
+"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 6 + 2] = imgB.x;                                   \n"
+"  inter[transOffset * 6 + 3] = imgR.y;                                   \n"
+"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
+"  inter[transOffset * 6 + 5] = imgB.y;                                   \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 96)                                                     \n"
+"    dst[y * mcu_width * 96 + x * 6 + localIdx % 6                        \n"
+"      + localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);         \n"
+"                                                                         \n"
+"}                                                                        \n";
+
+static const char     * jocldec_cl_source7  =
+"__kernel void UPSAMPLE_H2V1_FANCY_BGR   (__global uchar  *src,           \n"
+"                                        __global uchar8 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        __local  uchar2 *cb_upsample,    \n"
+"                                        __local  uchar2 *cr_upsample,    \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+"  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    localIdx    = get_local_id (0);                                \n"
+"  uint    transOffset =                                                  \n"
+"    ((localIdx >> 2) << 2) - (localIdx >> 5) * 60 + localIdx;            \n"
+"  uchar   dataInCbLeft, dataInCrLeft, dataInCbRight, dataInCrRight;      \n"
+"  uchar2  dataInY  = vload2(globalIdx / 64 * 128 + localIdx, src);       \n"
+"  uchar   dataInCb = cb_cache[localIdx] =                                \n"
+"    src[globalIdx / 64 * 256 + 128 + localIdx];                          \n"
+"  uchar   dataInCr = cr_cache[localIdx] =                                \n"
+"    src[globalIdx / 64 * 256 + 192 + localIdx];                          \n"
+"  uchar2  imgR, imgG, imgB;                                              \n"
+"  int     valueY,valueCb, valueCr;                                       \n"
+"  uint    x, y;                                                          \n"
+"                                                                         \n"
+"  x = (globalIdx >> 6) % mcu_width;                                      \n"
+"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  if (!(localIdx & 0x07) && !(globalIdx / 64 % mcu_width)) {             \n"
+"    dataInCbLeft  = dataInCb -1;                                         \n"
+"    dataInCrLeft  = dataInCr -1;                                         \n"
+"    dataInCbRight = cb_cache[localIdx+1];                                \n"
+"    dataInCrRight = cr_cache[localIdx+1];                                \n"
+"  }                                                                      \n"
+"  else if (!(localIdx & 0x07) && (globalIdx / 64 % mcu_width)) {         \n"
+"    dataInCbLeft  = src[globalIdx / 64 * 256 -64 + localIdx - 57];       \n"
+"    dataInCrLeft  = src[globalIdx / 64 * 256 + localIdx - 57];           \n"
+"    dataInCbRight = cb_cache[localIdx+1];                                \n"
+"    dataInCrRight = cr_cache[localIdx+1];                                \n"
+"  }                                                                      \n"
+"  else if ((localIdx & 0x07) == 7 &&                                     \n"
+"           (globalIdx / 64 % mcu_width) == (mcu_width - 1)) {            \n"
+"    dataInCbLeft  = cb_cache[localIdx-1];                                \n"
+"    dataInCrLeft  = cr_cache[localIdx-1];                                \n"
+"    dataInCbRight = dataInCb -2;                                         \n"
+"    dataInCrRight = dataInCr -2;                                         \n"
+"  }                                                                      \n"
+"  else if ((localIdx & 0x07) == 7 &&                                     \n"
+"           (globalIdx / 64 % mcu_width) != (mcu_width - 1)) {            \n"
+"    dataInCbLeft  = cb_cache[localIdx-1];                                \n"
+"    dataInCrLeft  = cr_cache[localIdx-1];                                \n"
+"    dataInCbRight = src[globalIdx / 64 * 256 + localIdx + 57 + 320];     \n"
+"    dataInCrRight = src[globalIdx / 64 * 256 + localIdx + 57 + 384];     \n"
+"  }                                                                      \n"
+"  else {                                                                 \n"
+"    dataInCbLeft  = cb_cache[localIdx-1];                                \n"
+"    dataInCrLeft  = cr_cache[localIdx-1];                                \n"
+"    dataInCbRight = cb_cache[localIdx+1];                                \n"
+"    dataInCrRight = cr_cache[localIdx+1];                                \n"
+"  }                                                                      \n"
+"                                                                         \n"
+"  cb_upsample[localIdx].x = (dataInCb * 3 + dataInCbLeft  + 1) >> 2;     \n"
+"  cb_upsample[localIdx].y = (dataInCb * 3 + dataInCbRight + 2) >> 2;     \n"
+"  cr_upsample[localIdx].x = (dataInCr * 3 + dataInCrLeft  + 1) >> 2;     \n"
+"  cr_upsample[localIdx].y = (dataInCr * 3 + dataInCrRight + 2) >> 2;     \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  valueY = convert_int(dataInY.x);                                       \n"
+"  valueCb = convert_int(cb_upsample[transOffset].x);                     \n"
+"  valueCr = convert_int(cr_upsample[transOffset].x);                     \n"
+"                                                                         \n"
+"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.y);                                      \n"
+"  valueCb = convert_int(cb_upsample[transOffset].y);                     \n"
+"  valueCr = convert_int(cr_upsample[transOffset].y);                     \n"
+"                                                                         \n"
+"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  inter[transOffset * 6 + 0] = imgR.x;                                   \n"
+"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 6 + 2] = imgB.x;                                   \n"
+"  inter[transOffset * 6 + 3] = imgR.y;                                   \n"
+"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
+"  inter[transOffset * 6 + 5] = imgB.y;                                   \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 48)                                                     \n"
+"    dst[y * mcu_width * 48 + x * 6 + localIdx % 6 +                      \n"
+"      localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);           \n"
+"}                                                                        \n"
+"__kernel void UPSAMPLE_H2V2_FANCY_BGR      (__global uchar  *src,        \n"
+"                                        __global uchar8 *dst,            \n"
+"                                        __local  uchar  *inter,          \n"
+"                                        __local  uchar  *cb_cache,       \n"
+"                                        __local  uchar  *cr_cache,       \n"
+"                                        __local  uchar2 *cb_upsample,    \n"
+"                                        __local  uchar2 *cr_upsample,    \n"
+"                                        const    uint    mcu_width)      \n"
+"{                                                                        \n"
+/*"  uint   globalIdx   = get_global_id(0);                                 \n"
+"  uint   localIdx    = get_local_id (0);                                 \n"
+"  uint   transOffset = localIdx - (localIdx >> 5) * 60 +                 \n"
+"    (localIdx >> 2 << 2) + (localIdx >> 6) * 56;                         \n"
+"  uchar2 dataInY     = vload2(globalIdx/128 * 192 + localIdx, src);      \n"
+"  uchar2 imgR, imgG, imgB;                                               \n"
+"  int    valueY, valueCb, valueCr;                                       \n"
+"  uint   x, y;                                                           \n"
+"  int    dataInTopCb, dataInBottomCb, dataInRightCb, dataInLeftCb;       \n"
+"  int    dataInLeftTopCb, dataInRightTopCb;                              \n"
+"  int    dataInLeftBottomCb, dataInRightBottomCb;                        \n"
+"  int    dataInTopCr, dataInBottomCr, dataInRightCr, dataInLeftCr;       \n"
+"  int    dataInLeftTopCr, dataInRightTopCr;                              \n"
+"  int    dataInLeftBottomCr, dataInRightBottomCr;                        \n"
+"                                                                         \n"
+"  uchar   dataInCb ,dataInCr;                                            \n"
+"  x = (globalIdx >> 7) % mcu_width;                                      \n"
+"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"                                                                         \n"
+"  if (localIdx < 64)                                                     \n"
+"  {                                                                      \n"
+"    cb_cache[localIdx] = src[globalIdx/128 * 384 + 256 + localIdx];      \n"
+"    cr_cache[localIdx] = src[globalIdx/128 * 384 + 320 + localIdx];      \n"
+"  }                                                                      \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 64)                                                     \n"
+"  {                                                                      \n"
+"  dataInCb = cb_cache[localIdx];                                         \n"
+"  dataInCr = cr_cache[localIdx];                                         \n"
+"                                                                         \n"
+"  dataInTopCb    = src[globalIdx/128 * 384 + 256 + localIdx - 8];        \n"
+"  dataInBottomCb = src[globalIdx/128 * 384 + 256 + localIdx + 8];        \n"
+"  dataInRightCb  = src[globalIdx/128 * 384 + 256 + localIdx + 1];        \n"
+"  dataInLeftCb   = src[globalIdx/128 * 384 + 256 + localIdx - 1];        \n"
+"  dataInLeftTopCb = src[globalIdx/128 * 384 + 256 + localIdx - 9];       \n"
+"  dataInRightTopCb = src[globalIdx/128 * 384 + 256 + localIdx - 7];      \n"
+"  dataInLeftBottomCb = src[globalIdx/128 * 384 + 256 + localIdx + 7];    \n"
+"  dataInRightBottomCb = src[globalIdx/128 * 384 + 256 + localIdx + 9];   \n"
+"                                                                         \n"
+"  dataInTopCr    = src[globalIdx/128 * 384 + 320 + localIdx - 8];        \n"
+"  dataInBottomCr = src[globalIdx/128 * 384 + 320 + localIdx + 8];        \n"
+"  dataInRightCr  = src[globalIdx/128 * 384 + 320 + localIdx + 1];        \n"
+"  dataInLeftCr   = src[globalIdx/128 * 384 + 320 + localIdx - 1];        \n"
+"  dataInLeftTopCr = src[globalIdx/128 * 384 + 320 + localIdx - 9];       \n"
+"  dataInRightTopCr = src[globalIdx/128 * 384 + 320 + localIdx - 7];      \n"
+"  dataInLeftBottomCr = src[globalIdx/128 * 384 + 320 + localIdx + 7];    \n"
+"  dataInRightBottomCr = src[globalIdx/128 * 384 + 320 + localIdx + 9];   \n"
+"                                                                         \n"
+"  if (globalIdx == 0) {                                                  \n"
+"    dataInTopCb        = dataInCb;                                       \n"
+"    dataInLeftCb       = dataInCb;                                       \n"
+"    dataInLeftTopCb    = dataInCb;                                       \n"
+"    dataInRightTopCb   = dataInRightCb;                                  \n"
+"    dataInLeftBottomCb = dataInBottomCb;                                 \n"
+"                                                                         \n"
+"    dataInTopCr        = dataInCr;                                       \n"
+"    dataInLeftCr       = dataInCr;                                       \n"
+"    dataInLeftTopCr    = dataInCr;                                       \n"
+"    dataInRightTopCr   = dataInRightCr;                                  \n"
+"    dataInLeftBottomCr = dataInBottomCr;                                 \n"
+"  }                                                                      \n"
+"  else if (globalIdx == get_global_size(0) - 65) {                       \n"
+"    dataInBottomCb      = dataInCb;                                      \n"
+"    dataInRightCb       = dataInCb;                                      \n"
+"    dataInRightTopCb    = dataInTopCb;                                   \n"
+"    dataInLeftBottomCb  = dataInLeftCb;                                  \n"
+"    dataInRightBottomCb = dataInBottomCb;                                \n"
+"                                                                         \n"
+"    dataInBottomCr      = dataInCr;                                      \n"
+"    dataInRightCr       = dataInCr;                                      \n"
+"    dataInRightTopCr    = dataInRightCr;                                 \n"
+"    dataInLeftBottomCr  = dataInLeftCr;                                  \n"
+"    dataInRightBottomCr = dataInBottomCr;                                \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 % mcu_width) &&                             \n"
+"    ((globalIdx / 128 / mcu_width) ==                                    \n"
+"    (get_global_size(0) /128 /mcu_width - 1)) && (localIdx == 56))  {    \n"
+"    dataInBottomCb      = dataInCb;                                      \n"
+"    dataInLeftCb        = dataInCb;                                      \n"
+"    dataInLeftTopCb     = dataInTopCb;                                   \n"
+"    dataInLeftBottomCb  = dataInBottomCb;                                \n"
+"    dataInRightBottomCb = dataInRightCb;                                 \n"
+"                                                                         \n"
+"    dataInBottomCr      = dataInCr;                                      \n"
+"    dataInLeftCr        = dataInCr;                                      \n"
+"    dataInLeftTopCr     = dataInTopCr;                                   \n"
+"    dataInLeftBottomCr  = dataInBottomCr;                                \n"
+"    dataInRightBottomCr = dataInRightCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) == (mcu_width - 1) &&           \n"
+"    (!(globalIdx / 128 / mcu_width)) && (localIdx == 7)){                \n"
+"    dataInTopCb         = dataInCb;                                      \n"
+"    dataInRightCb       = dataInCb;                                      \n"
+"    dataInLeftTopCb     = dataInLeftCb;                                  \n"
+"    dataInRightTopCb    = dataInTopCb;                                   \n"
+"    dataInRightBottomCb = dataInBottomCb;                                \n"
+"                                                                         \n"
+"    dataInTopCr         = dataInCr;                                      \n"
+"    dataInRightCr       = dataInCr;                                      \n"
+"    dataInLeftTopCr     = dataInLeftCr;                                  \n"
+"    dataInRightTopCr    = dataInTopCr;                                   \n"
+"    dataInRightBottomCr = dataInBottomCr;                                \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) != (mcu_width - 1) &&           \n"
+"    (!(globalIdx / 128 / mcu_width)) && (localIdx == 7)){                \n"
+"    dataInTopCb         = dataInCb;                                      \n"
+"    dataInRightCb       = src[(globalIdx/128 + 1) * 384 + 256];          \n"
+"    dataInLeftTopCb     = dataInLeftCb;                                  \n"
+"    dataInRightTopCb    = dataInRightCb;                                 \n"
+"    dataInRightBottomCb = src[(globalIdx/128 + 1) * 384 + 264];          \n"
+"                                                                         \n"
+"    dataInTopCr         = dataInCr;                                      \n"
+"    dataInRightCr       = src[(globalIdx/128 + 1) * 384 + 320];          \n"
+"    dataInLeftTopCr     = dataInLeftCr;                                  \n"
+"    dataInRightTopCr    = dataInRightCr;                                 \n"
+"    dataInRightBottomCr = src[(globalIdx/128 + 1) * 384 + 328];          \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 / mcu_width) &&                             \n"
+"    (localIdx == 0) && globalIdx){                                       \n"
+"    dataInTopCb        = dataInCb;                                       \n"
+"    dataInLeftCb       = src[(globalIdx/128 - 1) * 384 + 263];           \n"
+"    dataInLeftTopCb    = dataInLeftCb;                                   \n"
+"    dataInRightTopCb   = dataInRightCb;                                  \n"
+"    dataInLeftBottomCb = src[(globalIdx/128 - 1) * 384 + 271];           \n"
+"                                                                         \n"
+"    dataInTopCr        = dataInCr;                                       \n"
+"    dataInLeftCr       = src[(globalIdx/128 - 1) * 384 + 327];           \n"
+"    dataInLeftTopCr    = dataInLeftCr;                                   \n"
+"    dataInRightTopCr   = dataInRightCr;                                  \n"
+"    dataInLeftBottomCr = src[(globalIdx/128 - 1) * 384 + 335];           \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 % mcu_width) &&                             \n"
+"    (globalIdx / 128 / mcu_width) !=                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 56))  {     \n"
+"    dataInBottomCb      = src[(globalIdx/128 + mcu_width) * 384 + 256];  \n"
+"    dataInLeftCb        = dataInCb;                                      \n"
+"    dataInLeftTopCb     = dataInTopCb;                                   \n"
+"    dataInLeftBottomCb  = dataInBottomCb;                                \n"
+"    dataInRightBottomCb = src[(globalIdx/128 + mcu_width) * 384 + 257];  \n"
+"                                                                         \n"
+"    dataInBottomCr      = src[(globalIdx/128 + mcu_width) * 384 + 320];  \n"
+"    dataInLeftCr        = dataInCr;                                      \n"
+"    dataInLeftTopCr     = dataInTopCr;                                   \n"
+"    dataInLeftBottomCr  = dataInBottomCr;                                \n"
+"    dataInRightBottomCr = src[(globalIdx/128 + mcu_width) * 384 + 321];  \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 % mcu_width) &&                             \n"
+"    (globalIdx / 128 / mcu_width) && (localIdx == 0))  {                 \n"
+"    dataInTopCb        = src[(globalIdx/128 - mcu_width) * 384 + 312];   \n"
+"    dataInLeftCb       = dataInCb;                                       \n"
+"    dataInLeftTopCb    = dataInTopCb;                                    \n"
+"    dataInRightTopCb   = src[(globalIdx/128 - mcu_width) * 384 + 313];   \n"
+"    dataInLeftBottomCb = dataInBottomCb;                                 \n"
+"                                                                         \n"
+"    dataInTopCr        = src[(globalIdx/128 - mcu_width) * 384 + 376];   \n"
+"    dataInLeftCr       = dataInCr;                                       \n"
+"    dataInLeftTopCr    = dataInTopCr;                                    \n"
+"    dataInRightTopCr   = src[(globalIdx/128 - mcu_width) * 384 + 377];   \n"
+"    dataInLeftBottomCr = dataInBottomCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) == (mcu_width - 1) &&           \n"
+"    (globalIdx / 128 / mcu_width) !=                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 63)){       \n"
+"    dataInBottomCb      = src[(globalIdx/128 + mcu_width) * 384 + 263];  \n"
+"    dataInRightCb       = dataInCb;                                      \n"
+"    dataInRightTopCb    = dataInTopCb;                                   \n"
+"    dataInLeftBottomCb  = src[(globalIdx/128 + mcu_width) * 384 + 262];  \n"
+"    dataInRightBottomCb = dataInBottomCb;                                \n"
+"                                                                         \n"
+"    dataInBottomCr      = src[(globalIdx/128 + mcu_width) * 384 + 327];  \n"
+"    dataInRightCr       = dataInCr;                                      \n"
+"    dataInRightTopCr    = dataInTopCr;                                   \n"
+"    dataInLeftBottomCr  = src[(globalIdx/128 + mcu_width) * 384 + 326];  \n"
+"    dataInRightBottomCr = dataInBottomCr;                                \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) == (mcu_width - 1) &&           \n"
+"     (globalIdx / 128 / mcu_width) && (localIdx == 7)) {                 \n"
+"    dataInTopCb         = src[(globalIdx/128 - mcu_width) * 384 + 319];  \n"
+"    dataInRightCb       = dataInCb;                                      \n"
+"    dataInLeftTopCb     = src[(globalIdx/128 - mcu_width) * 384 + 318];  \n"
+"    dataInRightTopCb    = dataInTopCb;                                   \n"
+"    dataInRightBottomCb = dataInBottomCb;                                \n"
+"                                                                         \n"
+"    dataInTopCr         = src[(globalIdx/128 - mcu_width) * 384 + 383];  \n"
+"    dataInRightCr       = dataInCr;                                      \n"
+"    dataInLeftTopCr     = src[(globalIdx/128 - mcu_width) * 384 + 382];  \n"
+"    dataInRightTopCr    = dataInTopCr;                                   \n"
+"    dataInRightBottomCr = dataInBottomCr;                                \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) != (mcu_width - 1) &&           \n"
+"    (globalIdx / 128 / mcu_width) ==                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 63))  {     \n"
+"    dataInBottomCb      = dataInCb;                                      \n"
+"    dataInRightCb       = src[(globalIdx/128 + 1) * 384 + 312];          \n"
+"    dataInRightTopCb    = src[(globalIdx/128 + 1) * 384 + 304];          \n"
+"    dataInLeftBottomCb  = dataInLeftCb;                                  \n"
+"    dataInRightBottomCb = dataInRightCb;                                 \n"
+"                                                                         \n"
+"    dataInBottomCr = dataInCr;                                           \n"
+"    dataInRightCr       = src[(globalIdx/128 + 1) * 384 + 376];          \n"
+"    dataInRightTopCr    = src[(globalIdx/128 + 1) * 384 + 368];          \n"
+"    dataInLeftBottomCr  = dataInLeftCr;                                  \n"
+"    dataInRightBottomCr = dataInRightCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) &&                              \n"
+"    (globalIdx / 128 / mcu_width) ==                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 56))  {     \n"
+"    dataInBottomCb      = dataInCb;                                      \n"
+"    dataInLeftCb        = src[(globalIdx/128 - 1) * 384 + 319];          \n"
+"    dataInLeftTopCb     = src[(globalIdx/128 - 1) * 384 + 311];          \n"
+"    dataInLeftBottomCb  = dataInLeftCb;                                  \n"
+"    dataInRightBottomCb = dataInRightCb;                                 \n"
+"                                                                         \n"
+"    dataInBottomCr      = dataInCr;                                      \n"
+"    dataInLeftCr        = src[(globalIdx/128 - 1) * 384 + 383];          \n"
+"    dataInLeftTopCr     = src[(globalIdx/128 - 1) * 384 + 375];          \n"
+"    dataInLeftBottomCr  = dataInLeftCr;                                  \n"
+"    dataInRightBottomCr = dataInRightCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width)&&                               \n"
+"    (globalIdx / 128 / mcu_width) !=                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 56))  {     \n"
+"    dataInBottomCb      = src[(globalIdx/128 + mcu_width) * 384 + 256];  \n"
+"    dataInLeftCb        = src[(globalIdx/128 - 1) * 384 + 319];          \n"
+"    dataInLeftTopCb     = src[(globalIdx/128 - 1) * 384 + 311];          \n"
+"    dataInLeftBottomCb  = src[(globalIdx/128 + mcu_width- 1)* 384 + 263];\n"
+"    dataInRightBottomCb = src[(globalIdx/128 + mcu_width) * 384 + 257];  \n"
+"                                                                         \n"
+"    dataInBottomCr      = src[(globalIdx/128 + mcu_width) * 384 + 320];  \n"
+"    dataInLeftCr        = src[(globalIdx/128 - 1) * 384 + 383];          \n"
+"    dataInLeftTopCr     = src[(globalIdx/128 - 1) * 384 + 375];          \n"
+"    dataInLeftBottomCr  = src[(globalIdx/128 + mcu_width- 1)* 384 + 327];\n"
+"    dataInRightBottomCr = src[(globalIdx/128 + mcu_width) * 384 + 321];  \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) != (mcu_width - 1) &&           \n"
+"    (globalIdx / 128 / mcu_width) !=                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) && (localIdx == 63))  {     \n"
+"    dataInBottomCb      = src[(globalIdx/128 + mcu_width) * 384 + 263];  \n"
+"    dataInRightCb       = src[(globalIdx/128 + 1) * 384 + 312];          \n"
+"    dataInRightTopCb    = src[(globalIdx/128 + 1) * 384 + 304];          \n"
+"    dataInLeftBottomCb  = src[(globalIdx/128 + mcu_width) * 384 + 262];  \n"
+"    dataInRightBottomCb = src[(globalIdx/128 + mcu_width+ 1)* 384 + 256];\n"
+"                                                                         \n"
+"    dataInBottomCr      = src[(globalIdx/128 + mcu_width) * 384 + 327];  \n"
+"    dataInRightCr       = src[(globalIdx/128 + 1) * 384 + 376];          \n"
+"    dataInRightTopCr    = src[(globalIdx/128 + 1) * 384 + 368];          \n"
+"    dataInLeftBottomCr  = src[(globalIdx/128 + mcu_width) * 384 + 326];  \n"
+"    dataInRightBottomCr = src[(globalIdx/128 + mcu_width+ 1)* 384 + 320];\n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) != (mcu_width - 1) &&           \n"
+"     (globalIdx / 128 / mcu_width) && (localIdx == 7)){                  \n"
+"    dataInTopCb         = src[(globalIdx/128 - mcu_width) * 384 + 319];  \n"
+"    dataInRightCb       = src[(globalIdx/128 + 1) * 384 + 256];          \n"
+"    dataInLeftTopCb     = src[(globalIdx/128 - mcu_width) * 384 + 318];  \n"
+"    dataInRightTopCb    = src[(globalIdx/128 - mcu_width+ 1)* 384 + 312];\n"
+"    dataInRightBottomCb = src[(globalIdx/128 + 1) * 384 + 264];          \n"
+"                                                                         \n"
+"    dataInTopCr         = src[(globalIdx/128 - mcu_width) * 384 + 383];  \n"
+"    dataInRightCr       = src[(globalIdx/128 + 1) * 384 + 320];          \n"
+"    dataInLeftTopCr     = src[(globalIdx/128 - mcu_width) * 384 + 382];  \n"
+"    dataInRightTopCr    = src[(globalIdx/128 - mcu_width+ 1)* 384 + 376];\n"
+"    dataInRightBottomCr = src[(globalIdx/128 + 1) * 384 + 320 + 8];      \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 / mcu_width) && (localIdx == 0) &&           \n"
+"     (globalIdx / 128 % mcu_width)){                                     \n"
+"    dataInTopCb         = src[(globalIdx/128 - mcu_width) * 384 + 312];  \n"
+"    dataInLeftCb        = src[(globalIdx/128 - 1) * 384 + 256 + 7];      \n"
+"    dataInLeftTopCb     = src[(globalIdx/128 - mcu_width- 1)* 384 + 319];\n"
+"    dataInRightTopCb    = src[(globalIdx/128 - mcu_width) * 384 + 313];  \n"
+"    dataInLeftBottomCb  = src[(globalIdx/128 - 1) * 384 + 271];          \n"
+"                                                                         \n"
+"    dataInTopCr         = src[(globalIdx/128 - mcu_width) * 384 + 376];  \n"
+"    dataInLeftCr        = src[(globalIdx/128 - 1) * 384 + 327];          \n"
+"    dataInLeftTopCr     = src[(globalIdx/128 - mcu_width- 1)* 384 + 383];\n"
+"    dataInRightTopCr    = src[(globalIdx/128 - mcu_width) * 384 + 377];  \n"
+"    dataInLeftBottomCr  = src[(globalIdx/128 - 1) * 384 + 320 + 15];     \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) == (mcu_width - 1) &&           \n"
+"      (localIdx % 8 == 7) && localIdx != 7 && localIdx != 63) {          \n"
+"    dataInRightCb       = dataInCb;                                      \n"
+"    dataInRightTopCb    = dataInTopCb;                                   \n"
+"    dataInRightBottomCb = dataInBottomCb;                                \n"
+"                                                                         \n"
+"    dataInRightCr       = dataInCr;                                      \n"
+"    dataInRightTopCr    = dataInTopCr;                                   \n"
+"    dataInRightBottomCr = dataInBottomCr;                                \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 / mcu_width) && !(localIdx / 8)&&           \n"
+"      localIdx != 7 && localIdx != 0 ){                                  \n"
+"    dataInTopCb      = dataInCb;                                         \n"
+"    dataInLeftTopCb  = dataInLeftCb;                                     \n"
+"    dataInRightTopCb = dataInRightCb;                                    \n"
+"                                                                         \n"
+"    dataInTopCr      = dataInCr;                                         \n"
+"    dataInLeftTopCr  = dataInLeftCr;                                     \n"
+"    dataInRightTopCr = dataInRightCr;                                    \n"
+"  }                                                                      \n"
+"  else if (!(globalIdx / 128 % mcu_width) && !(localIdx & 0x07) &&       \n"
+"    (localIdx != 0) && (localIdx != 56))  {                              \n"
+"    dataInLeftCb       = dataInCb;                                       \n"
+"    dataInLeftTopCb    = dataInTopCb;                                    \n"
+"    dataInLeftBottomCb = dataInBottomCb;                                 \n"
+"                                                                         \n"
+"    dataInLeftCr       = dataInCr;                                       \n"
+"    dataInLeftTopCr    = dataInTopCr;                                    \n"
+"    dataInLeftBottomCr = dataInBottomCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((localIdx / 8 == 7) &&                                        \n"
+"    (globalIdx / 128 / mcu_width) ==                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) &&                          \n"
+"    (localIdx != 56) && (localIdx != 63))  {                             \n"
+"    dataInBottomCb      = dataInCb;                                      \n"
+"    dataInLeftBottomCb  = dataInLeftCb;                                  \n"
+"    dataInRightBottomCb = dataInRightCb;                                 \n"
+"                                                                         \n"
+"    dataInBottomCr      = dataInCr;                                      \n"
+"    dataInLeftBottomCr  = dataInLeftCr;                                  \n"
+"    dataInRightBottomCr = dataInRightCr;                                 \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) && !(localIdx & 0x07) &&        \n"
+"    (localIdx != 0) && (localIdx != 56))  {                              \n"
+"    dataInLeftCb       = src[(globalIdx/128- 1)*384 +256 +localIdx + 7]; \n"
+"    dataInLeftTopCb    = src[(globalIdx/128- 1)*384 +256 +localIdx - 1]; \n"
+"    dataInLeftBottomCb = src[(globalIdx/128- 1)*384 +256 +localIdx + 15];\n"
+"                                                                         \n"
+"    dataInLeftCr       = src[(globalIdx/128- 1)*384 +320 +localIdx + 7]; \n"
+"    dataInLeftTopCr    = src[(globalIdx/128- 1)*384 +320 +localIdx - 1]; \n"
+"    dataInLeftBottomCr = src[(globalIdx/128- 1)*384 +320 +localIdx + 15];\n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 / mcu_width) && !(localIdx / 8) &&           \n"
+"      localIdx != 7 && localIdx != 0 ){                                  \n"
+"    dataInTopCb       = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 312 + localIdx];                           \n"
+"    dataInLeftTopCb   = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 311 + localIdx];                           \n"
+"    dataInRightTopCb  = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 313 + localIdx];                           \n"
+"                                                                         \n"
+"    dataInTopCr       = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 376 + localIdx];                           \n"
+"    dataInLeftTopCr   = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 375 + localIdx];                           \n"
+"    dataInRightTopCr  = src[(globalIdx/128 - mcu_width) *                \n"
+"                        384 + 377 + localIdx];                           \n"
+"  }                                                                      \n"
+"  else if ((globalIdx / 128 % mcu_width) != (mcu_width - 1) &&           \n"
+"      (localIdx % 8 == 7) &&                                             \n"
+"      localIdx != 7 && localIdx != 63) {                                 \n"
+"    dataInRightCb       = src[(globalIdx/128+ 1) * 384 + 249 + localIdx];\n"
+"    dataInRightTopCb    = src[(globalIdx/128+ 1) * 384 + 241 + localIdx];\n"
+"    dataInRightBottomCb = src[(globalIdx/128+ 1) * 384 + 257 + localIdx];\n"
+"                                                                         \n"
+"    dataInRightCr       = src[(globalIdx/128+ 1) * 384 + 313 + localIdx];\n"
+"    dataInRightTopCr    = src[(globalIdx/128+ 1) * 384 + 305 + localIdx];\n"
+"    dataInRightBottomCr = src[(globalIdx/128+ 1) * 384 + 321 + localIdx];\n"
+"  }                                                                      \n"
+"  else if ((localIdx / 8 == 7) &&                                        \n"
+"    (globalIdx / 128 / mcu_width) !=                                     \n"
+"    (get_global_size(0) /128 /mcu_width - 1) &&                          \n"
+"    (localIdx != 56) && (localIdx != 63))  {                             \n"
+"    dataInBottomCb      = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 200 + localIdx];                         \n"
+"    dataInLeftBottomCb  = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 199 + localIdx];                         \n"
+"    dataInRightBottomCb = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 201 + localIdx];                         \n"
+"                                                                         \n"
+"    dataInBottomCr      = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 264 + localIdx];                         \n"
+"    dataInLeftBottomCr  = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 263 + localIdx];                         \n"
+"    dataInRightBottomCr = src[(globalIdx/128 + mcu_width) *              \n"
+"                          384 + 265 + localIdx];                         \n"
+"  }                                                                      \n"
+"                                                                         \n"
+"  cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0].x =         \n"
+"    ((dataInCb * 3 + dataInTopCb) * 3 +                                  \n"
+"    dataInLeftCb * 3 + dataInLeftTopCb + 8) >> 4;                        \n"
+"  cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0].y =         \n"
+"    ((dataInCb * 3 + dataInTopCb) * 3 +                                  \n"
+"    dataInRightCb * 3 + dataInRightTopCb + 7) >> 4;                      \n"
+"                                                                         \n"
+"  cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4].x =         \n"
+"    ((dataInCb * 3 + dataInBottomCb) * 3 +                               \n"
+"    dataInLeftCb * 3 + dataInLeftBottomCb + 8) >> 4;                     \n"
+"  cb_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4].y =         \n"
+"    ((dataInCb * 3 + dataInBottomCb) * 3 +                               \n"
+"    dataInRightCb * 3 + dataInRightBottomCb + 7) >> 4;                   \n"
+"                                                                         \n"
+"  cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0].x =         \n"
+"    ((dataInCr * 3 + dataInTopCr) * 3 +                                  \n"
+"    dataInLeftCr * 3 + dataInLeftTopCr + 8) >> 4;                        \n"
+"  cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 0].y =         \n"
+"    ((dataInCr * 3 + dataInTopCr) * 3 +                                  \n"
+"    dataInRightCr * 3 + dataInRightTopCr + 7) >> 4;                      \n"
+"                                                                         \n"
+"  cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4].x =         \n"
+"    ((dataInCr * 3 + dataInBottomCr) * 3 +                               \n"
+"    dataInLeftCr * 3 + dataInLeftBottomCr + 8) >> 4;                     \n"
+"  cr_upsample[localIdx + localIdx%8/4*28+localIdx/32*32 + 4].y =         \n"
+"    ((dataInCr * 3 + dataInBottomCr) * 3 +                               \n"
+"    dataInRightCr * 3 + dataInRightBottomCr + 7) >> 4;                   \n"
+"  }                                                                      \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.x);                                      \n"
+"  valueCb = convert_int(cb_upsample[localIdx].x);                        \n"
+"  valueCr = convert_int(cr_upsample[localIdx].x);                        \n"
+"                                                                         \n"
+"  imgB.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.x  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.x  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  valueY  = convert_int(dataInY.y);                                      \n"
+"  valueCb = convert_int(cb_upsample[localIdx].y);                        \n"
+"  valueCr = convert_int(cr_upsample[localIdx].y);                        \n"
+"                                                                         \n"
+"  imgB.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)91881 * (valueCr - 128) + (int)32768) >> 16));                \n"
+"  imgG.y  = convert_uchar_sat(valueY +                                   \n"
+"    ((((int)32768 - (int)22554 * (valueCb - 128))                        \n"
+"    - ((int)46802 * (valueCr - 128))) >> 16));                           \n"
+"  imgR.y  = convert_uchar_sat(valueY  +                                  \n"
+"    (((int)116130 * (valueCb - 128) + (int)32768) >> 16));               \n"
+"                                                                         \n"
+"  inter[transOffset * 6 + 0] = imgR.x;                                   \n"
+"  inter[transOffset * 6 + 1] = imgG.x;                                   \n"
+"  inter[transOffset * 6 + 2] = imgB.x;                                   \n"
+"  inter[transOffset * 6 + 3] = imgR.y;                                   \n"
+"  inter[transOffset * 6 + 4] = imgG.y;                                   \n"
+"  inter[transOffset * 6 + 5] = imgB.y;                                   \n"
+"                                                                         \n"
+"  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
+"  if (localIdx < 96)                                                     \n"
+"    dst[y * mcu_width * 96 + x * 6 + localIdx % 6                        \n"
+"      + localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);         \n"
+"                                                                         \n"*/
+"}                                                                        \n";
+
+#endif
diff --git a/joclinit.c b/joclinit.c
new file mode 100644
index 0000000..5358bb5
--- /dev/null
+++ b/joclinit.c
@@ -0,0 +1,676 @@
+/*
+ * joclinit.c
+ *
+ * Copyright (C) 2012-2013, MulticoreWare Inc.
+ * In July 2012, Written by Peixuan Zhang <zhangpeixuan.cn@gmail.com>
+ * Based on the OpenCL extension for IJG JPEG library,
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file contains the initialization of OpenCL.
+ */
+
+#define __JOCL_CL_INIT_MAIN__
+#include "jinclude.h"
+#include "jpeglib.h"
+#include "CL/opencl.h"
+#include "joclinit.h"
+#undef  __JOCL_CL_INIT_MAIN__
+
+/*
+ * OCL_STATIS ocl_status
+ * Store all the informations of OpenCL platform.
+ */
+
+typedef struct
+{
+  cl_platform_id   platform_id;
+  cl_device_id     device_id;
+  cl_context       context;
+  cl_command_queue command_queue;
+  cl_bool          is_opencl_available;
+  cl_bool          is_opencl_support;
+  char             platform_profile   [1024];
+  char             platform_version   [1024];
+  char             platform_name      [1024];
+  char             platform_vendor    [1024];
+  char             platform_extensions[1024];
+  char             device_name        [1024];
+} OCL_STATUS;
+
+static OCL_STATUS ocl_status = {NULL, NULL, NULL, NULL, CL_FALSE, CL_FALSE};
+
+
+/*
+ * jocl_cl_errstring
+ * Translate error code into string, support for the OpenCL 1.2
+ */
+
+const char* jocl_cl_errstring(cl_int err_code)
+{
+  static const char* strings[] =
+  {
+      "CL_SUCCESS"                                             /*   0 */
+    , "CL_DEVICE_NOT_FOUND"                                    /*  -1 */
+    , "CL_DEVICE_NOT_AVAILABLE"                                /*  -2 */
+    , "CL_COMPILER_NOT_AVAILABLE"                              /*  -3 */
+    , "CL_MEM_OBJECT_ALLOCATION_FAILURE"                       /*  -4 */
+    , "CL_OUT_OF_RESOURCES"                                    /*  -5 */
+    , "CL_OUT_OF_HOST_MEMORY"                                  /*  -6 */
+    , "CL_PROFILING_INFO_NOT_AVAILABLE"                        /*  -7 */
+    , "CL_MEM_COPY_OVERLAP"                                    /*  -8 */
+    , "CL_IMAGE_FORMAT_MISMATCH"                               /*  -9 */
+    , "CL_IMAGE_FORMAT_NOT_SUPPORTED"                          /* -10 */
+    , "CL_BUILD_PROGRAM_FAILURE"                               /* -11 */
+    , "CL_MAP_FAILURE"                                         /* -12 */
+    , "CL_MISALIGNED_SUB_BUFFER_OFFSET"                        /* -13 */
+    , "CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST"           /* -14 */
+    , "CL_COMPILE_PROGRAM_FAILURE"                             /* -15 */
+    , "CL_LINKER_NOT_AVAILABLE"                                /* -16 */
+    , "CL_LINK_PROGRAM_FAILURE"                                /* -17 */
+    , "CL_DEVICE_PARTITION_FAILED"                             /* -18 */
+    , "CL_KERNEL_ARG_INFO_NOT_AVAILABLE"                       /* -19 */
+    , "UNDEFINED_ERROR_CODE"                                   /* -20 */
+    , "UNDEFINED_ERROR_CODE"                                   /* -21 */
+    , "UNDEFINED_ERROR_CODE"                                   /* -22 */
+    , "UNDEFINED_ERROR_CODE"                                   /* -23 */
+    , "UNDEFINED_ERROR_CODE"                                   /* -24 */
+    , "UNDEFINED_ERROR_CODE"                                   /* -25 */
+    , "UNDEFINED_ERROR_CODE"                                   /* -26 */
+    , "UNDEFINED_ERROR_CODE"                                   /* -27 */
+    , "UNDEFINED_ERROR_CODE"                                   /* -28 */
+    , "UNDEFINED_ERROR_CODE"                                   /* -29 */
+    , "CL_INVALID_VALUE"                                       /* -30 */
+    , "CL_INVALID_DEVICE_TYPE"                                 /* -31 */
+    , "CL_INVALID_PLATFORM"                                    /* -32 */
+    , "CL_INVALID_DEVICE"                                      /* -33 */
+    , "CL_INVALID_CONTEXT"                                     /* -34 */
+    , "CL_INVALID_QUEUE_PROPERTIES"                            /* -35 */
+    , "CL_INVALID_COMMAND_QUEUE"                               /* -36 */
+    , "CL_INVALID_HOST_PTR"                                    /* -37 */
+    , "CL_INVALID_MEM_OBJECT"                                  /* -38 */
+    , "CL_INVALID_IMAGE_FORMAT_DESCRIPTOR"                     /* -39 */
+    , "CL_INVALID_IMAGE_SIZE"                                  /* -40 */
+    , "CL_INVALID_SAMPLER"                                     /* -41 */
+    , "CL_INVALID_BINARY"                                      /* -42 */
+    , "CL_INVALID_BUILD_OPTIONS"                               /* -43 */
+    , "CL_INVALID_PROGRAM"                                     /* -44 */
+    , "CL_INVALID_PROGRAM_EXECUTABLE"                          /* -45 */
+    , "CL_INVALID_KERNEL_NAME"                                 /* -46 */
+    , "CL_INVALID_KERNEL_DEFINITION"                           /* -47 */
+    , "CL_INVALID_KERNEL"                                      /* -48 */
+    , "CL_INVALID_ARG_INDEX"                                   /* -49 */
+    , "CL_INVALID_ARG_VALUE"                                   /* -50 */
+    , "CL_INVALID_ARG_SIZE"                                    /* -51 */
+    , "CL_INVALID_KERNEL_ARGS"                                 /* -52 */
+    , "CL_INVALID_WORK_DIMENSION"                              /* -53 */
+    , "CL_INVALID_WORK_GROUP_SIZE"                             /* -54 */
+    , "CL_INVALID_WORK_ITEM_SIZE"                              /* -55 */
+    , "CL_INVALID_GLOBAL_OFFSET"                               /* -56 */
+    , "CL_INVALID_EVENT_WAIT_LIST"                             /* -57 */
+    , "CL_INVALID_EVENT"                                       /* -58 */
+    , "CL_INVALID_OPERATION"                                   /* -59 */
+    , "CL_INVALID_GL_OBJECT"                                   /* -60 */
+    , "CL_INVALID_BUFFER_SIZE"                                 /* -61 */
+    , "CL_INVALID_MIP_LEVEL"                                   /* -62 */
+    , "CL_INVALID_GLOBAL_WORK_SIZE"                            /* -63 */
+    , "CL_INVALID_PROPERTY"                                    /* -64 */
+    , "CL_INVALID_IMAGE_DESCRIPTOR"                            /* -65 */
+    , "CL_INVALID_COMPILER_OPTIONS"                            /* -66 */
+    , "CL_INVALID_LINKER_OPTIONS"                              /* -67 */
+    , "CL_INVALID_DEVICE_PARTITION_COUNT"                      /* -68 */
+  };
+
+  if ( err_code > 0 || err_code < -68 )
+    return "CL_UNKNOWN_ERROR_CODE";
+  return strings[-err_code];
+}
+
+
+/*
+ * jocl_cl_init
+ * Dynamic loading the OpenCL API that need to use.
+ * Get and select a platform_id, a device_id, a context and a command_queue.
+ * If initialization is successful, return CL_TRUE, otherwise return CL_FALSE.
+ */
+#ifdef JOCL_CL_OS_WIN32
+
+#include <Windows.h>
+#define CL_LOAD_FUNCTION(func)                                                 \
+  if ((jocl_##func = (h_##func) GetProcAddress(module, #func)) == NULL)        \
+  {                                                                            \
+    CL_DEBUG_NOTE ("symbol jocl_%s is NULL\n",#func);                          \
+    FreeLibrary(module);                                                       \
+    return CL_FALSE;                                                           \
+  }
+
+#else
+
+#ifdef __APPLE__
+#define CL_LIBRARY_NAME "/System/Library/Frameworks/OpenCL.framework/Versions/Current/OpenCL"
+#else
+#define CL_LIBRARY_NAME "libOpenCL.so"
+#endif 
+
+#include<dlfcn.h>
+#define CL_LOAD_FUNCTION(func)                                                 \
+  if ((jocl_##func = (h_##func) dlsym(module, #func)) == NULL)                 \ 
+  {                                                                            \
+    CL_DEBUG_NOTE ("symbol jocl_%s is NULL\n",#func);                          \
+    dlclose(module);                                                           \
+    return CL_FALSE;                                                           \
+  }
+#endif
+cl_bool jocl_cl_init()
+{
+  if (!ocl_status.is_opencl_available)
+  {
+    cl_int          err_code;
+    cl_uint         num_platform;
+    cl_uint         num_device;
+    cl_platform_id* pids;
+    cl_device_id*   dids;
+    cl_uint         index;
+
+#ifdef JOCL_CL_OS_WIN32
+    HINSTANCE       module;
+    module = LoadLibraryW(L"OpenCL.dll");
+#else
+    void *module;
+    module = dlopen(CL_LIBRARY_NAME, RTLD_LAZY);
+#endif
+
+    if(module == NULL)
+    {
+      CL_DEBUG_NOTE ("Loading OpenCL Library fails!!\n");
+      return CL_FALSE;
+    }
+
+    /* Dynamic loading OpenCL API from library */
+    CL_LOAD_FUNCTION(clGetPlatformIDs                 );
+    CL_LOAD_FUNCTION(clGetPlatformInfo                );
+    CL_LOAD_FUNCTION(clGetDeviceIDs                   );
+    CL_LOAD_FUNCTION(clGetDeviceInfo                  );
+    /* CL_LOAD_FUNCTION(clCreateSubDevices               );
+    CL_LOAD_FUNCTION(clRetainDevice                   );
+    CL_LOAD_FUNCTION(clReleaseDevice                  );*/
+    CL_LOAD_FUNCTION(clCreateContext                  );
+    /* CL_LOAD_FUNCTION(clCreateContextFromType          );
+      CL_LOAD_FUNCTION(clRetainContext                  );
+      CL_LOAD_FUNCTION(clReleaseContext                 );
+      CL_LOAD_FUNCTION(clGetContextInfo                 );*/
+    CL_LOAD_FUNCTION(clCreateCommandQueue             );
+    /* CL_LOAD_FUNCTION(clRetainCommandQueue             );
+      CL_LOAD_FUNCTION(clReleaseCommandQueue            );
+      CL_LOAD_FUNCTION(clGetCommandQueueInfo            );*/
+    CL_LOAD_FUNCTION(clCreateBuffer                   );
+    /* CL_LOAD_FUNCTION(clCreateSubBuffer                );
+      CL_LOAD_FUNCTION(clCreateImage                    );
+      CL_LOAD_FUNCTION(clRetainMemObject                );*/
+    CL_LOAD_FUNCTION(clReleaseMemObject               );
+    /* CL_LOAD_FUNCTION(clGetSupportedImageFormats       );*/
+    CL_LOAD_FUNCTION(clGetMemObjectInfo               );
+    /* CL_LOAD_FUNCTION(clGetImageInfo                   );
+      CL_LOAD_FUNCTION(clSetMemObjectDestructorCallback );
+      CL_LOAD_FUNCTION(clCreateSampler                  );
+      CL_LOAD_FUNCTION(clRetainSampler                  );
+      CL_LOAD_FUNCTION(clReleaseSampler                 );
+      CL_LOAD_FUNCTION(clGetSamplerInfo                 );*/
+    CL_LOAD_FUNCTION(clCreateProgramWithSource        );
+    CL_LOAD_FUNCTION(clCreateProgramWithBinary        );
+    /* CL_LOAD_FUNCTION(clCreateProgramWithBuiltInKernels);
+      CL_LOAD_FUNCTION(clRetainProgram                  );
+      CL_LOAD_FUNCTION(clReleaseProgram                 );*/
+    CL_LOAD_FUNCTION(clBuildProgram                   );
+    /* CL_LOAD_FUNCTION(clCompileProgram                 );
+      CL_LOAD_FUNCTION(clLinkProgram                    );
+      CL_LOAD_FUNCTION(clUnloadPlatformCompiler         );*/
+    CL_LOAD_FUNCTION(clGetProgramInfo                 );
+    CL_LOAD_FUNCTION(clGetProgramBuildInfo            );
+    CL_LOAD_FUNCTION(clCreateKernel                   );
+    /* CL_LOAD_FUNCTION(clCreateKernelsInProgram         );
+      CL_LOAD_FUNCTION(clRetainKernel                   );
+      CL_LOAD_FUNCTION(clReleaseKernel                  );*/
+    CL_LOAD_FUNCTION(clSetKernelArg                   );
+    /*CL_LOAD_FUNCTION(clGetKernelInfo                  );
+      CL_LOAD_FUNCTION(clGetKernelArgInfo               );*/
+    CL_LOAD_FUNCTION(clGetKernelWorkGroupInfo         );
+    /* CL_LOAD_FUNCTION(clWaitForEvents                  );
+      CL_LOAD_FUNCTION(clGetEventInfo                   );
+      CL_LOAD_FUNCTION(clCreateUserEvent                );
+      CL_LOAD_FUNCTION(clRetainEvent                    );
+      CL_LOAD_FUNCTION(clReleaseEvent                   );
+      CL_LOAD_FUNCTION(clSetUserEventStatus             );
+      CL_LOAD_FUNCTION(clSetEventCallback               );
+      CL_LOAD_FUNCTION(clGetEventProfilingInfo          );*/
+    CL_LOAD_FUNCTION(clFlush                          );
+    CL_LOAD_FUNCTION(clFinish                         );
+    /* CL_LOAD_FUNCTION(clEnqueueReadBuffer              );
+      CL_LOAD_FUNCTION(clEnqueueReadBufferRect          );
+      CL_LOAD_FUNCTION(clEnqueueWriteBuffer             );
+      CL_LOAD_FUNCTION(clEnqueueWriteBufferRect         );
+      CL_LOAD_FUNCTION(clEnqueueFillBuffer              );
+      CL_LOAD_FUNCTION(clEnqueueCopyBuffer              );
+      CL_LOAD_FUNCTION(clEnqueueCopyBufferRect          );
+      CL_LOAD_FUNCTION(clEnqueueReadImage               );
+      CL_LOAD_FUNCTION(clEnqueueWriteImage              );
+      CL_LOAD_FUNCTION(clEnqueueFillImage               );
+      CL_LOAD_FUNCTION(clEnqueueCopyImage               );
+      CL_LOAD_FUNCTION(clEnqueueCopyImageToBuffer       );
+      CL_LOAD_FUNCTION(clEnqueueCopyBufferToImage       );*/
+    CL_LOAD_FUNCTION(clEnqueueMapBuffer               );
+    /* CL_LOAD_FUNCTION(clEnqueueMapImage                );*/
+    CL_LOAD_FUNCTION(clEnqueueUnmapMemObject          );
+    /* CL_LOAD_FUNCTION(clEnqueueMigrateMemObjects       );*/
+    CL_LOAD_FUNCTION(clEnqueueNDRangeKernel           );
+    /* CL_LOAD_FUNCTION(clEnqueueTask                    );
+      CL_LOAD_FUNCTION(clEnqueueNativeKernel            );
+      CL_LOAD_FUNCTION(clEnqueueMarkerWithWaitList      );
+      CL_LOAD_FUNCTION(clEnqueueBarrierWithWaitList     );
+      CL_LOAD_FUNCTION(clSetPrintfCallback              );*/
+
+    /* ********* Get and select a platform. ********* */
+    CL_SAFE_CALL0(err_code = jocl_clGetPlatformIDs(0, NULL, &num_platform)
+      , return CL_FALSE);
+    if ( num_platform < 1 )
+    {
+      CL_DEBUG_NOTE("NO CL PLATFORM!\n");
+      return CL_FALSE;
+    }
+
+    pids = (cl_platform_id*)malloc(num_platform * sizeof(cl_platform_id));
+
+    CL_SAFE_CALL1(err_code = jocl_clGetPlatformIDs(num_platform, pids, NULL)
+      , return CL_FALSE, pids);
+
+    for (index = 0 ; index < num_platform ; ++index )
+    {
+      ocl_status.platform_id = pids[index];
+
+      CL_SAFE_CALL1(err_code = jocl_clGetPlatformInfo(ocl_status.platform_id,
+        CL_PLATFORM_VENDOR, sizeof(ocl_status.platform_vendor),
+        ocl_status.platform_vendor, NULL), return CL_FALSE, pids);
+
+      if (0 == strcmp(ocl_status.platform_vendor,
+        "Advanced Micro Devices, Inc."))
+        break;
+    }
+
+    free(pids);
+
+    CL_SAFE_CALL0(err_code = jocl_clGetPlatformInfo(ocl_status.platform_id,
+      CL_PLATFORM_PROFILE, sizeof(ocl_status.platform_profile),
+      ocl_status.platform_profile, NULL), return CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clGetPlatformInfo(ocl_status.platform_id,
+      CL_PLATFORM_VERSION, sizeof(ocl_status.platform_version),
+      ocl_status.platform_version, NULL), return CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clGetPlatformInfo(ocl_status.platform_id,
+      CL_PLATFORM_NAME, sizeof(ocl_status.platform_name),
+      ocl_status.platform_name, NULL), return CL_FALSE);
+
+    CL_SAFE_CALL0(err_code = jocl_clGetPlatformInfo(ocl_status.platform_id,
+      CL_PLATFORM_EXTENSIONS, sizeof(ocl_status.platform_extensions),
+      ocl_status.platform_extensions, NULL), return CL_FALSE);
+
+    CL_DEBUG_NOTE("Platform:\nprofile: %s\nversion: %s\nname: %s\n"
+      "vendor: %s\nextensions: %s\n"
+      , ocl_status.platform_profile, ocl_status.platform_version
+      , ocl_status.platform_name, ocl_status.platform_vendor
+      , ocl_status.platform_extensions);
+
+    /* ********* Get and select a device. ********* */
+    CL_SAFE_CALL0(err_code = jocl_clGetDeviceIDs(ocl_status.platform_id,
+      CL_DEVICE_TYPE_ALL, 0, NULL, &num_device), return CL_FALSE);
+    if ( num_device < 1 )
+    {
+      CL_DEBUG_NOTE("NO DEVICE FOUND!\n");
+      return CL_FALSE;
+    }
+
+    dids = (cl_device_id*)malloc(num_device * sizeof(cl_device_id));
+
+    CL_SAFE_CALL1(err_code = jocl_clGetDeviceIDs(ocl_status.platform_id,
+      CL_DEVICE_TYPE_ALL, num_device, dids, NULL), return CL_FALSE, dids);
+
+    for ( index = 0 ; index < num_device ; ++index )
+    {
+      cl_device_type d_type;
+      ocl_status.device_id = dids[index];
+
+      CL_SAFE_CALL1(err_code = jocl_clGetDeviceInfo(ocl_status.device_id,
+        CL_DEVICE_TYPE, sizeof(cl_device_type), &d_type, NULL),
+        return CL_FALSE, dids);
+      if (CL_DEVICE_TYPE_GPU == d_type)
+        break;      
+    }
+
+    free(dids);
+
+    CL_SAFE_CALL0(err_code = jocl_clGetDeviceInfo(ocl_status.device_id,
+      CL_DEVICE_NAME, sizeof(ocl_status.device_name),
+      ocl_status.device_name, NULL), return CL_FALSE);
+    CL_DEBUG_NOTE("Device:\nName: %s\n",ocl_status.device_name);
+
+    /* ********* Create a context. ********* */
+    ocl_status.context = CL_SAFE_CALL0(jocl_clCreateContext(NULL,
+      1, &ocl_status.device_id, NULL, NULL, &err_code), return CL_FALSE);
+
+    /* ********* Create a command queue. ********* */
+    ocl_status.command_queue = CL_SAFE_CALL0(jocl_clCreateCommandQueue(
+      ocl_status.context, ocl_status.device_id, 0, &err_code),
+      return CL_FALSE);
+
+    /* *** OpenCL initialized successfully, modify the mark. *** */
+    ocl_status.is_opencl_available = CL_TRUE;
+    ocl_status.is_opencl_support = CL_TRUE;
+    CL_DEBUG_NOTE("OpenCL is enabled.\n");
+  }
+  return CL_TRUE;
+}
+
+#undef CL_LOAD_FUNCTION
+
+
+/*
+ * jocl_cl_compile_and_build
+ *
+ * If it's the first time to use libjpeg-turbo on this system,
+ * create and build program with source that specified in program_source,
+ * or create program with binary.
+ *   then create kernels that specified in kernel_name[].
+ */
+
+JOCL_CL_RUNDATA* jocl_cl_compile_and_build(const char**  program_source,
+                                           const char*  kernel_name[])
+{
+    int i;
+    size_t binarySizes;
+    
+    int num_device;
+    char *binaries, *str = NULL;
+    char deviceName[1024];
+    char fileName[256] = { 0 },cl_name[] = "kernel";
+    FILE * fp = NULL;
+    int b_error, binary_status;
+    char *binary;
+    size_t length_binary;
+    num_device = 1;
+  /* Perform this operation only when OpenCL is available. */
+  if (ocl_status.is_opencl_available)
+  {
+    
+    JOCL_CL_RUNDATA* cl_data = NULL;
+    cl_int  err_code;
+    cl_uint index;
+    cl_uint num_kernel = 0;
+    size_t  length[7];
+    for(i = 0; i < 7; i++)
+      length[i]= strlen(program_source[i]);
+
+    /* Get the number of kernel functions that need to be created. */
+    while (kernel_name[++num_kernel] != NULL);
+
+    /* Allocate memory for cl_data, and create cl_program.
+     * If there is any error in the following steps,
+     *   it needs to release the memory step by step.
+     */
+    cl_data = (JOCL_CL_RUNDATA*)
+      malloc(sizeof(JOCL_CL_RUNDATA));
+
+    CL_SAFE_CALL1(err_code = jocl_clGetDeviceInfo(ocl_status.device_id,
+      CL_DEVICE_NAME, sizeof(deviceName), deviceName, NULL),
+      return NULL, cl_data);
+    sprintf(fileName, "%s_%s.bin", cl_name, deviceName);
+
+    if(!(fp = fopen(fileName,"rb"))){
+      CL_SAFE_CALL1(cl_data->program = jocl_clCreateProgramWithSource(
+        ocl_status.context, 7, program_source, length, &err_code),
+        return NULL, cl_data);
+
+      /* Compile OpenCL code. If error, output the error informations. */
+      CL_SAFE_CALL1(err_code = jocl_clBuildProgram(cl_data->program,
+      0, NULL, NULL, NULL, NULL), return NULL, cl_data);
+
+      if (CL_SUCCESS != err_code) {
+        char *err_msg;
+        size_t sz_msg;
+        cl_uint build_error = err_code;
+      
+        CL_SAFE_CALL1(err_code = jocl_clGetProgramBuildInfo(
+          cl_data->program, ocl_status.device_id, CL_PROGRAM_BUILD_LOG,
+          0, NULL, &sz_msg), return NULL, cl_data);
+      
+        /* Output the error informations. */
+        err_msg = (char*)malloc(sz_msg);
+        CL_SAFE_CALL2(err_code = jocl_clGetProgramBuildInfo(
+          cl_data->program, ocl_status.device_id, CL_PROGRAM_BUILD_LOG,
+          sz_msg, err_msg, NULL), return NULL, err_msg, cl_data);
+      
+        CL_DEBUG_NOTE("OpenCL Build Error:%s\n%s\n",
+          jocl_cl_errstring(build_error),err_msg);
+      
+        free(err_msg);   
+        free(cl_data);
+        return NULL;
+      }
+      CL_SAFE_CALL1(jocl_clGetProgramInfo(cl_data->program, 
+        CL_PROGRAM_BINARY_SIZES, sizeof(size_t), &binarySizes, NULL),
+        return NULL, cl_data);
+
+      if (binarySizes != 0) {
+        binaries = (char*) malloc(sizeof(char) * binarySizes);
+        if (binaries == NULL) {
+            return 0;
+        }
+      }
+      else {
+         binaries = NULL;
+      }
+      CL_SAFE_CALL1(jocl_clGetProgramInfo(cl_data->program,
+        CL_PROGRAM_BINARIES, sizeof(char *) * num_device, &binaries,
+        NULL), return NULL, cl_data);
+       if (binarySizes != 0) {
+         fp = fopen(fileName, "wb");
+         if (fp == NULL) {
+           return 0;
+         }          
+         fwrite(binaries, sizeof(char), binarySizes, fp);
+         fclose(fp);
+       }
+    }
+    else {
+      b_error = 0;
+      length_binary = 0;
+      b_error |= fseek(fp, 0, SEEK_END) < 0;
+      b_error |= (length_binary = ftell(fp)) <= 0;
+      b_error |= fseek(fp, 0, SEEK_SET) < 0;
+      if (b_error) {
+          return 0;
+      }
+      binary = (char*) malloc(length_binary + 2);
+      if (!binary) {
+          return 0;
+      }
+      memset(binary, 0, length_binary + 2);
+      b_error |= fread(binary, 1, length_binary, fp) != length_binary;
+      CL_SAFE_CALL1(cl_data->program = jocl_clCreateProgramWithBinary(
+        ocl_status.context, 1, &ocl_status.device_id, &length_binary,
+        (const unsigned char**) &binary, &binary_status,&err_code),
+        return NULL, cl_data);
+
+      /* Compile OpenCL code. If error, output the error informations. */
+      CL_SAFE_CALL1(err_code = jocl_clBuildProgram(cl_data->program,
+        0, NULL, NULL, NULL, NULL), return NULL, cl_data);
+
+      if (CL_SUCCESS != err_code) {
+        char *err_msg;
+        size_t sz_msg;
+        cl_uint build_error = err_code;
+      
+        CL_SAFE_CALL1(err_code = jocl_clGetProgramBuildInfo(
+          cl_data->program, ocl_status.device_id, CL_PROGRAM_BUILD_LOG,
+          0, NULL, &sz_msg), return NULL, cl_data);
+      
+        /* Output the error informations. */
+        err_msg = (char*)malloc(sz_msg);
+        CL_SAFE_CALL2(err_code = jocl_clGetProgramBuildInfo(
+          cl_data->program, ocl_status.device_id, CL_PROGRAM_BUILD_LOG,
+          sz_msg, err_msg, NULL), return NULL, err_msg, cl_data);
+
+        CL_DEBUG_NOTE("OpenCL Build Error:%s\n%s\n",
+          jocl_cl_errstring(build_error),err_msg);
+
+        free(err_msg);
+        free(cl_data);
+        return NULL;
+      }
+      /* Build Successfully. */
+      CL_DEBUG_NOTE("Compiling OpenCL code successfully.\n");
+    }
+    /* Allocate memory for cl_kernel and other auxiliary variables. */
+    cl_data->kernel = (cl_kernel*)malloc(num_kernel * sizeof(cl_kernel));
+    cl_data->work_group_size = (size_t*)malloc(num_kernel * sizeof(size_t));
+
+    /* Create cl_kernels. */
+    for ( index = 0 ; index < num_kernel ; ++index )
+    {
+      CL_SAFE_CALL3(cl_data->kernel[index] = jocl_clCreateKernel(
+        cl_data->program, kernel_name[index], &err_code)
+        , return NULL, cl_data->kernel, cl_data->work_group_size, cl_data);
+
+      CL_SAFE_CALL3(err_code = jocl_clGetKernelWorkGroupInfo(
+        cl_data->kernel[index], ocl_status.device_id,
+        CL_KERNEL_WORK_GROUP_SIZE, sizeof(size_t),
+        &cl_data->work_group_size[index], NULL),
+        return NULL, cl_data->kernel, cl_data->work_group_size, cl_data);
+    }
+
+    /* Build cl_program and create cl_kernels successfully.*/
+    CL_DEBUG_NOTE("Create kernel OK!\n");
+    return cl_data;
+  }
+  return NULL;
+}
+
+
+/*
+ * jocl_cl_is_available
+ * jocl_cl_is_support_opencl
+ * jocl_cl_get_platform
+ * jocl_cl_get_device
+ * jocl_cl_get_context
+ * jocl_cl_get_command_queue
+ *
+ * These functions are used to return the platform informations,
+ *   so I'm not going to comment them one by one.
+ */
+
+cl_bool          jocl_cl_is_available(void)
+{
+  return ocl_status.is_opencl_available;
+}
+
+cl_bool          jocl_cl_is_support_opencl(void)
+{
+  return ocl_status.is_opencl_support;
+}
+
+cl_platform_id   jocl_cl_get_platform(void)
+{
+  return ocl_status.platform_id;
+}
+
+cl_device_id     jocl_cl_get_device(void)
+{
+  return ocl_status.device_id;
+}
+
+cl_context       jocl_cl_get_context(void)
+{
+  return ocl_status.context;
+}
+
+cl_command_queue jocl_cl_get_command_queue(void)
+{
+  return ocl_status.command_queue;
+}
+
+/*
+ * jocl_cl_set_opencl_failure
+ *
+ * If OpenCL is unavailable (The reason may be varied),
+ *   Set the flag to disable OpenCL.
+ */
+
+void jocl_cl_set_opencl_failure(void)
+{
+  ocl_status.is_opencl_available = CL_FALSE;
+}
+
+/*
+ * jocl_cl_set_opencl_success
+ *
+ * If OpenCL is available, set the flag to enable OpenCL.
+ */
+
+void jocl_cl_set_opencl_success(void)
+{
+  ocl_status.is_opencl_available = CL_TRUE;
+}
+
+/*
+ * jocl_cl_set_opencl_support_failure
+ *
+ * If OpenCL is not supported (The reason may be varied),
+ *   Set the flag to disable OpenCL.
+ */
+
+void jocl_cl_set_opencl_support_failure(void)
+{
+  ocl_status.is_opencl_support = CL_FALSE;
+}
+
+/*
+ * jocl_cl_is_nvidia_opencl
+ *
+ * If OpenCL is on NV
+ * 
+ */
+ 
+cl_bool jocl_cl_is_nvidia_opencl(void)
+{
+  if (0 == strcmp(ocl_status.platform_vendor,
+        "NVIDIA Corporation"))
+    return CL_TRUE;
+  else
+    return CL_FALSE;
+}
+      
+/*
+ * jocl_cl_is_opencl_decompress
+ *
+ * Determine whether the OpenCL decoding will be used.
+ */
+
+cl_bool jocl_cl_is_opencl_decompress(j_decompress_ptr cinfo)
+{
+  unsigned int output_buffer, input_buffer;
+  
+  /* output_buffer: the size of actual output */
+  /* input_buffer : the size of actual input  */
+  output_buffer = cinfo->MCUs_per_row * cinfo->total_iMCU_rows * cinfo->max_h_samp_factor * 
+               cinfo->max_v_samp_factor * NUM_COMPONENT * DCTSIZE2;
+  input_buffer  = sizeof(JCOEF) * (cinfo->max_h_samp_factor * cinfo->max_v_samp_factor + 2) *
+               cinfo->MCUs_per_row * cinfo->total_iMCU_rows * DCTSIZE2;
+  /* Determine if the opencl version will be used */
+  if(cinfo->num_components==1||
+     (cinfo->blocks_in_MCU!=6 && cinfo->blocks_in_MCU!=3 && cinfo->blocks_in_MCU!=4))
+     return CL_FALSE;
+  
+  if((output_buffer > MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 6) ||
+  (input_buffer  > MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4))
+     return CL_FALSE;
+
+  return CL_TRUE;
+}
\ No newline at end of file
diff --git a/joclinit.h b/joclinit.h
new file mode 100644
index 0000000..93144f7
--- /dev/null
+++ b/joclinit.h
@@ -0,0 +1,302 @@
+/*
+ * joclinit.h
+ *
+ * Copyright (C) 2012-2013, MulticoreWare Inc.
+ * In July 2012, Written by Peixuan Zhang <zhangpeixuan.cn@gmail.com>
+ * Based on the OpenCL extension for IJG JPEG library,
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file contains the initialization of OpenCL.
+ *
+ * Any module that need to call OpenCL API,
+ * should include this header file first.
+ */
+
+#ifndef __DYNAMIC_LOADING_OPENCL_INIT_H__
+#define __DYNAMIC_LOADING_OPENCL_INIT_H__
+
+
+/*
+ * In order to ensure that this extension can be successfully compiled
+ * on multiple platforms, we chose the dynamic loading of OpenCL.
+ * The following APIs belong OpenCL 1.2 standard.
+ */
+
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetPlatformIDs                 ) (cl_uint, cl_platform_id*, cl_uint*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetPlatformInfo                ) (cl_platform_id, cl_platform_info, size_t, void*, size_t*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetDeviceIDs                   ) (cl_platform_id, cl_device_type, cl_uint, cl_device_id*, cl_uint*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetDeviceInfo                  ) (cl_device_id, cl_device_info, size_t, void*, size_t*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clCreateSubDevices               ) (cl_device_id, const cl_device_partition_property*, cl_uint, cl_device_id*, cl_uint*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clRetainDevice                   ) (cl_device_id);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clReleaseDevice                  ) (cl_device_id);
+typedef CL_API_ENTRY cl_context       (CL_API_CALL *h_clCreateContext                  ) (const cl_context_properties*, cl_uint, const cl_device_id*, void (CL_CALLBACK*)(const char*, const void*, size_t, void*), void*, cl_int*);
+typedef CL_API_ENTRY cl_context       (CL_API_CALL *h_clCreateContextFromType          ) (const cl_context_properties*, cl_device_type, void (CL_CALLBACK*)(const char*, const void*, size_t, void*), void*, cl_int*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clRetainContext                  ) (cl_context);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clReleaseContext                 ) (cl_context);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetContextInfo                 ) (cl_context, cl_context_info, size_t, void*, size_t*);
+typedef CL_API_ENTRY cl_command_queue (CL_API_CALL *h_clCreateCommandQueue             ) (cl_context, cl_device_id, cl_command_queue_properties, cl_int*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clRetainCommandQueue             ) (cl_command_queue);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clReleaseCommandQueue            ) (cl_command_queue);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetCommandQueueInfo            ) (cl_command_queue, cl_command_queue_info, size_t, void*, size_t*);
+typedef CL_API_ENTRY cl_mem           (CL_API_CALL *h_clCreateBuffer                   ) (cl_context, cl_mem_flags, size_t, void*, cl_int*);
+typedef CL_API_ENTRY cl_mem           (CL_API_CALL *h_clCreateSubBuffer                ) (cl_mem, cl_mem_flags, cl_buffer_create_type, const void*, cl_int*);
+typedef CL_API_ENTRY cl_mem           (CL_API_CALL *h_clCreateImage                    ) (cl_context, cl_mem_flags, const cl_image_format*, const cl_image_desc*, void*, cl_int*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clRetainMemObject                ) (cl_mem);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clReleaseMemObject               ) (cl_mem);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetSupportedImageFormats       ) (cl_context, cl_mem_flags, cl_mem_object_type, cl_uint, cl_image_format*, cl_uint*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetMemObjectInfo               ) (cl_mem, cl_mem_info, size_t, void*, size_t*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetImageInfo                   ) (cl_mem, cl_image_info, size_t, void*, size_t*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clSetMemObjectDestructorCallback ) (cl_mem, void (CL_CALLBACK*)(cl_mem,void*), void*);
+typedef CL_API_ENTRY cl_sampler       (CL_API_CALL *h_clCreateSampler                  ) (cl_context, cl_bool, cl_addressing_mode, cl_filter_mode, cl_int*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clRetainSampler                  ) (cl_sampler);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clReleaseSampler                 ) (cl_sampler);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetSamplerInfo                 ) (cl_sampler, cl_sampler_info, size_t, void*, size_t*);
+typedef CL_API_ENTRY cl_program       (CL_API_CALL *h_clCreateProgramWithSource        ) (cl_context, cl_uint, const char**, const size_t*, cl_int*);
+typedef CL_API_ENTRY cl_program       (CL_API_CALL *h_clCreateProgramWithBinary        ) (cl_context, cl_uint, const cl_device_id*, const size_t*, const unsigned char**, cl_int*, cl_int*);
+typedef CL_API_ENTRY cl_program       (CL_API_CALL *h_clCreateProgramWithBuiltInKernels) (cl_context, cl_uint, const cl_device_id*, const char*, cl_int*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clRetainProgram                  ) (cl_program);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clReleaseProgram                 ) (cl_program);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clBuildProgram                   ) (cl_program, cl_uint, const cl_device_id*, const char*, void (CL_CALLBACK*)(cl_program, void*), void*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clCompileProgram                 ) (cl_program, cl_uint, const cl_device_id*, const char*, cl_uint, const cl_program*, const char**, void (CL_CALLBACK*)(cl_program, void*), void*);
+typedef CL_API_ENTRY cl_program       (CL_API_CALL *h_clLinkProgram                    ) (cl_context, cl_uint, const cl_device_id*, const char*, cl_uint, const cl_program*, void (CL_CALLBACK*)(cl_program, void*), void*, cl_int*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clUnloadPlatformCompiler         ) (cl_platform_id);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetProgramInfo                 ) (cl_program, cl_program_info, size_t, void*, size_t*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetProgramBuildInfo            ) (cl_program, cl_device_id, cl_program_build_info, size_t, void*, size_t*);
+typedef CL_API_ENTRY cl_kernel        (CL_API_CALL *h_clCreateKernel                   ) (cl_program, const char*, cl_int*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clCreateKernelsInProgram         ) (cl_program, cl_uint, cl_kernel*, cl_uint*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clRetainKernel                   ) (cl_kernel);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clReleaseKernel                  ) (cl_kernel);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clSetKernelArg                   ) (cl_kernel, cl_uint, size_t, const void*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetKernelInfo                  ) (cl_kernel, cl_kernel_info, size_t, void*, size_t*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetKernelArgInfo               ) (cl_kernel, cl_uint, cl_kernel_arg_info, size_t, void*, size_t*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetKernelWorkGroupInfo         ) (cl_kernel, cl_device_id, cl_kernel_work_group_info, size_t, void*, size_t*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clWaitForEvents                  ) (cl_uint, const cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetEventInfo                   ) (cl_event, cl_event_info, size_t, void*, size_t*);
+typedef CL_API_ENTRY cl_event         (CL_API_CALL *h_clCreateUserEvent                ) (cl_context, cl_int*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clRetainEvent                    ) (cl_event);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clReleaseEvent                   ) (cl_event);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clSetUserEventStatus             ) (cl_event, cl_int);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clSetEventCallback               ) (cl_event, cl_int, void (CL_CALLBACK*)(cl_event, cl_int, void*), void*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetEventProfilingInfo          ) (cl_event, cl_profiling_info, size_t, void*, size_t*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clFlush                          ) (cl_command_queue);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clFinish                         ) (cl_command_queue);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueReadBuffer              ) (cl_command_queue, cl_mem, cl_bool, size_t, size_t, void*, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueReadBufferRect          ) (cl_command_queue, cl_mem, cl_bool, const size_t*, const size_t*, const size_t*, size_t, size_t, size_t, size_t, void*, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueWriteBuffer             ) (cl_command_queue, cl_mem, cl_bool, size_t, size_t, const void*, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueWriteBufferRect         ) (cl_command_queue, cl_mem, cl_bool, const size_t*, const size_t*, const size_t*, size_t, size_t, size_t, size_t, const void*, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueFillBuffer              ) (cl_command_queue, cl_mem, const void*, size_t, size_t, size_t, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueCopyBuffer              ) (cl_command_queue, cl_mem, cl_mem, size_t, size_t, size_t, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueCopyBufferRect          ) (cl_command_queue, cl_mem, cl_mem, const size_t*, const size_t*, const size_t*, size_t, size_t, size_t, size_t, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueReadImage               ) (cl_command_queue, cl_mem, cl_bool, const size_t*, const size_t*, size_t, size_t, void*, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueWriteImage              ) (cl_command_queue, cl_mem, cl_bool, const size_t*, const size_t*, size_t, size_t, const void*, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueFillImage               ) (cl_command_queue, cl_mem, const void*, const size_t*, const size_t*, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueCopyImage               ) (cl_command_queue, cl_mem, cl_mem, const size_t*, const size_t*, const size_t*, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueCopyImageToBuffer       ) (cl_command_queue, cl_mem, cl_mem, const size_t*, const size_t*, size_t, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueCopyBufferToImage       ) (cl_command_queue, cl_mem, cl_mem, size_t, const size_t*, const size_t*, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY void *           (CL_API_CALL *h_clEnqueueMapBuffer               ) (cl_command_queue, cl_mem, cl_bool, cl_map_flags, size_t, size_t, cl_uint, const cl_event*, cl_event*, cl_int*);
+typedef CL_API_ENTRY void *           (CL_API_CALL *h_clEnqueueMapImage                ) (cl_command_queue, cl_mem, cl_bool, cl_map_flags, const size_t*, const size_t*, size_t*, size_t*, cl_uint, const cl_event*, cl_event*, cl_int*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueUnmapMemObject          ) (cl_command_queue, cl_mem, void*, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueMigrateMemObjects       ) (cl_command_queue, cl_uint, const cl_mem*, cl_mem_migration_flags, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueNDRangeKernel           ) (cl_command_queue, cl_kernel, cl_uint, const size_t*, const size_t*, const size_t*, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueTask                    ) (cl_command_queue, cl_kernel, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueNativeKernel            ) (cl_command_queue, void (CL_CALLBACK*)(void*), void*, size_t, cl_uint, const cl_mem*, const void**, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueMarkerWithWaitList      ) (cl_command_queue, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueBarrierWithWaitList     ) (cl_command_queue, cl_uint, const cl_event*, cl_event*);
+typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clSetPrintfCallback              ) (cl_context, void (CL_CALLBACK*)(cl_context, cl_uint, char*, void*), void*);
+
+
+/*
+ * Declaration or definition the API pointers.
+ * Use macros to streamline the code.
+ */
+
+#ifdef __JOCL_CL_INIT_MAIN__
+#define CL_LOADING_PREFIX
+#define CL_LOADING_SUFFIX = NULL
+#else
+#define CL_LOADING_PREFIX extern
+#define CL_LOADING_SUFFIX
+#endif
+
+CL_LOADING_PREFIX h_clGetPlatformIDs                  jocl_clGetPlatformIDs                  CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clGetPlatformInfo                 jocl_clGetPlatformInfo                 CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clGetDeviceIDs                    jocl_clGetDeviceIDs                    CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clGetDeviceInfo                   jocl_clGetDeviceInfo                   CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clCreateSubDevices                jocl_clCreateSubDevices                CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clRetainDevice                    jocl_clRetainDevice                    CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clReleaseDevice                   jocl_clReleaseDevice                   CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clCreateContext                   jocl_clCreateContext                   CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clCreateContextFromType           jocl_clCreateContextFromType           CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clRetainContext                   jocl_clRetainContext                   CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clReleaseContext                  jocl_clReleaseContext                  CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clGetContextInfo                  jocl_clGetContextInfo                  CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clCreateCommandQueue              jocl_clCreateCommandQueue              CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clRetainCommandQueue              jocl_clRetainCommandQueue              CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clReleaseCommandQueue             jocl_clReleaseCommandQueue             CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clGetCommandQueueInfo             jocl_clGetCommandQueueInfo             CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clCreateBuffer                    jocl_clCreateBuffer                    CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clCreateSubBuffer                 jocl_clCreateSubBuffer                 CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clCreateImage                     jocl_clCreateImage                     CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clRetainMemObject                 jocl_clRetainMemObject                 CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clReleaseMemObject                jocl_clReleaseMemObject                CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clGetSupportedImageFormats        jocl_clGetSupportedImageFormats        CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clGetMemObjectInfo                jocl_clGetMemObjectInfo                CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clGetImageInfo                    jocl_clGetImageInfo                    CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clSetMemObjectDestructorCallback  jocl_clSetMemObjectDestructorCallback  CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clCreateSampler                   jocl_clCreateSampler                   CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clRetainSampler                   jocl_clRetainSampler                   CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clReleaseSampler                  jocl_clReleaseSampler                  CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clGetSamplerInfo                  jocl_clGetSamplerInfo                  CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clCreateProgramWithSource         jocl_clCreateProgramWithSource         CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clCreateProgramWithBinary         jocl_clCreateProgramWithBinary         CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clCreateProgramWithBuiltInKernels jocl_clCreateProgramWithBuiltInKernels CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clRetainProgram                   jocl_clRetainProgram                   CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clReleaseProgram                  jocl_clReleaseProgram                  CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clBuildProgram                    jocl_clBuildProgram                    CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clCompileProgram                  jocl_clCompileProgram                  CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clLinkProgram                     jocl_clLinkProgram                     CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clUnloadPlatformCompiler          jocl_clUnloadPlatformCompiler          CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clGetProgramInfo                  jocl_clGetProgramInfo                  CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clGetProgramBuildInfo             jocl_clGetProgramBuildInfo             CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clCreateKernel                    jocl_clCreateKernel                    CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clCreateKernelsInProgram          jocl_clCreateKernelsInProgram          CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clRetainKernel                    jocl_clRetainKernel                    CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clReleaseKernel                   jocl_clReleaseKernel                   CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clSetKernelArg                    jocl_clSetKernelArg                    CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clGetKernelInfo                   jocl_clGetKernelInfo                   CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clGetKernelArgInfo                jocl_clGetKernelArgInfo                CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clGetKernelWorkGroupInfo          jocl_clGetKernelWorkGroupInfo          CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clWaitForEvents                   jocl_clWaitForEvents                   CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clGetEventInfo                    jocl_clGetEventInfo                    CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clCreateUserEvent                 jocl_clCreateUserEvent                 CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clRetainEvent                     jocl_clRetainEvent                     CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clReleaseEvent                    jocl_clReleaseEvent                    CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clSetUserEventStatus              jocl_clSetUserEventStatus              CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clSetEventCallback                jocl_clSetEventCallback                CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clGetEventProfilingInfo           jocl_clGetEventProfilingInfo           CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clFlush                           jocl_clFlush                           CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clFinish                          jocl_clFinish                          CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueReadBuffer               jocl_clEnqueueReadBuffer               CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueReadBufferRect           jocl_clEnqueueReadBufferRect           CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueWriteBuffer              jocl_clEnqueueWriteBuffer              CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueWriteBufferRect          jocl_clEnqueueWriteBufferRect          CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueFillBuffer               jocl_clEnqueueFillBuffer               CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueCopyBuffer               jocl_clEnqueueCopyBuffer               CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueCopyBufferRect           jocl_clEnqueueCopyBufferRect           CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueReadImage                jocl_clEnqueueReadImage                CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueWriteImage               jocl_clEnqueueWriteImage               CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueFillImage                jocl_clEnqueueFillImage                CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueCopyImage                jocl_clEnqueueCopyImage                CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueCopyImageToBuffer        jocl_clEnqueueCopyImageToBuffer        CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueCopyBufferToImage        jocl_clEnqueueCopyBufferToImage        CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueMapBuffer                jocl_clEnqueueMapBuffer                CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueMapImage                 jocl_clEnqueueMapImage                 CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueUnmapMemObject           jocl_clEnqueueUnmapMemObject           CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueMigrateMemObjects        jocl_clEnqueueMigrateMemObjects        CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueNDRangeKernel            jocl_clEnqueueNDRangeKernel            CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueTask                     jocl_clEnqueueTask                     CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueNativeKernel             jocl_clEnqueueNativeKernel             CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueMarkerWithWaitList       jocl_clEnqueueMarkerWithWaitList       CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clEnqueueBarrierWithWaitList      jocl_clEnqueueBarrierWithWaitList      CL_LOADING_SUFFIX;
+CL_LOADING_PREFIX h_clSetPrintfCallback               jocl_clSetPrintfCallback               CL_LOADING_SUFFIX;
+
+#undef CL_LOADING_PREFIX
+#undef CL_LOADING_SUFFIX
+
+
+/*
+ * Definition run_data structure of kernels.
+ * Forward declaration the OpenCL initialization API.
+ * Please check joclinit.c for the specific features of these functions.
+ */
+
+typedef struct
+{
+  cl_program program;
+  cl_kernel* kernel;
+  size_t*    work_group_size;
+} JOCL_CL_RUNDATA;
+
+
+const char*      jocl_cl_errstring                 (cl_int err_code);
+cl_bool          jocl_cl_init                      (void);
+JOCL_CL_RUNDATA* jocl_cl_compile_and_build         (const char** program_source,
+                                                    const char*  kernel_name[]);
+cl_bool          jocl_cl_is_support_opencl         (void);
+cl_bool          jocl_cl_is_available              (void);
+cl_platform_id   jocl_cl_get_platform              (void);
+cl_device_id     jocl_cl_get_device                (void);
+cl_context       jocl_cl_get_context               (void);
+cl_command_queue jocl_cl_get_command_queue         (void);
+void             jocl_cl_set_opencl_failure        (void);
+void             jocl_cl_set_opencl_success        (void);
+void             jocl_cl_set_opencl_support_failure(void);
+cl_bool          jocl_cl_is_opencl_decompress      (j_decompress_ptr cinfo);
+cl_bool          jocl_cl_is_nvidia_opencl          (void);
+
+
+/*
+ * The macro definition for exception handling code.
+ */
+
+#define CL_DEBUG_NOTE(...)                                               \
+  printf(__VA_ARGS__)
+
+#define CL_SAFE_CALL0(func, action)                                      \
+  func;                                                                  \
+  if(CL_SUCCESS != err_code)                                             \
+  {                                                                      \
+    CL_DEBUG_NOTE("OpenCL error in %s, Line %u in file %s\nError:%s\n",  \
+      #func, __LINE__, __FILE__, jocl_cl_errstring(err_code));           \
+    action;                                                              \
+  }
+
+#define CL_SAFE_CALL1(func, action, ptr)                                 \
+  func;                                                                  \
+  if(CL_SUCCESS != err_code)                                             \
+  {                                                                      \
+    CL_DEBUG_NOTE("OpenCL error in %s, Line %u in file %s\nError:%s\n",  \
+      #func, __LINE__, __FILE__, jocl_cl_errstring(err_code));           \
+    free(ptr);                                                           \
+    action;                                                              \
+  }
+
+#define CL_SAFE_CALL2(func, action, ptr1, ptr2)                          \
+  func;                                                                  \
+  if(CL_SUCCESS != err_code)                                             \
+  {                                                                      \
+    CL_DEBUG_NOTE("OpenCL error in %s, Line %u in file %s\nError:%s\n",  \
+      #func, __LINE__, __FILE__, jocl_cl_errstring(err_code));           \
+    free(ptr1);                                                          \
+    free(ptr2);                                                          \
+    action;                                                              \
+  }
+
+#define CL_SAFE_CALL3(func, action, ptr1, ptr2, ptr3)                    \
+  func;                                                                  \
+  if(CL_SUCCESS != err_code)                                             \
+  {                                                                      \
+    CL_DEBUG_NOTE("OpenCL error in %s, Line %u in file %s\nError:%s\n",  \
+      #func, __LINE__, __FILE__, jocl_cl_errstring(err_code));           \
+    free(ptr1);                                                          \
+    free(ptr2);                                                          \
+    free(ptr3);                                                          \
+    action;                                                              \
+  }
+
+#define CL_SAFE_CALL4(func, action, ptr1, ptr2, ptr3, ptr4)              \
+  func;                                                                  \
+  if(CL_SUCCESS != err_code)                                             \
+  {                                                                      \
+    CL_DEBUG_NOTE("OpenCL error in %s, Line %u in file %s\nError:%s\n",  \
+      #func, __LINE__, __FILE__, jocl_cl_errstring(err_code));           \
+    free(ptr1);                                                          \
+    free(ptr2);                                                          \
+    free(ptr3);                                                          \
+    free(ptr4);                                                          \
+    action;                                                              \
+  }
+
+
+/* The end of joclinit.h */
+#endif
\ No newline at end of file
diff --git a/jpegint.h b/jpegint.h
index 7871748..848d340 100644
--- a/jpegint.h
+++ b/jpegint.h
@@ -387,6 +387,10 @@ EXTERN(void) jzero_far JPP((void FAR * target, size_t bytestozero));
 extern const int jpeg_zigzag_order[]; /* natural coef order to zigzag order */
 #endif
 extern const int jpeg_natural_order[]; /* zigzag coef order to natural order */
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+/* zigzag coef order to natural order - OpenCL version */
+extern const int jpeg_natural_order_ocl[];
+#endif
 
 /* Arithmetic coding probability estimation tables in jaricom.c */
 extern const INT32 jpeg_aritab[];
diff --git a/jutils.c b/jutils.c
index d18a955..16bf8d6 100644
--- a/jutils.c
+++ b/jutils.c
@@ -3,6 +3,8 @@
  *
  * Copyright (C) 1991-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
+ * Modifications:
+ * Copyright (C) 2012-2013, MulticoreWare Inc.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains tables and miscellaneous utility routines needed
@@ -63,6 +65,20 @@ const int jpeg_natural_order[DCTSIZE2+16] = {
  63, 63, 63, 63, 63, 63, 63, 63
 };
 
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+const int jpeg_natural_order_ocl[DCTSIZE2+16] = {
+  0,  8,  1,  2,  9, 16, 24, 17,
+ 10,  3,  4, 11, 18, 25, 32, 40,
+ 33, 26, 19, 12,  5,  6, 13, 20,
+ 27, 34, 41, 48, 56, 49, 42, 35,
+ 28, 21, 14,  7, 15, 22, 29, 36,
+ 43, 50, 57, 58, 51, 44, 37, 30,
+ 23, 31, 38, 45, 52, 59, 60, 53,
+ 46, 39, 47, 54, 61, 62, 55, 63,
+ 63, 63, 63, 63, 63, 63, 63, 63, /* extra entries for safety in decoder */
+ 63, 63, 63, 63, 63, 63, 63, 63
+};
+#endif
 
 /*
  * Arithmetic utilities
diff --git a/win/jconfig.h.in b/win/jconfig.h.in
index ddcf97e..251f625 100644
--- a/win/jconfig.h.in
+++ b/win/jconfig.h.in
@@ -3,6 +3,8 @@
 
 #define JPEG_LIB_VERSION @JPEG_LIB_VERSION@
 #define LIBJPEG_TURBO_VERSION @VERSION@
+#cmakedefine WITH_OPENCL_DECODING_SUPPORTED
+#cmakedefine JOCL_CL_OS_WIN32
 #cmakedefine C_ARITH_CODING_SUPPORTED
 #cmakedefine D_ARITH_CODING_SUPPORTED
 #cmakedefine MEM_SRCDST_SUPPORTED
@@ -39,3 +41,11 @@ typedef signed int INT32;
 #undef RIGHT_SHIFT_IS_UNSIGNED
 
 #endif /* JPEG_INTERNALS */
+
+/* Define envionment variables of OpenCL decoding. */
+#ifdef WITH_OPENCL_DECODING_SUPPORTED
+#define OPENCL_PIPELINE           /* Pipeline or no pipeline */
+#define MAX_IMAGE_WIDTH   4096    /* Using to set the buffer size */
+#define MAX_IMAGE_HEIGHT  4096    /* Using to set the buffer size */
+#define NUM_COMPONENT     3       /* The number of component */
+#endif
-- 
1.8.1.4

