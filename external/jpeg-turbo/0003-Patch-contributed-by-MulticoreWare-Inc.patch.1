From 83aea4c13d3e534898bb498849556a040e9cc2c4 Mon Sep 17 00:00:00 2001
From: dcommander <dcommander@632fc199-4ca6-4c93-a231-07263d6284db>
Date: Wed, 25 Sep 2013 17:58:48 +0000
Subject: [PATCH 3/9] Patch contributed by MulticoreWare, Inc.
 https://sourceforge.net/p/libjpeg-turbo/patches/40
 https://sourceforge.net/p/libjpeg-turbo/patches/_discuss/thread/3d9969a0/77b0/attachment/patch20130925.patch

git-svn-id: http://svn.code.sf.net/p/libjpeg-turbo/code/branches/opencl@1041 632fc199-4ca6-4c93-a231-07263d6284db
---
 jconfig.h.in      |   9 +-
 jdapimin.c        |  83 ++---
 jdcoefct.c        |  90 ++---
 jdsample.c        |  13 +-
 jocldec.c         | 975 +++++++++++++++++++++++++++++++-----------------------
 jocldec.h         |   8 +-
 jocldec_kernels.h | 197 ++++++-----
 joclinit.c        | 304 ++++++++++-------
 joclinit.h        |  23 +-
 win/jconfig.h.in  |   5 +-
 10 files changed, 990 insertions(+), 717 deletions(-)

diff --git a/jconfig.h.in b/jconfig.h.in
index 9c655f4..f3ba2b8 100644
--- a/jconfig.h.in
+++ b/jconfig.h.in
@@ -64,8 +64,9 @@
 
 /* Define envionment variables of OpenCL decoding. */
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
-#define OPENCL_PIPELINE           /* Pipeline or no pipeline */
-#define MAX_IMAGE_WIDTH   4096    /* Using to set the buffer size */
-#define MAX_IMAGE_HEIGHT  4096    /* Using to set the buffer size */
-#define NUM_COMPONENT     3       /* The number of component */
+#define OPENCL_PIPELINE                /* Pipeline or no pipeline */
+#define MAX_BUFFER_SIZE   (9000 * 6000 * 4)  /* Using to set the buffer size */
+#define NUM_COMPONENT     3            /* The number of component */
+#define MCUNUMS           800
+#define BUFFERNUMS        10
 #endif
diff --git a/jdapimin.c b/jdapimin.c
index d78a70d..19495d0 100644
--- a/jdapimin.c
+++ b/jdapimin.c
@@ -38,7 +38,9 @@ jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
 {
   int i;
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
+  unsigned long    buffer_output_size = 0;
   cl_int err_code;
+  int j;
 #endif
 
   /* Guard against version mismatches between library and caller. */
@@ -92,65 +94,70 @@ jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
   cinfo->global_state = DSTATE_START;
 
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
-  if (CL_FALSE == jocl_cl_is_available() && CL_TRUE == jocl_cl_init()) {
-    if(CL_TRUE == jocl_cl_is_nvidia_opencl()) {
-      jocl_global_data_ptr_input  = (JCOEFPTR)malloc(MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4);
-      memset(jocl_global_data_ptr_input, 0, MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4);
-      jocl_global_data_ptr_output = (JSAMPROW)malloc(MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 6);
-      memset(jocl_global_data_ptr_output, 0, MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 6);
-      jocl_global_data_ptr_qutable = (float *)malloc(4096);
-      memset(jocl_global_data_ptr_qutable, 0, 4096);
-
-      CL_SAFE_CALL0(jocl_global_data_mem_input = jocl_clCreateBuffer(jocl_cl_get_context(),
-        CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR,
-        MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4, jocl_global_data_ptr_input, &err_code),return);
+  if (CL_FALSE == jocl_cl_is_support_opencl() && CL_TRUE == jocl_cl_init()) {
+    buffer_output_size = jocl_cl_get_buffer_unit_size();
+    if (CL_TRUE == jocl_cl_is_nvidia_opencl()) {
+      jocl_global_data_ptr_output = (JSAMPROW)malloc(buffer_output_size);
+      memset(jocl_global_data_ptr_output, 0, buffer_output_size);
       CL_SAFE_CALL0(jocl_global_data_mem_output = jocl_clCreateBuffer(jocl_cl_get_context(),
         CL_MEM_WRITE_ONLY | CL_MEM_USE_HOST_PTR,
-        MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 6, jocl_global_data_ptr_output, &err_code),return);
+        buffer_output_size, jocl_global_data_ptr_output, &err_code),return);
+      jocl_global_data_ptr_qutable = (float *)malloc(128 * sizeof(float));
+      memset(jocl_global_data_ptr_qutable, 0, 128 * sizeof(float));
       CL_SAFE_CALL0(jocl_global_data_mem_qutable = jocl_clCreateBuffer(jocl_cl_get_context(),
         CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
-        4096, jocl_global_data_ptr_qutable, &err_code),return);
-	  }
-	  else {
-      CL_SAFE_CALL0(jocl_global_data_mem_input = jocl_clCreateBuffer(jocl_cl_get_context(),
-        CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR,
-        MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4, NULL, &err_code),return);
-      CL_SAFE_CALL0(jocl_global_data_ptr_input = (JCOEFPTR)jocl_clEnqueueMapBuffer(
-        jocl_cl_get_command_queue(), jocl_global_data_mem_input, CL_TRUE,
-        CL_MAP_WRITE_INVALIDATE_REGION, 0, MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4,
-        0, NULL, NULL, &err_code),return);
-      memset(jocl_global_data_ptr_input,0,MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4);
-      CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
-        jocl_cl_get_command_queue(), jocl_global_data_mem_input,
-        jocl_global_data_ptr_input, 0, NULL, NULL),);
+        128 * sizeof(float), jocl_global_data_ptr_qutable, &err_code),return);
+
+      for(j = 0; j < BUFFERNUMS; ++j) {
+        jocl_global_data_ptr_input[j]  = (JCOEFPTR)malloc(MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF));
+        memset(jocl_global_data_ptr_input[j], 0, MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF));
+
+        CL_SAFE_CALL0(jocl_global_data_mem_input[j] = jocl_clCreateBuffer(jocl_cl_get_context(),
+          CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR,
+          MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF), jocl_global_data_ptr_input[j], &err_code),return);
+      }
+    }
+    else {
       CL_SAFE_CALL0(jocl_global_data_mem_output = jocl_clCreateBuffer(jocl_cl_get_context(),
         CL_MEM_WRITE_ONLY | CL_MEM_ALLOC_HOST_PTR,
-        MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 6, NULL, &err_code),return);
+        buffer_output_size, NULL, &err_code),return);
       CL_SAFE_CALL0(jocl_global_data_ptr_output = (JSAMPROW)jocl_clEnqueueMapBuffer(
         jocl_cl_get_command_queue(), jocl_global_data_mem_output, CL_TRUE,
-        CL_MAP_READ, 0, MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 6, 
+        CL_MAP_READ, 0, buffer_output_size, 
         0, NULL, NULL, &err_code),return);
       CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
         jocl_cl_get_command_queue(), jocl_global_data_mem_output,
-        jocl_global_data_ptr_output, 0, NULL, NULL),);
+        jocl_global_data_ptr_output, 0, NULL, NULL),return);
       CL_SAFE_CALL0(jocl_global_data_mem_qutable = jocl_clCreateBuffer(jocl_cl_get_context(),
         CL_MEM_READ_ONLY | CL_MEM_ALLOC_HOST_PTR,
-        4096, NULL, &err_code),return);
+        128 * sizeof(float), NULL, &err_code),return);
       CL_SAFE_CALL0(jocl_global_data_ptr_qutable = (float *)jocl_clEnqueueMapBuffer(
         jocl_cl_get_command_queue(), jocl_global_data_mem_qutable, CL_TRUE,
-        CL_MAP_WRITE_INVALIDATE_REGION, 0, 4096, 0, NULL, NULL, &err_code),return);
-      memset(jocl_global_data_ptr_qutable, 0, 4096);
+        CL_MAP_WRITE_INVALIDATE_REGION, 0, 128 * sizeof(float), 0, NULL, NULL, &err_code),return);
+      memset(jocl_global_data_ptr_qutable, 0, 128 * sizeof(float));
       CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
-        jocl_cl_get_command_queue(), jocl_global_data_mem_qutable ,
-        jocl_global_data_ptr_qutable, 0, NULL, NULL),);
+        jocl_cl_get_command_queue(), jocl_global_data_mem_qutable,
+        jocl_global_data_ptr_qutable, 0, NULL, NULL),return);
+
+      for(j = 0; j < BUFFERNUMS; ++j) {
+        CL_SAFE_CALL0(jocl_global_data_mem_input[j] = jocl_clCreateBuffer(jocl_cl_get_context(),
+          CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR,
+          MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF), NULL, &err_code),return);
+        CL_SAFE_CALL0(jocl_global_data_ptr_input[j] = (JCOEFPTR)jocl_clEnqueueMapBuffer(
+          jocl_cl_get_command_queue(), jocl_global_data_mem_input[j], CL_TRUE,
+          CL_MAP_WRITE_INVALIDATE_REGION, 0, MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF),
+          0, NULL, NULL, &err_code),return);
+        memset(jocl_global_data_ptr_input[j],0,MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF));
+        CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
+          jocl_cl_get_command_queue(), jocl_global_data_mem_input[j],
+          jocl_global_data_ptr_input[j], 0, NULL, NULL),return);
+      }
     }
     CL_SAFE_CALL0(jocl_global_data_mem_inter = jocl_clCreateBuffer(jocl_cl_get_context(), 
-      CL_MEM_READ_WRITE,MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 8 ,
-      NULL, &err_code),return);
+	  CL_MEM_READ_WRITE, MCUNUMS * DCTSIZE2 * 6, NULL, &err_code),return);
     if (CL_FALSE == jocldec_build_kernels(cinfo)) {
       jocl_cl_set_opencl_failure();
       jocl_cl_set_opencl_support_failure();
-      return;
     }
   }
 #endif
diff --git a/jdcoefct.c b/jdcoefct.c
index aa40ff5..5ca9245 100644
--- a/jdcoefct.c
+++ b/jdcoefct.c
@@ -172,20 +172,23 @@ decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
   int mcuy  = 0, index = 0;
   int block = cinfo->MCUs_per_row;
-  int i, j, upfactor;
+  int i, j, upfactor,buffer_index;
   int qutable[128];
-  float qutable_float[128];
+  float  qutable_float[128];
   short* qutable_short_inter = (short *)jocl_global_data_ptr_qutable;
-  int* qutable_int_inter = (int *)jocl_global_data_ptr_qutable;
+  int*   qutable_int_inter = (int *)jocl_global_data_ptr_qutable;
+  cl_event buffer_event[BUFFERNUMS];
+
+  unsigned long buffer_output_size = jocl_cl_get_buffer_unit_size();
 
   /*offset_input is used to compute the offset of input and output for Kernel*/
   unsigned int offset_input = 0;
-  /*kernel execution times  = cinfo->total_iMCU_rows/mcuNums*/
-  unsigned int mcuNums      = 800;
   unsigned int mcudecoder   = 0;
   int rows_per_iMCU_row     = coef->MCU_rows_per_iMCU_row;
   int decodeMCU = 0;
   int total_mcu_num = cinfo->total_iMCU_rows * rows_per_iMCU_row * cinfo->MCUs_per_row;
+  int buffer_flag = 0;
+  /* int info;*/
   /*IDCT FAST SHORT*/
   static const int aanscales[DCTSIZE2] = {
 	  /* precomputed values scaled up by 14 bits */
@@ -202,7 +205,6 @@ decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
   static const double aanscalefactor[8] = {1.0, 1.387039845, 1.306562965, 1.175875602,
                                            1.0, 0.785694958, 0.541196100, 0.275899379};
 
-
   if (CL_TRUE == jocl_cl_is_available()) { 
     switch (cinfo->dct_method){
 	  case JDCT_IFAST:{
@@ -295,17 +297,28 @@ decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
         yoffset++) {
         for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
           MCU_col_num++) {
+#ifdef PERFORMANCE_PPA
+  PPAStartCpuEventFunc(huffman);
+#endif
+            buffer_index = buffer_flag % BUFFERNUMS;
+
+            if(buffer_flag > (BUFFERNUMS - 1) && mcuy == 0) {
+             /*jocl_clGetEventInfo(buffer_event[buffer_index], CL_EVENT_COMMAND_EXECUTION_STATUS, sizeof(info),&info,NULL);*/
+             jocl_clWaitForEvents(1, &buffer_event[buffer_index]);
+            }
+
           if (CL_TRUE== jocl_cl_is_available()) {
 #ifndef JOCL_CL_OS_WIN32
             if(CL_FALSE == jocl_cl_is_nvidia_opencl()) {
-              jocl_global_data_ptr_input = (JCOEFPTR)jocl_clEnqueueMapBuffer(
-                jocl_cl_get_command_queue(), jocl_global_data_mem_input, CL_TRUE,
-                CL_MAP_WRITE_INVALIDATE_REGION, 0, MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4,
+              jocl_global_data_ptr_input[buffer_index] = (JCOEFPTR)jocl_clEnqueueMapBuffer(
+                jocl_cl_get_command_queue(), jocl_global_data_mem_input[buffer_index], CL_TRUE,
+                CL_MAP_WRITE_INVALIDATE_REGION, 0, MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF),
                 0, NULL, NULL, NULL);
             }
 #endif
-            for (index = 0; index<cinfo->blocks_in_MCU; ++index)
-              coef->MCU_buffer[index] = (JBLOCKROW)(jocl_global_data_ptr_input +
+
+            for (index = 0; index < cinfo->blocks_in_MCU; ++index)
+              coef->MCU_buffer[index] = (JBLOCKROW)(jocl_global_data_ptr_input[buffer_index] +
                 mcuy++ * DCTSIZE2);
           }
           if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
@@ -316,39 +329,28 @@ decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
           }
           decodeMCU++;
           mcudecoder++;
-
-          if(CL_TRUE == jocl_cl_is_nvidia_opencl()) {
-            if (     
-              (decodeMCU == cinfo->total_iMCU_rows *
-              coef->MCU_rows_per_iMCU_row * (last_MCU_col+1))) {
-              jocldec_run_kernels_full_image(cinfo,
-                                             upfactor,
-                                             mcudecoder,
-                                             block,
-                                             offset_input,
-                                             total_mcu_num,
-                                             decodeMCU);
-              offset_input += mcudecoder;
-              mcudecoder = 0;
-            }
-          }
-          else {
-            if (
+#ifdef PERFORMANCE_PPA
+   PPAStopCpuEventFunc(huffman);
+#endif
+          if (
 #ifdef OPENCL_PIPELINE
-              decodeMCU % mcuNums==0 ||
-#endif        
-              (decodeMCU == cinfo->total_iMCU_rows *
-              coef->MCU_rows_per_iMCU_row * (last_MCU_col+1))) {
-              jocldec_run_kernels_full_image(cinfo,
-                                             upfactor,
-                                             mcudecoder,
-                                             block,
-                                             offset_input,
-                                             total_mcu_num,
-                                             decodeMCU);
-              offset_input += mcudecoder;
-              mcudecoder = 0;
-            }
+            decodeMCU % MCUNUMS==0 ||
+#endif
+            (decodeMCU == cinfo->total_iMCU_rows *
+            coef->MCU_rows_per_iMCU_row * (last_MCU_col+1))) {
+            jocldec_run_kernels_full_image(cinfo,
+                                           upfactor,
+                                           mcudecoder,
+                                           block,
+                                           offset_input,
+                                           total_mcu_num,
+                                           decodeMCU,
+                                           buffer_index,
+                                           buffer_event);
+            offset_input += mcudecoder;
+            mcudecoder = 0;
+            mcuy = 0;
+            buffer_flag ++;
           }
         }
         /* Completed an MCU row, but perhaps not an iMCU row */
@@ -359,7 +361,7 @@ decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
 	  }
     }
 	/* Completed the iMCU row, advance counters for next one */
-	if ( ++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows) {
+	if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows) {
       (*cinfo->inputctl->finish_input_pass) (cinfo);
       return JPEG_ROW_COMPLETED;
     }
diff --git a/jdsample.c b/jdsample.c
index 7970d7c..4372540 100644
--- a/jdsample.c
+++ b/jdsample.c
@@ -145,9 +145,16 @@ sep_upsample (j_decompress_ptr cinfo,
     num_rows = out_rows_avail;
 
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
-  if (CL_TRUE== jocl_cl_is_available()) {
-    *output_buf = &jocl_global_data_ptr_output[cinfo->output_scanline * 
-      cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE * NUM_COMPONENT];
+  if (CL_TRUE == jocl_cl_is_available()) {
+    memcpy(*output_buf, jocl_global_data_ptr_output + cinfo->output_scanline * 
+      cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE * NUM_COMPONENT, 
+      cinfo->image_width * NUM_COMPONENT);
+    //*output_buf = &jocl_global_data_ptr_output[cinfo->output_scanline * 
+    //  cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE * NUM_COMPONENT];
+    if(num_rows == 2) {
+      *(output_buf + 1) =  &jocl_global_data_ptr_output[(cinfo->output_scanline + 1) * 
+        cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE * NUM_COMPONENT];
+    }
   }
   else
 #endif
diff --git a/jocldec.c b/jocldec.c
index deaaa3f..f27e6e4 100644
--- a/jocldec.c
+++ b/jocldec.c
@@ -20,11 +20,11 @@
 #include "jocldec_kernels.h"
 
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
-cl_mem   jocl_global_data_mem_input   = NULL;
+cl_mem   jocl_global_data_mem_input[BUFFERNUMS];
 cl_mem   jocl_global_data_mem_output  = NULL;
 cl_mem   jocl_global_data_mem_qutable = NULL;
 cl_mem   jocl_global_data_mem_inter   = NULL;
-JCOEFPTR jocl_global_data_ptr_input   = NULL;
+JCOEFPTR jocl_global_data_ptr_input[BUFFERNUMS];
 JSAMPROW jocl_global_data_ptr_output  = NULL;
 float*   jocl_global_data_ptr_qutable = NULL;
 
@@ -35,12 +35,11 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
   cl_int  err_code;
   cl_uint data_m = 6;
   cl_uint blocksWidth  = 64;
-  int     offset_input = 0;
   size_t  global_ws[1], local_ws[1];
 
   static  const char **jocldec_cl_source;
   char    **jocldec_cl_source_inter;
-  int     i;
+  int     i, j;
   jocldec_cl_source_inter = (char**) malloc(7 * sizeof(char*));
   for(i=0; i<7; ++i) {
     jocldec_cl_source_inter[i] = (char*) malloc(60000 * sizeof(char));
@@ -85,141 +84,163 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
 
                                   "UPSAMPLE_H2V1_FANCY_BGR",
                                   "UPSAMPLE_H2V2_FANCY_BGR",
+                                  "RESET_ZERO",
                                    NULL};
     jocldec_cl_rundata = jocl_cl_compile_and_build(jocldec_cl_source, kernel_names);
     /* IDCT FAST SHORT */
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_input),
-                                                 CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
-                                                 2,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_qutable),
-                                                 CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
-                                                 3,
-                                                 1024*sizeof(int),
-                                                 NULL),
-                                                 CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
-                                                 4,
-                                                 sizeof(int),
-                                                 &data_m),
-                                                 CL_FALSE);
-
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[0],
-                                                 1,
-                                                 0,
-                                                 global_ws,
-                                                 local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
-                                                 CL_FALSE);
-    /* IDCT SLOW INT */
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_input),
-                                                 CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
-                                                 2,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_qutable),
-                                                 CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
-                                                 3,
-                                                 1024*sizeof(int),
-                                                 NULL),
-                                                 CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
-                                                 4,
-                                                 sizeof(int),
-                                                 &data_m),
-                                                 CL_FALSE);
-
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[1],
-                                                 1,
-                                                 0,
-                                                 global_ws,
-                                                 local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
-                                                 CL_FALSE);
-    /* IDCT FAST FLOAT */
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_input),
-                                                 CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
-                                                 1,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
-                                                 2,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_qutable),
-                                                 CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
-                                                 3,
-                                                 1024*sizeof(int),
-                                                 NULL),
-                                                 CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
-                                                 4,
-                                                 sizeof(float),
-                                                 &data_m),
-                                                 CL_FALSE);
-
-    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[2],
-                                                 1,
-                                                 0,
-                                                 global_ws,
-                                                 local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
-                                                 CL_FALSE);
+    for(j = 0; j < BUFFERNUMS; ++j) {
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
+                                                   0,
+                                                   sizeof(cl_mem),
+                                                   &jocl_global_data_mem_input[j]),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
+                                                   1,
+                                                   sizeof(cl_mem),
+                                                   &jocl_global_data_mem_inter),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
+                                                   2,
+                                                   sizeof(cl_mem),
+                                                   &jocl_global_data_mem_qutable),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
+                                                   3,
+                                                   1024*sizeof(int),
+                                                   NULL),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[0],
+                                                   4,
+                                                   sizeof(int),
+                                                   &data_m),
+                                                   return CL_FALSE);      
+      CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                   jocldec_cl_rundata->kernel[0],
+                                                   1,
+                                                   0,
+                                                   global_ws,
+                                                   local_ws,
+                                                   0,
+                                                   NULL,
+                                                   NULL),
+                                                   return CL_FALSE);
+      /* IDCT SLOW INT */
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
+                                                   0,
+                                                   sizeof(cl_mem),
+                                                   &jocl_global_data_mem_input[j]),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
+                                                   1,
+                                                   sizeof(cl_mem),
+                                                   &jocl_global_data_mem_inter),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
+                                                   2,
+                                                   sizeof(cl_mem),
+                                                   &jocl_global_data_mem_qutable),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
+                                                   3,
+                                                   1024*sizeof(int),
+                                                   NULL),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[1],
+                                                   4,
+                                                   sizeof(int),
+                                                   &data_m),
+                                                   return CL_FALSE);
+      
+      CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                   jocldec_cl_rundata->kernel[1],
+                                                   1,
+                                                   0,
+                                                   global_ws,
+                                                   local_ws,
+                                                   0,
+                                                   NULL,
+                                                   NULL),
+                                                   return CL_FALSE);
+      /* IDCT FAST FLOAT */
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
+                                                   0,
+                                                   sizeof(cl_mem),
+                                                   &jocl_global_data_mem_input[j]),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
+                                                   1,
+                                                   sizeof(cl_mem),
+                                                   &jocl_global_data_mem_inter),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
+                                                   2,
+                                                   sizeof(cl_mem),
+                                                   &jocl_global_data_mem_qutable),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
+                                                   3,
+                                                   1024*sizeof(int),
+                                                   NULL),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[2],
+                                                   4,
+                                                   sizeof(float),
+                                                   &data_m),
+                                                   return CL_FALSE);
+      
+      CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                   jocldec_cl_rundata->kernel[2],
+                                                   1,
+                                                   0,
+                                                   global_ws,
+                                                   local_ws,
+                                                   0,
+                                                   NULL,
+                                                   NULL),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[21],
+                                                  0,
+                                                  sizeof(cl_mem),
+                                                  &jocl_global_data_mem_input[j]),
+                                                  return CL_FALSE);
+      
+      CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                  jocldec_cl_rundata->kernel[21],
+                                                  1,
+                                                  0,
+                                                  global_ws,
+                                                  local_ws,
+                                                  0,
+                                                  NULL,
+                                                  NULL),
+                                                  return CL_FALSE);
+    }
     /* H1V1 RGB */
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
                                                  2,
                                                  192*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
                                                  3,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-    
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[3],
+                                                 4,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);    
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[3],
                                                  1,
@@ -228,39 +249,44 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  local_ws,
                                                  0,
                                                  NULL,
-                                                 NULL),);
-    /* H1V2 RGB */
+                                                 NULL),
+												 return CL_FALSE);
+     /* H1V2 RGB */
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
                                                  2,
                                                  384*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
                                                  3,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
                                                  4,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);  
+                                                 return CL_FALSE);  
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
                                                  5,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[4],
+                                                 6,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[4],
                                                  1,
@@ -270,49 +296,53 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  0,
                                                  NULL,
                                                  NULL),
-                                                 CL_FALSE);
-   /* H2V1 RGB */
-   CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5], 
+                                                 return CL_FALSE);
+    /* H2V1 RGB */
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5], 
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
                                                  2,
                                                  384*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
                                                  3,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
                                                  4,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE); 
+                                                 return CL_FALSE); 
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
                                                  5,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
                                                  6,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
                                                  7,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[5],
+                                                 8,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[5],
                                                  1,
@@ -322,47 +352,51 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  0,
                                                  NULL,
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     /* H2V2 RGB */
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
                                                  2,
                                                  768*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
                                                  3,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
                                                  4, 64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE); 
+                                                 return CL_FALSE); 
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
                                                  5, 256*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                  return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
                                                  6,
                                                  256*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
                                                  7,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[6],
+                                                 8,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[6],
                                                  1,
@@ -372,49 +406,53 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  0,
                                                  NULL,
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     /* H2V1 RGB FANCY */
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7], 
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
                                                  2,
                                                  384*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
                                                  3,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
                                                  4,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE); 
+                                                 return CL_FALSE); 
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
                                                  5,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
                                                  6,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
                                                  7,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[7],
+                                                 8,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[7],
                                                  1,
@@ -424,47 +462,53 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  0,
                                                  NULL,
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     /* H2V2 RGB FANCY */
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
                                                  2,
                                                  768*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
                                                  3,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
-                                                 4, 64*sizeof(unsigned char),
+                                                 4,
+                                                 64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE); 
+                                                 return CL_FALSE); 
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
-                                                 5, 256*sizeof(unsigned char),
+                                                 5,
+                                                 256*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
                                                  6,
                                                  256*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
                                                  7,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[8],
+                                                 8,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[8],
                                                  1,
@@ -474,29 +518,33 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  0,
                                                  NULL,
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     /*H1V1_RGBA*/
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
                                                  2,
                                                  256*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
                                                  3,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[9],
+                                                 4,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[9],
                                                  1,
@@ -505,40 +553,45 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  local_ws,
                                                  0,
                                                  NULL,
-                                                 NULL),);
-
+                                                 NULL),
+                                                 return CL_FALSE);
+    
     /*H1V2_RGBA*/
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
                                                  2,
                                                  512*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
                                                  3,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
                                                  4,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);  
+                                                 return CL_FALSE);  
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
                                                  5,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[10],
+                                                 6,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[10],
                                                  1,
@@ -548,100 +601,110 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  0,
                                                  NULL,
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     /*H2V1_RGBA*/
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11], 
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
                                                  2,
                                                  512*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
                                                  3,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
                                                  4,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE); 
+                                                 return CL_FALSE); 
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
                                                  5,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
                                                  6,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
                                                  7,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-    
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[11],
+                                                 8,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);    
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                 jocldec_cl_rundata->kernel[11],
-                                                 1,
-                                                 0,
-                                                 global_ws,
-                                                 local_ws,
-                                                 0,
-                                                 NULL,
-                                                 NULL),
-                                                 CL_FALSE);
-
+                                                   jocldec_cl_rundata->kernel[11],
+                                                   1,
+                                                   0,
+                                                   global_ws,
+                                                   local_ws,
+                                                   0,
+                                                   NULL,
+                                                   NULL),
+                                                   return CL_FALSE);
+      
     /*H2V2_RGBA*/
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
                                                  2,
                                                  1024*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
                                                  3,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
-                                                 4, 64*sizeof(unsigned char),
+                                                 4,
+                                                 64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE); 
+                                                 return CL_FALSE); 
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
-                                                 5, 256*sizeof(unsigned char),
+                                                 5,
+                                                 256*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
                                                  6,
                                                  256*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
                                                  7,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[12],
+                                                 8,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[12],
                                                  1,
@@ -651,49 +714,53 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  0,
                                                  NULL,
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     /*H2V1_RGBA_FANCY*/
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13], 
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
                                                  2,
                                                  512*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
                                                  3,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
                                                  4,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE); 
+                                                 return CL_FALSE); 
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
                                                  5,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
                                                  6,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
                                                  7,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[13],
+                                                 8,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[13],
                                                  1,
@@ -703,47 +770,53 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  0,
                                                  NULL,
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     /*H2V2_RGBA_FANCY */
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
                                                  2,
                                                  1024*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
                                                  3,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
-                                                 4, 64*sizeof(unsigned char),
+                                                 4,
+                                                 64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE); 
+                                                 return CL_FALSE); 
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
-                                                 5, 256*sizeof(unsigned char),
+                                                 5,
+                                                 256*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
                                                  6,
                                                  256*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
                                                  7,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[14],
+                                                 8,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[14],
                                                  1,
@@ -753,29 +826,33 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  0,
                                                  NULL,
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     /* H1V1 BGR */
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
                                                  2,
                                                  192*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
                                                  3,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[15],
+                                                 4,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[15],
                                                  1,
@@ -784,39 +861,44 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  local_ws,
                                                  0,
                                                  NULL,
-                                                 NULL),);
+                                                 NULL),
+	 											 return CL_FALSE);
     /* H1V2 BGR */
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
                                                  2,
                                                  384*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
                                                  3,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
                                                  4,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);  
+                                                 return CL_FALSE);  
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
                                                  5,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[16],
+                                                 6,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[16],
                                                  1,
@@ -826,49 +908,53 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  0,
                                                  NULL,
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     /* H2V1 BGR */
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17], 
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
                                                  2,
                                                  384*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
                                                  3,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
                                                  4,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE); 
+                                                 return CL_FALSE); 
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
                                                  5,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
                                                  6,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
                                                  7,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[17],
+                                                 8,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[17],
                                                  1,
@@ -878,47 +964,53 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  0,
                                                  NULL,
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     /* H2V2 BGR */
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
                                                  2,
                                                  768*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
                                                  3,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
-                                                 4, 64*sizeof(unsigned char),
+                                                 4,
+                                                 64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE); 
+                                                 return CL_FALSE); 
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
-                                                 5, 256*sizeof(unsigned char),
+                                                 5,
+                                                 256*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
                                                  6,
                                                  256*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
                                                  7,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[18],
+                                                 8,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[18],
                                                  1,
@@ -928,49 +1020,53 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  0,
                                                  NULL,
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     /* H2V1 BGR FANCY  */
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19], 
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
                                                  2,
                                                  384*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
                                                  3,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
                                                  4,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE); 
+                                                 return CL_FALSE); 
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
                                                  5,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
                                                  6,
                                                  128*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
                                                  7,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[19],
+                                                 8,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[19],
                                                  1,
@@ -980,47 +1076,53 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  0,
                                                  NULL,
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     /* H2V2 BGR FANCY */
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
                                                  0,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_inter),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
                                                  1,
                                                  sizeof(cl_mem),
                                                  &jocl_global_data_mem_output),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
                                                  2,
                                                  768*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
                                                  3,
                                                  64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
-                                                 4, 64*sizeof(unsigned char),
+                                                 4,
+                                                 64*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE); 
+                                                 return CL_FALSE); 
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
-                                                 5, 256*sizeof(unsigned char),
+                                                 5,
+                                                 256*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
                                                  6,
                                                  256*sizeof(unsigned char),
                                                  NULL),
-                                                 CL_FALSE);
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
                                                  7,
                                                  sizeof(unsigned int),
                                                  &blocksWidth),
-                                                 CL_FALSE);
-
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[20],
+                                                 8,
+                                                 sizeof(unsigned int),
+                                                 &blocksWidth),
+                                                 return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_rundata->kernel[20],
                                                  1,
@@ -1030,8 +1132,8 @@ cl_bool jocldec_build_kernels(j_decompress_ptr cinfo)
                                                  0,
                                                  NULL,
                                                  NULL),
-                                                 CL_FALSE);
-    CL_SAFE_CALL0(err_code = jocl_clFinish(jocl_cl_get_command_queue()),CL_FALSE);
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clFinish(jocl_cl_get_command_queue()), return CL_FALSE);
   }
   return CL_TRUE;
 }
@@ -1043,20 +1145,22 @@ cl_bool jocldec_run_kernels_full_image(
                             unsigned int blocksWidth,
                             unsigned int offset_mcu,
                             int total_mcu_num,
-                            int decodeMCU)
+                            int decodeMCU,
+                            int buffer_index,
+                            cl_event* buffer_event)
 {
   cl_int err_code;
   size_t global_ws,local_ws;
   int    mcu_out,mcu_in;
   int    data_m_inter = data_m;
-  int    data_index = 0,sign = 0;
   int    size_map;
-  unsigned int offset_output,offset_input;
+  unsigned int offset_output;
   cl_kernel jocldec_cl_kernel_use;
 
   int KernelArg2 = 0;
   int KernelArg5 = 0;
   int KernelArg6 = 0;
+  /* int info; */
 
   if (data_m==5) data_m_inter = 4;
   switch(data_m) {
@@ -1078,21 +1182,20 @@ cl_bool jocldec_run_kernels_full_image(
             break;
   }
   if(CL_TRUE == jocl_cl_is_nvidia_opencl()) {
-    CL_SAFE_CALL0(jocl_global_data_mem_input = jocl_clCreateBuffer(jocl_cl_get_context(),
+    CL_SAFE_CALL0(jocl_global_data_mem_input[buffer_index] = jocl_clCreateBuffer(jocl_cl_get_context(),
       CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR,
-      MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4, jocl_global_data_ptr_input, &err_code),return CL_FALSE);
+     MCUNUMS * DCTSIZE2 * 6 * sizeof(JCOEF), jocl_global_data_ptr_input[buffer_index], &err_code),return CL_FALSE); 
     CL_SAFE_CALL0(jocl_global_data_mem_qutable = jocl_clCreateBuffer(jocl_cl_get_context(),
       CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
-      4096, jocl_global_data_ptr_qutable, &err_code),return CL_FALSE);
-}
+      128 * sizeof(float), jocl_global_data_ptr_qutable, &err_code),return CL_FALSE);
+  }
 #ifndef JOCL_CL_OS_WIN32
   if(CL_FALSE == jocl_cl_is_nvidia_opencl()) {
     CL_SAFE_CALL0(err_code = jocl_clEnqueueUnmapMemObject(
-      jocl_cl_get_command_queue(), jocl_global_data_mem_input,
-      jocl_global_data_ptr_input, 0, NULL, NULL),return CL_FALSE);
+      jocl_cl_get_command_queue(), jocl_global_data_mem_input[buffer_index],
+      jocl_global_data_ptr_input[buffer_index], 0, NULL, NULL),return CL_FALSE);
   }
 #endif
-  offset_input = offset_mcu * mcu_in/8;
   switch (cinfo->dct_method){
     case JDCT_IFAST:
       local_ws = 256;
@@ -1107,12 +1210,12 @@ cl_bool jocldec_run_kernels_full_image(
       jocldec_cl_kernel_use = jocldec_cl_rundata->kernel[2];
       break;
   }
-  if (0 == offset_mcu) {
-    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                 0,
-                                                 sizeof(cl_mem),
-                                                 &jocl_global_data_mem_input),
-                                                 return CL_FALSE);
+  CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                               0,
+                                               sizeof(cl_mem),
+                                               &jocl_global_data_mem_input[buffer_index]),
+                                               return CL_FALSE);
+  if (0 == offset_mcu || CL_TRUE == jocl_cl_is_nvidia_opencl()) {
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  1,
                                                  sizeof(cl_mem),
@@ -1125,7 +1228,7 @@ cl_bool jocldec_run_kernels_full_image(
                                                  return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                  3,
-                                                 1024*sizeof(int),
+                                                 4096,
                                                  NULL),
                                                  return CL_FALSE);
     CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
@@ -1137,7 +1240,7 @@ cl_bool jocldec_run_kernels_full_image(
   CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
                                                  jocldec_cl_kernel_use,
                                                  1,
-                                                 &offset_input,
+                                                 0,
                                                  &global_ws,
                                                  &local_ws,
                                                  0,
@@ -1159,38 +1262,43 @@ cl_bool jocldec_run_kernels_full_image(
         jocldec_cl_kernel_use = jocldec_cl_rundata->kernel[15];
         break;
 	}/*end switch */
-	if (0 == offset_mcu) {
+    if (0 == offset_mcu || CL_TRUE == jocl_cl_is_nvidia_opencl()) {
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                   0,
+                                                   sizeof(cl_mem),
+                                                   &jocl_global_data_mem_inter),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                   1,
+                                                   sizeof(cl_mem),
+                                                   &jocl_global_data_mem_output),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                   2,
+                                                   256*sizeof(unsigned char),
+                                                   NULL),
+                                                   return CL_FALSE);
       CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                    0,
-                                                    sizeof(cl_mem),
-                                                    &jocl_global_data_mem_inter),
-                                                    return CL_FALSE);
-       CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                    1,
-                                                    sizeof(cl_mem),
-                                                    &jocl_global_data_mem_output),
-                                                    return CL_FALSE);
-       CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                    2,
-                                                    256*sizeof(unsigned char),
-                                                    NULL),
-                                                    return CL_FALSE);
-       CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                    3,
-                                                    sizeof(unsigned int),
-                                                    &blocksWidth),
-                                                    return CL_FALSE);
-        }
-       CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                       jocldec_cl_kernel_use,
-                                                       1,
-                                                       &offset_output,
-                                                       &global_ws,
-                                                       &local_ws,
-                                                       0,
-                                                       NULL,
-                                                       NULL),
-                                                       return CL_FALSE);
+                                                   3,
+                                                   sizeof(unsigned int),
+                                                   &blocksWidth),
+                                                   return CL_FALSE);
+    }
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 4,
+                                                 sizeof(unsigned int),
+                                                 &offset_output),
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_kernel_use,
+                                                 1,
+                                                 0,
+                                                 &global_ws,
+                                                 &local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 return CL_FALSE);
   }  /*1v1 end*/
   else if(5 == data_m){ 
 	offset_output = offset_mcu * 128;
@@ -1210,7 +1318,7 @@ cl_bool jocldec_run_kernels_full_image(
 	  	jocldec_cl_kernel_use = jocldec_cl_rundata->kernel[16];
         break;
 	}/*end switch */
-	if (0 == offset_mcu) {
+    if (0 == offset_mcu || CL_TRUE == jocl_cl_is_nvidia_opencl()) {
       CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
                                                    0,
                                                    sizeof(cl_mem),
@@ -1241,17 +1349,22 @@ cl_bool jocldec_run_kernels_full_image(
                                                    sizeof(unsigned int),
                                                    &blocksWidth),
                                                    return CL_FALSE);
-      }
-      CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                       jocldec_cl_kernel_use,
-                                                       1,
-                                                       &offset_output,
-                                                       &global_ws,
-                                                       &local_ws,
-                                                       0,
-                                                       NULL,
-                                                       NULL),
-                                                       return CL_FALSE);
+    }
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                   6,
+                                                   sizeof(unsigned int),
+                                                   &offset_output),
+                                                   return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                   jocldec_cl_kernel_use,
+                                                   1,
+                                                   0,
+                                                   &global_ws,
+                                                   &local_ws,
+                                                   0,
+                                                   NULL,
+                                                   NULL),
+                                                   return CL_FALSE);
   }/*1v2 end*/
   else if((4 == data_m ) || (6 == data_m )){
 	switch (cinfo->out_color_space){
@@ -1353,64 +1466,93 @@ cl_bool jocldec_run_kernels_full_image(
           else{
             jocldec_cl_kernel_use = jocldec_cl_rundata -> kernel[20];
           }
-      }/* end if(data_m == 6)*/
-     }/*end of case JCS_EXT_BGR:*/
-     break;
+        }/* end if(data_m == 6)*/
+      }/*end of case JCS_EXT_BGR:*/
+      break;
     }/*end switch */
-    if (0 == offset_mcu) {
-       CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                    0,
-                                                    sizeof(cl_mem),
-                                                    &jocl_global_data_mem_inter),
-                                                    return CL_FALSE);
-       CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                    1,
-                                                    sizeof(cl_mem),
-                                                    &jocl_global_data_mem_output),
-                                                    return CL_FALSE);
-       CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                    2,
-                                                    KernelArg2,
-                                                    NULL),
-                                                    return CL_FALSE);
-       CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                    3,
-                                                    64*sizeof(unsigned char),
-                                                    NULL),
-                                                    return CL_FALSE);
-       CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                    4,
-                                                    64*sizeof(unsigned char),
-                                                    NULL),
-                                                    return CL_FALSE);
-       CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                    5,
-                                                    KernelArg5,
-                                                    NULL),
-                                                    return CL_FALSE);
-       CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                    6,
-                                                    KernelArg6,
-                                                    NULL),
-                                                    return CL_FALSE);
-       CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
-                                                    7,
-                                                    sizeof(unsigned int),
-                                                    &blocksWidth),
-                                                    return CL_FALSE);
-       }
-       CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
-                                                         jocldec_cl_kernel_use,
-                                                         1,
-                                                         &offset_output,
-                                                         &global_ws,
-                                                         &local_ws,
-                                                         0,
-                                                         NULL,
-                                                         NULL),
-                                                         return CL_FALSE);
+    if (0 == offset_mcu || CL_TRUE == jocl_cl_is_nvidia_opencl()) {
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                   0,
+                                                   sizeof(cl_mem),
+                                                   &jocl_global_data_mem_inter),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                   1,
+                                                   sizeof(cl_mem),
+                                                   &jocl_global_data_mem_output),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                   2,
+                                                   KernelArg2,
+                                                   NULL),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                   3,
+                                                   64*sizeof(unsigned char),
+                                                   NULL),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                   4,
+                                                   64*sizeof(unsigned char),
+                                                   NULL),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                   5,
+                                                   KernelArg5,
+                                                   NULL),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                   6,
+                                                   KernelArg6,
+                                                   NULL),
+                                                   return CL_FALSE);
+      CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                   7,
+                                                   sizeof(unsigned int),
+                                                   &blocksWidth),
+                                                   return CL_FALSE);
+    }
+    CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_kernel_use,
+                                                 8,
+                                                 sizeof(unsigned int),
+                                                 &offset_output),
+                                                 return CL_FALSE);
+    CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                                 jocldec_cl_kernel_use,
+                                                 1,
+                                                 0,
+                                                 &global_ws,
+                                                 &local_ws,
+                                                 0,
+                                                 NULL,
+                                                 NULL),
+                                                 return CL_FALSE);
 
   }
+  global_ws = (mcu_num * mcu_in/8 + 255)/256*256;
+  local_ws  = 256;
+  CL_SAFE_CALL0(err_code = jocl_clSetKernelArg(jocldec_cl_rundata->kernel[21],
+                                               0,
+                                               sizeof(cl_mem),
+                                               &jocl_global_data_mem_input[buffer_index]),
+                                               return CL_FALSE);
+
+  CL_SAFE_CALL0(err_code = jocl_clEnqueueNDRangeKernel(jocl_cl_get_command_queue(),
+                                               jocldec_cl_rundata->kernel[21],
+                                               1,
+                                               0,
+                                               &global_ws,
+                                               &local_ws,
+                                               0,
+                                               NULL,
+                                               &buffer_event[buffer_index]),
+                                               return CL_FALSE);
+ /* jocl_clGetEventInfo(*buffer_event, CL_EVENT_COMMAND_EXECUTION_STATUS, sizeof(info),&info,NULL); */
+
+  if(CL_TRUE == jocl_cl_is_nvidia_opencl()) {
+    CL_SAFE_CALL0(jocl_clReleaseMemObject(jocl_global_data_mem_input[buffer_index]),return CL_FALSE);
+    CL_SAFE_CALL0(jocl_clReleaseMemObject(jocl_global_data_mem_qutable),return CL_FALSE);
+  }
   size_map = cinfo->max_h_samp_factor * cinfo->MCUs_per_row * DCTSIZE *
     cinfo->image_height * NUM_COMPONENT;
 
@@ -1430,4 +1572,5 @@ cl_bool jocldec_run_kernels_full_image(
   }
   return CL_TRUE;
 }
+
 #endif
diff --git a/jocldec.h b/jocldec.h
index 4994801..fffcff8 100644
--- a/jocldec.h
+++ b/jocldec.h
@@ -16,12 +16,12 @@
 #define __JPEG_OPENCL_DECODING_H__
 
 /* Global OpenCL buffer and mapping variables. */
-extern cl_mem   jocl_global_data_mem_input;
+extern cl_mem   jocl_global_data_mem_input[BUFFERNUMS];
 extern cl_mem   jocl_global_data_mem_output;
 extern cl_mem   jocl_global_data_mem_qutable;
 extern cl_mem   jocl_global_data_mem_inter;
 extern float*   jocl_global_data_ptr_qutable;
-extern JCOEFPTR jocl_global_data_ptr_input;
+extern JCOEFPTR jocl_global_data_ptr_input[BUFFERNUMS];
 extern JSAMPROW jocl_global_data_ptr_output;
 
 /* Compile OpenCL kernels. */
@@ -35,5 +35,7 @@ cl_bool jocldec_run_kernels_full_image(
   unsigned int mcu_in_width,      /* Number of MCUs in image width */
   unsigned int offset_input,      /* The offset of buffer used to calculate the global ID */
   int total_mcu_num,              /* The total MCU-number of an image */
-  int decodeMCU);                 /* The number of MCUs will be decoded */
+  int decodeMCU,                  /* The number of MCUs will be decoded */
+  int buffer_flag,                /* The index of buffer will be used */
+  cl_event* buffer_event);        /* The event of OpenCL sent by clEnqueueNDRangeKernel() */
 #endif
diff --git a/jocldec_kernels.h b/jocldec_kernels.h
index 4c4a8f8..82174f7 100644
--- a/jocldec_kernels.h
+++ b/jocldec_kernels.h
@@ -350,12 +350,14 @@ static const char     * jocldec_cl_source1  =
 "}                                                                        \n";
 
 static const char     * jocldec_cl_source2  =
-"__kernel void UPSAMPLE_H1V1_RGB            (__global uchar  *src,        \n"
+"__kernel void UPSAMPLE_H1V1_RGB        (__global uchar  *src,            \n"
 "                                        __global uchar4 *dst,            \n"
 "                                        __local  uchar  *inter,          \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
 "  uint    globalIdx = get_global_id(0);                                  \n"
+"  uint    globalIdx1= get_global_id(0) + mcu_offset;                     \n"
 "  uint    localIdx  = get_local_id (0);                                  \n"
 "  uchar   dataInY   = src[globalIdx / 64 * 192 + localIdx];              \n"
 "  uchar   dataInCb  = src[globalIdx / 64 * 192 + 64 + localIdx];         \n"
@@ -363,8 +365,8 @@ static const char     * jocldec_cl_source2  =
 "  uchar   imgR, imgG, imgB;                                              \n"
 "  uint    x, y;                                                          \n"
 "                                                                         \n"
-"  x = (globalIdx >> 6) % mcu_width;                                      \n"
-"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 6) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 6) / mcu_width;                                     \n"
 "                                                                         \n"
 "  imgB = convert_uchar_sat(                                              \n"
 "    dataInY  + (((int)91881 * (dataInCr - 128) + (int)32768) >> 16));    \n"
@@ -384,22 +386,24 @@ static const char     * jocldec_cl_source2  =
 "      + localIdx / 6 * mcu_width * 6] = vload4(localIdx, inter);         \n"
 "}                                                                        \n"
 "                                                                         \n"
-"__kernel void UPSAMPLE_H1V2_RGB            (__global uchar  *src,        \n"
+"__kernel void UPSAMPLE_H1V2_RGB        (__global uchar  *src,            \n"
 "                                        __global uchar4 *dst,            \n"
 "                                        __local  uchar  *inter,          \n"
 "                                        __local  uchar  *cb_cache,       \n"
 "                                        __local  uchar  *cr_cache,       \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
 "  uint    globalIdx = get_global_id(0);                                  \n"
-"  uint    localIdx =  get_local_id(0);                                   \n"
+"  uint    globalIdx1= get_global_id(0) + mcu_offset;                     \n"
+"  uint    localIdx  =  get_local_id(0);                                  \n"
 "  uint    transOffset = ((localIdx >> 4) << 3) + (localIdx & 0x07);      \n"
 "  uchar   dataInY = src[globalIdx / 128 * 256 + localIdx];               \n"
 "  uchar   imgR, imgG, imgB;                                              \n"
 "  uint    x, y;                                                          \n"
 "                                                                         \n"
-"  x = (globalIdx >> 7) % mcu_width;                                      \n"
-"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 7) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 7) / mcu_width;                                     \n"
 "                                                                         \n"
 "  if (localIdx < 64)                                                     \n"
 "  {                                                                      \n"
@@ -433,9 +437,11 @@ static const char     * jocldec_cl_source2  =
 "                                        __local  uchar  *cr_cache,       \n"
 "                                        __local  uchar2 *cb_upsample,    \n"
 "                                        __local  uchar2 *cr_upsample,    \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
 "  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    globalIdx1  = get_global_id(0) + mcu_offset;                   \n"
 "  uint    localIdx    = get_local_id (0);                                \n"
 "  uint    transOffset =                                                  \n"
 "    ((localIdx >> 2) << 2) - (localIdx >> 5) * 60 + localIdx;            \n"
@@ -448,8 +454,8 @@ static const char     * jocldec_cl_source2  =
 "  int     valueY,valueCb, valueCr;                                       \n"
 "  uint    x, y;                                                          \n"
 "                                                                         \n"
-"  x = (globalIdx >> 6) % mcu_width;                                      \n"
-"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 6) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 6) / mcu_width;                                     \n"
 "                                                                         \n"
 "  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
 "                                                                         \n"
@@ -504,9 +510,11 @@ static const char     * jocldec_cl_source2  =
 "                                        __local  uchar  *cr_cache,       \n"
 "                                        __local  uchar2 *cb_upsample,    \n"
 "                                        __local  uchar2 *cr_upsample,    \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
 "  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    globalIdx1  = get_global_id(0) + mcu_offset;                   \n"
 "  uint    localIdx    = get_local_id (0);                                \n"
 "  uint    transOffset = localIdx - (localIdx >> 5) * 60 +                \n"
 "    (localIdx >> 2 << 2) + (localIdx >> 6) * 56;                         \n"
@@ -515,8 +523,8 @@ static const char     * jocldec_cl_source2  =
 "  int     valueY, valueCb, valueCr;                                      \n"
 "  uint    x, y;                                                          \n"
 "                                                                         \n"
-"  x = (globalIdx >> 7) % mcu_width;                                      \n"
-"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 7) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 7) / mcu_width;                                     \n"
 "                                                                         \n"
 "  if (localIdx < 64)                                                     \n"
 "  {                                                                      \n"
@@ -573,16 +581,18 @@ static const char     * jocldec_cl_source2  =
 "}                                                                        \n";
 
 static const char     * jocldec_cl_source3  =
-"__kernel void UPSAMPLE_H2V1_FANCY_RGB   (__global uchar  *src,           \n"
+"__kernel void UPSAMPLE_H2V1_FANCY_RGB  (__global uchar  *src,            \n"
 "                                        __global uchar8 *dst,            \n"
 "                                        __local  uchar  *inter,          \n"
 "                                        __local  uchar  *cb_cache,       \n"
 "                                        __local  uchar  *cr_cache,       \n"
 "                                        __local  uchar2 *cb_upsample,    \n"
 "                                        __local  uchar2 *cr_upsample,    \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
 "  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    globalIdx1  = get_global_id(0) + mcu_offset;                   \n"
 "  uint    localIdx    = get_local_id (0);                                \n"
 "  uint    transOffset =                                                  \n"
 "    ((localIdx >> 2) << 2) - (localIdx >> 5) * 60 + localIdx;            \n"
@@ -596,8 +606,8 @@ static const char     * jocldec_cl_source3  =
 "  int     valueY,valueCb, valueCr;                                       \n"
 "  uint    x, y;                                                          \n"
 "                                                                         \n"
-"  x = (globalIdx >> 6) % mcu_width;                                      \n"
-"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 6) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 6) / mcu_width;                                     \n"
 "                                                                         \n"
 "  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
 "                                                                         \n"
@@ -677,16 +687,18 @@ static const char     * jocldec_cl_source3  =
 "    dst[y * mcu_width * 48 + x * 6 + localIdx % 6 +                      \n"
 "      localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);           \n"
 "}                                                                        \n"
-"__kernel void UPSAMPLE_H2V2_FANCY_RGB      (__global uchar  *src,        \n"
+"__kernel void UPSAMPLE_H2V2_FANCY_RGB  (__global uchar  *src,            \n"
 "                                        __global uchar8 *dst,            \n"
 "                                        __local  uchar  *inter,          \n"
 "                                        __local  uchar  *cb_cache,       \n"
 "                                        __local  uchar  *cr_cache,       \n"
 "                                        __local  uchar2 *cb_upsample,    \n"
 "                                        __local  uchar2 *cr_upsample,    \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
-"  uint   globalIdx   = get_global_id(0);                                 \n"
+/*"  uint   globalIdx   = get_global_id(0);                                 \n"
+"  uint    globalIdx1  = get_global_id(0) + mcu_offset;                   \n"
 "  uint   localIdx    = get_local_id (0);                                 \n"
 "  uint   transOffset = localIdx - (localIdx >> 5) * 60 +                 \n"
 "    (localIdx >> 2 << 2) + (localIdx >> 6) * 56;                         \n"
@@ -702,8 +714,8 @@ static const char     * jocldec_cl_source3  =
 "  int    dataInLeftBottomCr, dataInRightBottomCr;                        \n"
 "                                                                         \n"
 "  uchar   dataInCb ,dataInCr;                                            \n"
-"  x = (globalIdx >> 7) % mcu_width;                                      \n"
-"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 7) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 7) / mcu_width;                                     \n"
 "                                                                         \n"
 "  if (localIdx < 64)                                                     \n"
 "  {                                                                      \n"
@@ -1127,16 +1139,18 @@ static const char     * jocldec_cl_source3  =
 "  if (localIdx < 96)                                                     \n"
 "    dst[y * mcu_width * 96 + x * 6 + localIdx % 6                        \n"
 "      + localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);         \n"
-"                                                                         \n"
+"                                                                         \n"*/
 "}                                                                        \n";
 
 static const char     * jocldec_cl_source4  =
-"__kernel void UPSAMPLE_H1V1_RGBA           (__global uchar  *src,        \n"
+"__kernel void UPSAMPLE_H1V1_RGBA       (__global uchar  *src,            \n"
 "                                        __global uchar4 *dst,            \n"
 "                                        __local  uchar  *inter,          \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
 "  uint    globalIdx = get_global_id(0);                                  \n"
+"  uint    globalIdx1= get_global_id(0) + mcu_offset;                     \n"
 "  uint    localIdx  = get_local_id (0);                                  \n"
 "  uchar   dataInY   = src[globalIdx / 64 * 192 + localIdx];              \n"
 "  uchar   dataInCb  = src[globalIdx / 64 * 192 + 64 + localIdx];         \n"
@@ -1144,8 +1158,8 @@ static const char     * jocldec_cl_source4  =
 "  uchar   imgR, imgG, imgB, imgA;                                        \n"
 "  uint    x, y;                                                          \n"
 "                                                                         \n"
-"  x = (globalIdx >> 6) % mcu_width;                                      \n"
-"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 6) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 6) / mcu_width;                                     \n"
 "                                                                         \n"
 "  imgB = convert_uchar_sat(                                              \n"
 "    dataInY  + (((int)91881 * (dataInCr - 128) + (int)32768) >> 16));    \n"
@@ -1172,17 +1186,19 @@ static const char     * jocldec_cl_source4  =
 "                                        __local  uchar  *inter,          \n"
 "                                        __local  uchar  *cb_cache,       \n"
 "                                        __local  uchar  *cr_cache,       \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
 "  uint    globalIdx = get_global_id(0);                                  \n"
-"  uint    localIdx =  get_local_id(0);                                   \n"
+"  uint    globalIdx1= get_global_id(0) + mcu_offset;                     \n"
+"  uint    localIdx  =  get_local_id(0);                                  \n"
 "  uint    transOffset = ((localIdx >> 4) << 3) + (localIdx & 0x07);      \n"
 "  uchar   dataInY = src[globalIdx / 128 * 256 + localIdx];               \n"
 "  uchar   imgR, imgG, imgB,imgA;                                         \n"
 "  uint    x, y;                                                          \n"
 "                                                                         \n"
-"  x = (globalIdx >> 7) % mcu_width;                                      \n"
-"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 7) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 7) / mcu_width;                                     \n"
 "                                                                         \n"
 "  if (localIdx < 64)                                                     \n"
 "  {                                                                      \n"
@@ -1210,16 +1226,18 @@ static const char     * jocldec_cl_source4  =
 "      localIdx / 8 * mcu_width * 8] = vload4(localIdx, inter);           \n"
 "}                                                                        \n"
 "                                                                         \n"
-"__kernel void UPSAMPLE_H2V1_RGBA            (__global uchar  *src,       \n"
+"__kernel void UPSAMPLE_H2V1_RGBA       (__global uchar  *src,            \n"
 "                                        __global uchar8 *dst,            \n"
 "                                        __local  uchar  *inter,          \n"
 "                                        __local  uchar  *cb_cache,       \n"
 "                                        __local  uchar  *cr_cache,       \n"
 "                                        __local  uchar2 *cb_upsample,    \n"
 "                                        __local  uchar2 *cr_upsample,    \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
 "  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    globalIdx1  = get_global_id(0) + mcu_offset;                   \n"
 "  uint    localIdx    = get_local_id (0);                                \n"
 "  uint    transOffset =                                                  \n"
 "    ((localIdx >> 2) << 2) - (localIdx >> 5) * 60 + localIdx;            \n"
@@ -1233,8 +1251,8 @@ static const char     * jocldec_cl_source4  =
 "  int     valueY,valueCb, valueCr;                                       \n"
 "  uint    x, y;                                                          \n"
 "                                                                         \n"
-"  x = (globalIdx >> 6) % mcu_width;                                      \n"
-"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 6) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 6) / mcu_width;                                     \n"
 "                                                                         \n"
 "  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
 "                                                                         \n"
@@ -1283,16 +1301,18 @@ static const char     * jocldec_cl_source4  =
 "      localIdx / 8 * mcu_width * 8] = vload8(localIdx, inter);           \n"
 "}                                                                        \n"
 "                                                                         \n"
-"__kernel void UPSAMPLE_H2V2_RGBA            (__global uchar  *src,       \n"
+"__kernel void UPSAMPLE_H2V2_RGBA       (__global uchar  *src,            \n"
 "                                        __global uchar8 *dst,            \n"
 "                                        __local  uchar  *inter,          \n"
 "                                        __local  uchar  *cb_cache,       \n"
 "                                        __local  uchar  *cr_cache,       \n"
 "                                        __local  uchar2 *cb_upsample,    \n"
 "                                        __local  uchar2 *cr_upsample,    \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
 "  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    globalIdx1  = get_global_id(0) + mcu_offset;                   \n"
 "  uint    localIdx    = get_local_id (0);                                \n"
 "  uint    transOffset = localIdx - (localIdx >> 5) * 60 +                \n"
 "    (localIdx >> 2 << 2) + (localIdx >> 6) * 56;                         \n"
@@ -1301,8 +1321,8 @@ static const char     * jocldec_cl_source4  =
 "  int     valueY, valueCb, valueCr;                                      \n"
 "  uint    x, y;                                                          \n"
 "                                                                         \n"
-"  x = (globalIdx >> 7) % mcu_width;                                      \n"
-"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 7) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 7) / mcu_width;                                     \n"
 "                                                                         \n"
 "  if (localIdx < 64)                                                     \n"
 "  {                                                                      \n"
@@ -1360,16 +1380,18 @@ static const char     * jocldec_cl_source4  =
 "}                                                                        \n";
 
 static const char     * jocldec_cl_source5  =
-"__kernel void UPSAMPLE_H2V1_FANCY_RGBA      (__global uchar  *src,       \n"
+"__kernel void UPSAMPLE_H2V1_FANCY_RGBA (__global uchar  *src,            \n"
 "                                        __global uchar8 *dst,            \n"
 "                                        __local  uchar  *inter,          \n"
 "                                        __local  uchar  *cb_cache,       \n"
 "                                        __local  uchar  *cr_cache,       \n"
 "                                        __local  uchar2 *cb_upsample,    \n"
 "                                        __local  uchar2 *cr_upsample,    \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
 "  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    globalIdx1  = get_global_id(0) + mcu_offset;                   \n"
 "  uint    localIdx    = get_local_id (0);                                \n"
 "  uint    transOffset =                                                  \n"
 "    ((localIdx >> 2) << 2) - (localIdx >> 5) * 60 + localIdx;            \n"
@@ -1383,8 +1405,8 @@ static const char     * jocldec_cl_source5  =
 "  int     valueY,valueCb, valueCr;                                       \n"
 "  uint    x, y;                                                          \n"
 "                                                                         \n"
-"  x = (globalIdx >> 6) % mcu_width;                                      \n"
-"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 6) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 6) / mcu_width;                                     \n"
 "                                                                         \n"
 "  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
 "                                                                         \n"
@@ -1466,16 +1488,18 @@ static const char     * jocldec_cl_source5  =
 "    dst[y * mcu_width * 64 + x * 8 + localIdx % 8 +                      \n"
 "      localIdx / 8 * mcu_width * 8] = vload8(localIdx, inter);           \n"
 "}                                                                        \n"
-"__kernel void UPSAMPLE_H2V2_FANCY_RGBA     (__global uchar  *src,        \n"
+"__kernel void UPSAMPLE_H2V2_FANCY_RGBA (__global uchar  *src,            \n"
 "                                        __global uchar8 *dst,            \n"
 "                                        __local  uchar  *inter,          \n"
 "                                        __local  uchar  *cb_cache,       \n"
 "                                        __local  uchar  *cr_cache,       \n"
 "                                        __local  uchar2 *cb_upsample,    \n"
 "                                        __local  uchar2 *cr_upsample,    \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
-"  uint   globalIdx   = get_global_id(0);                                 \n"
+/*"  uint   globalIdx   = get_global_id(0);                                 \n"
+"  uint   globalIdx1  = get_global_id(0) + mcu_offset;                    \n"
 "  uint   localIdx    = get_local_id (0);                                 \n"
 "  uint   transOffset = localIdx - (localIdx >> 5) * 60 +                 \n"
 "    (localIdx >> 2 << 2) + (localIdx >> 6) * 56;                         \n"
@@ -1491,8 +1515,8 @@ static const char     * jocldec_cl_source5  =
 "  int    dataInLeftBottomCr, dataInRightBottomCr;                        \n"
 "                                                                         \n"
 "  uchar   dataInCb ,dataInCr;                                            \n"
-"  x = (globalIdx >> 7) % mcu_width;                                      \n"
-"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 7) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 7) / mcu_width;                                     \n"
 "                                                                         \n"
 "  if (localIdx < 64)                                                     \n"
 "  {                                                                      \n"
@@ -1917,16 +1941,17 @@ static const char     * jocldec_cl_source5  =
 "  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
 "  if (localIdx < 128)                                                    \n"
 "    dst[y * mcu_width * 128 + x * 8 + localIdx % 8                       \n"
-"      + localIdx / 8 * mcu_width * 8] = vload8(localIdx, inter);         \n"
-"                                                                         \n"
+"      + localIdx / 8 * mcu_width * 8] = vload8(localIdx, inter);         \n"*/
 "}                                                                        \n";
 static const char     * jocldec_cl_source6  =
-"__kernel void UPSAMPLE_H1V1_BGR            (__global uchar  *src,        \n"
+"__kernel void UPSAMPLE_H1V1_BGR        (__global uchar  *src,            \n"
 "                                        __global uchar4 *dst,            \n"
 "                                        __local  uchar  *inter,          \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
 "  uint    globalIdx = get_global_id(0);                                  \n"
+"  uint    globalIdx1= get_global_id(0) + mcu_offset;                     \n"
 "  uint    localIdx  = get_local_id (0);                                  \n"
 "  uchar   dataInY   = src[globalIdx / 64 * 192 + localIdx];              \n"
 "  uchar   dataInCb  = src[globalIdx / 64 * 192 + 64 + localIdx];         \n"
@@ -1934,8 +1959,8 @@ static const char     * jocldec_cl_source6  =
 "  uchar   imgR, imgG, imgB;                                              \n"
 "  uint    x, y;                                                          \n"
 "                                                                         \n"
-"  x = (globalIdx >> 6) % mcu_width;                                      \n"
-"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 6) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 6) / mcu_width;                                     \n"
 "                                                                         \n"
 "  imgB = convert_uchar_sat(                                              \n"
 "    dataInY  + (((int)91881 * (dataInCr - 128) + (int)32768) >> 16));    \n"
@@ -1955,22 +1980,24 @@ static const char     * jocldec_cl_source6  =
 "      + localIdx / 6 * mcu_width * 6] = vload4(localIdx, inter);         \n"
 "}                                                                        \n"
 "                                                                         \n"
-"__kernel void UPSAMPLE_H1V2_BGR            (__global uchar  *src,        \n"
+"__kernel void UPSAMPLE_H1V2_BGR        (__global uchar  *src,            \n"
 "                                        __global uchar4 *dst,            \n"
 "                                        __local  uchar  *inter,          \n"
 "                                        __local  uchar  *cb_cache,       \n"
 "                                        __local  uchar  *cr_cache,       \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
 "  uint    globalIdx = get_global_id(0);                                  \n"
-"  uint    localIdx =  get_local_id(0);                                   \n"
+"  uint    globalIdx1= get_global_id(0) + mcu_offset;                     \n"
+"  uint    localIdx  =  get_local_id(0);                                  \n"
 "  uint    transOffset = ((localIdx >> 4) << 3) + (localIdx & 0x07);      \n"
 "  uchar   dataInY = src[globalIdx / 128 * 256 + localIdx];               \n"
 "  uchar   imgR, imgG, imgB;                                              \n"
 "  uint    x, y;                                                          \n"
 "                                                                         \n"
-"  x = (globalIdx >> 7) % mcu_width;                                      \n"
-"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 7) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 7) / mcu_width;                                     \n"
 "                                                                         \n"
 "  if (localIdx < 64)                                                     \n"
 "  {                                                                      \n"
@@ -1997,16 +2024,18 @@ static const char     * jocldec_cl_source6  =
 "      localIdx / 6 * mcu_width * 6] = vload4(localIdx, inter);           \n"
 "}                                                                        \n"
 "                                                                         \n"
-"__kernel void UPSAMPLE_H2V1_BGR            (__global uchar  *src,        \n"
+"__kernel void UPSAMPLE_H2V1_BGR        (__global uchar  *src,            \n"
 "                                        __global uchar8 *dst,            \n"
 "                                        __local  uchar  *inter,          \n"
 "                                        __local  uchar  *cb_cache,       \n"
 "                                        __local  uchar  *cr_cache,       \n"
 "                                        __local  uchar2 *cb_upsample,    \n"
 "                                        __local  uchar2 *cr_upsample,    \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
 "  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    globalIdx1  = get_global_id(0) + mcu_offset;                   \n"
 "  uint    localIdx    = get_local_id (0);                                \n"
 "  uint    transOffset =                                                  \n"
 "    ((localIdx >> 2) << 2) - (localIdx >> 5) * 60 + localIdx;            \n"
@@ -2019,8 +2048,8 @@ static const char     * jocldec_cl_source6  =
 "  int     valueY,valueCb, valueCr;                                       \n"
 "  uint    x, y;                                                          \n"
 "                                                                         \n"
-"  x = (globalIdx >> 6) % mcu_width;                                      \n"
-"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 6) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 6) / mcu_width;                                     \n"
 "                                                                         \n"
 "  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
 "                                                                         \n"
@@ -2075,9 +2104,11 @@ static const char     * jocldec_cl_source6  =
 "                                        __local  uchar  *cr_cache,       \n"
 "                                        __local  uchar2 *cb_upsample,    \n"
 "                                        __local  uchar2 *cr_upsample,    \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
 "  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    globalIdx1  = get_global_id(0) + mcu_offset;                   \n"
 "  uint    localIdx    = get_local_id (0);                                \n"
 "  uint    transOffset = localIdx - (localIdx >> 5) * 60 +                \n"
 "    (localIdx >> 2 << 2) + (localIdx >> 6) * 56;                         \n"
@@ -2086,8 +2117,8 @@ static const char     * jocldec_cl_source6  =
 "  int     valueY, valueCb, valueCr;                                      \n"
 "  uint    x, y;                                                          \n"
 "                                                                         \n"
-"  x = (globalIdx >> 7) % mcu_width;                                      \n"
-"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 7) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 7) / mcu_width;                                     \n"
 "                                                                         \n"
 "  if (localIdx < 64)                                                     \n"
 "  {                                                                      \n"
@@ -2151,9 +2182,11 @@ static const char     * jocldec_cl_source7  =
 "                                        __local  uchar  *cr_cache,       \n"
 "                                        __local  uchar2 *cb_upsample,    \n"
 "                                        __local  uchar2 *cr_upsample,    \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
 "  uint    globalIdx   = get_global_id(0);                                \n"
+"  uint    globalIdx1  = get_global_id(0) + mcu_offset;                   \n"
 "  uint    localIdx    = get_local_id (0);                                \n"
 "  uint    transOffset =                                                  \n"
 "    ((localIdx >> 2) << 2) - (localIdx >> 5) * 60 + localIdx;            \n"
@@ -2167,8 +2200,8 @@ static const char     * jocldec_cl_source7  =
 "  int     valueY,valueCb, valueCr;                                       \n"
 "  uint    x, y;                                                          \n"
 "                                                                         \n"
-"  x = (globalIdx >> 6) % mcu_width;                                      \n"
-"  y = (globalIdx >> 6) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 6) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 6) / mcu_width;                                     \n"
 "                                                                         \n"
 "  barrier(CLK_LOCAL_MEM_FENCE);                                          \n"
 "                                                                         \n"
@@ -2248,16 +2281,18 @@ static const char     * jocldec_cl_source7  =
 "    dst[y * mcu_width * 48 + x * 6 + localIdx % 6 +                      \n"
 "      localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);           \n"
 "}                                                                        \n"
-"__kernel void UPSAMPLE_H2V2_FANCY_BGR      (__global uchar  *src,        \n"
+"__kernel void UPSAMPLE_H2V2_FANCY_BGR  (__global uchar  *src,            \n"
 "                                        __global uchar8 *dst,            \n"
 "                                        __local  uchar  *inter,          \n"
 "                                        __local  uchar  *cb_cache,       \n"
 "                                        __local  uchar  *cr_cache,       \n"
 "                                        __local  uchar2 *cb_upsample,    \n"
 "                                        __local  uchar2 *cr_upsample,    \n"
-"                                        const    uint    mcu_width)      \n"
+"                                        const    uint    mcu_width,      \n"
+"                                        const    uint    mcu_offset)     \n"
 "{                                                                        \n"
-"  uint   globalIdx   = get_global_id(0);                                 \n"
+/*"  uint   globalIdx   = get_global_id(0);                                 \n"
+"  uint   globalIdx1  = get_global_id(0) + mcu_offset;                    \n"
 "  uint   localIdx    = get_local_id (0);                                 \n"
 "  uint   transOffset = localIdx - (localIdx >> 5) * 60 +                 \n"
 "    (localIdx >> 2 << 2) + (localIdx >> 6) * 56;                         \n"
@@ -2273,8 +2308,8 @@ static const char     * jocldec_cl_source7  =
 "  int    dataInLeftBottomCr, dataInRightBottomCr;                        \n"
 "                                                                         \n"
 "  uchar   dataInCb ,dataInCr;                                            \n"
-"  x = (globalIdx >> 7) % mcu_width;                                      \n"
-"  y = (globalIdx >> 7) / mcu_width;                                      \n"
+"  x = (globalIdx1 >> 7) % mcu_width;                                     \n"
+"  y = (globalIdx1 >> 7) / mcu_width;                                     \n"
 "                                                                         \n"
 "  if (localIdx < 64)                                                     \n"
 "  {                                                                      \n"
@@ -2698,7 +2733,13 @@ static const char     * jocldec_cl_source7  =
 "  if (localIdx < 96)                                                     \n"
 "    dst[y * mcu_width * 96 + x * 6 + localIdx % 6                        \n"
 "      + localIdx / 6 * mcu_width * 6] = vload8(localIdx, inter);         \n"
-"                                                                         \n"
+"                                                                         \n"*/
+"}                                                                        \n"
+"__kernel void RESET_ZERO    (__global short8 *src)                       \n"
+"{                                                                        \n"
+"  uint   globalIdx = get_global_id(0);                                   \n"
+"  short8 tempIn;                                                         \n"
+"  tempIn = 0;                                                            \n"
+"  src[globalIdx] = tempIn;                                               \n"
 "}                                                                        \n";
-
 #endif
diff --git a/joclinit.c b/joclinit.c
index 3cc7532..783b252 100644
--- a/joclinit.c
+++ b/joclinit.c
@@ -16,6 +16,10 @@
 #include "joclinit.h"
 #undef  __JOCL_CL_INIT_MAIN__
 
+#ifdef JOCL_CL_OS_WIN32
+#define CL_QUEUE_THREAD_HANDLE_AMD 0x403E
+#define CL_PARAM_NUM 20
+#endif
 /*
  * OCL_STATIS ocl_status
  * Store all the informations of OpenCL platform.
@@ -30,6 +34,7 @@ typedef struct
   cl_bool          is_opencl_available;
   cl_bool          is_opencl_support;
   cl_bool          fancy_index;
+  unsigned long    mem_size;
   char             platform_profile   [1024];
   char             platform_version   [1024];
   char             platform_name      [1024];
@@ -38,7 +43,7 @@ typedef struct
   char             device_name        [1024];
 } OCL_STATUS;
 
-static OCL_STATUS ocl_status = {NULL, NULL, NULL, NULL, CL_FALSE, CL_FALSE};
+static OCL_STATUS ocl_status = {NULL, NULL, NULL, NULL, CL_FALSE, CL_FALSE, CL_FALSE, 0};
 
 
 /*
@@ -163,14 +168,18 @@ const char* jocl_cl_errstring(cl_int err_code)
 #endif
 cl_bool jocl_cl_init()
 {
-  if (!ocl_status.is_opencl_available)
-  {
+#ifdef JOCL_CL_OS_WIN32
+  void *handle = INVALID_HANDLE_VALUE;
+  int ret;
+#endif
+  if (!ocl_status.is_opencl_available) {
     cl_int          err_code;
     cl_uint         num_platform;
     cl_uint         num_device;
     cl_platform_id* pids;
     cl_device_id*   dids;
     cl_uint         index;
+	unsigned int    num_gpu_device = 0;
 
 #ifdef JOCL_CL_OS_WIN32
     HINSTANCE       module;
@@ -180,8 +189,7 @@ cl_bool jocl_cl_init()
     module = dlopen(CL_LIBRARY_NAME, RTLD_LAZY);
 #endif
 
-    if(module == NULL)
-    {
+    if(module == NULL) {
       CL_DEBUG_NOTE ("Loading OpenCL Library fails!!\n");
       return CL_FALSE;
     }
@@ -191,100 +199,98 @@ cl_bool jocl_cl_init()
     CL_LOAD_FUNCTION(clGetPlatformInfo                );
     CL_LOAD_FUNCTION(clGetDeviceIDs                   );
     CL_LOAD_FUNCTION(clGetDeviceInfo                  );
-    /* CL_LOAD_FUNCTION(clCreateSubDevices               );
+    /* CL_LOAD_FUNCTION(clCreateSubDevices            );
     CL_LOAD_FUNCTION(clRetainDevice                   );
     CL_LOAD_FUNCTION(clReleaseDevice                  );*/
     CL_LOAD_FUNCTION(clCreateContext                  );
-    /* CL_LOAD_FUNCTION(clCreateContextFromType          );
-      CL_LOAD_FUNCTION(clRetainContext                  );
-      CL_LOAD_FUNCTION(clReleaseContext                 );
-      CL_LOAD_FUNCTION(clGetContextInfo                 );*/
+    /* CL_LOAD_FUNCTION(clCreateContextFromType       );
+    CL_LOAD_FUNCTION(clRetainContext                  );
+    CL_LOAD_FUNCTION(clReleaseContext                 );
+    CL_LOAD_FUNCTION(clGetContextInfo                 );*/
     CL_LOAD_FUNCTION(clCreateCommandQueue             );
-    /* CL_LOAD_FUNCTION(clRetainCommandQueue             );
-      CL_LOAD_FUNCTION(clReleaseCommandQueue            );
-      CL_LOAD_FUNCTION(clGetCommandQueueInfo            );*/
+    /* CL_LOAD_FUNCTION(clRetainCommandQueue          );
+    CL_LOAD_FUNCTION(clReleaseCommandQueue            );*/
+    CL_LOAD_FUNCTION(clGetCommandQueueInfo            );
     CL_LOAD_FUNCTION(clCreateBuffer                   );
-    /* CL_LOAD_FUNCTION(clCreateSubBuffer                );
-      CL_LOAD_FUNCTION(clCreateImage                    );
-      CL_LOAD_FUNCTION(clRetainMemObject                );*/
+    /* CL_LOAD_FUNCTION(clCreateSubBuffer             );
+    CL_LOAD_FUNCTION(clCreateImage                    );
+    CL_LOAD_FUNCTION(clRetainMemObject                );*/
     CL_LOAD_FUNCTION(clReleaseMemObject               );
-    /* CL_LOAD_FUNCTION(clGetSupportedImageFormats       );*/
+    /* CL_LOAD_FUNCTION(clGetSupportedImageFormats    );*/
     CL_LOAD_FUNCTION(clGetMemObjectInfo               );
-    /* CL_LOAD_FUNCTION(clGetImageInfo                   );
-      CL_LOAD_FUNCTION(clSetMemObjectDestructorCallback );
-      CL_LOAD_FUNCTION(clCreateSampler                  );
-      CL_LOAD_FUNCTION(clRetainSampler                  );
-      CL_LOAD_FUNCTION(clReleaseSampler                 );
-      CL_LOAD_FUNCTION(clGetSamplerInfo                 );*/
+    /* CL_LOAD_FUNCTION(clGetImageInfo                );
+    CL_LOAD_FUNCTION(clSetMemObjectDestructorCallback );
+    CL_LOAD_FUNCTION(clCreateSampler                  );
+    CL_LOAD_FUNCTION(clRetainSampler                  );
+    CL_LOAD_FUNCTION(clReleaseSampler                 );
+    CL_LOAD_FUNCTION(clGetSamplerInfo                 );*/
     CL_LOAD_FUNCTION(clCreateProgramWithSource        );
     CL_LOAD_FUNCTION(clCreateProgramWithBinary        );
     /* CL_LOAD_FUNCTION(clCreateProgramWithBuiltInKernels);
-      CL_LOAD_FUNCTION(clRetainProgram                  );
-      CL_LOAD_FUNCTION(clReleaseProgram                 );*/
+    CL_LOAD_FUNCTION(clRetainProgram                  );
+    CL_LOAD_FUNCTION(clReleaseProgram                 );*/
     CL_LOAD_FUNCTION(clBuildProgram                   );
-    /* CL_LOAD_FUNCTION(clCompileProgram                 );
-      CL_LOAD_FUNCTION(clLinkProgram                    );
-      CL_LOAD_FUNCTION(clUnloadPlatformCompiler         );*/
+    /* CL_LOAD_FUNCTION(clCompileProgram              );
+    CL_LOAD_FUNCTION(clLinkProgram                    );
+    CL_LOAD_FUNCTION(clUnloadPlatformCompiler         );*/
     CL_LOAD_FUNCTION(clGetProgramInfo                 );
     CL_LOAD_FUNCTION(clGetProgramBuildInfo            );
     CL_LOAD_FUNCTION(clCreateKernel                   );
-    /* CL_LOAD_FUNCTION(clCreateKernelsInProgram         );
-      CL_LOAD_FUNCTION(clRetainKernel                   );
-      CL_LOAD_FUNCTION(clReleaseKernel                  );*/
+    /* CL_LOAD_FUNCTION(clCreateKernelsInProgram      );
+    CL_LOAD_FUNCTION(clRetainKernel                   );
+    CL_LOAD_FUNCTION(clReleaseKernel                  );*/
     CL_LOAD_FUNCTION(clSetKernelArg                   );
-    /*CL_LOAD_FUNCTION(clGetKernelInfo                  );
-      CL_LOAD_FUNCTION(clGetKernelArgInfo               );*/
+    /*CL_LOAD_FUNCTION(clGetKernelInfo                );
+    CL_LOAD_FUNCTION(clGetKernelArgInfo               );*/
     CL_LOAD_FUNCTION(clGetKernelWorkGroupInfo         );
-    /* CL_LOAD_FUNCTION(clWaitForEvents                  );
-      CL_LOAD_FUNCTION(clGetEventInfo                   );
-      CL_LOAD_FUNCTION(clCreateUserEvent                );
-      CL_LOAD_FUNCTION(clRetainEvent                    );
-      CL_LOAD_FUNCTION(clReleaseEvent                   );
-      CL_LOAD_FUNCTION(clSetUserEventStatus             );
-      CL_LOAD_FUNCTION(clSetEventCallback               );
-      CL_LOAD_FUNCTION(clGetEventProfilingInfo          );*/
+    CL_LOAD_FUNCTION(clWaitForEvents                  );
+    CL_LOAD_FUNCTION(clGetEventInfo                   );
+    CL_LOAD_FUNCTION(clCreateUserEvent                );
+    /* CL_LOAD_FUNCTION(clRetainEvent                 );*/
+    CL_LOAD_FUNCTION(clReleaseEvent                   );
+    CL_LOAD_FUNCTION(clSetUserEventStatus             );
+    /*  CL_LOAD_FUNCTION(clSetEventCallback           );
+    CL_LOAD_FUNCTION(clGetEventProfilingInfo          );*/
     CL_LOAD_FUNCTION(clFlush                          );
     CL_LOAD_FUNCTION(clFinish                         );
-    /* CL_LOAD_FUNCTION(clEnqueueReadBuffer              );
-      CL_LOAD_FUNCTION(clEnqueueReadBufferRect          );
-      CL_LOAD_FUNCTION(clEnqueueWriteBuffer             );
-      CL_LOAD_FUNCTION(clEnqueueWriteBufferRect         );
-      CL_LOAD_FUNCTION(clEnqueueFillBuffer              );
-      CL_LOAD_FUNCTION(clEnqueueCopyBuffer              );
-      CL_LOAD_FUNCTION(clEnqueueCopyBufferRect          );
-      CL_LOAD_FUNCTION(clEnqueueReadImage               );
-      CL_LOAD_FUNCTION(clEnqueueWriteImage              );
-      CL_LOAD_FUNCTION(clEnqueueFillImage               );
-      CL_LOAD_FUNCTION(clEnqueueCopyImage               );
-      CL_LOAD_FUNCTION(clEnqueueCopyImageToBuffer       );
-      CL_LOAD_FUNCTION(clEnqueueCopyBufferToImage       );*/
+    /* CL_LOAD_FUNCTION(clEnqueueReadBuffer           );
+    CL_LOAD_FUNCTION(clEnqueueReadBufferRect          );*/
+    CL_LOAD_FUNCTION(clEnqueueWriteBuffer             );
+    /* CL_LOAD_FUNCTION(clEnqueueWriteBufferRect      );
+    CL_LOAD_FUNCTION(clEnqueueFillBuffer              );
+    CL_LOAD_FUNCTION(clEnqueueCopyBuffer              );
+    CL_LOAD_FUNCTION(clEnqueueCopyBufferRect          );
+    CL_LOAD_FUNCTION(clEnqueueReadImage               );
+    CL_LOAD_FUNCTION(clEnqueueWriteImage              );
+    CL_LOAD_FUNCTION(clEnqueueFillImage               );
+    CL_LOAD_FUNCTION(clEnqueueCopyImage               );
+    CL_LOAD_FUNCTION(clEnqueueCopyImageToBuffer       );
+    CL_LOAD_FUNCTION(clEnqueueCopyBufferToImage       );*/
     CL_LOAD_FUNCTION(clEnqueueMapBuffer               );
-    /* CL_LOAD_FUNCTION(clEnqueueMapImage                );*/
+    /* CL_LOAD_FUNCTION(clEnqueueMapImage             );*/
     CL_LOAD_FUNCTION(clEnqueueUnmapMemObject          );
-    /* CL_LOAD_FUNCTION(clEnqueueMigrateMemObjects       );*/
+    /* CL_LOAD_FUNCTION(clEnqueueMigrateMemObjects    );*/
     CL_LOAD_FUNCTION(clEnqueueNDRangeKernel           );
-    /* CL_LOAD_FUNCTION(clEnqueueTask                    );
-      CL_LOAD_FUNCTION(clEnqueueNativeKernel            );
-      CL_LOAD_FUNCTION(clEnqueueMarkerWithWaitList      );
-      CL_LOAD_FUNCTION(clEnqueueBarrierWithWaitList     );
-      CL_LOAD_FUNCTION(clSetPrintfCallback              );*/
+    /* CL_LOAD_FUNCTION(clEnqueueTask                 );
+    CL_LOAD_FUNCTION(clEnqueueNativeKernel            );
+    CL_LOAD_FUNCTION(clEnqueueMarkerWithWaitList      );
+    CL_LOAD_FUNCTION(clEnqueueBarrierWithWaitList     );
+    CL_LOAD_FUNCTION(clSetPrintfCallback              );*/
 
     /* ********* Get and select a platform. ********* */
     CL_SAFE_CALL0(err_code = jocl_clGetPlatformIDs(0, NULL, &num_platform)
       , return CL_FALSE);
-    if ( num_platform < 1 )
-    {
+    if ( num_platform < 1 ) {
       CL_DEBUG_NOTE("NO CL PLATFORM!\n");
       return CL_FALSE;
     }
 
     pids = (cl_platform_id*)malloc(num_platform * sizeof(cl_platform_id));
 
-    CL_SAFE_CALL1(err_code = jocl_clGetPlatformIDs(num_platform, pids, NULL)
-      , return CL_FALSE, pids);
+    CL_SAFE_CALL1(err_code = jocl_clGetPlatformIDs(num_platform, pids, NULL),
+      return CL_FALSE, pids);
 
-    for (index = 0 ; index < num_platform ; ++index )
-    {
+    for (index = 0 ; index < num_platform ; ++index ) {
       ocl_status.platform_id = pids[index];
 
       CL_SAFE_CALL1(err_code = jocl_clGetPlatformInfo(ocl_status.platform_id,
@@ -323,8 +329,7 @@ cl_bool jocl_cl_init()
     /* ********* Get and select a device. ********* */
     CL_SAFE_CALL0(err_code = jocl_clGetDeviceIDs(ocl_status.platform_id,
       CL_DEVICE_TYPE_ALL, 0, NULL, &num_device), return CL_FALSE);
-    if ( num_device < 1 )
-    {
+    if ( num_device < 1 ) {
       CL_DEBUG_NOTE("NO DEVICE FOUND!\n");
       return CL_FALSE;
     }
@@ -334,24 +339,40 @@ cl_bool jocl_cl_init()
     CL_SAFE_CALL1(err_code = jocl_clGetDeviceIDs(ocl_status.platform_id,
       CL_DEVICE_TYPE_ALL, num_device, dids, NULL), return CL_FALSE, dids);
 
-    for ( index = 0 ; index < num_device ; ++index )
-    {
-      cl_device_type d_type;
-      ocl_status.device_id = dids[index];
-
-      CL_SAFE_CALL1(err_code = jocl_clGetDeviceInfo(ocl_status.device_id,
-        CL_DEVICE_TYPE, sizeof(cl_device_type), &d_type, NULL),
-        return CL_FALSE, dids);
-      if (CL_DEVICE_TYPE_GPU == d_type)
-        break;      
-    }
+	for ( index = 0 ; index < num_device ; ++index ) {
+	  cl_device_type d_type;
+	  ocl_status.device_id = dids[index];
+	  CL_SAFE_CALL1(err_code = jocl_clGetDeviceInfo(ocl_status.device_id,
+	  	CL_DEVICE_TYPE, sizeof(cl_device_type), &d_type, NULL),
+	  	return CL_FALSE, dids);
+	  if(CL_DEVICE_TYPE_GPU == d_type)
+	  	num_gpu_device++;
+	}
+	for (index = 0; index < num_device; ++index) {
+	  cl_device_type d_type;
+	  ocl_status.device_id = dids[index];
+	  CL_SAFE_CALL1(err_code = jocl_clGetDeviceInfo(ocl_status.device_id,
+	    CL_DEVICE_TYPE, sizeof(cl_device_type), &d_type, NULL),
+	    return CL_FALSE, dids);
+	  CL_SAFE_CALL0(err_code = jocl_clGetDeviceInfo(ocl_status.device_id,
+	    CL_DEVICE_NAME, sizeof(ocl_status.device_name), ocl_status.device_name, NULL),
+	    return CL_FALSE);
+	  if(CL_DEVICE_TYPE_GPU == d_type) {
+	    num_gpu_device--;
+	    if (0 == strcmp(ocl_status.device_name,
+	      "Devastator"))
+	      break;
+	  }
+	  if(num_gpu_device == 0)
+	    break;
+	}
+	CL_DEBUG_NOTE("Device:\nName: %s\n",ocl_status.device_name);
+	/* AMD A10-4600M APU with Radeon(tm) HD Graphics */
 
     free(dids);
-
-    CL_SAFE_CALL0(err_code = jocl_clGetDeviceInfo(ocl_status.device_id,
-      CL_DEVICE_NAME, sizeof(ocl_status.device_name),
-      ocl_status.device_name, NULL), return CL_FALSE);
-    CL_DEBUG_NOTE("Device:\nName: %s\n",ocl_status.device_name);
+	CL_SAFE_CALL0(err_code = jocl_clGetDeviceInfo(ocl_status.device_id,
+	  CL_DEVICE_MAX_MEM_ALLOC_SIZE, sizeof(cl_device_type),
+	  &ocl_status.mem_size, NULL), return CL_FALSE);
 
     /* ********* Create a context. ********* */
     ocl_status.context = CL_SAFE_CALL0(jocl_clCreateContext(NULL,
@@ -361,7 +382,21 @@ cl_bool jocl_cl_init()
     ocl_status.command_queue = CL_SAFE_CALL0(jocl_clCreateCommandQueue(
       ocl_status.context, ocl_status.device_id, 0, &err_code),
       return CL_FALSE);
-
+#ifdef JOCL_CL_OS_WIN32
+    if( jocl_clGetCommandQueueInfo( ocl_status.command_queue,
+      CL_QUEUE_THREAD_HANDLE_AMD, sizeof(handle),
+      &handle, NULL ) == CL_SUCCESS && handle != INVALID_HANDLE_VALUE ) {
+      if(SetThreadPriority( handle, THREAD_PRIORITY_TIME_CRITICAL )) {
+        CL_DEBUG_NOTE ("SetThreadPriority success\n");
+        ret = GetThreadPriority(handle);
+        CL_DEBUG_NOTE ("Priority level = %d\n",ret);
+      }
+      else {
+        int ret = GetLastError();
+        CL_DEBUG_NOTE ("SetThreadPriority error,code  = %d\n",ret);
+      }
+    }  
+#endif
     /* *** OpenCL initialized successfully, modify the mark. *** */
     ocl_status.is_opencl_available = CL_TRUE;
     ocl_status.is_opencl_support = CL_TRUE;
@@ -372,8 +407,6 @@ cl_bool jocl_cl_init()
 }
 
 #undef CL_LOAD_FUNCTION
-
-
 /*
  * jocl_cl_compile_and_build
  *
@@ -386,22 +419,19 @@ cl_bool jocl_cl_init()
 JOCL_CL_RUNDATA* jocl_cl_compile_and_build(const char**  program_source,
                                            const char*  kernel_name[])
 {
-    int i;
-    size_t binarySizes;
-    
-    int num_device;
-    char *binaries, *str = NULL;
-    char deviceName[1024];
-    char fileName[256] = { 0 },cl_name[] = "kernel";
-    FILE * fp = NULL;
-    int b_error, binary_status;
-    char *binary;
-    size_t length_binary;
-    num_device = 1;
+  int i;
+  size_t binarySizes;
+  int num_device;
+  char *binaries, *str = NULL;
+  char deviceName[1024];
+  char fileName[256] = { 0 },cl_name[] = "kernel";
+  FILE * fp = NULL;
+  int b_error, binary_status;
+  char *binary;
+  size_t length_binary;
+  num_device = 1;
   /* Perform this operation only when OpenCL is available. */
-  if (ocl_status.is_opencl_available)
-  {
-    
+  if (ocl_status.is_opencl_available) {   
     JOCL_CL_RUNDATA* cl_data = NULL;
     cl_int  err_code;
     cl_uint index;
@@ -432,7 +462,7 @@ JOCL_CL_RUNDATA* jocl_cl_compile_and_build(const char**  program_source,
 
       /* Compile OpenCL code. If error, output the error informations. */
       CL_SAFE_CALL1(err_code = jocl_clBuildProgram(cl_data->program,
-      0, NULL, NULL, NULL, NULL), return NULL, cl_data);
+        0, NULL, NULL, NULL, NULL), return NULL, cl_data);
 
       if (CL_SUCCESS != err_code) {
         char *err_msg;
@@ -535,8 +565,7 @@ JOCL_CL_RUNDATA* jocl_cl_compile_and_build(const char**  program_source,
     cl_data->work_group_size = (size_t*)malloc(num_kernel * sizeof(size_t));
 
     /* Create cl_kernels. */
-    for ( index = 0 ; index < num_kernel ; ++index )
-    {
+    for ( index = 0 ; index < num_kernel ; ++index ) {
       CL_SAFE_CALL3(cl_data->kernel[index] = jocl_clCreateKernel(
         cl_data->program, kernel_name[index], &err_code)
         , return NULL, cl_data->kernel, cl_data->work_group_size, cl_data);
@@ -645,8 +674,13 @@ cl_bool jocl_cl_is_nvidia_opencl(void)
   if (0 == strcmp(ocl_status.platform_vendor,
         "NVIDIA Corporation"))
     return CL_TRUE;
-  else
+  else {
+#ifdef __APPLE__
+    return CL_TRUE;
+#else
     return CL_FALSE;
+#endif
+  }
 }
       
 /*
@@ -657,28 +691,41 @@ cl_bool jocl_cl_is_nvidia_opencl(void)
 
 cl_bool jocl_cl_is_opencl_decompress(j_decompress_ptr cinfo)
 {
-  unsigned int output_buffer, input_buffer;
-  
+  unsigned int output_buffer;
+  unsigned long buffer_output_size = jocl_cl_get_buffer_unit_size();
+
   /* output_buffer: the size of actual output */
   /* input_buffer : the size of actual input  */
   output_buffer = cinfo->MCUs_per_row * cinfo->total_iMCU_rows * cinfo->max_h_samp_factor * 
-               cinfo->max_v_samp_factor * NUM_COMPONENT * DCTSIZE2;
-  input_buffer  = sizeof(JCOEF) * (cinfo->max_h_samp_factor * cinfo->max_v_samp_factor + 2) *
-               cinfo->MCUs_per_row * cinfo->total_iMCU_rows * DCTSIZE2;
+    cinfo->max_v_samp_factor * NUM_COMPONENT * DCTSIZE2;
   /* Determine if the opencl version will be used */
-  if(cinfo->num_components==1||
-     (cinfo->blocks_in_MCU!=6 && cinfo->blocks_in_MCU!=3 && cinfo->blocks_in_MCU!=4))
-     return CL_FALSE;
-  if(JCS_GRAYSCALE == cinfo->out_color_space)
-     return CL_FALSE;
+  if(cinfo->num_components==1|| cinfo->progressive_mode == 1 ||
+    (cinfo->blocks_in_MCU!=6 && cinfo->blocks_in_MCU!=3 && cinfo->blocks_in_MCU!=4))
+    return CL_FALSE;
+  if(JCS_RGB != cinfo->out_color_space)
+    return CL_FALSE;
+  if(cinfo->scale_denom != 1 || cinfo->scale_num != 1)
+    return CL_FALSE;
+  if(cinfo->desired_number_of_colors != 256 || cinfo->quantize_colors == TRUE)
+    return CL_FALSE;
+  if(cinfo->two_pass_quantize == FALSE || cinfo->dither_mode != JDITHER_FS ||
+    (cinfo->dct_method != JDCT_ISLOW && cinfo->dct_method != JDCT_IFAST &&
+    cinfo->dct_method != JDCT_FLOAT))
+    return CL_FALSE;
 
-  if((output_buffer > MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 6) ||
-  (input_buffer  > MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT * 4))
+  if((output_buffer > buffer_output_size))
      return CL_FALSE;
   
   return CL_TRUE;
 }
 
+/*
+ * jocl_cl_get_fancy_status
+ * jocl_cl_set_fancy_status
+ *
+ * If the -nosmooth is used.
+ */
+
 cl_bool jocl_cl_get_fancy_status(void)
 {
   return ocl_status.fancy_index;
@@ -688,3 +735,22 @@ void jocl_cl_set_fancy_status(void)
 {
   ocl_status.fancy_index = CL_FALSE;
 }
+
+/*
+ * jocl_cl_get_buffer_unit_size
+ *
+ * Determine the buffer size.
+ */
+
+unsigned long jocl_cl_get_buffer_unit_size(void)
+{
+  unsigned long buffer_output_size = 0;
+  unsigned long mem_size = ocl_status.mem_size;
+  
+  buffer_output_size = mem_size - (MCUNUMS * DCTSIZE2 * 18 * BUFFERNUMS);
+  if (mem_size > (MAX_BUFFER_SIZE + (MCUNUMS * DCTSIZE2 * 18 * BUFFERNUMS)))
+  {
+  	buffer_output_size = MAX_BUFFER_SIZE;
+  }
+  return buffer_output_size ;
+}
diff --git a/joclinit.h b/joclinit.h
index e6f12f4..bfa8a70 100644
--- a/joclinit.h
+++ b/joclinit.h
@@ -26,7 +26,7 @@ typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetPlatformIDs
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetPlatformInfo                ) (cl_platform_id, cl_platform_info, size_t, void*, size_t*);
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetDeviceIDs                   ) (cl_platform_id, cl_device_type, cl_uint, cl_device_id*, cl_uint*);
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetDeviceInfo                  ) (cl_device_id, cl_device_info, size_t, void*, size_t*);
-typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clCreateSubDevices               ) (cl_device_id, const cl_device_partition_property*, cl_uint, cl_device_id*, cl_uint*);
+//typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clCreateSubDevices               ) (cl_device_id, const cl_device_partition_property*, cl_uint, cl_device_id*, cl_uint*);
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clRetainDevice                   ) (cl_device_id);
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clReleaseDevice                  ) (cl_device_id);
 typedef CL_API_ENTRY cl_context       (CL_API_CALL *h_clCreateContext                  ) (const cl_context_properties*, cl_uint, const cl_device_id*, void (CL_CALLBACK*)(const char*, const void*, size_t, void*), void*, cl_int*);
@@ -40,7 +40,7 @@ typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clReleaseCommandQueue
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetCommandQueueInfo            ) (cl_command_queue, cl_command_queue_info, size_t, void*, size_t*);
 typedef CL_API_ENTRY cl_mem           (CL_API_CALL *h_clCreateBuffer                   ) (cl_context, cl_mem_flags, size_t, void*, cl_int*);
 typedef CL_API_ENTRY cl_mem           (CL_API_CALL *h_clCreateSubBuffer                ) (cl_mem, cl_mem_flags, cl_buffer_create_type, const void*, cl_int*);
-typedef CL_API_ENTRY cl_mem           (CL_API_CALL *h_clCreateImage                    ) (cl_context, cl_mem_flags, const cl_image_format*, const cl_image_desc*, void*, cl_int*);
+//typedef CL_API_ENTRY cl_mem           (CL_API_CALL *h_clCreateImage                    ) (cl_context, cl_mem_flags, const cl_image_format*, const cl_image_desc*, void*, cl_int*);
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clRetainMemObject                ) (cl_mem);
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clReleaseMemObject               ) (cl_mem);
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetSupportedImageFormats       ) (cl_context, cl_mem_flags, cl_mem_object_type, cl_uint, cl_image_format*, cl_uint*);
@@ -68,7 +68,7 @@ typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clRetainKernel
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clReleaseKernel                  ) (cl_kernel);
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clSetKernelArg                   ) (cl_kernel, cl_uint, size_t, const void*);
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetKernelInfo                  ) (cl_kernel, cl_kernel_info, size_t, void*, size_t*);
-typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetKernelArgInfo               ) (cl_kernel, cl_uint, cl_kernel_arg_info, size_t, void*, size_t*);
+//typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetKernelArgInfo               ) (cl_kernel, cl_uint, cl_kernel_arg_info, size_t, void*, size_t*);
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetKernelWorkGroupInfo         ) (cl_kernel, cl_device_id, cl_kernel_work_group_info, size_t, void*, size_t*);
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clWaitForEvents                  ) (cl_uint, const cl_event*);
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clGetEventInfo                   ) (cl_event, cl_event_info, size_t, void*, size_t*);
@@ -96,7 +96,7 @@ typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueCopyBufferToImage
 typedef CL_API_ENTRY void *           (CL_API_CALL *h_clEnqueueMapBuffer               ) (cl_command_queue, cl_mem, cl_bool, cl_map_flags, size_t, size_t, cl_uint, const cl_event*, cl_event*, cl_int*);
 typedef CL_API_ENTRY void *           (CL_API_CALL *h_clEnqueueMapImage                ) (cl_command_queue, cl_mem, cl_bool, cl_map_flags, const size_t*, const size_t*, size_t*, size_t*, cl_uint, const cl_event*, cl_event*, cl_int*);
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueUnmapMemObject          ) (cl_command_queue, cl_mem, void*, cl_uint, const cl_event*, cl_event*);
-typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueMigrateMemObjects       ) (cl_command_queue, cl_uint, const cl_mem*, cl_mem_migration_flags, cl_uint, const cl_event*, cl_event*);
+//typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueMigrateMemObjects       ) (cl_command_queue, cl_uint, const cl_mem*, cl_mem_migration_flags, cl_uint, const cl_event*, cl_event*);
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueNDRangeKernel           ) (cl_command_queue, cl_kernel, cl_uint, const size_t*, const size_t*, const size_t*, cl_uint, const cl_event*, cl_event*);
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueTask                    ) (cl_command_queue, cl_kernel, cl_uint, const cl_event*, cl_event*);
 typedef CL_API_ENTRY cl_int           (CL_API_CALL *h_clEnqueueNativeKernel            ) (cl_command_queue, void (CL_CALLBACK*)(void*), void*, size_t, cl_uint, const cl_mem*, const void**, cl_uint, const cl_event*, cl_event*);
@@ -122,7 +122,7 @@ CL_LOADING_PREFIX h_clGetPlatformIDs                  jocl_clGetPlatformIDs
 CL_LOADING_PREFIX h_clGetPlatformInfo                 jocl_clGetPlatformInfo                 CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clGetDeviceIDs                    jocl_clGetDeviceIDs                    CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clGetDeviceInfo                   jocl_clGetDeviceInfo                   CL_LOADING_SUFFIX;
-CL_LOADING_PREFIX h_clCreateSubDevices                jocl_clCreateSubDevices                CL_LOADING_SUFFIX;
+//CL_LOADING_PREFIX h_clCreateSubDevices                jocl_clCreateSubDevices                CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clRetainDevice                    jocl_clRetainDevice                    CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clReleaseDevice                   jocl_clReleaseDevice                   CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clCreateContext                   jocl_clCreateContext                   CL_LOADING_SUFFIX;
@@ -136,7 +136,7 @@ CL_LOADING_PREFIX h_clReleaseCommandQueue             jocl_clReleaseCommandQueue
 CL_LOADING_PREFIX h_clGetCommandQueueInfo             jocl_clGetCommandQueueInfo             CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clCreateBuffer                    jocl_clCreateBuffer                    CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clCreateSubBuffer                 jocl_clCreateSubBuffer                 CL_LOADING_SUFFIX;
-CL_LOADING_PREFIX h_clCreateImage                     jocl_clCreateImage                     CL_LOADING_SUFFIX;
+//CL_LOADING_PREFIX h_clCreateImage                     jocl_clCreateImage                     CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clRetainMemObject                 jocl_clRetainMemObject                 CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clReleaseMemObject                jocl_clReleaseMemObject                CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clGetSupportedImageFormats        jocl_clGetSupportedImageFormats        CL_LOADING_SUFFIX;
@@ -164,7 +164,7 @@ CL_LOADING_PREFIX h_clRetainKernel                    jocl_clRetainKernel
 CL_LOADING_PREFIX h_clReleaseKernel                   jocl_clReleaseKernel                   CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clSetKernelArg                    jocl_clSetKernelArg                    CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clGetKernelInfo                   jocl_clGetKernelInfo                   CL_LOADING_SUFFIX;
-CL_LOADING_PREFIX h_clGetKernelArgInfo                jocl_clGetKernelArgInfo                CL_LOADING_SUFFIX;
+//CL_LOADING_PREFIX h_clGetKernelArgInfo                jocl_clGetKernelArgInfo                CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clGetKernelWorkGroupInfo          jocl_clGetKernelWorkGroupInfo          CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clWaitForEvents                   jocl_clWaitForEvents                   CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clGetEventInfo                    jocl_clGetEventInfo                    CL_LOADING_SUFFIX;
@@ -192,7 +192,7 @@ CL_LOADING_PREFIX h_clEnqueueCopyBufferToImage        jocl_clEnqueueCopyBufferTo
 CL_LOADING_PREFIX h_clEnqueueMapBuffer                jocl_clEnqueueMapBuffer                CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clEnqueueMapImage                 jocl_clEnqueueMapImage                 CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clEnqueueUnmapMemObject           jocl_clEnqueueUnmapMemObject           CL_LOADING_SUFFIX;
-CL_LOADING_PREFIX h_clEnqueueMigrateMemObjects        jocl_clEnqueueMigrateMemObjects        CL_LOADING_SUFFIX;
+//CL_LOADING_PREFIX h_clEnqueueMigrateMemObjects        jocl_clEnqueueMigrateMemObjects        CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clEnqueueNDRangeKernel            jocl_clEnqueueNDRangeKernel            CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clEnqueueTask                     jocl_clEnqueueTask                     CL_LOADING_SUFFIX;
 CL_LOADING_PREFIX h_clEnqueueNativeKernel             jocl_clEnqueueNativeKernel             CL_LOADING_SUFFIX;
@@ -203,7 +203,9 @@ CL_LOADING_PREFIX h_clSetPrintfCallback               jocl_clSetPrintfCallback
 #undef CL_LOADING_PREFIX
 #undef CL_LOADING_SUFFIX
 
-
+#ifdef __APPLE__
+#define CL_MAP_WRITE_INVALIDATE_REGION  CL_MAP_WRITE
+#endif
 /*
  * Definition run_data structure of kernels.
  * Forward declaration the OpenCL initialization API.
@@ -235,13 +237,14 @@ cl_bool          jocl_cl_is_opencl_decompress      (j_decompress_ptr cinfo);
 cl_bool          jocl_cl_is_nvidia_opencl          (void);
 void             jocl_cl_set_fancy_status          (void);
 cl_bool          jocl_cl_get_fancy_status          (void);
+unsigned long	 jocl_cl_get_buffer_unit_size      (void);
 
 /*
  * The macro definition for exception handling code.
  */
 
 #define CL_DEBUG_NOTE(...)                                               \
-  printf(__VA_ARGS__)
+  //printf(__VA_ARGS__)
 
 #define CL_SAFE_CALL0(func, action)                                      \
   func;                                                                  \
diff --git a/win/jconfig.h.in b/win/jconfig.h.in
index 251f625..4b31753 100644
--- a/win/jconfig.h.in
+++ b/win/jconfig.h.in
@@ -45,7 +45,8 @@ typedef signed int INT32;
 /* Define envionment variables of OpenCL decoding. */
 #ifdef WITH_OPENCL_DECODING_SUPPORTED
 #define OPENCL_PIPELINE           /* Pipeline or no pipeline */
-#define MAX_IMAGE_WIDTH   4096    /* Using to set the buffer size */
-#define MAX_IMAGE_HEIGHT  4096    /* Using to set the buffer size */
+#define MAX_BUFFER_SIZE   (9000 * 6000 * 4)  /* Using to set the buffer size */
 #define NUM_COMPONENT     3       /* The number of component */
+#define MCUNUMS           800
+#define BUFFERNUMS        10
 #endif
-- 
1.8.1.4

