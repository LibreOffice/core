diff -uprN misc/vigra1.6.0/configure misc/build/vigra1.6.0/configure
--- misc/vigra1.6.0/configure	2008-08-13 08:15:32.000000000 -0500
+++ misc/build/vigra1.6.0/configure	2012-09-19 17:30:24.000000000 -0500
@@ -7843,7 +7843,7 @@ kfreebsd*-gnu)
   ;;
 
 freebsd*)
-  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
+  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
   version_type=freebsd-$objformat
   case $version_type in
     freebsd-elf*)
@@ -11504,7 +11504,7 @@ kfreebsd*-gnu)
   ;;
 
 freebsd*)
-  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
+  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
   version_type=freebsd-$objformat
   case $version_type in
     freebsd-elf*)
@@ -14616,7 +14616,7 @@ kfreebsd*-gnu)
   ;;
 
 freebsd*)
-  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
+  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
   version_type=freebsd-$objformat
   case $version_type in
     freebsd-elf*)
@@ -16958,7 +16958,7 @@ kfreebsd*-gnu)
   ;;
 
 freebsd*)
-  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout`
+  objformat=`test -x /usr/bin/objformat && /usr/bin/objformat || echo elf`
   version_type=freebsd-$objformat
   case $version_type in
     freebsd-elf*)
diff -uprN misc/vigra1.6.0/include/vigra/array_vector.hxx misc/build/vigra1.6.0/include/vigra/array_vector.hxx
--- misc/vigra1.6.0/include/vigra/array_vector.hxx	2008-08-13 08:15:34.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/array_vector.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -578,7 +578,38 @@ public:
     iterator insert(iterator p, size_type n, value_type const & v);
 
     template <class InputIterator>
-    iterator insert(iterator p, InputIterator i, InputIterator iend);
+    iterator insert(iterator p, InputIterator i, InputIterator iend)
+    {
+        difference_type n = iend - i;
+        difference_type pos = p - begin();
+        size_type new_size = size() + n;
+        if(new_size >= capacity_)
+        {
+            pointer new_data = reserve_raw(new_size);
+            std::uninitialized_copy(begin(), p, new_data);
+            std::uninitialized_copy(i, iend, new_data + pos);
+            std::uninitialized_copy(p, end(), new_data + pos + n);
+            deallocate(data_, size_);
+            capacity_ = new_size;
+            data_ = new_data;
+        }
+        else if(pos + n >= size_)
+        {
+            size_type diff = pos + n - size_;
+            std::uninitialized_copy(p, end(), end() + diff);
+            std::uninitialized_copy(iend - diff, iend, end());
+            std::copy(i, iend - diff, p);
+        }
+        else
+        {
+            size_type diff = size_ - (pos + n);
+            std::uninitialized_copy(end() - n, end(), end());
+            std::copy_backward(p, p + diff, end());
+            std::copy(i, iend, p);
+        }
+        size_ = new_size;
+        return begin() + pos;
+    }
 
     iterator erase(iterator p);
 
diff -uprN misc/vigra1.6.0/include/vigra/basicimage.hxx misc/build/vigra1.6.0/include/vigra/basicimage.hxx
--- misc/vigra1.6.0/include/vigra/basicimage.hxx	2008-08-13 08:15:34.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/basicimage.hxx	2012-09-19 17:46:22.000000000 -0500
@@ -572,7 +572,11 @@ class BasicImage
     typedef Alloc allocator_type;
 
     typedef Alloc Allocator;
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
     typedef typename Alloc::template rebind<PIXELTYPE *>::other LineAllocator;
+#else
+    typedef std::allocator<PIXELTYPE*> LineAllocator;
+#endif
 
         /** construct image of size 0x0
         */
@@ -589,39 +593,51 @@ class BasicImage
       width_(0),
       height_(0),
       allocator_(alloc),
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       pallocator_(alloc)
+#else
+      pallocator_()
+#endif
     {}
 
         /** construct image of size width x height, use the specified allocator.
         */
-    BasicImage(int width, int height, Alloc const & alloc = Alloc())
+    BasicImage(int w, int h, Alloc const & alloc = Alloc())
     : data_(0),
       width_(0),
       height_(0),
       allocator_(alloc),
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       pallocator_(alloc)
+#else
+      pallocator_()
+#endif
     {
-        vigra_precondition((width >= 0) && (height >= 0),
-             "BasicImage::BasicImage(int width, int height): "
+        vigra_precondition((w >= 0) && (h >= 0),
+             "BasicImage::BasicImage(int w, int h): "
              "width and height must be >= 0.\n");
 
-        resize(width, height, value_type());
+        resize(w, h, value_type());
     }
 
         /** construct image of size size.x x size.y, use the specified allocator.
         */
-    explicit BasicImage(difference_type const & size, Alloc const & alloc = Alloc())
+    explicit BasicImage(difference_type const & sz, Alloc const & alloc = Alloc())
     : data_(0),
       width_(0),
       height_(0),
       allocator_(alloc),
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       pallocator_(alloc)
-    {
-        vigra_precondition((size.x >= 0) && (size.y >= 0),
-             "BasicImage::BasicImage(Diff2D size): "
-             "size.x and size.y must be >= 0.\n");
+#else
+      pallocator_()
+#endif
+    {
+        vigra_precondition((sz.x >= 0) && (sz.y >= 0),
+             "BasicImage::BasicImage(Diff2D sz): "
+             "sz.x and sz.y must be >= 0.\n");
 
-        resize(size.x, size.y, value_type());
+        resize(sz.x, sz.y, value_type());
     }
 
         /** construct image of size width*height and initialize every
@@ -629,71 +645,87 @@ class BasicImage
         value_type doesn't have a default constructor). 
         Use the specified allocator.
         */
-    BasicImage(int width, int height, value_type const & d, Alloc const & alloc = Alloc())
+    BasicImage(int w, int h, value_type const & d, Alloc const & alloc = Alloc())
     : data_(0),
       width_(0),
       height_(0),
       allocator_(alloc),
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       pallocator_(alloc)
+#else
+      pallocator_()
+#endif
     {
-        vigra_precondition((width >= 0) && (height >= 0),
-             "BasicImage::BasicImage(int width, int height, value_type const & ): "
+        vigra_precondition((w >= 0) && (h >= 0),
+             "BasicImage::BasicImage(int w, int h, value_type const & ): "
              "width and height must be >= 0.\n");
 
-        resize(width, height, d);
+        resize(w, h, d);
     }
 
         /** construct image of size size.x x size.y and initialize
         every pixel with given data (use this constructor, if
         value_type doesn't have a default constructor). Use the specified allocator.
         */
-    explicit BasicImage(difference_type const & size, value_type const & d, Alloc const & alloc = Alloc())
+    explicit BasicImage(difference_type const & sz, value_type const & d, Alloc const & alloc = Alloc())
     : data_(0),
       width_(0),
       height_(0),
       allocator_(alloc),
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       pallocator_(alloc)
-    {
-        vigra_precondition((size.x >= 0) && (size.y >= 0),
-             "BasicImage::BasicImage(Diff2D const & size, value_type const & v): "
-             "size.x and size.y must be >= 0.\n");
+#else
+      pallocator_()
+#endif
+    {
+        vigra_precondition((sz.x >= 0) && (sz.y >= 0),
+             "BasicImage::BasicImage(Diff2D const & sz, value_type const & v): "
+             "sz.x and sz.y must be >= 0.\n");
 
-        resize(size.x, size.y, d);
+        resize(sz.x, sz.y, d);
     }
 
 
         /** construct image of size width*height and copy the data from the
             given C-style array \a d. Use the specified allocator.
         */
-    BasicImage(int width, int height, const_pointer d, Alloc const & alloc = Alloc())
+    BasicImage(int w, int h, const_pointer d, Alloc const & alloc = Alloc())
     : data_(0),
       width_(0),
       height_(0),
       allocator_(alloc),
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       pallocator_(alloc)
+#else
+      pallocator_()
+#endif
     {
-        vigra_precondition((width >= 0) && (height >= 0),
-             "BasicImage::BasicImage(int width, int height, const_pointer ): "
+        vigra_precondition((w >= 0) && (h >= 0),
+             "BasicImage::BasicImage(int w, int h, const_pointer ): "
              "width and height must be >= 0.\n");
 
-        resizeCopy(width, height, d);
+        resizeCopy(w, h, d);
     }
 
         /** construct image of size size.x x size.y  and copy the data from the
             given C-style array. Use the specified allocator.
         */
-    explicit BasicImage(difference_type const & size, const_pointer d, Alloc const & alloc = Alloc())
+    explicit BasicImage(difference_type const & sz, const_pointer d, Alloc const & alloc = Alloc())
     : data_(0),
       width_(0),
       height_(0),
       allocator_(alloc),
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       pallocator_(alloc)
-    {
-        vigra_precondition((size.x >= 0) && (size.y >= 0),
-             "BasicImage::BasicImage(Diff2D const & size, const_pointer): "
-             "size.x and size.y must be >= 0.\n");
+#else
+      pallocator_()
+#endif
+    {
+        vigra_precondition((sz.x >= 0) && (sz.y >= 0),
+             "BasicImage::BasicImage(Diff2D const & sz, const_pointer): "
+             "sz.x and sz.y must be >= 0.\n");
 
-        resizeCopy(size.x, size.y, d);
+        resizeCopy(sz.x, sz.y, d);
     }
 
         /** copy rhs image
@@ -730,20 +762,20 @@ class BasicImage
         /** reset image to specified size (dimensions must not be negative)
             (old data are kept if new size matches old size)
         */
-    void resize(int width, int height)
+    void resize(int w, int h)
     {
-        if(width != width_ || height != height_)
-            resize(width, height, value_type());
+        if(w != width_ || h != height_)
+            resize(w, h, value_type());
     }
 
         /** reset image to specified size (dimensions must not be negative)
             (old data are kept if new size matches old size)
         */
-    void resize(difference_type const & size)
+    void resize(difference_type const & sz)
     {
-        if(size.x != width_ || size.y != height_)
+        if(sz.x != width_ || sz.y != height_)
         {
-            resize(size.x, size.y, value_type());
+            resize(sz.x, sz.y, value_type());
         }
     }
 
@@ -752,12 +784,12 @@ class BasicImage
             constructor, dimensions must not be negative,
             old data are kept if new size matches old size)
         */
-    void resize(int width, int height, value_type const & d);
+    void resize(int w, int h, value_type const & d);
 
         /** resize image to given size and initialize by copying data
             from the C-style arra \a data.
         */
-    void resizeCopy(int width, int height, const_pointer data);
+    void resizeCopy(int w, int h, const_pointer data);
 
         /** resize image to size of other image and copy it's data
         */
@@ -1066,30 +1098,30 @@ BasicImage<PIXELTYPE, Alloc>::init(value
 
 template <class PIXELTYPE, class Alloc>
 void
-BasicImage<PIXELTYPE, Alloc>::resize(int width, int height, value_type const & d)
+BasicImage<PIXELTYPE, Alloc>::resize(int w, int h, value_type const & d)
 {
-    vigra_precondition((width >= 0) && (height >= 0),
-         "BasicImage::resize(int width, int height, value_type const &): "
+    vigra_precondition((w >= 0) && (h >= 0),
+         "BasicImage::resize(int w, int h, value_type const &): "
          "width and height must be >= 0.\n");
 
-    if (width_ != width || height_ != height)  // change size?
+    if (width_ != w || height_ != h)  // change size?
     {
         value_type * newdata = 0;
         value_type ** newlines = 0;
-        if(width*height > 0)
+        if(w*h > 0)
         {
-            if (width*height != width_*height_) // different sizes, must reallocate
+            if (w*h != width_*height_) // different sizes, must reallocate
             {
-                newdata = allocator_.allocate(typename Alloc::size_type(width*height));
-                std::uninitialized_fill_n(newdata, width*height, d);
-                newlines = initLineStartArray(newdata, width, height);
+                newdata = allocator_.allocate(typename Alloc::size_type(w*h));
+                std::uninitialized_fill_n(newdata, w*h, d);
+                newlines = initLineStartArray(newdata, w, h);
                 deallocate();
             }
             else // need only to reshape
             {
                 newdata = data_;
-                std::fill_n(newdata, width*height, d);
-                newlines = initLineStartArray(newdata, width, height);
+                std::fill_n(newdata, w*h, d);
+                newlines = initLineStartArray(newdata, w, h);
                 pallocator_.deallocate(lines_, typename Alloc::size_type(height_));
             }
         }
@@ -1100,22 +1132,22 @@ BasicImage<PIXELTYPE, Alloc>::resize(int
 
         data_ = newdata;
         lines_ = newlines;
-        width_ = width;
-        height_ = height;
+        width_ = w;
+        height_ = h;
     }
-    else if(width*height > 0) // keep size, re-init data
+    else if(w*h > 0) // keep size, re-init data
     {
-        std::fill_n(data_, width*height, d);
+        std::fill_n(data_, w*h, d);
     }
 }
 
 
 template <class PIXELTYPE, class Alloc>
 void
-BasicImage<PIXELTYPE, Alloc>::resizeCopy(int width, int height, const_pointer data)
+BasicImage<PIXELTYPE, Alloc>::resizeCopy(int w, int h, const_pointer src_data)
 {
-    int newsize = width*height;
-    if (width_ != width || height_ != height)  // change size?
+    int newsize = w*h;
+    if (width_ != w || height_ != h)  // change size?
     {
         value_type * newdata = 0;
         value_type ** newlines = 0;
@@ -1124,15 +1156,15 @@ BasicImage<PIXELTYPE, Alloc>::resizeCopy
             if (newsize != width_*height_) // different sizes, must reallocate
             {
                 newdata = allocator_.allocate(typename Alloc::size_type(newsize));
-                std::uninitialized_copy(data, data + newsize, newdata);
-                newlines = initLineStartArray(newdata, width, height);
+                std::uninitialized_copy(src_data, src_data + newsize, newdata);
+                newlines = initLineStartArray(newdata, w, h);
                 deallocate();
             }
             else // need only to reshape
             {
                 newdata = data_;
-                std::copy(data, data + newsize, newdata);
-                newlines = initLineStartArray(newdata, width, height);
+                std::copy(src_data, src_data + newsize, newdata);
+                newlines = initLineStartArray(newdata, w, h);
                 pallocator_.deallocate(lines_, typename Alloc::size_type(height_));
             }
         }
@@ -1143,12 +1175,12 @@ BasicImage<PIXELTYPE, Alloc>::resizeCopy
 
         data_ = newdata;
         lines_ = newlines;
-        width_ = width;
-        height_ = height;
+        width_ = w;
+        height_ = h;
     }
     else if(newsize > 0) // keep size, copy data
     {
-        std::copy(data, data + newsize, data_);
+        std::copy(src_data, src_data + newsize, data_);
     }
 }
 
@@ -1183,11 +1215,11 @@ BasicImage<PIXELTYPE, Alloc>::deallocate
 
 template <class PIXELTYPE, class Alloc>
 PIXELTYPE **
-BasicImage<PIXELTYPE, Alloc>::initLineStartArray(value_type * data, int width, int height)
+BasicImage<PIXELTYPE, Alloc>::initLineStartArray(value_type * src_data, int w, int h)
 {
-    value_type ** lines = pallocator_.allocate(typename Alloc::size_type(height));
-    for(int y=0; y<height; ++y)
-         lines[y] = data + y*width;
+    value_type ** lines = pallocator_.allocate(typename Alloc::size_type(h));
+    for(int y=0; y<h; ++y)
+         lines[y] = src_data + y*w;
     return lines;
 }
 
diff -uprN misc/vigra1.6.0/include/vigra/basicimageview.hxx misc/build/vigra1.6.0/include/vigra/basicimageview.hxx
--- misc/vigra1.6.0/include/vigra/basicimageview.hxx	2008-08-13 08:15:34.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/basicimageview.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -176,20 +176,20 @@ class BasicImageView
 
         /** construct view of size w x h
         */
-    BasicImageView(const_pointer data, int w, int h, int stride = 0)
-    : data_(const_cast<pointer>(data)),
+    BasicImageView(const_pointer src_data, int w, int h, int data_stride = 0)
+    : data_(const_cast<pointer>(src_data)),
       width_(w),
       height_(h),
-      stride_(stride == 0 ? w : stride)
+      stride_(data_stride == 0 ? w : data_stride)
     {}
 
         /** construct view of size size.x x size.y
         */
-    BasicImageView(const_pointer data, difference_type const & size, int stride = 0)
-    : data_(const_cast<pointer>(data)),
-      width_(size.x),
-      height_(size.y),
-      stride_(stride == 0 ? size.x : stride)
+    BasicImageView(const_pointer src_data, difference_type const & sz, int data_stride = 0)
+    : data_(const_cast<pointer>(src_data)),
+      width_(sz.x),
+      height_(sz.y),
+      stride_(data_stride == 0 ? sz.x : data_stride)
     {}
 
         /** set Image with const value
diff -uprN misc/vigra1.6.0/include/vigra/boundarytensor.hxx misc/build/vigra1.6.0/include/vigra/boundarytensor.hxx
--- misc/vigra1.6.0/include/vigra/boundarytensor.hxx	2008-08-13 08:15:34.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/boundarytensor.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -71,8 +71,8 @@ initGaussianPolarFilters1(double std_dev
     int radius = (int)(4.0*std_dev + 0.5);
     std_dev *= 1.08179074376;
     double f = 1.0 / VIGRA_CSTD::sqrt(2.0 * M_PI) / std_dev;  // norm
-    double a = 0.558868151788 / VIGRA_CSTD::pow(std_dev, 5);
-    double b = -2.04251639729 / VIGRA_CSTD::pow(std_dev, 3);
+    double a = 0.558868151788 / VIGRA_CSTD::pow(std_dev, 5.0);
+    double b = -2.04251639729 / VIGRA_CSTD::pow(std_dev, 3.0);
     double sigma22 = -0.5 / std_dev / std_dev;
 
 
@@ -175,7 +175,7 @@ initGaussianPolarFilters3(double std_dev
     std_dev *= 1.15470053838;
     double sigma22 = -0.5 / std_dev / std_dev;
     double f = 1.0 / VIGRA_CSTD::sqrt(2.0 * M_PI) / std_dev;  // norm
-    double a = 0.883887052922 / VIGRA_CSTD::pow(std_dev, 5);
+    double a = 0.883887052922 / VIGRA_CSTD::pow(std_dev, 5.0);
 
     for(unsigned int i=0; i<k.size(); ++i)
     {
diff -uprN misc/vigra1.6.0/include/vigra/config.hxx misc/build/vigra1.6.0/include/vigra/config.hxx
--- misc/vigra1.6.0/include/vigra/config.hxx	2008-08-13 08:15:35.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/config.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -84,6 +84,12 @@
 		#endif // VIGRA_NO_STD_MINMAX
 	#endif // (_MSC_VER < 1300)
 
+    #if _MSC_VER <= 1310
+	    #ifndef CMATH_NOT_IN_STD
+	        #define CMATH_NOT_IN_STD
+        #endif
+    #endif // _MSC_VER < 1310
+
     #if _MSC_VER < 1310
         #define NO_PARTIAL_TEMPLATE_SPECIALIZATION
         #define NO_OUT_OF_LINE_MEMBER_TEMPLATES
diff -uprN misc/vigra1.6.0/include/vigra/diff2d.hxx misc/build/vigra1.6.0/include/vigra/diff2d.hxx
--- misc/vigra1.6.0/include/vigra/diff2d.hxx	2008-08-13 08:15:35.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/diff2d.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -490,8 +490,8 @@ public:
 
         /** Construct point at given position.
         */
-    Size2D(int width, int height)
-    : Diff2D(width, height)
+    Size2D(int w, int h)
+    : Diff2D(w, h)
     {}
 
         /** Copy Constructor.
@@ -620,8 +620,8 @@ public:
 
         /** Construct point at given position.
         */
-    Point2D(int x, int y)
-    : Diff2D(x, y)
+    Point2D(int x_, int y_)
+    : Diff2D(x_, y_)
     {}
 
         /** Copy Constructor.
@@ -884,26 +884,26 @@ public:
          * (lowerRight is considered to be outside the rectangle as
          * usual in the VIGRA)
          */
-    Rect2D(Point2D const &upperLeft, Point2D const &lowerRight)
-    : upperLeft_(upperLeft), lowerRight_(lowerRight)
+    Rect2D(Point2D const &ul, Point2D const &lr)
+    : upperLeft_(ul), lowerRight_(lr)
     {}
 
         /** Construct a rectangle representing the given range
          */
-    Rect2D(int left, int top, int right, int bottom)
-    : upperLeft_(left, top), lowerRight_(right, bottom)
+    Rect2D(int l, int t, int r, int b)
+        : upperLeft_(l,t), lowerRight_(r,b)
     {}
 
         /** Construct a rectangle of given position and size
          */
-    Rect2D(Point2D const &upperLeft, Size2D const &size)
-    : upperLeft_(upperLeft), lowerRight_(upperLeft + size)
+    Rect2D(Point2D const &ul, Size2D const &sz)
+    : upperLeft_(ul), lowerRight_(ul + sz)
     {}
 
         /** Construct a rectangle of given size at position (0,0)
          */
-    explicit Rect2D(Size2D const &size)
-    : lowerRight_(Point2D(size))
+    explicit Rect2D(Size2D const &sz)
+    : lowerRight_(Point2D(sz))
     {}
 
         /** Return the first point (scan-order wise) which is
@@ -950,9 +950,9 @@ public:
         /** Move the whole rectangle so that upperLeft() will become
          * Point2D(left, top) afterwards.
          */
-    void moveTo(int left, int top)
+    void moveTo(int l, int t)
     {
-        moveTo(Point2D(left, top));
+        moveTo(Point2D(l, t));
     }
 
         /** Move the whole rectangle by the given 2D offset.
@@ -1037,17 +1037,17 @@ public:
         /** Resize this rectangle to the given extents. This will move
          * the lower right corner only.
          */
-    void setSize(Size2D const &size)
+    void setSize(Size2D const &sz)
     {
-        lowerRight_ = upperLeft_ + size;
+        lowerRight_ = upperLeft_ + sz;
     }
 
         /** Resize this rectangle to the given extents. This will move
          * the lower right corner only.
          */
-    void setSize(int width, int height)
+    void setSize(int w, int h)
     {
-        lowerRight_ = upperLeft_ + Size2D(width, height);
+        lowerRight_ = upperLeft_ + Size2D(w, h);
     }
 
         /** Increase the size of the rectangle by the given offset. This
@@ -1131,7 +1131,7 @@ public:
     bool contains(Rect2D const &r) const
     {
         return r.isEmpty() ||
-            contains(r.upperLeft()) && contains(r.lowerRight()-Diff2D(1,1));
+            (contains(r.upperLeft()) && contains(r.lowerRight()-Diff2D(1,1)));
     }
 
         /** Return whether this rectangle overlaps with the given
diff -uprN misc/vigra1.6.0/include/vigra/fftw.hxx misc/build/vigra1.6.0/include/vigra/fftw.hxx
--- misc/vigra1.6.0/include/vigra/fftw.hxx	2008-08-13 08:15:36.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/fftw.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -399,8 +399,6 @@ inline FFTWComplex operator /(FFTWComple
     return a;
 }
 
-using VIGRA_CSTD::abs;
-
 inline FFTWComplex::value_type abs(const FFTWComplex &a)
 {
     return a.magnitude();
diff -uprN misc/vigra1.6.0/include/vigra/fftw3.hxx misc/build/vigra1.6.0/include/vigra/fftw3.hxx
--- misc/vigra1.6.0/include/vigra/fftw3.hxx	2008-08-13 08:15:36.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/fftw3.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -572,8 +572,6 @@ inline FFTWComplex operator /(FFTWComple
     return a;
 }
 
-using VIGRA_CSTD::abs;
-
     /// absolute value (= magnitude)
 inline FFTWComplex::value_type abs(const FFTWComplex &a)
 {
diff -uprN misc/vigra1.6.0/include/vigra/fixedpoint.hxx misc/build/vigra1.6.0/include/vigra/fixedpoint.hxx
--- misc/vigra1.6.0/include/vigra/fixedpoint.hxx	2008-08-13 08:15:36.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/fixedpoint.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -118,20 +118,18 @@ enum FixedPointNoShift { FPNoShift };
 
 namespace detail {
 
-template <bool MustRound>
+template <bool MustRound, int N>
 struct FPAssignWithRound;
 
-template <>
-struct FPAssignWithRound<false>
+template <int N>
+struct FPAssignWithRound<false, N>
 {
-    template <int N>
     static inline int exec(int v) { return v << (-N); }
 };
 
-template <>
-struct FPAssignWithRound<true>
+template <int N>
+struct FPAssignWithRound<true, N>
 {
-    template <int N>
     static inline int exec(int const v)
     {
         return (v + (1 << (N - 1))) >> (N);
@@ -276,7 +274,7 @@ public:
         */
     template <unsigned Int2, unsigned Frac2>
     FixedPoint(const FixedPoint<Int2, Frac2> &other)
-    : value(detail::FPAssignWithRound<(Frac2 > FractionalBits)>::template exec<Frac2 - FractionalBits>(other.value))
+        : value(detail::FPAssignWithRound<(Frac2 > FractionalBits), Frac2 - FractionalBits>::exec(other.value))
     {
         VIGRA_STATIC_ASSERT((FixedPoint_overflow_error__More_than_31_bits_requested<(IntBits + FractionalBits)>));
         VIGRA_STATIC_ASSERT((FixedPoint_assignment_error__Target_object_has_too_few_integer_bits<(IntBits >= Int2)>));
@@ -321,7 +319,7 @@ public:
     FixedPoint & operator=(const FixedPoint<Int2, Frac2> &other)
     {
         VIGRA_STATIC_ASSERT((FixedPoint_assignment_error__Target_object_has_too_few_integer_bits<(IntBits >= Int2)>));
-        value = detail::FPAssignWithRound<(Frac2 > FractionalBits)>::template exec<Frac2 - FractionalBits>(other.value);
+        value = detail::FPAssignWithRound<(Frac2 > FractionalBits),Frac2 - FractionalBits>::exec(other.value);
         return *this;
     }
 
@@ -373,7 +371,7 @@ public:
     FixedPoint & operator+=(const FixedPoint<Int2, Frac2> &other)
     {
         VIGRA_STATIC_ASSERT((FixedPoint_assignment_error__Target_object_has_too_few_integer_bits<(IntBits >= Int2)>));
-        value += detail::FPAssignWithRound<(Frac2 > FractionalBits)>::template exec<Frac2 - FractionalBits>(other.value);
+        value += detail::FPAssignWithRound<(Frac2 > FractionalBits),Frac2 - FractionalBits>::exec(other.value);
         return *this;
     }
 
@@ -384,7 +382,7 @@ public:
     FixedPoint & operator-=(const FixedPoint<Int2, Frac2> &other)
     {
         VIGRA_STATIC_ASSERT((FixedPoint_assignment_error__Target_object_has_too_few_integer_bits<(IntBits >= Int2)>));
-        value -= detail::FPAssignWithRound<(Frac2 > FractionalBits)>::template exec<Frac2 - FractionalBits>(other.value);
+        value -= detail::FPAssignWithRound<(Frac2 > FractionalBits),Frac2 - FractionalBits>::exec(other.value);
         return *this;
     }
     
diff -uprN misc/vigra1.6.0/include/vigra/gaborfilter.hxx misc/build/vigra1.6.0/include/vigra/gaborfilter.hxx
--- misc/vigra1.6.0/include/vigra/gaborfilter.hxx	2008-08-13 08:15:36.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/gaborfilter.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -287,7 +287,11 @@ inline double angularGaborSigma(int dire
     Namespace: vigra
 */
 template <class ImageType, 
+#ifndef VIGRA_WITHOUT_NESTED_TEMPLATE_PARAMS
       class Alloc = typename ImageType::allocator_type::template rebind<ImageType>::other >
+#else
+      class Alloc = std::allocator<ImageType> >
+#endif
 class GaborFilterFamily 
 : public ImageArray<ImageType, Alloc>
 {
diff -uprN misc/vigra1.6.0/include/vigra/gaussians.hxx misc/build/vigra1.6.0/include/vigra/gaussians.hxx
--- misc/vigra1.6.0/include/vigra/gaussians.hxx	2008-08-13 08:15:36.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/gaussians.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -88,26 +88,26 @@ class Gaussian
             sigma > 0.0
             \endcode
         */
-    explicit Gaussian(T sigma = 1.0, unsigned int derivativeOrder = 0)
-    : sigma_(sigma),
-      sigma2_(-0.5 / sigma / sigma),
+    explicit Gaussian(T s = 1.0, unsigned int derivOrder = 0)
+    : sigma_(s),
+      sigma2_(-0.5 / s / s),
       norm_(0.0),
-      order_(derivativeOrder),
-      hermitePolynomial_(derivativeOrder / 2 + 1)
+      order_(derivOrder),
+      hermitePolynomial_(derivOrder / 2 + 1)
     {
-        vigra_precondition(sigma_ > 0.0,
+        vigra_precondition(s > 0.0,
             "Gaussian::Gaussian(): sigma > 0 required.");
         switch(order_)
         {
             case 1:
             case 2:
-                norm_ = -1.0 / (VIGRA_CSTD::sqrt(2.0 * M_PI) * sq(sigma) * sigma);
+                norm_ = -1.0 / (VIGRA_CSTD::sqrt(2.0 * M_PI) * sq(s) * s);
                 break;
             case 3:
-                norm_ = 1.0 / (VIGRA_CSTD::sqrt(2.0 * M_PI) * sq(sigma) * sq(sigma) * sigma);
+                norm_ = 1.0 / (VIGRA_CSTD::sqrt(2.0 * M_PI) * sq(s) * sq(s) * s);
                 break;
             default:
-                norm_ = 1.0 / VIGRA_CSTD::sqrt(2.0 * M_PI) / sigma;
+                norm_ = 1.0 / VIGRA_CSTD::sqrt(2.0 * M_PI) / s;
         }
         calculateHermitePolynomial();
     }
--- misc/vigra1.6.0/include/vigra/mathutil.hxx	2008-08-13 08:15:38.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/mathutil.hxx	2012-09-21 02:16:23.000000000 -0500
@@ -88,7 +88,7 @@ using VIGRA_CSTD::ceil;  
 
 // import abs(float), abs(double), abs(long double) from <cmath>
 //    and abs(int), abs(long), abs(long long) from <cstdlib>
-using std::abs;  
+//using std::abs;  
 
 // define the missing variants of abs() to avoid 'ambigous overload'
 // errors in template functions
@@ -100,17 +100,41 @@ VIGRA_DEFINE_UNSIGNED_ABS(unsigned char)
 VIGRA_DEFINE_UNSIGNED_ABS(unsigned short)
 VIGRA_DEFINE_UNSIGNED_ABS(unsigned int)
 VIGRA_DEFINE_UNSIGNED_ABS(unsigned long)
+#ifdef VIGRA_HAS_LONG_LONG
 VIGRA_DEFINE_UNSIGNED_ABS(unsigned long long)
+#endif
 
 #undef VIGRA_DEFINE_UNSIGNED_ABS
 
 #define VIGRA_DEFINE_MISSING_ABS(T) \
     inline T abs(T t) { return t < 0 ? -t : t; }
 
-VIGRA_DEFINE_MISSING_ABS(signed char)
-VIGRA_DEFINE_MISSING_ABS(signed short)
+#define VIGRA_DEFINE_SIGNED_ABS(T) \
+    inline T abs(T t) { return (T)abs(t); }
+#define VIGRA_DEFINE_SIGNED_LABS(T) \
+    inline T abs(T t) { return (T)labs(t); }
+#define VIGRA_DEFINE_SIGNED_LLABS(T) \
+    inline T abs(T t) { return (T)llabs(t); }
+#define VIGRA_DEFINE_FABS(T) \
+    inline T abs(T t) { return (T)fabs(t); }
+
+VIGRA_DEFINE_SIGNED_ABS(signed char)
+VIGRA_DEFINE_SIGNED_ABS(signed short)
+VIGRA_DEFINE_SIGNED_ABS(signed int)
+VIGRA_DEFINE_SIGNED_LABS(signed long)
+#ifdef VIGRA_HAS_LONG_LONG
+VIGRA_DEFINE_SIGNED_LLABS(signed long long)
+#endif
+VIGRA_DEFINE_FABS(float)
+VIGRA_DEFINE_FABS(double)
+#ifdef VIGRA_HAS_LONG_DOUBLE
+VIGRA_DEFINE_FABS(long double)
+#endif
 
-#undef VIGRA_DEFINE_MISSING_ABS
+#undef VIGRA_DEFINE_SIGNED_ABS
+#undef VIGRA_DEFINE_SIGNED_LABS
+#undef VIGRA_DEFINE_SIGNED_LLABS
+#undef VIGRA_DEFINE_FABS
 
     /*! The rounding function.
 
@@ -134,12 +158,14 @@ inline double round(double t)
                 : ceil(t - 0.5);
 }
 
+#ifdef VIGRA_HAS_LONG_DOUBLE
 inline long double round(long double t)
 {
      return t >= 0.0
                 ? floor(t + 0.5)
                 : ceil(t - 0.5);
 }
+#endif
 
     /*! Round up to the nearest power of 2.
 
@@ -440,9 +466,15 @@ VIGRA_DEFINE_NORM(int)
 VIGRA_DEFINE_NORM(unsigned int)
 VIGRA_DEFINE_NORM(long)
 VIGRA_DEFINE_NORM(unsigned long)
+#ifdef VIGRA_HAS_LONG_LONG
+VIGRA_DEFINE_NORM(long long)
+VIGRA_DEFINE_NORM(unsigned long long)
+#endif
 VIGRA_DEFINE_NORM(float)
 VIGRA_DEFINE_NORM(double)
+#ifdef VIGRA_HAS_LONG_DOUBLE
 VIGRA_DEFINE_NORM(long double)
+#endif
 
 #undef VIGRA_DEFINE_NORM
 
diff -uprN misc/vigra1.6.0/include/vigra/numerictraits.hxx misc/build/vigra1.6.0/include/vigra/numerictraits.hxx
--- misc/vigra1.6.0/include/vigra/numerictraits.hxx	2008-08-13 08:15:39.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/numerictraits.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -863,6 +863,90 @@ struct NumericTraits<long>
     }
 };
 
+#ifdef VIGRA_HAS_LONG_LONG
+template<>
+struct NumericTraits<long long>
+{
+    typedef long long Type;
+    typedef long long Promote;
+    typedef double RealPromote;
+    typedef std::complex<RealPromote> ComplexPromote;
+    typedef Type ValueType;
+
+    typedef VigraTrueType isIntegral;
+    typedef VigraTrueType isScalar;
+    typedef VigraTrueType isSigned;
+    typedef VigraTrueType isOrdered;
+    typedef VigraFalseType isComplex;
+    
+    static long long zero() { return 0; }
+    static long long one() { return 1; }
+    static long long nonZero() { return 1; }
+    static long long min() { return LLONG_MIN; }
+    static long long max() { return LLONG_MAX; }
+    
+#ifdef NO_INLINE_STATIC_CONST_DEFINITION
+    enum { minConst = LONG_MIN, maxConst = LLONG_MAX };
+#else
+    static const long long minConst = LLONG_MIN;
+    static const long long maxConst = LLONG_MAX;
+#endif
+
+    static Promote toPromote(long long v) { return v; }
+    static RealPromote toRealPromote(long long v) { return v; }
+    static long long fromPromote(Promote v) { return v; }
+    static long long fromRealPromote(RealPromote v) {
+        return ((v < 0.0) 
+                 ? ((v < (RealPromote)LLONG_MIN) 
+                     ? LLONG_MIN 
+                     : static_cast<long long>(v - 0.5)) 
+                 : ((v > (RealPromote)LLONG_MAX) 
+                     ? LLONG_MAX 
+                     : static_cast<long long>(v + 0.5))); 
+    }
+};
+
+template<>
+struct NumericTraits<unsigned long long>
+{
+    typedef unsigned long long Type;
+    typedef unsigned long long Promote;
+    typedef double RealPromote;
+    typedef std::complex<RealPromote> ComplexPromote;
+    typedef Type ValueType;
+
+    typedef VigraTrueType isIntegral;
+    typedef VigraTrueType isScalar;
+    typedef VigraFalseType isSigned;
+    typedef VigraTrueType isOrdered;
+    typedef VigraFalseType isComplex;
+    
+    static unsigned long long zero() { return 0; }
+    static unsigned long long one() { return 1; }
+    static unsigned long long nonZero() { return 1; }
+    static unsigned long long min() { return 0; }
+    static unsigned long long max() { return ULLONG_MAX; }
+    
+#ifdef NO_INLINE_STATIC_CONST_DEFINITION
+    enum { minConst = 0, maxConst = ULLONG_MAX };
+#else
+    static const unsigned long long minConst = 0;
+    static const unsigned long long maxConst = ULLONG_MAX;
+#endif
+
+    static Promote toPromote(unsigned long long v) { return v; }
+    static RealPromote toRealPromote(unsigned long long v) { return v; }
+    static unsigned long long fromPromote(Promote v) { return v; }
+    static unsigned long long fromRealPromote(RealPromote v) {
+            return ((v < 0.0) 
+                     ? 0 
+                     : ((v > (RealPromote)ULLONG_MAX) 
+                         ? ULLONG_MAX 
+                         : static_cast<unsigned long long>(v + 0.5)));
+    }
+};
+#endif
+
 template<>
 struct NumericTraits<unsigned long>
 {
@@ -1050,6 +1134,7 @@ struct NumericTraits<double>
     static double fromRealPromote(RealPromote v) { return v; }
 };
 
+#ifdef VIGRA_HAS_LONG_DOUBLE
 template<>
 struct NumericTraits<long double>
 {
@@ -1079,6 +1164,7 @@ struct NumericTraits<long double>
     static long double fromPromote(Promote v) { return v; }
     static long double fromRealPromote(RealPromote v) { return v; }
 };
+#endif
 
 #ifndef NO_PARTIAL_TEMPLATE_SPECIALIZATION
 
@@ -1158,9 +1244,15 @@ VIGRA_DEFINE_NORM_TRAITS(int)
 VIGRA_DEFINE_NORM_TRAITS(unsigned int)
 VIGRA_DEFINE_NORM_TRAITS(long)
 VIGRA_DEFINE_NORM_TRAITS(unsigned long)
+#ifdef VIGRA_HAS_LONG_LONG
+VIGRA_DEFINE_NORM_TRAITS(long long)
+VIGRA_DEFINE_NORM_TRAITS(unsigned long long)
+#endif
 VIGRA_DEFINE_NORM_TRAITS(float)
 VIGRA_DEFINE_NORM_TRAITS(double)
+#ifdef VIGRA_HAS_LONG_DOUBLE
 VIGRA_DEFINE_NORM_TRAITS(long double)
+#endif
 
 #ifdef LLONG_MAX
 VIGRA_DEFINE_NORM_TRAITS(long long)
diff -uprN misc/vigra1.6.0/include/vigra/orientedtensorfilters.hxx misc/build/vigra1.6.0/include/vigra/orientedtensorfilters.hxx
--- misc/vigra1.6.0/include/vigra/orientedtensorfilters.hxx	2008-08-13 08:15:40.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/orientedtensorfilters.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -435,7 +435,7 @@ class Sin6RingKernel
         if(x == 0 && y == 0)
             return weights_(radius_, radius_);
         double d = dot(vectors_(x+radius_, y+radius_), v);
-        return VIGRA_CSTD::pow(1.0 - d * d, 3) * weights_(x+radius_, y+radius_);
+        return VIGRA_CSTD::pow(1.0 - d * d, 3.0) * weights_(x+radius_, y+radius_);
     }
 };
 
@@ -456,7 +456,7 @@ class Sin6Kernel
         if(x == 0 && y == 0)
             return weights_(radius_, radius_);
         double d = dot(vectors_(x+radius_, y+radius_), v);
-        return VIGRA_CSTD::pow(1.0 - d * d, 3) * weights_(x+radius_, y+radius_);
+        return VIGRA_CSTD::pow(1.0 - d * d, 3.0) * weights_(x+radius_, y+radius_);
     }
 };
 
@@ -477,7 +477,7 @@ class Cos6RingKernel
         if(x == 0 && y == 0)
             return weights_(radius_, radius_);
         double d = dot(vectors_(x+radius_, y+radius_), v);
-        return (1.0 - VIGRA_CSTD::pow(1.0 - d * d, 3)) * weights_(x+radius_, y+radius_);
+        return (1.0 - VIGRA_CSTD::pow(1.0 - d * d, 3.0)) * weights_(x+radius_, y+radius_);
     }
 };
 
@@ -498,7 +498,7 @@ class Cos6Kernel
         if(x == 0 && y == 0)
             return weights_(radius_, radius_);
         double d = dot(vectors_(x+radius_, y+radius_), v);
-        return (1.0 - VIGRA_CSTD::pow(1.0 - d * d, 3)) * weights_(x+radius_, y+radius_);
+        return (1.0 - VIGRA_CSTD::pow(1.0 - d * d, 3.0)) * weights_(x+radius_, y+radius_);
     }
 };
 
diff -uprN misc/vigra1.6.0/include/vigra/polynomial.hxx misc/build/vigra1.6.0/include/vigra/polynomial.hxx
--- misc/vigra1.6.0/include/vigra/polynomial.hxx	2008-08-13 08:15:40.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/polynomial.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -119,10 +119,10 @@ class PolynomialView
             of subsequent algorithms (especially root finding) performed on the
             polynomial.
         */
-    PolynomialView(T * coeffs, unsigned int order, double epsilon = 1.0e-14)
+    PolynomialView(T * coeffs, unsigned int ord, double eps = 1.0e-14)
     : coeffs_(coeffs),
-      order_(order),
-      epsilon_(epsilon)
+      order_(ord),
+      epsilon_(eps)
     {}
     
         /// Access the coefficient of x^i
@@ -245,16 +245,16 @@ class PolynomialView
         { epsilon_ = eps; }
 
   protected:
-    PolynomialView(double epsilon = 1e-14)
+    PolynomialView(double eps = 1e-14)
     : coeffs_(0),
       order_(0),
-      epsilon_(epsilon)
+      epsilon_(eps)
     {}
     
-    void setCoeffs(T * coeffs, unsigned int order)
+    void setCoeffs(T * coeffs, unsigned int ord)
     {
         coeffs_ = coeffs;
-        order_ = order;
+        order_ = ord;
     }
   
     T * coeffs_;
@@ -397,9 +397,9 @@ PolynomialView<T>::deflateConjugatePair(
     
 template <class T>
 void 
-PolynomialView<T>::minimizeOrder(double epsilon)
+PolynomialView<T>::minimizeOrder(double eps)
 {
-    while(std::abs(coeffs_[order_]) <= epsilon && order_ > 0)
+    while(std::abs(coeffs_[order_]) <= eps && order_ > 0)
             --order_;
 }
 
diff -uprN misc/vigra1.6.0/include/vigra/recursiveconvolution.hxx misc/build/vigra1.6.0/include/vigra/recursiveconvolution.hxx
--- misc/vigra1.6.0/include/vigra/recursiveconvolution.hxx	2008-08-13 08:15:40.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/recursiveconvolution.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -261,16 +261,16 @@ void recursiveFilterLine(SrcIterator is,
     {    
        // correction factors for b
         double bright = b;
-        double bleft = VIGRA_CSTD::pow(b, w);
+        double bleft = VIGRA_CSTD::pow(b, (double)w);
 
         for(x=w-1; x>=0; --x, --is, --id)
         {    
             TempType f = b * old;
             old = as(is) + f;
-            double norm = (1.0 - b) / (1.0 + b - bleft - bright);
+            double norm2 = (1.0 - b) / (1.0 + b - bleft - bright);
             bleft /= b;
             bright *= b;
-            ad.set(norm * (line[x] + f), id);
+            ad.set(norm2 * (line[x] + f), id);
         }
     }
     else if(border == BORDER_TREATMENT_AVOID)
diff -uprN misc/vigra1.6.0/include/vigra/rgbvalue.hxx misc/build/vigra1.6.0/include/vigra/rgbvalue.hxx
--- misc/vigra1.6.0/include/vigra/rgbvalue.hxx	2008-08-13 08:15:41.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/rgbvalue.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -39,6 +39,10 @@
 #ifndef VIGRA_RGBVALUE_HXX
 #define VIGRA_RGBVALUE_HXX
 
+#if defined __GNUC__
+#pragma GCC system_header
+#endif
+
 #include <cmath>    // abs(double)
 #include <cstdlib>  // abs(int)
 #include "config.hxx"
@@ -702,8 +706,6 @@ operator/=(RGBValue<V, RIDX, GIDX, BIDX>
     return l;
 }
 
-using VIGRA_CSTD::abs;
-
     /// component-wise absolute value
 template <class T, unsigned int RIDX, unsigned int GIDX, unsigned int BIDX>
 inline
diff -uprN misc/vigra1.6.0/include/vigra/separableconvolution.hxx misc/build/vigra1.6.0/include/vigra/separableconvolution.hxx
--- misc/vigra1.6.0/include/vigra/separableconvolution.hxx	2008-08-13 08:15:41.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/separableconvolution.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -1022,11 +1022,11 @@ class Kernel1D
         */
     InitProxy operator=(value_type const & v)
     {
-        int size = right_ - left_ + 1;
+        int sz = right_ - left_ + 1;
         for(unsigned int i=0; i<kernel_.size(); ++i) kernel_[i] = v;
-        norm_ = (double)size*v;
+        norm_ = (double)sz*v;
 
-        return InitProxy(kernel_.begin(), size, norm_);
+        return InitProxy(kernel_.begin(), sz, norm_);
     }
 
         /** Destructor.
@@ -1663,8 +1663,8 @@ class Kernel1D
 };
 
 template <class ARITHTYPE>
-void Kernel1D<ARITHTYPE>::normalize(value_type norm,
-                          unsigned int derivativeOrder,
+void Kernel1D<ARITHTYPE>::normalize(value_type normFactor,
+                          unsigned int derivOrder,
                           double offset)
 {
     typedef typename NumericTraits<value_type>::RealPromote TmpType;
@@ -1673,7 +1673,7 @@ void Kernel1D<ARITHTYPE>::normalize(valu
     Iterator k = kernel_.begin();
     TmpType sum = NumericTraits<TmpType>::zero();
 
-    if(derivativeOrder == 0)
+    if(derivOrder == 0)
     {
         for(; k < kernel_.end(); ++k)
         {
@@ -1683,11 +1683,11 @@ void Kernel1D<ARITHTYPE>::normalize(valu
     else
     {
         unsigned int faculty = 1;
-        for(unsigned int i = 2; i <= derivativeOrder; ++i)
+        for(unsigned int i = 2; i <= derivOrder; ++i)
             faculty *= i;
         for(double x = left() + offset; k < kernel_.end(); ++x, ++k)
         {
-            sum += *k * VIGRA_CSTD::pow(-x, int(derivativeOrder)) / faculty;
+            sum += *k * VIGRA_CSTD::pow(-x, (double)derivOrder) / faculty;
         }
     }
 
@@ -1695,21 +1695,21 @@ void Kernel1D<ARITHTYPE>::normalize(valu
                     "Kernel1D<ARITHTYPE>::normalize(): "
                     "Cannot normalize a kernel with sum = 0");
     // normalize
-    sum = norm / sum;
+    sum = normFactor / sum;
     k = kernel_.begin();
     for(; k != kernel_.end(); ++k)
     {
         *k = *k * sum;
     }
 
-    norm_ = norm;
+    norm_ = normFactor;
 }
 
 /***********************************************************************/
 
 template <class ARITHTYPE>
 void Kernel1D<ARITHTYPE>::initGaussian(double std_dev,
-                                       value_type norm)
+                                       value_type normFactor)
 {
     vigra_precondition(std_dev >= 0.0,
               "Kernel1D::initGaussian(): Standard deviation must be >= 0.");
@@ -1742,8 +1742,8 @@ void Kernel1D<ARITHTYPE>::initGaussian(d
         right_ = 0;
     }
 
-    if(norm != 0.0)
-        normalize(norm);
+    if(normFactor != 0.0)
+        normalize(normFactor);
     else
         norm_ = 1.0;
 
@@ -1755,7 +1755,7 @@ void Kernel1D<ARITHTYPE>::initGaussian(d
 
 template <class ARITHTYPE>
 void Kernel1D<ARITHTYPE>::initDiscreteGaussian(double std_dev,
-                                       value_type norm)
+                                               value_type normFactor)
 {
     vigra_precondition(std_dev >= 0.0,
               "Kernel1D::initDiscreteGaussian(): Standard deviation must be >= 0.");
@@ -1797,7 +1797,7 @@ void Kernel1D<ARITHTYPE>::initDiscreteGa
             er += warray[i];
         }
 
-        double scale = norm / (2*er - warray[0]);
+        double scale = normFactor / (2*er - warray[0]);
 
         initExplicitly(-radius, radius);
         iterator c = center();
@@ -1810,12 +1810,12 @@ void Kernel1D<ARITHTYPE>::initDiscreteGa
     else
     {
         kernel_.erase(kernel_.begin(), kernel_.end());
-        kernel_.push_back(norm);
+        kernel_.push_back(normFactor);
         left_ = 0;
         right_ = 0;
     }
 
-    norm_ = norm;
+    norm_ = normFactor;
 
     // best border treatment for Gaussians is BORDER_TREATMENT_REFLECT
     border_treatment_ = BORDER_TREATMENT_REFLECT;
@@ -1826,15 +1826,15 @@ void Kernel1D<ARITHTYPE>::initDiscreteGa
 template <class ARITHTYPE>
 void
 Kernel1D<ARITHTYPE>::initGaussianDerivative(double std_dev,
-                    int order,
-                    value_type norm)
+                                            int order,
+                                            value_type normFactor)
 {
     vigra_precondition(order >= 0,
               "Kernel1D::initGaussianDerivative(): Order must be >= 0.");
 
     if(order == 0)
     {
-        initGaussian(std_dev, norm);
+        initGaussian(std_dev, normFactor);
         return;
     }
 
@@ -1865,7 +1865,7 @@ Kernel1D<ARITHTYPE>::initGaussianDerivat
 
     // remove DC, but only if kernel correction is permitted by a non-zero
     // value for norm
-    if(norm != 0.0)
+    if(normFactor != 0.0)
     {
         for(unsigned int i=0; i < kernel_.size(); ++i)
         {
@@ -1876,8 +1876,8 @@ Kernel1D<ARITHTYPE>::initGaussianDerivat
     left_ = -radius;
     right_ = radius;
 
-    if(norm != 0.0)
-        normalize(norm, order);
+    if(normFactor != 0.0)
+        normalize(normFactor, order);
     else
         norm_ = 1.0;
 
@@ -1891,7 +1891,7 @@ Kernel1D<ARITHTYPE>::initGaussianDerivat
 template <class ARITHTYPE>
 void
 Kernel1D<ARITHTYPE>::initBinomial(int radius,
-                                  value_type norm)
+                                  value_type normFactor)
 {
     vigra_precondition(radius > 0,
               "Kernel1D::initBinomial(): Radius must be > 0.");
@@ -1921,12 +1921,12 @@ Kernel1D<ARITHTYPE>::initBinomial(int ra
 
     for(i=0; i<=radius*2+1; ++i)
     {
-        kernel_.push_back(kernel[i] * norm);
+        kernel_.push_back(kernel[i] * normFactor);
     }
 
     left_ = -radius;
     right_ = radius;
-    norm_ = norm;
+    norm_ = normFactor;
 
     // best border treatment for Binomial is BORDER_TREATMENT_REFLECT
     border_treatment_ = BORDER_TREATMENT_REFLECT;
@@ -1936,7 +1936,7 @@ Kernel1D<ARITHTYPE>::initBinomial(int ra
 
 template <class ARITHTYPE>
 void Kernel1D<ARITHTYPE>::initAveraging(int radius,
-                                        value_type norm)
+                                        value_type normFactor)
 {
     vigra_precondition(radius > 0,
               "Kernel1D::initAveraging(): Radius must be > 0.");
@@ -1950,12 +1950,12 @@ void Kernel1D<ARITHTYPE>::initAveraging(
 
     for(int i=0; i<=radius*2+1; ++i)
     {
-        kernel_.push_back(scale * norm);
+        kernel_.push_back(scale * normFactor);
     }
 
     left_ = -radius;
     right_ = radius;
-    norm_ = norm;
+    norm_ = normFactor;
 
     // best border treatment for Averaging is BORDER_TREATMENT_CLIP
     border_treatment_ = BORDER_TREATMENT_CLIP;
diff -uprN misc/vigra1.6.0/include/vigra/sized_int.hxx misc/build/vigra1.6.0/include/vigra/sized_int.hxx
--- misc/vigra1.6.0/include/vigra/sized_int.hxx	2008-08-13 08:15:41.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/sized_int.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -73,11 +73,15 @@ struct SelectIntegerType<SIZE, Int_type_
     typedef Int_type_not_supported_on_this_platform type;
 };
 
+#if defined __SUNPRO_CC
+#pragma disable_warn
+#endif
+
 template<class LIST>
 struct SelectBiggestIntegerType
 {
-    enum { cursize = LIST::size, 
-           nextsize = SelectBiggestIntegerType<typename LIST::next>::size,
+    enum { cursize = static_cast< int >(LIST::size), 
+           nextsize = static_cast< int >(SelectBiggestIntegerType<typename LIST::next>::size),
            size = (cursize < nextsize) ? nextsize : cursize };
     typedef typename 
        IfBool<(cursize < nextsize), 
@@ -86,6 +90,10 @@ struct SelectBiggestIntegerType
        type;
 };
 
+#if defined __SUNPRO_CC
+#pragma enable_warn
+#endif
+
 template<>
 struct SelectBiggestIntegerType<Int_type_not_supported_on_this_platform>
 {
diff -uprN misc/vigra1.6.0/include/vigra/splines.hxx misc/build/vigra1.6.0/include/vigra/splines.hxx
--- misc/vigra1.6.0/include/vigra/splines.hxx	2008-08-13 08:15:41.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/splines.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -108,8 +108,8 @@ class BSplineBase
         /** Create functor for gevine derivative of the spline. The spline's order
             is specified spline by the template argument <TT>ORDER</tt>.
         */
-    explicit BSplineBase(unsigned int derivativeOrder = 0)
-    : s1_(derivativeOrder)
+    explicit BSplineBase(unsigned int derivOrder = 0)
+    : s1_(derivOrder)
     {}
 
         /** Unary function call.
@@ -280,8 +280,8 @@ class BSplineBase<0, T>
     typedef T            result_type;
     enum StaticOrder { order = 0 };
 
-    explicit BSplineBase(unsigned int derivativeOrder = 0)
-    : derivativeOrder_(derivativeOrder)
+    explicit BSplineBase(unsigned int derivOrder = 0)
+    : derivativeOrder_(derivOrder)
     {}
 
     result_type operator()(argument_type x) const
@@ -357,8 +357,8 @@ class BSpline<1, T>
     typedef T            result_type;
     enum  StaticOrder { order = 1 };
 
-    explicit BSpline(unsigned int derivativeOrder = 0)
-    : derivativeOrder_(derivativeOrder)
+    explicit BSpline(unsigned int derivOrder = 0)
+    : derivativeOrder_(derivOrder)
     {}
 
     result_type operator()(argument_type x) const
@@ -454,8 +454,8 @@ class BSpline<2, T>
     typedef T            result_type;
     enum StaticOrder { order = 2 };
 
-    explicit BSpline(unsigned int derivativeOrder = 0)
-    : derivativeOrder_(derivativeOrder)
+    explicit BSpline(unsigned int derivOrder = 0)
+    : derivativeOrder_(derivOrder)
     {}
 
     result_type operator()(argument_type x) const
@@ -583,8 +583,8 @@ class BSpline<3, T>
     typedef T            result_type;
     enum StaticOrder { order = 3 };
 
-    explicit BSpline(unsigned int derivativeOrder = 0)
-    : derivativeOrder_(derivativeOrder)
+    explicit BSpline(unsigned int derivOrder = 0)
+    : derivativeOrder_(derivOrder)
     {}
 
     result_type operator()(argument_type x) const
@@ -735,8 +735,8 @@ class BSpline<4, T>
     typedef T            result_type;
     enum StaticOrder { order = 4 };
 
-    explicit BSpline(unsigned int derivativeOrder = 0)
-    : derivativeOrder_(derivativeOrder)
+    explicit BSpline(unsigned int derivOrder = 0)
+    : derivativeOrder_(derivOrder)
     {}
 
     result_type operator()(argument_type x) const
diff -uprN misc/vigra1.6.0/include/vigra/static_assert.hxx misc/build/vigra1.6.0/include/vigra/static_assert.hxx
--- misc/vigra1.6.0/include/vigra/static_assert.hxx	2008-08-13 08:15:41.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/static_assert.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -115,7 +115,7 @@ assertImpl( void (*)(Predicate), typenam
     
 TODO: provide more assertion base classes for other (non boolean) types of tests
 */
-#if !defined(__GNUC__) || __GNUC__ > 2
+#if (!defined(__GNUC__) || __GNUC__ > 2) && (!defined(__SUNPRO_CC) || __SUNPRO_CC > 0x550)
 #define VIGRA_STATIC_ASSERT(Predicate) \
 enum { \
     VIGRA_PREPROCESSOR_CONCATENATE(vigra_assertion_in_line_, __LINE__) = sizeof( \
diff -uprN misc/vigra1.6.0/include/vigra/tinyvector.hxx misc/build/vigra1.6.0/include/vigra/tinyvector.hxx
--- misc/vigra1.6.0/include/vigra/tinyvector.hxx	2008-08-13 08:15:42.000000000 -0500
+++ misc/build/vigra1.6.0/include/vigra/tinyvector.hxx	2012-09-19 17:30:24.000000000 -0500
@@ -39,6 +39,10 @@
 #ifndef VIGRA_TINYVECTOR_HXX
 #define VIGRA_TINYVECTOR_HXX
 
+#if defined __GNUC__
+#pragma GCC system_header
+#endif
+
 #include <cmath>    // abs(double)
 #include <cstdlib>  // abs(int)
 #include <iosfwd>   // ostream
@@ -49,7 +53,6 @@
 
 namespace vigra {
 
-using VIGRA_CSTD::abs;
 using VIGRA_CSTD::ceil;
 using VIGRA_CSTD::floor;
 
@@ -439,9 +442,9 @@ class TinyVectorBase
         /** Initialize from another sequence (must have length SIZE!)
         */
     template <class Iterator>
-    void init(Iterator i, Iterator end)
+    void init(Iterator i, Iterator iend)
     {
-		vigra_precondition(end-i == SIZE,
+		vigra_precondition(iend-i == SIZE,
             "TinyVector::init(): Sequence has wrong size.");
         Loop::assignCast(data_, i);
     }
