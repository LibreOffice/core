diff -ur collada2gltf.org/assetModifiers/GLTFAssetModifier.h collada2gltf/assetModifiers/GLTFAssetModifier.h
--- collada2gltf.org/assetModifiers/GLTFAssetModifier.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/assetModifiers/GLTFAssetModifier.h	2014-09-29 15:32:47.000000000 +0200
@@ -24,6 +24,8 @@
 #ifndef __GLTFASSETMODIFIER__
 #define __GLTFASSETMODIFIER__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF
 {
     /* Abstract
@@ -33,7 +35,7 @@
     class GLTFAssetModifier {
     public:
         virtual bool init() { return true; };
-        virtual void modify(std::shared_ptr<JSONObject> glTFAsset) = 0;
+        virtual void modify(boost::shared_ptr<JSONObject> glTFAsset) = 0;
         virtual void cleanup() { };
         virtual ~GLTFAssetModifier() {};
     };
diff -ur collada2gltf.org/assetModifiers/GLTFFlipUVModifier.cpp collada2gltf/assetModifiers/GLTFFlipUVModifier.cpp
--- collada2gltf.org/assetModifiers/GLTFFlipUVModifier.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/assetModifiers/GLTFFlipUVModifier.cpp	2014-09-29 15:39:27.000000000 +0200
@@ -65,21 +65,21 @@
         }
     }
     
-    void GLTFFlipUVModifier::modify(shared_ptr<JSONObject> glTFAsset) {
+    void GLTFFlipUVModifier::modify(boost::shared_ptr<JSONObject> glTFAsset) {
         if (glTFAsset->contains(kMeshes) == false)
             return;
         
-        shared_ptr<JSONObject> meshes = glTFAsset->getObject(kMeshes);
+        boost::shared_ptr<JSONObject> meshes = glTFAsset->getObject(kMeshes);
         std::vector <std::string> meshesUIDs = meshes->getAllKeys();
         
         for (size_t i = 0 ; i < meshesUIDs.size() ; i++) {
-            shared_ptr<GLTFMesh> mesh = static_pointer_cast<GLTFMesh>(meshes->getObject(meshesUIDs[i]));
+            boost::shared_ptr<GLTFMesh> mesh = boost::static_pointer_cast<GLTFMesh>(meshes->getObject(meshesUIDs[i]));
             if (mesh->hasSemantic(GLTF::TEXCOORD)) {
                 //https://github.com/KhronosGroup/collada2json/issues/41
                 
                 size_t attributesCount = mesh->getMeshAttributesCountForSemantic(GLTF::TEXCOORD);
                 for (size_t k = 0 ; k < attributesCount ; k++) {
-                    shared_ptr <GLTF::GLTFAccessor> meshAttribute = mesh->getMeshAttribute(GLTF::TEXCOORD, k);
+                    boost::shared_ptr <GLTF::GLTFAccessor> meshAttribute = mesh->getMeshAttribute(GLTF::TEXCOORD, k);
                     meshAttribute->applyOnAccessor(__InvertV, NULL);
                 }
             }
diff -ur collada2gltf.org/assetModifiers/GLTFFlipUVModifier.h collada2gltf/assetModifiers/GLTFFlipUVModifier.h
--- collada2gltf.org/assetModifiers/GLTFFlipUVModifier.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/assetModifiers/GLTFFlipUVModifier.h	2014-09-29 15:33:01.000000000 +0200
@@ -24,6 +24,8 @@
 #ifndef __GLTFFLIPUVMODIFIER__
 #define __GLTFFLIPUVMODIFIER__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF
 {
     class GLTFFlipUVModifier : public GLTFAssetModifier {
@@ -32,7 +34,7 @@
         virtual ~GLTFFlipUVModifier();
         
         virtual bool init();
-        virtual void modify(std::shared_ptr<JSONObject> glTFAsset);
+        virtual void modify(boost::shared_ptr<JSONObject> glTFAsset);
         virtual void cleanup();
     };
 }
diff -ur collada2gltf.org/COLLADA2GLTFWriter.cpp collada2gltf/COLLADA2GLTFWriter.cpp
--- collada2gltf.org/COLLADA2GLTFWriter.cpp	2014-09-29 15:30:40.142494472 +0200
+++ collada2gltf/COLLADA2GLTFWriter.cpp	2014-09-29 15:39:59.000000000 +0200
@@ -48,7 +48,7 @@
 {
     /*
      */
-    COLLADA2GLTFWriter::COLLADA2GLTFWriter(shared_ptr<GLTFAsset> asset):
+    COLLADA2GLTFWriter::COLLADA2GLTFWriter(boost::shared_ptr<GLTFAsset> asset):
     _asset(asset),
     _visualScene(0) {
 	}
@@ -71,14 +71,17 @@
         //To comply with macro to access config
         GLTFAsset *asset = this->_asset.get();
         asset->setExtras(this->_extraDataHandler->allExtras());
-        asset->prepareForProfile(shared_ptr <GLTFWebGL_1_0_Profile> (new GLTFWebGL_1_0_Profile()));
+        asset->prepareForProfile(boost::shared_ptr <GLTFWebGL_1_0_Profile> (new GLTFWebGL_1_0_Profile()));
                 
 		COLLADAFW::Root root(&this->_loader, this);
         this->_loader.registerExtraDataCallbackHandler(this->_extraDataHandler);
-		if (!root.loadDocument(asset->getInputFilePath()))
+		if (!root.loadDocument(asset->getInputFilePath())) {
+                    delete _extraDataHandler;
 			return false;
+                }
         
         asset->write();
+        delete _extraDataHandler;
                 
 		return true;
 	}
@@ -99,7 +102,7 @@
 	//--------------------------------------------------------------------
 	bool COLLADA2GLTFWriter::writeGlobalAsset( const COLLADAFW::FileInfo* globalAsset ) {
         GLTFAsset* asset = this->_asset.get();
-        shared_ptr<JSONObject> assetObject = asset->root()->createObjectIfNeeded(kAsset);
+        boost::shared_ptr<JSONObject> assetObject = asset->root()->createObjectIfNeeded(kAsset);
         std::string version = "collada2gltf@"+std::string(g_GIT_SHA1);
         
         assetObject->setString("generator",version);
@@ -127,7 +130,7 @@
         return getTransparency(effectCommon)  >= 1;
     }
     
-    void COLLADA2GLTFWriter::registerObjectWithOriginalUID(std::string originalId, shared_ptr <JSONObject> obj, shared_ptr <JSONObject> objLib) {
+    void COLLADA2GLTFWriter::registerObjectWithOriginalUID(std::string originalId, boost::shared_ptr <JSONObject> obj, boost::shared_ptr <JSONObject> objLib) {
         if (this->_asset->_originalIDToTrackedObject.count(originalId) == 0) {
             if (!objLib->contains(originalId)) {
                 objLib->setValue(originalId, obj);
@@ -149,13 +152,13 @@
             return;
         }
         
-        shared_ptr <GLTFMesh> mesh = static_pointer_cast<GLTFMesh>(this->_asset->getValueForUniqueId(meshUID));
+        boost::shared_ptr <GLTFMesh> mesh = boost::static_pointer_cast<GLTFMesh>(this->_asset->getValueForUniqueId(meshUID));
         this->_asset->setOriginalId(meshUID, mesh->getID());
         
         MaterialBindingsForNodeUID& mb = this->_asset->materialBindingsForNodeUID();
-        shared_ptr <MaterialBindingsForMeshUID> materialBindingsMap;
+        boost::shared_ptr <MaterialBindingsForMeshUID> materialBindingsMap;
         if (mb.count(nodeUID) == 0) {
-            materialBindingsMap = shared_ptr<MaterialBindingsForMeshUID>(new MaterialBindingsForMeshUID());
+            materialBindingsMap = boost::shared_ptr<MaterialBindingsForMeshUID>(new MaterialBindingsForMeshUID());
             mb[nodeUID] = materialBindingsMap;
         } else {
             materialBindingsMap = mb[nodeUID];
@@ -163,9 +166,9 @@
         
         //apply prefix on MeshUID
         std::string prefixedMeshUID = prefix + meshUID;
-        shared_ptr <MaterialBindingsPrimitiveMap> materialBindingsPrimitiveMap;
+        boost::shared_ptr <MaterialBindingsPrimitiveMap> materialBindingsPrimitiveMap;
         if (materialBindingsMap->count(prefixedMeshUID) == 0) {
-            materialBindingsPrimitiveMap = shared_ptr<MaterialBindingsPrimitiveMap> (new MaterialBindingsPrimitiveMap());
+            materialBindingsPrimitiveMap = boost::shared_ptr<MaterialBindingsPrimitiveMap> (new MaterialBindingsPrimitiveMap());
             (*materialBindingsMap)[prefixedMeshUID] = materialBindingsPrimitiveMap;
         } else {
             materialBindingsPrimitiveMap = (*materialBindingsMap)[prefixedMeshUID];
@@ -173,7 +176,7 @@
         
         GLTF::JSONValueVector primitives = mesh->getPrimitives()->values();
         for (size_t j = 0 ; j < primitives.size() ; j++) {
-            shared_ptr <GLTF::GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[j]);
+            boost::shared_ptr <GLTF::GLTFPrimitive> primitive = boost::static_pointer_cast<GLTFPrimitive>(primitives[j]);
             //FIXME: consider optimizing this with a hashtable, would be better if it was coming that way from OpenCOLLADA
             int materialBindingIndex = -1;
             for (size_t k = 0; k < materialBindings.getCount() ; k++) {
@@ -182,7 +185,7 @@
                 }
             }
             if (materialBindingIndex != -1) {
-                shared_ptr <COLLADAFW::MaterialBinding> materialBinding(new COLLADAFW::MaterialBinding(materialBindings[materialBindingIndex]));
+                boost::shared_ptr <COLLADAFW::MaterialBinding> materialBinding(new COLLADAFW::MaterialBinding(materialBindings[materialBindingIndex]));
                 (*materialBindingsPrimitiveMap)[primitive->getMaterialObjectID()] = materialBinding;
             }            
         }
@@ -191,7 +194,7 @@
 
     
     bool COLLADA2GLTFWriter::writeNode( const COLLADAFW::Node* node,
-                                       shared_ptr <GLTF::JSONObject> nodesObject,
+                                       boost::shared_ptr <GLTF::JSONObject> nodesObject,
                                        COLLADABU::Math::Matrix4 parentMatrix,
                                        SceneFlatteningInfo* sceneFlatteningInfo) {
         GLTFAsset *asset = this->_asset.get();
@@ -206,10 +209,10 @@
         
         COLLADABU::Math::Matrix4 matrix = COLLADABU::Math::Matrix4::IDENTITY;
         
-        shared_ptr <GLTF::JSONObject> nodeObject(new GLTF::JSONObject());
+        boost::shared_ptr <GLTF::JSONObject> nodeObject(new GLTF::JSONObject());
         nodeObject->setString(kName,node->getName());
         
-        this->_asset->_uniqueIDToOpenCOLLADAObject[uniqueUID] = shared_ptr <COLLADAFW::Object> (node->clone());
+        this->_asset->_uniqueIDToOpenCOLLADAObject[uniqueUID] = boost::shared_ptr <COLLADAFW::Object> (node->clone());
         this->_asset->setOriginalId(uniqueUID, nodeOriginalID);
         this->_asset->setValueForUniqueId(uniqueUID, nodeObject);
         if (node->getType() == COLLADAFW::Node::JOINT) {
@@ -222,7 +225,7 @@
         size_t camerasCount = instanceCameras.getCount();
         if (camerasCount > 0) {
             InstanceCamera* instanceCamera = instanceCameras[0];
-            shared_ptr <GLTF::JSONObject> cameraObject(new GLTF::JSONObject());
+            boost::shared_ptr <GLTF::JSONObject> cameraObject(new GLTF::JSONObject());
             
             std::string cameraId = uniqueIdWithType(kCamera, instanceCamera->getInstanciatedObjectId());
             nodeObject->setString(kCamera, cameraId);
@@ -265,10 +268,10 @@
             if (!animationListID.isValid())
                 continue;
             
-            shared_ptr<AnimatedTargets> animatedTargets(new AnimatedTargets());
+            boost::shared_ptr<AnimatedTargets> animatedTargets(new AnimatedTargets());
             
             this->_asset->_uniqueIDToAnimatedTargets[animationListID.toAscii()] = animatedTargets;
-            shared_ptr <JSONObject> animatedTarget(new JSONObject());
+            boost::shared_ptr <JSONObject> animatedTarget(new JSONObject());
             std::string animationID = animationListID.toAscii();
             animatedTarget->setString(kTarget, uniqueUID);
             animatedTarget->setString("transformId", animationID);
@@ -326,16 +329,16 @@
         const InstanceControllerPointerArray& instanceControllers = node->getInstanceControllers();
 		unsigned int count = (unsigned int)instanceControllers.getCount();
         if (count > 0) {
-            shared_ptr<JSONObject> skins = this->_asset->root()->createObjectIfNeeded(kSkins);
+            boost::shared_ptr<JSONObject> skins = this->_asset->root()->createObjectIfNeeded(kSkins);
             for (unsigned int i = 0 ; i < count; i++) {
                 InstanceController* instanceController = instanceControllers[i];
                 MaterialBindingArray &materialBindings = instanceController->getMaterialBindings();
                 COLLADAFW::UniqueId uniqueId = instanceController->getInstanciatedObjectId();
                 if (asset->containsValueForUniqueId(uniqueId.toAscii())) {
                     
-                    shared_ptr<JSONString> skinControllerDataUID = static_pointer_cast<JSONString>(asset->getValueForUniqueId(uniqueId.toAscii()));
+                    boost::shared_ptr<JSONString> skinControllerDataUID = boost::static_pointer_cast<JSONString>(asset->getValueForUniqueId(uniqueId.toAscii()));
 
-                    shared_ptr<GLTFSkin> skin = static_pointer_cast<GLTFSkin>(skins->getObject(skinControllerDataUID->getString()));
+                    boost::shared_ptr<GLTFSkin> skin = boost::static_pointer_cast<GLTFSkin>(skins->getObject(skinControllerDataUID->getString()));
                     
                     UniqueId meshUniqueId(skin->getSourceUID());
                     _storeMaterialBindingArray("skin-meshes-",
@@ -344,7 +347,7 @@
                                                materialBindings);
                     
                     //write instanceController
-                    shared_ptr<JSONObject> serializedInstanceController(new JSONObject());
+                    boost::shared_ptr<JSONObject> serializedInstanceController(new JSONObject());
                     
                     UniqueId skinDataUniqueId(skin->extras()->getString("uniqueId"));
                     
@@ -352,13 +355,13 @@
                     Loader::InstanceControllerDataList list = this->_loader.getInstanceControllerDataListMap()[skinDataUniqueId];
                     Loader::InstanceControllerData instanceControllerData = *list.begin();
                     
-                    shared_ptr<JSONObject> instanceSkin(new JSONObject());
+                    boost::shared_ptr<JSONObject> instanceSkin(new JSONObject());
                     
-                    shared_ptr<JSONArray> skeletons(new JSONArray());
+                    boost::shared_ptr<JSONArray> skeletons(new JSONArray());
                     URIList::iterator listIterator;
                     for(listIterator = instanceControllerData.skeletonRoots.begin(); listIterator != instanceControllerData.skeletonRoots.end(); ++listIterator) {
                         std::string skeleton = listIterator->getFragment();
-                        skeletons->appendValue(shared_ptr<JSONString>(new JSONString(skeleton)));
+                        skeletons->appendValue(boost::shared_ptr<JSONString>(new JSONString(skeleton)));
                     }
                     
                     instanceSkin->setValue("skeletons", skeletons);
@@ -384,7 +387,7 @@
             }
         }
         
-        shared_ptr <GLTF::JSONArray> childrenArray(new GLTF::JSONArray());
+        boost::shared_ptr <GLTF::JSONArray> childrenArray(new GLTF::JSONArray());
         nodeObject->setValue(kChildren, childrenArray);
         
         count = (unsigned int)nodes.getCount();
@@ -393,7 +396,7 @@
             if (childOriginalID.length() == 0) {
                 childOriginalID = uniqueIdWithType(kNode, nodes[i]->getUniqueId());
             }
-            childrenArray->appendValue(shared_ptr <GLTF::JSONString> (new GLTF::JSONString(childOriginalID)));
+            childrenArray->appendValue(boost::shared_ptr <GLTF::JSONString> (new GLTF::JSONString(childOriginalID)));
         }
         
         registerObjectWithOriginalUID(nodeOriginalID, nodeObject, nodesObject);
@@ -407,43 +410,43 @@
         for (unsigned int i = 0 ; i < count ; i++) {
             InstanceNode* instanceNode  = instanceNodes[i];
             std::string id = instanceNode->getInstanciatedObjectId().toAscii();
-            shared_ptr<JSONArray> parents;
+            boost::shared_ptr<JSONArray> parents;
             if (this->_asset->_uniqueIDToParentsOfInstanceNode.count(id) == 0) {
-                parents =  shared_ptr<JSONArray> (new JSONArray());
+                parents =  boost::shared_ptr<JSONArray> (new JSONArray());
                 this->_asset->_uniqueIDToParentsOfInstanceNode[id] = parents;
             } else {
                 parents = this->_asset->_uniqueIDToParentsOfInstanceNode[id];
             }
             
-            parents->appendValue(shared_ptr<JSONString> (new JSONString(node->getUniqueId().toAscii())));
+            parents->appendValue(boost::shared_ptr<JSONString> (new JSONString(node->getUniqueId().toAscii())));
         }
         
-        shared_ptr <GLTF::JSONArray> lightsInNode(new GLTF::JSONArray());
+        boost::shared_ptr <GLTF::JSONArray> lightsInNode(new GLTF::JSONArray());
 
         const InstanceLightPointerArray& instanceLights = node->getInstanceLights();
         count = (unsigned int)instanceLights.getCount();
         
         //For a given light, keep track of all the nodes holding it
         if (count) {
-            shared_ptr<JSONObject> lights = this->_asset->root()->createObjectIfNeeded(kLights);
+            boost::shared_ptr<JSONObject> lights = this->_asset->root()->createObjectIfNeeded(kLights);
             for (unsigned int i = 0 ; i < count ; i++) {
                 InstanceLight* instanceLight  = instanceLights[i];
                 std::string id = instanceLight->getInstanciatedObjectId().toAscii();
                 
-                shared_ptr<JSONObject> light = static_pointer_cast<JSONObject>(this->_asset->getValueForUniqueId(id));
+                boost::shared_ptr<JSONObject> light = boost::static_pointer_cast<JSONObject>(this->_asset->getValueForUniqueId(id));
                 if (light) {
                     std::string lightUID = this->_asset->getOriginalId(id);
                     
-                    shared_ptr<JSONArray> listOfNodesPerLight;
+                    boost::shared_ptr<JSONArray> listOfNodesPerLight;
                     if (this->_asset->_uniqueIDOfLightToNodes.count(id) == 0) {
-                        listOfNodesPerLight =  shared_ptr<JSONArray> (new JSONArray());
+                        listOfNodesPerLight =  boost::shared_ptr<JSONArray> (new JSONArray());
                         this->_asset->_uniqueIDOfLightToNodes[lightUID] = listOfNodesPerLight;
                     } else {
                         listOfNodesPerLight = this->_asset->_uniqueIDOfLightToNodes[lightUID];
                     }
                     
                     listOfNodesPerLight->appendValue(JSONSTRING(nodeOriginalID));
-                    lightsInNode->appendValue(shared_ptr <JSONString> (new JSONString(lightUID)));
+                    lightsInNode->appendValue(boost::shared_ptr <JSONString> (new JSONString(lightUID)));
                     lights->setValue(lightUID, light);
                 }
             }
@@ -484,9 +487,9 @@
          //First collect all kind of meshAttributes available
          size_t count = allMeshes.size();
          for (size_t i = 0 ; i < count ; i++) {
-         shared_ptr <MeshFlatteningInfo> meshInfo = allMeshes[i];
+         boost::shared_ptr <MeshFlatteningInfo> meshInfo = allMeshes[i];
          MeshVectorSharedPtr *meshes = this->_uniqueIDToMeshes[meshInfo->getUID()];
-         // shared_ptr <MeshAttributeVector> meshAttributes = mesh->meshAttributes();
+         // boost::shared_ptr <MeshAttributeVector> meshAttributes = mesh->meshAttributes();
          }
          */
         return true;
@@ -494,9 +497,9 @@
     
     bool COLLADA2GLTFWriter::writeVisualScene( const COLLADAFW::VisualScene* visualScene ) {
         //FIXME: only one visual scene assumed/handled
-        shared_ptr <GLTF::JSONObject> scenesObject(new GLTF::JSONObject());
-        shared_ptr <GLTF::JSONObject> sceneObject(new GLTF::JSONObject());
-        shared_ptr <GLTF::JSONObject> nodesObject = this->_asset->root()->createObjectIfNeeded(kNodes);
+        boost::shared_ptr <GLTF::JSONObject> scenesObject(new GLTF::JSONObject());
+        boost::shared_ptr <GLTF::JSONObject> sceneObject(new GLTF::JSONObject());
+        boost::shared_ptr <GLTF::JSONObject> nodesObject = this->_asset->root()->createObjectIfNeeded(kNodes);
         
 		const NodePointerArray& nodePointerArray = visualScene->getRootNodes();
         size_t nodeCount = nodePointerArray.getCount();
@@ -507,7 +510,7 @@
         scenesObject->setValue("defaultScene", sceneObject); //FIXME: should use this id -> visualScene->getOriginalId()
         
         //first pass to output children name of our root node
-        shared_ptr <GLTF::JSONArray> childrenArray(new GLTF::JSONArray());
+        boost::shared_ptr <GLTF::JSONArray> childrenArray(new GLTF::JSONArray());
         sceneObject->setValue(kNodes, childrenArray);
         
         for (size_t i = 0 ; i < nodeCount ; i++) {
@@ -516,8 +519,8 @@
                 nodeUID = uniqueIdWithType(kNode, nodePointerArray[i]->getUniqueId());
             }
                         
-            shared_ptr <GLTF::JSONString> nodeIDValue(new GLTF::JSONString(nodeUID));
-            childrenArray->appendValue(static_pointer_cast <GLTF::JSONValue> (nodeIDValue));
+            boost::shared_ptr <GLTF::JSONString> nodeIDValue(new GLTF::JSONString(nodeUID));
+            childrenArray->appendValue(boost::static_pointer_cast <GLTF::JSONValue> (nodeIDValue));
         }
                 
         for (size_t i = 0 ; i < nodeCount ; i++) {
@@ -537,7 +540,7 @@
 	bool COLLADA2GLTFWriter::writeLibraryNodes( const COLLADAFW::LibraryNodes* libraryNodes ) {
         const NodePointerArray& nodes = libraryNodes->getNodes();
         
-        shared_ptr <GLTF::JSONObject> nodesObject = this->_asset->root()->createObjectIfNeeded(kNodes);
+        boost::shared_ptr <GLTF::JSONObject> nodesObject = this->_asset->root()->createObjectIfNeeded(kNodes);
                 
         size_t count = nodes.getCount();
         for (size_t i = 0 ; i < count ; i++) {
@@ -545,15 +548,15 @@
             
             std::string id = node->getUniqueId().toAscii();
             if (this->_asset->_uniqueIDToParentsOfInstanceNode.count(id) > 0) {
-                shared_ptr<JSONArray> parents = this->_asset->_uniqueIDToParentsOfInstanceNode[id];
-                std::vector <shared_ptr <JSONValue> > values = parents->values();
+                boost::shared_ptr<JSONArray> parents = this->_asset->_uniqueIDToParentsOfInstanceNode[id];
+                std::vector <boost::shared_ptr <JSONValue> > values = parents->values();
                 for (size_t k = 0 ; k < values.size() ; k++) {
-                    shared_ptr<JSONString> value = static_pointer_cast<JSONString>(values[k]);
+                    boost::shared_ptr<JSONString> value = boost::static_pointer_cast<JSONString>(values[k]);
 
-                    shared_ptr<JSONObject> parentNode = static_pointer_cast<JSONObject>(this->_asset->getValueForUniqueId(value->getString()));
+                    boost::shared_ptr<JSONObject> parentNode = boost::static_pointer_cast<JSONObject>(this->_asset->getValueForUniqueId(value->getString()));
                     if (parentNode) {
-                        shared_ptr <JSONArray> children = parentNode->createArrayIfNeeded(kChildren);
-                        children->appendValue(shared_ptr <JSONString>(new JSONString(node->getOriginalId())));
+                        boost::shared_ptr <JSONArray> children = parentNode->createArrayIfNeeded(kChildren);
+                        children->appendValue(boost::shared_ptr <JSONString>(new JSONString(node->getOriginalId())));
                     }
                 }
             }
@@ -573,8 +576,8 @@
                 const COLLADAFW::Mesh* mesh = (COLLADAFW::Mesh*)geometry;
                 std::string meshUID = geometry->getUniqueId().toAscii();
                 if (this->_asset->containsValueForUniqueId(meshUID) == false) {
-                    shared_ptr<GLTFMesh> cvtMesh = convertOpenCOLLADAMesh((COLLADAFW::Mesh*)mesh, this->_asset.get());
-                    if (cvtMesh != nullptr) {
+                    boost::shared_ptr<GLTFMesh> cvtMesh = convertOpenCOLLADAMesh((COLLADAFW::Mesh*)mesh, this->_asset.get());
+                    if (cvtMesh != 0) {
                         this->_asset->root()->createObjectIfNeeded(kMeshes)->setValue(cvtMesh->getID(), cvtMesh);
                         this->_asset->setValueForUniqueId(meshUID, cvtMesh);
                     }
@@ -660,14 +663,14 @@
         
         std::string samplerUID = "sampler_"+GLTFUtils::toString(index);
         if (addSampler) {
-            shared_ptr <JSONObject> sampler2D(new JSONObject());
+            boost::shared_ptr <JSONObject> sampler2D(new JSONObject());
             
             sampler2D->setUnsignedInt32("wrapS", wrapS);
             sampler2D->setUnsignedInt32("wrapT", wrapT);
             sampler2D->setUnsignedInt32("minFilter", minFilter);
             sampler2D->setUnsignedInt32("magFilter", maxFilter);
 
-            shared_ptr <GLTF::JSONObject> samplers = this->_asset->root()->createObjectIfNeeded("samplers");
+            boost::shared_ptr <GLTF::JSONObject> samplers = this->_asset->root()->createObjectIfNeeded("samplers");
             samplers->setValue(samplerUID, sampler2D);
         }
         
@@ -678,18 +681,18 @@
     void COLLADA2GLTFWriter::_installTextureSlot(Sampler* sampler,
                                                 const std::string& slotName,
                                                 const std::string& texcoord,
-                                                shared_ptr <GLTFAsset> asset,
-                                                shared_ptr<GLTFEffect> cvtEffect)
+                                                boost::shared_ptr <GLTFAsset> asset,
+                                                boost::shared_ptr<GLTFEffect> cvtEffect)
     {
         assert(sampler);
         assert(asset);
         assert(cvtEffect);
-        shared_ptr <JSONObject> values = cvtEffect->getValues();
+        boost::shared_ptr <JSONObject> values = cvtEffect->getValues();
         std::string originalImageUID = asset->getOriginalId(sampler->getSourceImage().toAscii());
         GLTFProfile* profile = asset->profile().get();
 
         cvtEffect->addSemanticForTexcoordName(texcoord, slotName);
-        shared_ptr <JSONObject> slotObject(new JSONObject());
+        boost::shared_ptr <JSONObject> slotObject(new JSONObject());
         
         //do we need to export a new texture ? if yes compose a new unique ID
         slotObject->setUnsignedInt32("type", profile->getGLenumForString("SAMPLER_2D"));
@@ -701,9 +704,9 @@
                                                                   __GetFilterMode(sampler->getMagFilter(), profile));
         
         std::string textureUID = "texture_" + originalImageUID;
-        shared_ptr <GLTF::JSONObject> textures = asset->root()->createObjectIfNeeded("textures");
+        boost::shared_ptr <GLTF::JSONObject> textures = asset->root()->createObjectIfNeeded("textures");
         if (textures->contains(textureUID) == false) {
-            shared_ptr <JSONObject> textureObject(new JSONObject());
+            boost::shared_ptr <JSONObject> textureObject(new JSONObject());
             textureObject->setString(kSource, originalImageUID);
             textureObject->setString("sampler", samplerUID);
             textureObject->setUnsignedInt32("format", profile->getGLenumForString("RGBA"));
@@ -723,9 +726,9 @@
     
     void COLLADA2GLTFWriter::handleEffectSlot(const COLLADAFW::EffectCommon* commonProfile,
                                               std::string slotName,
-                                              shared_ptr <GLTFEffect> cvtEffect,
-                                              shared_ptr <JSONObject> extras) {
-        shared_ptr <JSONObject> values = cvtEffect->getValues();
+                                              boost::shared_ptr <GLTFEffect> cvtEffect,
+                                              boost::shared_ptr <JSONObject> extras) {
+        boost::shared_ptr <JSONObject> values = cvtEffect->getValues();
         GLTFAsset *asset = this->_asset.get();
         GLTFProfile* profile = asset->profile().get();
 
@@ -754,9 +757,9 @@
             //here we handle an extras slot
             //for other extras, this will need refactoring
             if (extras->contains("textures")) {
-                shared_ptr <JSONObject> textures = extras->getObject("textures");
+                boost::shared_ptr <JSONObject> textures = extras->getObject("textures");
                 if (textures->contains("bump")) {
-                    shared_ptr <JSONObject> bump = textures->getObject("bump");
+                    boost::shared_ptr <JSONObject> bump = textures->getObject("bump");
                     
                     std::string texture = bump->getString("texture");
                     std::string texcoord = bump->getString("texcoord");
@@ -782,7 +785,7 @@
                 blue = color.getBlue();
                 alpha = color.getAlpha();
             }
-            shared_ptr <JSONObject> slotObject(new JSONObject());
+            boost::shared_ptr <JSONObject> slotObject(new JSONObject());
             slotObject->setValue("value", serializeVec4(red, green, blue, alpha));
             slotObject->setUnsignedInt32("type", profile->getGLenumForString("FLOAT_VEC4"));
             values->setValue(slotName, slotObject);
@@ -812,8 +815,8 @@
 #endif
             uniqueId += GLTF::GLTFUtils::toString(effect->getUniqueId().getObjectId());;
             
-            shared_ptr <GLTFEffect> cvtEffect(new GLTFEffect(effect->getOriginalId()));
-            shared_ptr <JSONObject> values(new JSONObject());
+            boost::shared_ptr <GLTFEffect> cvtEffect(new GLTFEffect(effect->getOriginalId()));
+            boost::shared_ptr <JSONObject> values(new JSONObject());
             
             cvtEffect->setValues(values);
             
@@ -836,7 +839,7 @@
                     break;
             }
             
-            shared_ptr<JSONObject> extras = this->_extraDataHandler->getExtras(effect->getUniqueId());
+            boost::shared_ptr<JSONObject> extras = this->_extraDataHandler->getExtras(effect->getUniqueId());
             
             handleEffectSlot(effectCommon,"diffuse" , cvtEffect, extras);
             handleEffectSlot(effectCommon,"ambient" , cvtEffect, extras);
@@ -846,14 +849,14 @@
             handleEffectSlot(effectCommon,"bump" , cvtEffect, extras);
             
             if (CONFIG_BOOL(asset, "alwaysExportFilterColor")) {
-                shared_ptr <JSONObject> slotObject(new JSONObject());
+                boost::shared_ptr <JSONObject> slotObject(new JSONObject());
                 slotObject->setValue("value", serializeVec4(1, 1, 1, 1));
                 slotObject->setUnsignedInt32("type", profile->getGLenumForString("FLOAT_VEC4"));
                 values->setValue("filterColor", slotObject);
             }
             
             if (!isOpaque(effectCommon) || CONFIG_BOOL(asset, "alwaysExportTransparency")) {
-                shared_ptr <JSONObject> transparency(new JSONObject());
+                boost::shared_ptr <JSONObject> transparency(new JSONObject());
                 transparency->setDouble("value", this->getTransparency(effectCommon));
                 transparency->setUnsignedInt32("type", profile->getGLenumForString("FLOAT"));
                 values->setValue("transparency", transparency);
@@ -865,13 +868,13 @@
                 if (shininess < 1) {
                     shininess *= 128.0;
                 }
-                shared_ptr <JSONObject> shininessObject(new JSONObject());
+                boost::shared_ptr <JSONObject> shininessObject(new JSONObject());
                 shininessObject->setUnsignedInt32("type", profile->getGLenumForString("FLOAT"));
                 shininessObject->setDouble("value", shininess);
                 values->setValue("shininess", shininessObject);
             }
             
-            shared_ptr<JSONObject> materials = this->_asset->root()->createObjectIfNeeded(kMaterials);
+            boost::shared_ptr<JSONObject> materials = this->_asset->root()->createObjectIfNeeded(kMaterials);
             materials->setValue(cvtEffect->getID(), cvtEffect);
             this->_asset->setValueForUniqueId(effect->getUniqueId().toAscii(), cvtEffect);
             
@@ -881,14 +884,14 @@
     
 	//--------------------------------------------------------------------
 	bool COLLADA2GLTFWriter::writeCamera( const COLLADAFW::Camera* camera ) {
-        shared_ptr <GLTF::JSONObject> camerasObject = static_pointer_cast <GLTF::JSONObject> (this->_asset->root()->getValue("cameras"));
+        boost::shared_ptr <GLTF::JSONObject> camerasObject = boost::static_pointer_cast <GLTF::JSONObject> (this->_asset->root()->getValue("cameras"));
         if (!camerasObject) {
-            camerasObject = shared_ptr <GLTF::JSONObject> (new GLTF::JSONObject());
+            camerasObject = boost::shared_ptr <GLTF::JSONObject> (new GLTF::JSONObject());
             this->_asset->root()->setValue("cameras", camerasObject);
         }
         
-        shared_ptr <GLTF::JSONObject> cameraObject(new GLTF::JSONObject());
-        shared_ptr <GLTF::JSONObject> projectionObject(new GLTF::JSONObject());
+        boost::shared_ptr <GLTF::JSONObject> cameraObject(new GLTF::JSONObject());
+        boost::shared_ptr <GLTF::JSONObject> projectionObject(new GLTF::JSONObject());
 
         std::string id = uniqueIdWithType(kCamera, camera->getUniqueId());
         
@@ -968,8 +971,8 @@
     
 	//--------------------------------------------------------------------
 	bool COLLADA2GLTFWriter::writeImage( const COLLADAFW::Image* openCOLLADAImage ) {
-        shared_ptr <GLTF::JSONObject> images = this->_asset->root()->createObjectIfNeeded(kImages);
-        shared_ptr <GLTF::JSONObject> image(new GLTF::JSONObject());
+        boost::shared_ptr <GLTF::JSONObject> images = this->_asset->root()->createObjectIfNeeded(kImages);
+        boost::shared_ptr <GLTF::JSONObject> image(new GLTF::JSONObject());
         
         std::string imageUID = openCOLLADAImage->getUniqueId().toAscii();
         this->_asset->setValueForUniqueId(imageUID, image);
@@ -992,8 +995,8 @@
 	//--------------------------------------------------------------------
 	bool COLLADA2GLTFWriter::writeLight( const COLLADAFW::Light* light ) {
         //FIXME: add projection
-        shared_ptr <JSONObject> glTFLight(new JSONObject());
-        shared_ptr <JSONObject> description(new JSONObject());
+        boost::shared_ptr <JSONObject> glTFLight(new JSONObject());
+        boost::shared_ptr <JSONObject> description(new JSONObject());
 
         COLLADAFW::Light::LightType lightType = light->getLightType();
 		Color color = light->getColor();
@@ -1002,7 +1005,7 @@
         float linearAttenuation = (float)light->getLinearAttenuation().getValue();
         float quadraticAttenuation = (float)light->getQuadraticAttenuation().getValue();
 
-        shared_ptr <JSONValue> lightColor = serializeVec3(color.getRed(), color.getGreen(), color.getBlue());
+        boost::shared_ptr <JSONValue> lightColor = serializeVec3(color.getRed(), color.getGreen(), color.getBlue());
         
         switch (lightType) {
             case COLLADAFW::Light::AMBIENT_LIGHT:
@@ -1014,9 +1017,9 @@
             case COLLADAFW::Light::POINT_LIGHT: {
                 glTFLight->setString("type", "point");
 
-                description->setValue("constantAttenuation", shared_ptr <JSONNumber> (new JSONNumber(constantAttenuation)));
-                description->setValue("linearAttenuation", shared_ptr <JSONNumber> (new JSONNumber(linearAttenuation)));
-                description->setValue("quadraticAttenuation", shared_ptr <JSONNumber> (new JSONNumber(quadraticAttenuation)));
+                description->setValue("constantAttenuation", boost::shared_ptr <JSONNumber> (new JSONNumber(constantAttenuation)));
+                description->setValue("linearAttenuation", boost::shared_ptr <JSONNumber> (new JSONNumber(linearAttenuation)));
+                description->setValue("quadraticAttenuation", boost::shared_ptr <JSONNumber> (new JSONNumber(quadraticAttenuation)));
             }
                 break;
             case COLLADAFW::Light::SPOT_LIGHT: {
@@ -1025,12 +1028,12 @@
                 float fallOffAngle =  (float)light->getFallOffAngle().getValue();
                 float fallOffExponent = (float)light->getFallOffExponent().getValue();
                 
-                description->setValue("constantAttenuation", shared_ptr <JSONNumber> (new JSONNumber(constantAttenuation)));
-                description->setValue("linearAttenuation", shared_ptr <JSONNumber> (new JSONNumber(linearAttenuation)));
-                description->setValue("quadraticAttenuation", shared_ptr <JSONNumber> (new JSONNumber(quadraticAttenuation)));
+                description->setValue("constantAttenuation", boost::shared_ptr <JSONNumber> (new JSONNumber(constantAttenuation)));
+                description->setValue("linearAttenuation", boost::shared_ptr <JSONNumber> (new JSONNumber(linearAttenuation)));
+                description->setValue("quadraticAttenuation", boost::shared_ptr <JSONNumber> (new JSONNumber(quadraticAttenuation)));
                 
-                description->setValue("fallOffAngle", shared_ptr <JSONNumber> (new JSONNumber(fallOffAngle)));
-                description->setValue("fallOffExponent", shared_ptr <JSONNumber> (new JSONNumber(fallOffExponent)));
+                description->setValue("fallOffAngle", boost::shared_ptr <JSONNumber> (new JSONNumber(fallOffAngle)));
+                description->setValue("fallOffExponent", boost::shared_ptr <JSONNumber> (new JSONNumber(fallOffExponent)));
             }
                 break;
             default:
@@ -1044,23 +1047,23 @@
         this->_asset->setValueForUniqueId(lightId, glTFLight);
         this->_asset->setOriginalId(lightId, light->getOriginalId());
         
-        shared_ptr<JSONArray> lightsIds = this->_asset->root()->createArrayIfNeeded("lightsIds");
-        lightsIds->appendValue(shared_ptr<JSONString>(new JSONString(light->getOriginalId())));
+        boost::shared_ptr<JSONArray> lightsIds = this->_asset->root()->createArrayIfNeeded("lightsIds");
+        lightsIds->appendValue(boost::shared_ptr<JSONString>(new JSONString(light->getOriginalId())));
         
 		return true;
 	}
     
 	//--------------------------------------------------------------------
 	bool COLLADA2GLTFWriter::writeAnimation( const COLLADAFW::Animation* animation) {
-        shared_ptr <GLTFAnimation> cvtAnimation = convertOpenCOLLADAAnimationToGLTFAnimation(animation, this->_asset.get());
+        boost::shared_ptr <GLTFAnimation> cvtAnimation = convertOpenCOLLADAAnimationToGLTFAnimation(animation, this->_asset.get());
         
         cvtAnimation->setOriginalID(animation->getOriginalId());
         
         if (this->_asset->_flattenerMapsForAnimationID.count(animation->getOriginalId()) == 0) {
-            this->_asset->_flattenerMapsForAnimationID[animation->getOriginalId()] = shared_ptr <AnimationFlattenerForTargetUID> (new AnimationFlattenerForTargetUID());
+            this->_asset->_flattenerMapsForAnimationID[animation->getOriginalId()] = boost::shared_ptr <AnimationFlattenerForTargetUID> (new AnimationFlattenerForTargetUID());
         }
         
-        shared_ptr<JSONObject> animations = this->_asset->root()->createObjectIfNeeded("animations");
+        boost::shared_ptr<JSONObject> animations = this->_asset->root()->createObjectIfNeeded("animations");
         animations->setValue(animation->getUniqueId().toAscii(), cvtAnimation);
         
 		return true;
@@ -1070,23 +1073,23 @@
 	bool COLLADA2GLTFWriter::writeAnimationList( const COLLADAFW::AnimationList* animationList ) {
         const COLLADAFW::AnimationList::AnimationBindings &animationBindings = animationList->getAnimationBindings();
         
-        shared_ptr<JSONObject> animations = this->_asset->root()->createObjectIfNeeded("animations");
+        boost::shared_ptr<JSONObject> animations = this->_asset->root()->createObjectIfNeeded("animations");
         AnimatedTargetsSharedPtr animatedTargets = this->_asset->_uniqueIDToAnimatedTargets[animationList->getUniqueId().toAscii()];
         
         for (size_t i = 0 ; i < animationBindings.getCount() ; i++) {
             const COLLADAFW::AnimationList::AnimationClass animationClass = animationBindings[i].animationClass;
 
-            shared_ptr <GLTFAnimation> cvtAnimation = static_pointer_cast<GLTFAnimation>(animations->getObject(animationBindings[i].animation.toAscii()));
+            boost::shared_ptr <GLTFAnimation> cvtAnimation = boost::static_pointer_cast<GLTFAnimation>(animations->getObject(animationBindings[i].animation.toAscii()));
 
             AnimationFlattenerForTargetUIDSharedPtr animationFlattenerMap = this->_asset->_flattenerMapsForAnimationID[cvtAnimation->getOriginalID()];
             for (size_t j = 0 ; j < animatedTargets->size() ; j++) {
-                shared_ptr<JSONObject> animatedTarget = (*animatedTargets)[j];
-                shared_ptr<GLTFAnimationFlattener> animationFlattener;
+                boost::shared_ptr<JSONObject> animatedTarget = (*animatedTargets)[j];
+                boost::shared_ptr<GLTFAnimationFlattener> animationFlattener;
                 std::string targetUID = animatedTarget->getString(kTarget);
                 if (animationFlattenerMap->count(targetUID) == 0) {
                     //FIXME: assuming node here is wrong
                     COLLADAFW::Node *node = (COLLADAFW::Node*)this->_asset->_uniqueIDToOpenCOLLADAObject[targetUID].get();
-                    animationFlattener = shared_ptr<GLTFAnimationFlattener> (new GLTFAnimationFlattener(node));
+                    animationFlattener = boost::shared_ptr<GLTFAnimationFlattener> (new GLTFAnimationFlattener(node));
                     (*animationFlattenerMap)[targetUID] = animationFlattener;
                 }
             }
@@ -1104,8 +1107,8 @@
     
 	//--------------------------------------------------------------------
 	bool COLLADA2GLTFWriter::writeSkinControllerData( const COLLADAFW::SkinControllerData* skinControllerData ) {
-        shared_ptr <GLTFSkin> glTFSkin(new GLTFSkin(skinControllerData->getOriginalId()));
-        shared_ptr <GLTFProfile> profile = this->_asset->profile();
+        boost::shared_ptr <GLTFSkin> glTFSkin(new GLTFSkin(skinControllerData->getOriginalId()));
+        boost::shared_ptr <GLTFProfile> profile = this->_asset->profile();
         
         glTFSkin->extras()->setString("uniqueId", skinControllerData->getUniqueId().toAscii());
         glTFSkin->setBindShapeMatrix(serializeOpenCOLLADAMatrix4(skinControllerData->getBindShapeMatrix()));
@@ -1169,23 +1172,23 @@
         for (size_t i = 0 ; i < skinControllerData->getJointsCount() ; i++) {
             fillFloatPtrFromOpenCOLLADAMatrix4(matrices[i], matricesPtr + (i*16));
         }
-        shared_ptr <GLTFBufferView> inverseBindMatricesView = createBufferViewWithAllocatedBuffer(matricesPtr, 0, matricesSize, true);
+        boost::shared_ptr <GLTFBufferView> inverseBindMatricesView = createBufferViewWithAllocatedBuffer(matricesPtr, 0, matricesSize, true);
         glTFSkin->setInverseBindMatrices(inverseBindMatricesView);
         
-        shared_ptr<JSONObject> inverseBindMatrices(new JSONObject());
+        boost::shared_ptr<JSONObject> inverseBindMatrices(new JSONObject());
         inverseBindMatrices->setUnsignedInt32(kType, profile->getGLenumForString("FLOAT_MAT4"));
 		inverseBindMatrices->setUnsignedInt32(kCount, (unsigned int)skinControllerData->getJointsCount());
         inverseBindMatrices->setUnsignedInt32(kByteOffset, 0);
         glTFSkin->extras()->setValue(kInverseBindMatrices, inverseBindMatrices);
         
-        shared_ptr<GLTFOutputStream> animationOutputStream = this->_asset->createOutputStreamIfNeeded(this->_asset->getSharedBufferId());
+        boost::shared_ptr<GLTFOutputStream> animationOutputStream = this->_asset->createOutputStreamIfNeeded(this->_asset->getSharedBufferId());
 		inverseBindMatrices->setUnsignedInt32(kByteOffset, (unsigned int)animationOutputStream->length());
-        shared_ptr<GLTFBuffer> buffer = glTFSkin->getInverseBindMatrices()->getBuffer();
+        boost::shared_ptr<GLTFBuffer> buffer = glTFSkin->getInverseBindMatrices()->getBuffer();
         animationOutputStream->write(buffer);
 
         //
-        shared_ptr <GLTFBufferView> weightsView = createBufferViewWithAllocatedBuffer(weightsPtr, 0, skinAttributeSize, true);
-        shared_ptr <GLTFAccessor> weightsAttribute(new GLTFAccessor(profile, profile->getGLTypeForComponentType(GLTF::FLOAT, bucketSize)));
+        boost::shared_ptr <GLTFBufferView> weightsView = createBufferViewWithAllocatedBuffer(weightsPtr, 0, skinAttributeSize, true);
+        boost::shared_ptr <GLTFAccessor> weightsAttribute(new GLTFAccessor(profile, profile->getGLTypeForComponentType(GLTF::FLOAT, bucketSize)));
         
         weightsAttribute->setBufferView(weightsView);
         weightsAttribute->setByteStride(componentSize * bucketSize);
@@ -1193,8 +1196,8 @@
 
         glTFSkin->setWeights(weightsAttribute);
         
-        shared_ptr <GLTFBufferView> jointsView = createBufferViewWithAllocatedBuffer(bonesIndices, 0, skinAttributeSize, true);
-        shared_ptr <GLTFAccessor> jointsAttribute(new GLTFAccessor(profile, profile->getGLTypeForComponentType(GLTF::FLOAT, bucketSize)));
+        boost::shared_ptr <GLTFBufferView> jointsView = createBufferViewWithAllocatedBuffer(bonesIndices, 0, skinAttributeSize, true);
+        boost::shared_ptr <GLTFAccessor> jointsAttribute(new GLTFAccessor(profile, profile->getGLTypeForComponentType(GLTF::FLOAT, bucketSize)));
         
         jointsAttribute->setBufferView(jointsView);
         jointsAttribute->setByteStride(componentSize * bucketSize);
@@ -1203,7 +1206,7 @@
         glTFSkin->setJoints(jointsAttribute);
         glTFSkin->setJointsCount(skinControllerData->getJointsCount());
         
-        shared_ptr<JSONObject> skins = this->_asset->root()->createObjectIfNeeded(kSkins);
+        boost::shared_ptr<JSONObject> skins = this->_asset->root()->createObjectIfNeeded(kSkins);
          
         //Also we work around here what looks to be a bug in OpenCOLLADA with a fileId == 0
         COLLADAFW::UniqueId uniqueId = skinControllerData->getUniqueId();
@@ -1216,12 +1219,12 @@
     
 	//--------------------------------------------------------------------
     
-    static shared_ptr<GLTFAccessor> __CreateAttributeByApplyingRemapTable(shared_ptr<GLTFAccessor> meshAttribute, size_t vertexCount, unsigned int* remapTableForPositions, shared_ptr<GLTFProfile> profile) {
+    static boost::shared_ptr<GLTFAccessor> __CreateAttributeByApplyingRemapTable(boost::shared_ptr<GLTFAccessor> meshAttribute, size_t vertexCount, unsigned int* remapTableForPositions, boost::shared_ptr<GLTFProfile> profile) {
         unsigned char* sourcePtr = (unsigned char*)meshAttribute->getBufferView()->getBufferDataByApplyingOffset();
         size_t bufferSize = meshAttribute->elementByteLength() * vertexCount;
         unsigned char* destinationPtr = (unsigned char*)malloc(bufferSize);
 
-        shared_ptr <GLTFAccessor> targetAttribute(new GLTFAccessor(profile, profile->getGLTypeForComponentType(meshAttribute->componentType(), meshAttribute->componentsPerElement())));
+        boost::shared_ptr <GLTFAccessor> targetAttribute(new GLTFAccessor(profile, profile->getGLTypeForComponentType(meshAttribute->componentType(), meshAttribute->componentsPerElement())));
         targetAttribute->setByteStride(meshAttribute->getByteStride());
         targetAttribute->setCount(vertexCount);
 
@@ -1233,7 +1236,7 @@
             memcpy(ptrDst, ptrSrc , meshAttribute->elementByteLength());
         }
         
-        shared_ptr<GLTFBufferView> targetView = createBufferViewWithAllocatedBuffer(destinationPtr, 0, bufferSize, true);
+        boost::shared_ptr<GLTFBufferView> targetView = createBufferViewWithAllocatedBuffer(destinationPtr, 0, bufferSize, true);
         targetAttribute->setBufferView(targetView);
         
         return targetAttribute;
@@ -1244,40 +1247,40 @@
             COLLADAFW::SkinController* skinController = (COLLADAFW::SkinController*)controller;
             
             //Now we get the skin and the mesh, and
-            shared_ptr<JSONObject> skins = this->_asset->root()->createObjectIfNeeded(kSkins);
+            boost::shared_ptr<JSONObject> skins = this->_asset->root()->createObjectIfNeeded(kSkins);
             
             COLLADAFW::UniqueId uniqueId = skinController->getSkinControllerData().toAscii();
 
-            shared_ptr <GLTFSkin> glTFSkin = static_pointer_cast<GLTFSkin>(skins->getValue(uniqueId.toAscii()));
-            shared_ptr<GLTFMesh> mesh = static_pointer_cast<GLTFMesh>(this->_asset->getValueForUniqueId(skinController->getSource().toAscii()));
+            boost::shared_ptr <GLTFSkin> glTFSkin = boost::static_pointer_cast<GLTFSkin>(skins->getValue(uniqueId.toAscii()));
+            boost::shared_ptr<GLTFMesh> mesh = boost::static_pointer_cast<GLTFMesh>(this->_asset->getValueForUniqueId(skinController->getSource().toAscii()));
             this->_asset->setValueForUniqueId(controller->getUniqueId().toAscii(),
-                                              shared_ptr<JSONString> (new JSONString(uniqueId.toAscii())));
+                                              boost::shared_ptr<JSONString> (new JSONString(uniqueId.toAscii())));
             glTFSkin->setSourceUID(skinController->getSource().toAscii());
             
             unsigned int *remapTableForPositions = mesh->getRemapTableForPositions();
             size_t vertexCount = mesh->getMeshAttribute(GLTF::POSITION, 0)->getCount();
             //Now we remap the bone indices and weight attribute in respect of deindexing we have
             
-            shared_ptr<GLTFAccessor> weightsAttribute = __CreateAttributeByApplyingRemapTable(glTFSkin->getWeights(), vertexCount, remapTableForPositions, this->_asset->profile());
+            boost::shared_ptr<GLTFAccessor> weightsAttribute = __CreateAttributeByApplyingRemapTable(glTFSkin->getWeights(), vertexCount, remapTableForPositions, this->_asset->profile());
             
             mesh->setMeshAttribute(GLTF::WEIGHT, 0, weightsAttribute);
             
-            shared_ptr<GLTFAccessor> jointsAttribute = __CreateAttributeByApplyingRemapTable(glTFSkin->getJoints(), vertexCount, remapTableForPositions, this->_asset->profile());
+            boost::shared_ptr<GLTFAccessor> jointsAttribute = __CreateAttributeByApplyingRemapTable(glTFSkin->getJoints(), vertexCount, remapTableForPositions, this->_asset->profile());
             
             mesh->setMeshAttribute(GLTF::JOINT, 0, jointsAttribute);
             
             GLTF::JSONValueVector primitives = mesh->getPrimitives()->values();
             for (size_t i = 0 ; i < primitives.size() ; i++) {
-                shared_ptr<GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
-                primitive->appendVertexAttribute(shared_ptr <GLTF::JSONVertexAttribute>( new GLTF::JSONVertexAttribute(GLTF::JOINT,0)));
-                primitive->appendVertexAttribute(shared_ptr <GLTF::JSONVertexAttribute>( new GLTF::JSONVertexAttribute(GLTF::WEIGHT,0)));
+                boost::shared_ptr<GLTFPrimitive> primitive = boost::static_pointer_cast<GLTFPrimitive>(primitives[i]);
+                primitive->appendVertexAttribute(boost::shared_ptr <GLTF::JSONVertexAttribute>( new GLTF::JSONVertexAttribute(GLTF::JOINT,0)));
+                primitive->appendVertexAttribute(boost::shared_ptr <GLTF::JSONVertexAttribute>( new GLTF::JSONVertexAttribute(GLTF::WEIGHT,0)));
             }
             
             //save the list of joints, first as uniqueIds, and then we will replace with sid's
-            shared_ptr <JSONArray> joints(new JSONArray());
+            boost::shared_ptr <JSONArray> joints(new JSONArray());
             UniqueIdArray& jointsUID = skinController->getJoints();
             for (size_t i = 0 ; i < jointsUID.getCount() ; i++) {
-                shared_ptr<JSONString> jointId(new JSONString(jointsUID[i].toAscii()));
+                boost::shared_ptr<JSONString> jointId(new JSONString(jointsUID[i].toAscii()));
                 joints->appendValue(jointId);
             }
             glTFSkin->setJointsIds(joints);
diff -ur collada2gltf.org/COLLADA2GLTFWriter.h collada2gltf/COLLADA2GLTFWriter.h
--- collada2gltf.org/COLLADA2GLTFWriter.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/COLLADA2GLTFWriter.h	2014-09-29 15:31:48.000000000 +0200
@@ -36,6 +36,8 @@
 #include "convert/animationConverter.h"
 #include "convert/meshConverter.h"
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF
 {
     class GLTFObject;
@@ -59,7 +61,7 @@
     };
     
     
-    typedef std::vector < std::shared_ptr <MeshFlatteningInfo> > MeshFlatteningInfoVector;
+    typedef std::vector < boost::shared_ptr <MeshFlatteningInfo> > MeshFlatteningInfoVector;
     
     typedef struct 
     {
@@ -72,17 +74,17 @@
 	class COLLADA2GLTFWriter : public COLLADAFW::IWriter
 	{
 	public:        
-		COLLADA2GLTFWriter(std::shared_ptr<GLTF::GLTFAsset> asset);
+		COLLADA2GLTFWriter(boost::shared_ptr<GLTF::GLTFAsset> asset);
 		virtual ~COLLADA2GLTFWriter();
     private:
 		static void reportError(const std::string& method, const std::string& message);
-        bool writeNode(const COLLADAFW::Node* node, std::shared_ptr <GLTF::JSONObject> nodesObject, COLLADABU::Math::Matrix4, SceneFlatteningInfo*);
+        bool writeNode(const COLLADAFW::Node* node, boost::shared_ptr <GLTF::JSONObject> nodesObject, COLLADABU::Math::Matrix4, SceneFlatteningInfo*);
         bool processSceneFlatteningInfo(SceneFlatteningInfo* sceneFlatteningInfo);
         float getTransparency(const COLLADAFW::EffectCommon* effectCommon);
         float isOpaque(const COLLADAFW::EffectCommon* effectCommon);
         bool writeMeshFromUIDWithMaterialBindings(COLLADAFW::UniqueId uniqueId,
                                                   COLLADAFW::MaterialBindingArray &materialBindings,
-                                                  std::shared_ptr <GLTF::JSONArray> &meshesArray);
+                                                  boost::shared_ptr <GLTF::JSONArray> &meshesArray);
         
 	public:        
         
@@ -168,25 +170,25 @@
         void _installTextureSlot(COLLADAFW::Sampler* sampler,
                                  const std::string& slotName,
                                  const std::string& texcoord,
-                                 std::shared_ptr <GLTF::GLTFAsset> asset,
-                                 std::shared_ptr<GLTF::GLTFEffect> cvtEffect);
+                                 boost::shared_ptr <GLTF::GLTFAsset> asset,
+                                 boost::shared_ptr<GLTF::GLTFEffect> cvtEffect);
         
         void _storeMaterialBindingArray(const std::string& prefix,
                                         const std::string& nodeUID,
                                         const std::string& meshUID,
                                         COLLADAFW::MaterialBindingArray &materialBindings);
-        void registerObjectWithOriginalUID(std::string nodeUID, std::shared_ptr <JSONObject> nodeObject, std::shared_ptr <JSONObject> nodesObject);
+        void registerObjectWithOriginalUID(std::string nodeUID, boost::shared_ptr <JSONObject> nodeObject, boost::shared_ptr <JSONObject> nodesObject);
         bool writeData(std::string filename, unsigned char* data, size_t length);
         void handleEffectSlot(const COLLADAFW::EffectCommon* commonProfile,
                               std::string slotName,
-                              std::shared_ptr <GLTFEffect> cvtEffect,
-                              std::shared_ptr<JSONObject> extras);
+                              boost::shared_ptr <GLTFEffect> cvtEffect,
+                              boost::shared_ptr<JSONObject> extras);
         
         std::string getSamplerUIDForParameters(unsigned int wrapS, unsigned int wrapT, unsigned int minFilter, unsigned int maxFilter);
         
 	private:
         COLLADASaxFWL::Loader _loader;
-        std::shared_ptr<GLTF::GLTFAsset> _asset;
+        boost::shared_ptr<GLTF::GLTFAsset> _asset;
         const COLLADAFW::VisualScene *_visualScene;
         SceneFlatteningInfo _sceneFlatteningInfo;
         GLTF::ExtraDataHandler *_extraDataHandler;
diff -ur collada2gltf.org/convert/animationConverter.cpp collada2gltf/convert/animationConverter.cpp
--- collada2gltf.org/convert/animationConverter.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/convert/animationConverter.cpp	2014-09-29 15:33:17.000000000 +0200
@@ -29,19 +29,19 @@
      The animation creation/write is in 2 steps.
      We first create the animation, but then, we need to set the channels for every targets, and targets ids are not available when animations are created
      */
-    bool writeAnimation(shared_ptr <GLTFAnimation> cvtAnimation,
+    bool writeAnimation(boost::shared_ptr <GLTFAnimation> cvtAnimation,
                         const COLLADAFW::AnimationList::AnimationClass animationClass,
                         AnimatedTargetsSharedPtr animatedTargets,
                         GLTF::GLTFAsset *asset) {
         
         std::string inputParameterName = "TIME";
-        shared_ptr<JSONObject> samplers = cvtAnimation->samplers();
-        shared_ptr<JSONArray> channels = cvtAnimation->channels();
-        shared_ptr<GLTFBufferView> timeBufferView = cvtAnimation->getBufferViewForParameter(inputParameterName);
+        boost::shared_ptr<JSONObject> samplers = cvtAnimation->samplers();
+        boost::shared_ptr<JSONArray> channels = cvtAnimation->channels();
+        boost::shared_ptr<GLTFBufferView> timeBufferView = cvtAnimation->getBufferViewForParameter(inputParameterName);
         
-        shared_ptr<GLTFAnimationFlattener> animationFlattener;
+        boost::shared_ptr<GLTFAnimationFlattener> animationFlattener;
 
-        shared_ptr<GLTFBufferView> bufferView =  cvtAnimation->getBufferViewForParameter("OUTPUT");
+        boost::shared_ptr<GLTFBufferView> bufferView =  cvtAnimation->getBufferViewForParameter("OUTPUT");
         cvtAnimation->unregisterBufferView("OUTPUT");
         
         switch (animationClass) {
@@ -54,7 +54,7 @@
                     //the angles to radians necessary convertion is done within the animationFlattener
                     //but it might be better to make it before...
                     for (size_t animatedTargetIndex = 0 ; animatedTargetIndex < animatedTargets->size() ; animatedTargetIndex++) {
-                        shared_ptr<JSONObject> animatedTarget = (*animatedTargets)[animatedTargetIndex];
+                        boost::shared_ptr<JSONObject> animatedTarget = (*animatedTargets)[animatedTargetIndex];
                         std::string targetID = animatedTarget->getString(kTarget);
                         if (asset->_uniqueIDToOpenCOLLADAObject.count(targetID) != 0) {
                             cvtAnimation->targets()->setValue(targetID, animatedTarget);
@@ -69,7 +69,7 @@
                                 for (size_t k = 0 ; k < cvtAnimation->getCount() ; k++) {
                                     size_t offset = k * 4;
                                     
-                                    shared_ptr <COLLADAFW::Rotate> rotate(new COLLADAFW::Rotate(rotations[offset + 0],
+                                    boost::shared_ptr <COLLADAFW::Rotate> rotate(new COLLADAFW::Rotate(rotations[offset + 0],
                                                                                                 rotations[offset + 1],
                                                                                                 rotations[offset + 2],
                                                                                                 rotations[offset + 3]));
@@ -81,13 +81,13 @@
                 }
                 return true;
             case COLLADAFW::AnimationList::MATRIX4X4: {
-                    std::vector< shared_ptr <GLTFBufferView> > TRSBufferViews;
+                    std::vector< boost::shared_ptr <GLTFBufferView> > TRSBufferViews;
                     //FIXME: we assume float here, might be double
                     float* matrices = (float*)bufferView->getBufferDataByApplyingOffset();
                     float* timeValues = (float*)timeBufferView->getBufferDataByApplyingOffset();
                     
                     for (size_t animatedTargetIndex = 0 ; animatedTargetIndex < animatedTargets->size() ; animatedTargetIndex++) {
-                        shared_ptr<JSONObject> animatedTarget = (*animatedTargets)[animatedTargetIndex];
+                        boost::shared_ptr<JSONObject> animatedTarget = (*animatedTargets)[animatedTargetIndex];
                         if (animatedTarget->getString("path") == "MATRIX") {
                             std::string targetID = animatedTarget->getString(kTarget);
                             if (asset->_uniqueIDToOpenCOLLADAObject.count(targetID) != 0) {
@@ -105,7 +105,7 @@
                                                        m[8], m[9], m[10], m[11],
                                                        m[12], m[13], m[14], m[15] );
                                     
-                                    shared_ptr <COLLADAFW::Matrix> matTr(new COLLADAFW::Matrix(mat));
+                                    boost::shared_ptr <COLLADAFW::Matrix> matTr(new COLLADAFW::Matrix(mat));
                                     animationFlattener->insertTransformAtTime(transformID, matTr, timeValues[k]);
                                 }
                             }
@@ -117,7 +117,7 @@
                     //the angles to radians necessary convertion is done within the animationFlattener
                     //but it might be better to make it before...
                     for (size_t animatedTargetIndex = 0 ; animatedTargetIndex < animatedTargets->size() ; animatedTargetIndex++) {
-                        shared_ptr<JSONObject> animatedTarget = (*animatedTargets)[animatedTargetIndex];
+                        boost::shared_ptr<JSONObject> animatedTarget = (*animatedTargets)[animatedTargetIndex];
                         std::string targetID = animatedTarget->getString(kTarget);
                         if (asset->_uniqueIDToOpenCOLLADAObject.count(targetID) != 0) {
                             cvtAnimation->targets()->setValue(targetID, animatedTarget);
@@ -131,7 +131,7 @@
                                 float* translations = (float*)bufferView->getBufferDataByApplyingOffset();
                                 for (size_t k = 0 ; k < cvtAnimation->getCount() ; k++) {
                                     size_t offset = k * 3;
-                                    shared_ptr <COLLADAFW::Translate> translate(new COLLADAFW::Translate(translations[offset + 0],
+                                    boost::shared_ptr <COLLADAFW::Translate> translate(new COLLADAFW::Translate(translations[offset + 0],
                                                                                                          translations[offset + 1],
                                                                                                          translations[offset + 2]));
                                     animationFlattener->insertTransformAtTime(transformID, translate, timeValues[k]);
@@ -143,7 +143,7 @@
                                 float* scales = (float*)bufferView->getBufferDataByApplyingOffset();
                                 for (size_t k = 0 ; k < cvtAnimation->getCount() ; k++) {
                                     size_t offset = k * 3;
-                                    shared_ptr <COLLADAFW::Scale> scale(new COLLADAFW::Scale(scales[offset + 0],
+                                    boost::shared_ptr <COLLADAFW::Scale> scale(new COLLADAFW::Scale(scales[offset + 0],
                                                                                              scales[offset + 1],
                                                                                              scales[offset + 2]));
                                     animationFlattener->insertTransformAtTime(transformID, scale, timeValues[k]);
@@ -158,7 +158,7 @@
                     //the angles to radians necessary convertion is done within the animationFlattener
                     //but it might be better to make it before...
                     for (size_t animatedTargetIndex = 0 ; animatedTargetIndex < animatedTargets->size() ; animatedTargetIndex++) {
-                        shared_ptr<JSONObject> animatedTarget = (*animatedTargets)[animatedTargetIndex];
+                        boost::shared_ptr<JSONObject> animatedTarget = (*animatedTargets)[animatedTargetIndex];
                         std::string targetID = animatedTarget->getString(kTarget);
                         if (asset->_uniqueIDToOpenCOLLADAObject.count(targetID) != 0) {
                             cvtAnimation->targets()->setValue(targetID, animatedTarget);
@@ -184,7 +184,7 @@
             {
                 int index = animationClass - COLLADAFW::AnimationList::POSITION_X;
                 for (size_t animatedTargetIndex = 0 ; animatedTargetIndex < animatedTargets->size() ; animatedTargetIndex++) {
-                    shared_ptr<JSONObject> animatedTarget = (*animatedTargets)[animatedTargetIndex];
+                    boost::shared_ptr<JSONObject> animatedTarget = (*animatedTargets)[animatedTargetIndex];
                     std::string targetID = animatedTarget->getString(kTarget);
                     if (asset->_uniqueIDToOpenCOLLADAObject.count(targetID) != 0) {
                         cvtAnimation->targets()->setValue(targetID, animatedTarget);
@@ -223,11 +223,11 @@
         return false;
     }
     
-    shared_ptr <GLTFAnimation> convertOpenCOLLADAAnimationToGLTFAnimation(const COLLADAFW::Animation* animation, GLTF::GLTFAsset *asset)
+    boost::shared_ptr <GLTFAnimation> convertOpenCOLLADAAnimationToGLTFAnimation(const COLLADAFW::Animation* animation, GLTF::GLTFAsset *asset)
     {
-        shared_ptr <GLTFAnimation> cvtAnimation(new GLTFAnimation());
+        boost::shared_ptr <GLTFAnimation> cvtAnimation(new GLTFAnimation());
         if (animation->getAnimationType() == COLLADAFW::Animation::ANIMATION_CURVE) {
-            shared_ptr <JSONObject> animationParameters = cvtAnimation->parameters();
+            boost::shared_ptr <JSONObject> animationParameters = cvtAnimation->parameters();
             
             const COLLADAFW::AnimationCurve *animationCurve = (const COLLADAFW::AnimationCurve*)animation;
             
@@ -246,9 +246,9 @@
             
             const std::string originalID = animationCurve->getOriginalId();
             
-            //shared_ptr <JSONObject> inputParameter(new JSONObject());
-            shared_ptr <GLTFBufferView> inputBufferView = convertFloatOrDoubleArrayToGLTFBufferView(inputArray);
-            shared_ptr <GLTFBufferView> outputBufferView = convertFloatOrDoubleArrayToGLTFBufferView(outputArray);
+            //boost::shared_ptr <JSONObject> inputParameter(new JSONObject());
+            boost::shared_ptr <GLTFBufferView> inputBufferView = convertFloatOrDoubleArrayToGLTFBufferView(inputArray);
+            boost::shared_ptr <GLTFBufferView> outputBufferView = convertFloatOrDoubleArrayToGLTFBufferView(outputArray);
             
             cvtAnimation->registerBufferView("TIME", inputBufferView);
             cvtAnimation->registerBufferView("OUTPUT", outputBufferView);            
diff -ur collada2gltf.org/convert/animationConverter.h collada2gltf/convert/animationConverter.h
--- collada2gltf.org/convert/animationConverter.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/convert/animationConverter.h	2014-09-29 15:33:30.000000000 +0200
@@ -8,16 +8,18 @@
 #include "../GLTFOpenCOLLADA.h"
 #include "mathHelpers.h"
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF
 {    
     //a few helper classes to help flattening animations
     
-    typedef std::map<std::string , std::shared_ptr<COLLADAFW::Transformation> > IDToTransform;
+    typedef std::map<std::string , boost::shared_ptr<COLLADAFW::Transformation> > IDToTransform;
     
     class GLTFTransformKey {
     public:
         
-        GLTFTransformKey(double time, std::shared_ptr<COLLADAFW::Transformation> transform, std::string transformID) {
+        GLTFTransformKey(double time, boost::shared_ptr<COLLADAFW::Transformation> transform, std::string transformID) {
             this->_subTransforms[transformID] = transform;
             this->_time = time;
         }
@@ -47,7 +49,7 @@
     
     class GLTFAnimationFlattener {
     private:
-        void _updateTransformByReplacingValueAtIndex(std::shared_ptr<COLLADAFW::Transformation> transform, size_t index, float value)
+        void _updateTransformByReplacingValueAtIndex(boost::shared_ptr<COLLADAFW::Transformation> transform, size_t index, float value)
         {
             switch (transform->getTransformationType()) {
                 case COLLADAFW::Transformation::ROTATE:
@@ -115,10 +117,10 @@
             }
         }
         
-        std::shared_ptr<COLLADAFW::Transformation> _cloneTransformByReplacingValueAtIndex(std::string transformID, size_t index, float value)
+        boost::shared_ptr<COLLADAFW::Transformation> _cloneTransformByReplacingValueAtIndex(std::string transformID, size_t index, float value)
         {
-            std::shared_ptr<COLLADAFW::Transformation> transform = _idToTransform[transformID];
-            std::shared_ptr<COLLADAFW::Transformation> clonedTransform(transform->clone());
+            boost::shared_ptr<COLLADAFW::Transformation> transform = _idToTransform[transformID];
+            boost::shared_ptr<COLLADAFW::Transformation> clonedTransform(transform->clone());
             
             _updateTransformByReplacingValueAtIndex(clonedTransform, index, value);
             
@@ -128,7 +130,7 @@
     public:
         
         GLTFAnimationFlattener(COLLADAFW::Node *node) {
-            this->_transformsOrder = std::shared_ptr <std::vector<std::string> > (new std::vector<std::string>);
+            this->_transformsOrder = boost::shared_ptr <std::vector<std::string> > (new std::vector<std::string>);
             const COLLADAFW::TransformationPointerArray& transformations = node->getTransformations();
             size_t transformationsCount = transformations.getCount();
             int index = 0;
@@ -140,7 +142,7 @@
             _idIndex = (int*)malloc(sizeof(int) * transformationsCount);
             for (size_t i = 0 ; i < transformationsCount ; i++) {
                 const COLLADAFW::Transformation* tr = transformations[i];
-                std::shared_ptr<COLLADAFW::Transformation> clonedTransform(tr->clone());
+                boost::shared_ptr<COLLADAFW::Transformation> clonedTransform(tr->clone());
                 const COLLADAFW::UniqueId& animationListID = tr->getAnimationList();
                 if (animationListID.isValid()) {                    
                     _idIndex[i] = index++;
@@ -196,7 +198,7 @@
             float *previousAxisAngle = 0;
             float axisAngle[4];
             for (size_t i = 0 ; i < _transforms.size() ; i++) {
-                std::shared_ptr<GLTFTransformKey> key = this->_transforms[i];
+                boost::shared_ptr<GLTFTransformKey> key = this->_transforms[i];
 
                 if ((i > 0) && (rotations != 0)) {
                     previousAxisAngle = rotations + ((i-1) * 4);
@@ -269,7 +271,7 @@
             }
         }
         
-        void transformWasInserted(std::shared_ptr<COLLADAFW::Transformation> tr) {
+        void transformWasInserted(boost::shared_ptr<COLLADAFW::Transformation> tr) {
             switch (tr->getTransformationType()) {
                 case COLLADAFW::Transformation::MATRIX:
                     this->_hasAnimatedScale = this->_hasAnimatedTranslation = this->_hasAnimatedRotation = true;
@@ -290,14 +292,14 @@
         }
         
         //to be used for whole matrices and angle axis
-        void insertTransformAtTime(std::string transformID, std::shared_ptr<COLLADAFW::Transformation> transformation, double time) {
+        void insertTransformAtTime(std::string transformID, boost::shared_ptr<COLLADAFW::Transformation> transformation, double time) {
             transformWasInserted(transformation);
             if (_transforms.size() == 0) {
-                std::shared_ptr <GLTFTransformKey> key(new GLTFTransformKey(time, transformation, transformID));
+                boost::shared_ptr <GLTFTransformKey> key(new GLTFTransformKey(time, transformation, transformID));
                 _transforms.push_back(key);
             } else {
                 for (size_t i = 0 ; i < _transforms.size() ; i++) {
-                    std::shared_ptr<GLTFTransformKey> key = _transforms[i];
+                    boost::shared_ptr<GLTFTransformKey> key = _transforms[i];
                     if (time == key->getTime()) {
                         if ( (*key->subTransforms()).count(transformID) > 0) {
                             printf("INCONSISTENCY ERROR: overlap\n");
@@ -306,16 +308,16 @@
                         return;
                     } else if (time > key->getTime()) {
                         if (i + 1 == _transforms.size()) {
-                            std::shared_ptr <GLTFTransformKey> key(new GLTFTransformKey(time, transformation, transformID));
+                            boost::shared_ptr <GLTFTransformKey> key(new GLTFTransformKey(time, transformation, transformID));
                             _transforms.push_back(key);
                             return;
                         } else if (time < _transforms[i+1]->getTime()) {
-                            std::shared_ptr <GLTFTransformKey> key(new GLTFTransformKey(time, transformation, transformID));
+                            boost::shared_ptr <GLTFTransformKey> key(new GLTFTransformKey(time, transformation, transformID));
                             _transforms.insert(_transforms.begin() + i, key);
                             return;
                         }
                     } else {
-                        std::shared_ptr <GLTFTransformKey> key(new GLTFTransformKey(time, transformation, transformID));
+                        boost::shared_ptr <GLTFTransformKey> key(new GLTFTransformKey(time, transformation, transformID));
                         _transforms.insert(_transforms.begin() + i, key);
                         return;
                     }
@@ -324,17 +326,17 @@
         }
         
         void insertValueAtTime(std::string transformID, float value, size_t index, double time) {
-            std::shared_ptr <COLLADAFW::Transformation> transformation;
+            boost::shared_ptr <COLLADAFW::Transformation> transformation;
             if (_transforms.size() == 0) {
                 transformation = this->_cloneTransformByReplacingValueAtIndex(transformID,  index, value);
                 
-                std::shared_ptr <GLTFTransformKey> key(new GLTFTransformKey(time, transformation, transformID));
+                boost::shared_ptr <GLTFTransformKey> key(new GLTFTransformKey(time, transformation, transformID));
                 _transforms.push_back(key);
                 transformWasInserted(transformation);
                 return;
             } else {
                 for (size_t i = 0 ; i < _transforms.size() ; i++) {
-                    std::shared_ptr<GLTFTransformKey> key = _transforms[i];
+                    boost::shared_ptr<GLTFTransformKey> key = _transforms[i];
                     if (time == key->getTime()) {
                         if ( (*key->subTransforms()).count(transformID) > 0) {
                             transformation = (*key->subTransforms())[transformID];
@@ -349,14 +351,14 @@
                         if (i + 1 == _transforms.size()) {
                             transformation = this->_cloneTransformByReplacingValueAtIndex(transformID,  index, value);
                             
-                            std::shared_ptr <GLTFTransformKey> key(new GLTFTransformKey(time, transformation, transformID));
+                            boost::shared_ptr <GLTFTransformKey> key(new GLTFTransformKey(time, transformation, transformID));
                             _transforms.push_back(key);
                             transformWasInserted(transformation);
                             return;
                         } else if (time < _transforms[i+1]->getTime()) {
                             transformation = this->_cloneTransformByReplacingValueAtIndex(transformID,  index, value);
                             
-                            std::shared_ptr <GLTFTransformKey> key(new GLTFTransformKey(time, transformation, transformID));
+                            boost::shared_ptr <GLTFTransformKey> key(new GLTFTransformKey(time, transformation, transformID));
                             _transforms.insert(_transforms.begin() + i, key);
                             transformWasInserted(transformation);
                             return;
@@ -364,7 +366,7 @@
                     } else {
                         transformation = this->_cloneTransformByReplacingValueAtIndex(transformID,  index, value);
                         
-                        std::shared_ptr <GLTFTransformKey> key(new GLTFTransformKey(time, transformation, transformID));
+                        boost::shared_ptr <GLTFTransformKey> key(new GLTFTransformKey(time, transformation, transformID));
                         _transforms.insert(_transforms.begin() + i, key);
                         transformWasInserted(transformation);
                         return;
@@ -374,11 +376,11 @@
             
         }
         
-        void setTransformsOrder(std::shared_ptr<std::vector<std::string> > transformsOrder) {
+        void setTransformsOrder(boost::shared_ptr<std::vector<std::string> > transformsOrder) {
             this->_transformsOrder = transformsOrder;
         }
         
-        std::shared_ptr<std::vector<std::string> > getTransformsOrder() {
+        boost::shared_ptr<std::vector<std::string> > getTransformsOrder() {
             return this->_transformsOrder;
         }
         
@@ -387,10 +389,10 @@
 #define _INTERPOLATE(I1, I2, STEP) (I1 + (STEP * (I2-I1)))
         
         //TODO: might be worth checking for equality for prev & transform to be interpolated here
-        std::shared_ptr <COLLADAFW::Transformation> _interpolateTransforms(std::shared_ptr<COLLADAFW::Transformation> previousTransform, std::shared_ptr<COLLADAFW::Transformation> nextTransform, double ratio) {
+        boost::shared_ptr <COLLADAFW::Transformation> _interpolateTransforms(boost::shared_ptr<COLLADAFW::Transformation> previousTransform, boost::shared_ptr<COLLADAFW::Transformation> nextTransform, double ratio) {
             
             COLLADAFW::Transformation::TransformationType transformationType = previousTransform->getTransformationType();
-            std::shared_ptr<COLLADAFW::Transformation> transform(previousTransform->clone());
+            boost::shared_ptr<COLLADAFW::Transformation> transform(previousTransform->clone());
             
             switch (transformationType) {
                 case COLLADAFW::Transformation::ROTATE:
@@ -464,16 +466,16 @@
                 int idIndex = _idIndex[i];
                 if (idIndex != -1) {
                     std::string transformID = this->_transformsOrder->at(idIndex);
-                    std::shared_ptr <GLTFTransformKey> key = this->_transforms[index];
+                    boost::shared_ptr <GLTFTransformKey> key = this->_transforms[index];
                     
                     if ((*key->subTransforms()).count(transformID) == 0) {
                         //so here we need to get a transform matching transformID for this key but it does not contain it,
                         //we need to figure it out by interpolating the previous/next key containing this transform (this involves a search.
                         
-                        std::shared_ptr<COLLADAFW::Transformation> previousTransform;
-                        std::shared_ptr<COLLADAFW::Transformation> nextTransform;
-                        std::shared_ptr <GLTFTransformKey> previousKey;
-                        std::shared_ptr <GLTFTransformKey> nextKey;
+                        boost::shared_ptr<COLLADAFW::Transformation> previousTransform;
+                        boost::shared_ptr<COLLADAFW::Transformation> nextTransform;
+                        boost::shared_ptr <GLTFTransformKey> previousKey;
+                        boost::shared_ptr <GLTFTransformKey> nextKey;
                         double t1 = 0, t2 = 0;
                         
                         bool found = false;
@@ -510,7 +512,7 @@
                         }
                         
                         if (found == false) {
-                            std::shared_ptr <GLTFTransformKey> lastKey = this->_transforms[this->_transforms.size() - 1];
+                            boost::shared_ptr <GLTFTransformKey> lastKey = this->_transforms[this->_transforms.size() - 1];
                             nextTransform = _idToTransform[transformID];
                             t2 = lastKey->getTime();
                         }
@@ -579,14 +581,14 @@
         bool _hasAnimatedScale, _hasAnimatedTranslation, _hasAnimatedRotation;
         std::string _targetUID;
         int *_idIndex;
-        std::vector<std::shared_ptr<COLLADAFW::Transformation> > _originalTransforms;
-        std::vector<std::shared_ptr<GLTFTransformKey> > _transforms;
-        std::map<std::string , std::shared_ptr<COLLADAFW::Transformation> > _idToTransform;
-        std::shared_ptr<std::vector<std::string> > _transformsOrder;
+        std::vector<boost::shared_ptr<COLLADAFW::Transformation> > _originalTransforms;
+        std::vector<boost::shared_ptr<GLTFTransformKey> > _transforms;
+        std::map<std::string , boost::shared_ptr<COLLADAFW::Transformation> > _idToTransform;
+        boost::shared_ptr<std::vector<std::string> > _transformsOrder;
     };
     
-    std::shared_ptr <GLTFAnimation> convertOpenCOLLADAAnimationToGLTFAnimation(const COLLADAFW::Animation* animation, GLTF::GLTFAsset *asset);
-    bool writeAnimation(std::shared_ptr <GLTFAnimation> cvtAnimation,
+    boost::shared_ptr <GLTFAnimation> convertOpenCOLLADAAnimationToGLTFAnimation(const COLLADAFW::Animation* animation, GLTF::GLTFAsset *asset);
+    bool writeAnimation(boost::shared_ptr <GLTFAnimation> cvtAnimation,
                         const COLLADAFW::AnimationList::AnimationClass animationClass,
                         AnimatedTargetsSharedPtr animatedTargets,
                         GLTF::GLTFAsset *asset);
diff -ur collada2gltf.org/convert/meshConverter.cpp collada2gltf/convert/meshConverter.cpp
--- collada2gltf.org/convert/meshConverter.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/convert/meshConverter.cpp	2014-09-29 15:40:28.000000000 +0200
@@ -35,7 +35,7 @@
      Convert an OpenCOLLADA's FloatOrDoubleArray type to a GLTFBufferView
      Note: the resulting GLTFBufferView is not typed, it's the call responsability to keep track of the type if needed.
      */
-    shared_ptr <GLTFBufferView> convertFloatOrDoubleArrayToGLTFBufferView(const COLLADAFW::FloatOrDoubleArray &floatOrDoubleArray) {
+    boost::shared_ptr <GLTFBufferView> convertFloatOrDoubleArrayToGLTFBufferView(const COLLADAFW::FloatOrDoubleArray &floatOrDoubleArray) {
         unsigned char* sourceData = 0;
         size_t sourceSize = 0;
         
@@ -62,28 +62,28 @@
         unsigned char* copiedData = (unsigned char*)malloc(sourceSize);
         memcpy(copiedData, sourceData, sourceSize);
         
-        shared_ptr <GLTF::GLTFBufferView> bufferView = createBufferViewWithAllocatedBuffer(copiedData, 0, sourceSize, true);
+        boost::shared_ptr <GLTF::GLTFBufferView> bufferView = createBufferViewWithAllocatedBuffer(copiedData, 0, sourceSize, true);
         
         return bufferView;
     }
     
-    shared_ptr <GLTFBufferView> convertUnsignedIntArrayToGLTFBufferView(const COLLADAFW::UIntValuesArray &array) {
+    boost::shared_ptr <GLTFBufferView> convertUnsignedIntArrayToGLTFBufferView(const COLLADAFW::UIntValuesArray &array) {
         unsigned char* sourceData = (unsigned char*)array.getData();
         size_t sourceSize = array.getCount() * sizeof(unsigned int);
         unsigned char* copiedData = (unsigned char*)malloc(sourceSize);
         memcpy(copiedData, sourceData, sourceSize);
-        shared_ptr <GLTF::GLTFBufferView> bufferView = createBufferViewWithAllocatedBuffer(copiedData, 0, sourceSize, true);
+        boost::shared_ptr <GLTF::GLTFBufferView> bufferView = createBufferViewWithAllocatedBuffer(copiedData, 0, sourceSize, true);
         
         return bufferView;
     }
     
     //FIXME: these 3 functions up there could use some refactoring
-    shared_ptr <GLTFBufferView> convertIntArrayToGLTFBufferView(const COLLADAFW::IntValuesArray &array) {
+    boost::shared_ptr <GLTFBufferView> convertIntArrayToGLTFBufferView(const COLLADAFW::IntValuesArray &array) {
         unsigned char* sourceData = (unsigned char*)array.getData();
         size_t sourceSize = array.getCount() * sizeof(int);
         unsigned char* copiedData = (unsigned char*)malloc(sourceSize);
         memcpy(copiedData, sourceData, sourceSize);
-        shared_ptr <GLTF::GLTFBufferView> bufferView = createBufferViewWithAllocatedBuffer(copiedData, 0, sourceSize, true);
+        boost::shared_ptr <GLTF::GLTFBufferView> bufferView = createBufferViewWithAllocatedBuffer(copiedData, 0, sourceSize, true);
         
         return bufferView;
     }
@@ -93,7 +93,7 @@
                                                                           GLTFMesh* mesh,
                                                                           GLTF::Semantic semantic,
                                                                           size_t allowedComponentsPerAttribute,
-                                                                          shared_ptr<GLTFProfile> profile)
+                                                                          boost::shared_ptr<GLTFProfile> profile)
     {
         // The following are OpenCOLLADA fmk issues preventing doing a totally generic processing of sources
         //1. "set"(s) other than texCoord don't have valid input infos
@@ -194,8 +194,8 @@
             }
             
             // FIXME: the source could be shared, store / retrieve it here
-            shared_ptr <GLTFBufferView> cvtBufferView = createBufferViewWithAllocatedBuffer(id, sourceData, 0, sourceSize, meshAttributeOwnsBuffer);
-            shared_ptr <GLTFAccessor> cvtMeshAttribute(new GLTFAccessor(profile, profile->getGLTypeForComponentType(componentType, componentsPerElement)));
+            boost::shared_ptr <GLTFBufferView> cvtBufferView = createBufferViewWithAllocatedBuffer(id, sourceData, 0, sourceSize, meshAttributeOwnsBuffer);
+            boost::shared_ptr <GLTFAccessor> cvtMeshAttribute(new GLTFAccessor(profile, profile->getGLTypeForComponentType(componentType, componentsPerElement)));
             
             cvtMeshAttribute->setBufferView(cvtBufferView);
             cvtMeshAttribute->setByteStride(stride);
@@ -207,9 +207,9 @@
         return (unsigned int)setCount;
     }
     
-    static void __AppendIndices(shared_ptr <GLTF::GLTFPrimitive> &primitive, IndicesVector &primitiveIndicesVector, shared_ptr <GLTF::GLTFAccessor> &indices, GLTF::Semantic semantic, unsigned int indexOfSet)
+    static void __AppendIndices(boost::shared_ptr <GLTF::GLTFPrimitive> &primitive, IndicesVector &primitiveIndicesVector, boost::shared_ptr <GLTF::GLTFAccessor> &indices, GLTF::Semantic semantic, unsigned int indexOfSet)
     {
-        primitive->appendVertexAttribute(shared_ptr <GLTF::JSONVertexAttribute>( new GLTF::JSONVertexAttribute(semantic,indexOfSet)));
+        primitive->appendVertexAttribute(boost::shared_ptr <GLTF::JSONVertexAttribute>( new GLTF::JSONVertexAttribute(semantic,indexOfSet)));
         primitiveIndicesVector.push_back(indices);
     }
     
@@ -220,9 +220,9 @@
                                   unsigned int count,
                                   unsigned int vcount,
                                   unsigned int *verticesCountArray,
-                                  shared_ptr <GLTF::GLTFPrimitive> cvtPrimitive,
+                                  boost::shared_ptr <GLTF::GLTFPrimitive> cvtPrimitive,
                                   IndicesVector &primitiveIndicesVector,
-                                  shared_ptr<GLTFProfile> profile)
+                                  boost::shared_ptr<GLTFProfile> profile)
     {
         unsigned int triangulatedIndicesCount = 0;
         bool ownData = false;
@@ -251,8 +251,8 @@
             indices = bufferDestination;
         }
         
-        shared_ptr <GLTF::GLTFBufferView> uvBuffer = createBufferViewWithAllocatedBuffer(indices, 0, count * sizeof(unsigned int), ownData);
-        shared_ptr <GLTFAccessor> accessor(new GLTFAccessor(profile, profile->getGLenumForString("UNSIGNED_SHORT")));
+        boost::shared_ptr <GLTF::GLTFBufferView> uvBuffer = createBufferViewWithAllocatedBuffer(indices, 0, count * sizeof(unsigned int), ownData);
+        boost::shared_ptr <GLTFAccessor> accessor(new GLTFAccessor(profile, profile->getGLenumForString("UNSIGNED_SHORT")));
         
         accessor->setBufferView(uvBuffer);
         accessor->setCount(count);
@@ -260,11 +260,11 @@
         __AppendIndices(cvtPrimitive, primitiveIndicesVector, accessor, semantic, idx);
     }
     
-    static shared_ptr <GLTF::GLTFPrimitive> __ConvertOpenCOLLADAMeshPrimitive(COLLADAFW::MeshPrimitive *openCOLLADAMeshPrimitive,
+    static boost::shared_ptr <GLTF::GLTFPrimitive> __ConvertOpenCOLLADAMeshPrimitive(COLLADAFW::MeshPrimitive *openCOLLADAMeshPrimitive,
                                                                               IndicesVector &primitiveIndicesVector,
-                                                                              shared_ptr<GLTFProfile> profile)
+                                                                              boost::shared_ptr<GLTFProfile> profile)
     {
-        shared_ptr <GLTF::GLTFPrimitive> cvtPrimitive(new GLTF::GLTFPrimitive());
+        boost::shared_ptr <GLTF::GLTFPrimitive> cvtPrimitive(new GLTF::GLTFPrimitive());
         
         // We want to match OpenGL/ES mode , as WebGL spec points to OpenGL/ES spec...
         // "Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, and GL_TRIANGLES are accepted."
@@ -334,9 +334,9 @@
             count = triangulatedIndicesCount;
         }
         
-        shared_ptr <GLTFBufferView> positionBuffer = createBufferViewWithAllocatedBuffer(indices, 0, count * sizeof(unsigned int), shouldTriangulate ? true : false);
+        boost::shared_ptr <GLTFBufferView> positionBuffer = createBufferViewWithAllocatedBuffer(indices, 0, count * sizeof(unsigned int), shouldTriangulate ? true : false);
         
-        shared_ptr <GLTF::GLTFAccessor> positionIndices(new GLTF::GLTFAccessor(profile, profile->getGLenumForString("UNSIGNED_SHORT")));
+        boost::shared_ptr <GLTF::GLTFAccessor> positionIndices(new GLTF::GLTFAccessor(profile, profile->getGLenumForString("UNSIGNED_SHORT")));
         
         positionIndices->setBufferView(positionBuffer);
         positionIndices->setCount(count);
@@ -351,8 +351,8 @@
                 count = triangulatedIndicesCount;
             }
             
-            shared_ptr <GLTF::GLTFBufferView> normalBuffer = createBufferViewWithAllocatedBuffer(indices, 0, count * sizeof(unsigned int), shouldTriangulate ? true : false);
-            shared_ptr <GLTF::GLTFAccessor> normalIndices(new GLTF::GLTFAccessor(profile, profile->getGLenumForString("UNSIGNED_SHORT")));
+            boost::shared_ptr <GLTF::GLTFBufferView> normalBuffer = createBufferViewWithAllocatedBuffer(indices, 0, count * sizeof(unsigned int), shouldTriangulate ? true : false);
+            boost::shared_ptr <GLTF::GLTFAccessor> normalIndices(new GLTF::GLTFAccessor(profile, profile->getGLenumForString("UNSIGNED_SHORT")));
             
             normalIndices->setBufferView(normalBuffer);
             normalIndices->setCount(count);
@@ -402,8 +402,8 @@
                 indices = createTrianglesFromPolylist(verticesCountArray, indices, vcount, &triangulatedIndicesCount);
                 count = triangulatedIndicesCount;
             }
-            shared_ptr <GLTF::GLTFBufferView> binormalBuffer = createBufferViewWithAllocatedBuffer(indices, 0, count * sizeof(unsigned int), shouldTriangulate ? true : false);
-            shared_ptr <GLTF::GLTFAccessor> binormalIndices(new GLTF::GLTFAccessor(profile, profile->getGLenumForString("UNSIGNED_SHORT")));
+            boost::shared_ptr <GLTF::GLTFBufferView> binormalBuffer = createBufferViewWithAllocatedBuffer(indices, 0, count * sizeof(unsigned int), shouldTriangulate ? true : false);
+            boost::shared_ptr <GLTF::GLTFAccessor> binormalIndices(new GLTF::GLTFAccessor(profile, profile->getGLenumForString("UNSIGNED_SHORT")));
             
             binormalIndices->setBufferView(binormalBuffer);
             binormalIndices->setCount(count);
@@ -423,8 +423,8 @@
                 indices = createTrianglesFromPolylist(verticesCountArray, indices, vcount, &triangulatedIndicesCount);
                 count = triangulatedIndicesCount;
             }
-            shared_ptr <GLTF::GLTFBufferView> tangentBuffer = createBufferViewWithAllocatedBuffer(indices, 0, count * sizeof(unsigned int), shouldTriangulate ? true : false);
-            shared_ptr <GLTF::GLTFAccessor> tangentIndices(new GLTF::GLTFAccessor(profile, profile->getGLenumForString("UNSIGNED_SHORT")));
+            boost::shared_ptr <GLTF::GLTFBufferView> tangentBuffer = createBufferViewWithAllocatedBuffer(indices, 0, count * sizeof(unsigned int), shouldTriangulate ? true : false);
+            boost::shared_ptr <GLTF::GLTFAccessor> tangentIndices(new GLTF::GLTFAccessor(profile, profile->getGLenumForString("UNSIGNED_SHORT")));
             
             tangentIndices->setBufferView(tangentBuffer);
             tangentIndices->setCount(count);
@@ -439,8 +439,8 @@
         return cvtPrimitive;
     }
     
-    shared_ptr<GLTFMesh> convertOpenCOLLADAMesh(COLLADAFW::Mesh* openCOLLADAMesh, GLTFAsset* asset) {
-        shared_ptr <GLTF::GLTFMesh> cvtMesh(new GLTF::GLTFMesh());
+    boost::shared_ptr<GLTFMesh> convertOpenCOLLADAMesh(COLLADAFW::Mesh* openCOLLADAMesh, GLTFAsset* asset) {
+        boost::shared_ptr <GLTF::GLTFMesh> cvtMesh(new GLTF::GLTFMesh());
         
         cvtMesh->setID(openCOLLADAMesh->getOriginalId());
         cvtMesh->setName(openCOLLADAMesh->getName());
@@ -448,7 +448,7 @@
         const COLLADAFW::MeshPrimitiveArray& primitives =  openCOLLADAMesh->getMeshPrimitives();
         size_t primitiveCount = primitives.getCount();
         
-        std::vector< shared_ptr<IndicesVector> > allPrimitiveIndicesVectors;
+        std::vector< boost::shared_ptr<IndicesVector> > allPrimitiveIndicesVectors;
                 
         // get all primitives
         for (size_t i = 0 ; i < primitiveCount ; i++) {
@@ -471,19 +471,19 @@
                 continue;
             }
             
-            shared_ptr <GLTF::IndicesVector> primitiveIndicesVector(new GLTF::IndicesVector());
+            boost::shared_ptr <GLTF::IndicesVector> primitiveIndicesVector(new GLTF::IndicesVector());
             allPrimitiveIndicesVectors.push_back(primitiveIndicesVector);
             
-            shared_ptr <GLTF::GLTFPrimitive> primitive = __ConvertOpenCOLLADAMeshPrimitive(primitives[i],*primitiveIndicesVector, asset->profile());
+            boost::shared_ptr <GLTF::GLTFPrimitive> primitive = __ConvertOpenCOLLADAMeshPrimitive(primitives[i],*primitiveIndicesVector, asset->profile());
             cvtMesh->appendPrimitive(primitive);
             
             VertexAttributeVector vertexAttributes = primitive->getVertexAttributes();
             primitiveIndicesVector = allPrimitiveIndicesVectors[allPrimitiveIndicesVectors.size()-1];
             
             // once we got a primitive, keep track of its meshAttributes
-            std::vector< shared_ptr<GLTF::GLTFAccessor> > allIndices = *primitiveIndicesVector;
+            std::vector< boost::shared_ptr<GLTF::GLTFAccessor> > allIndices = *primitiveIndicesVector;
             for (size_t k = 0 ; k < allIndices.size() ; k++) {
-                shared_ptr<GLTF::GLTFAccessor> indices = allIndices[k];
+                boost::shared_ptr<GLTF::GLTFAccessor> indices = allIndices[k];
                 GLTF::Semantic semantic = vertexAttributes[k]->getSemantic();
                 
                 switch (semantic) {
@@ -521,6 +521,6 @@
             return createUnifiedIndexesMeshFromMesh(cvtMesh.get(), allPrimitiveIndicesVectors, asset->profile());
         }
 
-        return nullptr;
+        return boost::shared_ptr<GLTFMesh>();
     }
 }
diff -ur collada2gltf.org/convert/meshConverter.h collada2gltf/convert/meshConverter.h
--- collada2gltf.org/convert/meshConverter.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/convert/meshConverter.h	2014-09-29 15:33:42.000000000 +0200
@@ -4,12 +4,14 @@
 #ifndef __GLTFMESHCONVERTER_H__
 #define __GLTFMESHCONVERTER_H__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF
 {
-    std::shared_ptr <GLTFMesh> convertOpenCOLLADAMesh(COLLADAFW::Mesh* openCOLLADAMesh, GLTFAsset* asset);
-    std::shared_ptr <GLTFBufferView> convertIntArrayToGLTFBufferView(const COLLADAFW::IntValuesArray &array);
-    std::shared_ptr <GLTFBufferView> convertUnsignedIntArrayToGLTFBufferView(const COLLADAFW::UIntValuesArray &array);
-    std::shared_ptr <GLTFBufferView> convertFloatOrDoubleArrayToGLTFBufferView(const COLLADAFW::FloatOrDoubleArray &floatOrDoubleArray);
+    boost::shared_ptr <GLTFMesh> convertOpenCOLLADAMesh(COLLADAFW::Mesh* openCOLLADAMesh, GLTFAsset* asset);
+    boost::shared_ptr <GLTFBufferView> convertIntArrayToGLTFBufferView(const COLLADAFW::IntValuesArray &array);
+    boost::shared_ptr <GLTFBufferView> convertUnsignedIntArrayToGLTFBufferView(const COLLADAFW::UIntValuesArray &array);
+    boost::shared_ptr <GLTFBufferView> convertFloatOrDoubleArrayToGLTFBufferView(const COLLADAFW::FloatOrDoubleArray &floatOrDoubleArray);
 }
 
 
diff -ur collada2gltf.org/extensions/o3dgc-compression/GLTF-Open3DGC.cpp collada2gltf/extensions/o3dgc-compression/GLTF-Open3DGC.cpp
--- collada2gltf.org/extensions/o3dgc-compression/GLTF-Open3DGC.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/extensions/o3dgc-compression/GLTF-Open3DGC.cpp	2014-09-29 15:55:51.898551665 +0200
@@ -138,7 +138,7 @@
         return true;
     }
 #if 0
-    void testDecode(shared_ptr <GLTFMesh> mesh, BinaryStream &bstream)
+    void testDecode(boost::shared_ptr <GLTFMesh> mesh, BinaryStream &bstream)
     {
         SC3DMCDecoder <unsigned short> decoder;
         IndexedFaceSet <unsigned short> ifs;
@@ -171,7 +171,7 @@
         
         //---
         
-        shared_ptr <GLTFAccessor> meshAttribute = mesh->getMeshAttribute(POSITION, 0);
+        boost::shared_ptr <GLTFAccessor> meshAttribute = mesh->getMeshAttribute(POSITION, 0);
         
         const double* min = meshAttribute->getMin();
         const double* max = meshAttribute->getMax();
@@ -207,13 +207,13 @@
     //All these limitations will be fixed in coming iterations:
     //Do we have only triangles, only one set of texcoord and no skinning ?
     //TODO:Also check that the same buffer is not shared by 2 different semantics or set
-    bool canEncodeOpen3DGCMesh(shared_ptr <GLTFMesh> mesh, shared_ptr<GLTFProfile> profile)
+    bool canEncodeOpen3DGCMesh(boost::shared_ptr <GLTFMesh> mesh, boost::shared_ptr<GLTFProfile> profile)
     {
         JSONValueVector primitives = mesh->getPrimitives()->values();
         unsigned int primitivesCount =  (unsigned int)primitives.size();
         
         for (unsigned int i = 0 ; i < primitivesCount ; i++) {
-            shared_ptr<GLTF::GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
+            boost::shared_ptr<GLTF::GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
             if (primitive->getPrimitive() != profile->getGLenumForString("TRIANGLES")) {
                 return false;
             }
@@ -237,13 +237,13 @@
         return o3dPredictionMode;
     }
     
-    void encodeOpen3DGCMesh(shared_ptr <GLTFMesh> mesh,
-                            shared_ptr<JSONObject> floatAttributeIndexMapping,
+    void encodeOpen3DGCMesh(boost::shared_ptr <GLTFMesh> mesh,
+                            boost::shared_ptr<JSONObject> floatAttributeIndexMapping,
                             GLTFAsset* asset)
     {
         o3dgc::SC3DMCEncodeParams params;
         o3dgc::IndexedFaceSet <unsigned short> ifs;
-        shared_ptr <GLTFConfig> config = asset->converterConfig();
+        boost::shared_ptr <GLTFConfig> config = asset->converterConfig();
         
         //setup options
         int qcoord    = 12;
@@ -281,8 +281,8 @@
         
         //First run through primitives to gather the number of indices and infer the number of triangles.
         for (unsigned int i = 0 ; i < primitivesCount ; i++) {
-            shared_ptr<GLTF::GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
-            shared_ptr <GLTF::GLTFAccessor> uniqueIndices = primitive->getIndices();
+            boost::shared_ptr<GLTF::GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
+            boost::shared_ptr <GLTF::GLTFAccessor> uniqueIndices = primitive->getIndices();
             unsigned int indicesCount = (unsigned int)(uniqueIndices->getCount());
             //FIXME: assumes triangles, but we are guarded from issues by canEncodeOpen3DGCMesh
             allIndicesCount += indicesCount;
@@ -302,8 +302,8 @@
             }
             primitiveIDsPtr += trianglesCount;
             allTrianglesCount += trianglesCount;
-            shared_ptr<GLTF::GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
-            shared_ptr <GLTF::GLTFAccessor> uniqueIndices = primitive->getIndices();
+            boost::shared_ptr<GLTF::GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
+            boost::shared_ptr <GLTF::GLTFAccessor> uniqueIndices = primitive->getIndices();
             unsigned int indicesCount = (unsigned int)(uniqueIndices->getCount());
             unsigned int* indicesPtr = (unsigned int*)uniqueIndices->getBufferView()->getBufferDataByApplyingOffset();
             for (unsigned int j = 0 ; j < indicesCount ; j++) {
@@ -326,7 +326,7 @@
             size_t attributesCount = mesh->getMeshAttributesCountForSemantic(semantic);
             
             for (size_t j = 0 ; j < attributesCount ; j++) {
-                shared_ptr <GLTFAccessor> meshAttribute = mesh->getMeshAttribute(semantic, j);
+                boost::shared_ptr <GLTFAccessor> meshAttribute = mesh->getMeshAttribute(semantic, j);
                 vertexCount = meshAttribute->getCount();
                 size_t componentsPerElement = meshAttribute->componentsPerElement();
                 char *buffer = (char*)meshAttribute->getBufferView()->getBufferDataByApplyingOffset();
@@ -400,12 +400,12 @@
         
         params.SetNumFloatAttributes(nFloatAttributes);
         ifs.SetNumFloatAttributes(nFloatAttributes);
-        shared_ptr<JSONObject> compressionObject = static_pointer_cast<JSONObject>(mesh->getExtensions()->createObjectIfNeeded("Open3DGC-compression"));
+        boost::shared_ptr<JSONObject> compressionObject = static_pointer_cast<JSONObject>(mesh->getExtensions()->createObjectIfNeeded("Open3DGC-compression"));
         
         ifs.ComputeMinMax(O3DGC_SC3DMC_MAX_ALL_DIMS);
         BinaryStream bstream(vertexCount * 8);
         SC3DMCEncoder <unsigned short> encoder;
-        shared_ptr<JSONObject> compressedData(new JSONObject());
+        boost::shared_ptr<JSONObject> compressedData(new JSONObject());
         compressedData->setInt32("verticesCount", vertexCount);
         compressedData->setInt32("indicesCount", allIndicesCount);
         //Open3DGC binary is disabled
@@ -446,7 +446,7 @@
         Real min[32];
         O3DGCStreamType streamType = CONFIG_STRING(asset, "compressionMode")  == "ascii" ? O3DGC_STREAM_TYPE_ASCII : O3DGC_STREAM_TYPE_BINARY;
         
-        shared_ptr<GLTFConfig> config = asset->converterConfig();
+        boost::shared_ptr<GLTFConfig> config = asset->converterConfig();
         
         DynamicVector dynamicVector;
         dynamicVector.SetVectors(buffer);
@@ -516,9 +516,9 @@
      Handles Parameter creation / addition
      */
     static std::string __SetupSamplerForParameter(GLTFAnimation *cvtAnimation,
-                                                  shared_ptr<JSONObject> parameter,
+                                                  boost::shared_ptr<JSONObject> parameter,
                                                   const std::string &name) {
-        shared_ptr<JSONObject> sampler(new JSONObject());
+        boost::shared_ptr<JSONObject> sampler(new JSONObject());
         std::string samplerID = cvtAnimation->getSamplerIDForName(name);
         sampler->setString("input", "TIME");           //FIXME:harcoded for now
         sampler->setString("interpolation", "LINEAR"); //FIXME:harcoded for now
@@ -528,7 +528,7 @@
         return samplerID;
     }
     
-    static shared_ptr <JSONObject> __WriteAnimationParameter(GLTFAnimation *cvtAnimation,
+    static boost::shared_ptr <JSONObject> __WriteAnimationParameter(GLTFAnimation *cvtAnimation,
                                                              const std::string& parameterSID,
                                                              const std::string& accessorUID,
                                                              const std::string& parameterType,
@@ -536,9 +536,9 @@
                                                              bool isInputParameter,
                                                              GLTFAsset *asset) {
         //setup
-        shared_ptr <GLTFProfile> profile = asset->profile();
-        shared_ptr <GLTF::JSONObject> accessors = asset->root()->createObjectIfNeeded(kAccessors);
-        shared_ptr<JSONObject> parameter(new JSONObject());
+        boost::shared_ptr <GLTFProfile> profile = asset->profile();
+        boost::shared_ptr <GLTF::JSONObject> accessors = asset->root()->createObjectIfNeeded(kAccessors);
+        boost::shared_ptr<JSONObject> parameter(new JSONObject());
         parameter->setUnsignedInt32("count", cvtAnimation->getCount());
         parameter->setUnsignedInt32("type", profile->getGLenumForString(parameterType));
 
@@ -561,9 +561,9 @@
                 
                 byteLength = outputStream->length() - byteOffset;
                 
-                shared_ptr<JSONObject> extensionsObject = parameter->createObjectIfNeeded(kExtensions);
-                shared_ptr<JSONObject> compressionObject = extensionsObject->createObjectIfNeeded("Open3DGC-compression");
-                shared_ptr<JSONObject> compressionDataObject = compressionObject->createObjectIfNeeded("compressedData");
+                boost::shared_ptr<JSONObject> extensionsObject = parameter->createObjectIfNeeded(kExtensions);
+                boost::shared_ptr<JSONObject> compressionObject = extensionsObject->createObjectIfNeeded("Open3DGC-compression");
+                boost::shared_ptr<JSONObject> compressionDataObject = compressionObject->createObjectIfNeeded("compressedData");
                 
                 compressionDataObject->setUnsignedInt32("byteOffset", byteOffset);
                 compressionDataObject->setUnsignedInt32("count", byteLength);
@@ -591,8 +591,8 @@
                                          bool isInputParameter,
                                          GLTFAsset *asset) {
         
-        shared_ptr <JSONObject> parameter;
-        shared_ptr <GLTF::JSONObject> accessors = asset->root()->createObjectIfNeeded(kAccessors);
+        boost::shared_ptr <JSONObject> parameter;
+        boost::shared_ptr <GLTF::JSONObject> accessors = asset->root()->createObjectIfNeeded(kAccessors);
         if (CONFIG_BOOL(asset, "shareAnimationAccessors")) {
             GLTFAccessorCache accessorCache(buffer, byteLength);
             UniqueIDToAccessor::iterator it = asset->_uniqueIDToAccessorObject.find(accessorCache);
diff -ur collada2gltf.org/extensions/o3dgc-compression/GLTF-Open3DGC.h collada2gltf/extensions/o3dgc-compression/GLTF-Open3DGC.h
--- collada2gltf.org/extensions/o3dgc-compression/GLTF-Open3DGC.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/extensions/o3dgc-compression/GLTF-Open3DGC.h	2014-09-29 15:56:05.562552182 +0200
@@ -24,12 +24,14 @@
 #ifndef __GLTF_Open3DGC__
 #define __GLTF_Open3DGC__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF
 {
-    bool canEncodeOpen3DGCMesh(std::shared_ptr <GLTFMesh> mesh, std::shared_ptr <GLTFProfile> profile);
+    bool canEncodeOpen3DGCMesh(boost::shared_ptr <GLTFMesh> mesh, boost::shared_ptr <GLTFProfile> profile);
     
-    void encodeOpen3DGCMesh(std::shared_ptr <GLTFMesh> mesh,
-                            std::shared_ptr<JSONObject> floatAttributeIndexMapping,
+    void encodeOpen3DGCMesh(boost::shared_ptr <GLTFMesh> mesh,
+                            boost::shared_ptr<JSONObject> floatAttributeIndexMapping,
                             GLTFAsset* asset);
     
     void encodeDynamicVector(float *buffer, const std::string &path, size_t componentsCount, size_t count, GLTFAsset& asset);
diff -ur collada2gltf.org/GLTF/GLTFAccessorCache.cpp collada2gltf/GLTF/GLTFAccessorCache.cpp
--- collada2gltf.org/GLTF/GLTFAccessorCache.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFAccessorCache.cpp	2014-09-28 12:34:05.000000000 +0200
@@ -22,7 +22,7 @@
     }
 
     GLTFAccessorCache::~GLTFAccessorCache() {
-        delete this->m_pData;
+        delete[] this->m_pData;
     }
     
     bool GLTFAccessorCache::operator<(const GLTFAccessorCache& rhs) const {
diff -ur collada2gltf.org/GLTF/GLTFAccessor.cpp collada2gltf/GLTF/GLTFAccessor.cpp
--- collada2gltf.org/GLTF/GLTFAccessor.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFAccessor.cpp	2014-09-29 15:34:08.000000000 +0200
@@ -38,7 +38,7 @@
         this->_ID = GLTFUtils::generateIDForType("accessor");
     }
     
-    GLTFAccessor::GLTFAccessor(shared_ptr<GLTFProfile> profile, unsigned int glType):
+    GLTFAccessor::GLTFAccessor(boost::shared_ptr<GLTFProfile> profile, unsigned int glType):
     JSONObject() {
         this->_minMaxDirty = true;
         this->setUnsignedInt32(kType, glType);
@@ -71,13 +71,13 @@
     GLTFAccessor::~GLTFAccessor() {
     }
         
-    void GLTFAccessor::setBufferView(shared_ptr <GLTFBufferView> bufferView) {
+    void GLTFAccessor::setBufferView(boost::shared_ptr <GLTFBufferView> bufferView) {
         this->_bufferView = bufferView;
         this->_minMaxDirty = true;
         this->setString(kBufferView, bufferView->getID());
     }
         
-    shared_ptr <GLTFBufferView> GLTFAccessor::getBufferView() {
+    boost::shared_ptr <GLTFBufferView> GLTFAccessor::getBufferView() {
         return this->_bufferView;
     }
     
@@ -121,12 +121,12 @@
         return this->_elementByteLength;
     }
     
-    shared_ptr<JSONArray> GLTFAccessor::min() {
+    boost::shared_ptr<JSONArray> GLTFAccessor::min() {
         this->_computeMinMaxIfNeeded();        
         return this->_min;
     }
 
-    shared_ptr<JSONArray> GLTFAccessor::max() {
+    boost::shared_ptr<JSONArray> GLTFAccessor::max() {
         this->_computeMinMaxIfNeeded();
         return this->_max;
     }
@@ -169,8 +169,8 @@
             double max[32];
 
             size_t componentsPerElement = this->_componentsPerElement;
-            shared_ptr<JSONArray> minObject = this->createArrayIfNeeded("min");
-            shared_ptr<JSONArray> maxObject = this->createArrayIfNeeded("max");
+            boost::shared_ptr<JSONArray> minObject = this->createArrayIfNeeded("min");
+            boost::shared_ptr<JSONArray> maxObject = this->createArrayIfNeeded("max");
             
             __MinMaxApplierInfo minMaxApplierInfo;
             minMaxApplierInfo.min = min;
@@ -183,8 +183,8 @@
             applyOnAccessor(__ComputeMinMax, &minMaxApplierInfo);
             
             for (size_t i = 0 ; i < this->_componentsPerElement ; i++) {
-                minObject->appendValue(shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(min[i])));
-                maxObject->appendValue(shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(max[i])));
+                minObject->appendValue(boost::shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(min[i])));
+                maxObject->appendValue(boost::shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(max[i])));
             }
             this->_minMaxDirty = false;
         }
@@ -198,7 +198,7 @@
         size_t byteStride = this->getByteStride();
         size_t componentsPerElement = this->_componentsPerElement;
         size_t vertexAttributeByteSize = this->_elementByteLength;
-        shared_ptr <GLTF::GLTFBufferView> bufferView = this->getBufferView();
+        boost::shared_ptr <GLTF::GLTFBufferView> bufferView = this->getBufferView();
         ComponentType type = this->_componentType;
         unsigned char* bufferData = (unsigned char*)bufferView->getBufferDataByApplyingOffset();
 
diff -ur collada2gltf.org/GLTF/GLTFAccessor.h collada2gltf/GLTF/GLTFAccessor.h
--- collada2gltf.org/GLTF/GLTFAccessor.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFAccessor.h	2014-09-29 15:34:19.000000000 +0200
@@ -27,6 +27,8 @@
 #ifndef __GLTF_ACCESSOR_H__
 #define __GLTF_ACCESSOR_H__
 
+#include <boost/shared_ptr.hpp>
+
 /* 
     A GLTFAccessor contains all the properties required to describe a buffer to be handled by WebGL (http://www.khronos.org/registry/webgl/specs/latest/ )
      
@@ -49,13 +51,13 @@
 
     public:
         
-        GLTFAccessor(std::shared_ptr<GLTFProfile>, unsigned int glType);
+        GLTFAccessor(boost::shared_ptr<GLTFProfile>, unsigned int glType);
         GLTFAccessor(GLTFAccessor *);
         
         virtual ~GLTFAccessor();
         
-        void setBufferView(std::shared_ptr <GLTFBufferView> buffer);
-        std::shared_ptr <GLTFBufferView> getBufferView();
+        void setBufferView(boost::shared_ptr <GLTFBufferView> buffer);
+        boost::shared_ptr <GLTFBufferView> getBufferView();
                 
         void setByteStride(size_t stride);
         size_t getByteStride();
@@ -78,8 +80,8 @@
         
         size_t elementByteLength();
         
-        std::shared_ptr<JSONArray> min();
-        std::shared_ptr<JSONArray> max();
+        boost::shared_ptr<JSONArray> min();
+        boost::shared_ptr<JSONArray> max();
         
         bool matchesLayout(GLTFAccessor* meshAttribute);
         void exposeMinMax();
@@ -87,13 +89,13 @@
         void _computeMinMaxIfNeeded();
         
     private:
-        std::shared_ptr <GLTFBufferView> _bufferView;
+        boost::shared_ptr <GLTFBufferView> _bufferView;
         size_t                  _componentsPerElement;
         ComponentType           _componentType;
         size_t                  _elementByteLength;
         std::string             _ID;
-        std::shared_ptr<JSONArray>   _min;
-        std::shared_ptr<JSONArray>   _max;
+        boost::shared_ptr<JSONArray>   _min;
+        boost::shared_ptr<JSONArray>   _max;
         bool                    _minMaxDirty;
     };
 }
diff -ur collada2gltf.org/GLTF/GLTFAnimation.cpp collada2gltf/GLTF/GLTFAnimation.cpp
--- collada2gltf.org/GLTF/GLTFAnimation.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFAnimation.cpp	2014-09-29 15:34:30.000000000 +0200
@@ -42,12 +42,12 @@
         this->createArrayIfNeeded(kChannels);
         this->createObjectIfNeeded(kParameters);
         
-        this->_targets = shared_ptr<JSONObject> (new JSONObject());
+        this->_targets = boost::shared_ptr<JSONObject> (new JSONObject());
     }
 
     GLTFAnimation::~GLTFAnimation() {}
 
-    shared_ptr <JSONObject> GLTFAnimation::targets() {
+    boost::shared_ptr <JSONObject> GLTFAnimation::targets() {
         return this->_targets;
     }
 
@@ -59,11 +59,11 @@
 		this->setUnsignedInt32(kCount, (unsigned int)count);
     }
      
-    shared_ptr <JSONObject> GLTFAnimation::parameters() {
+    boost::shared_ptr <JSONObject> GLTFAnimation::parameters() {
         return this->getObject(kParameters);
     }
 
-    shared_ptr <JSONObject>  GLTFAnimation::getParameterNamed(std::string parameter) {
+    boost::shared_ptr <JSONObject>  GLTFAnimation::getParameterNamed(std::string parameter) {
         return this->parameters()->getObject(parameter);
     }
 
@@ -79,11 +79,11 @@
         return this->_id;
     }
     
-    shared_ptr <JSONObject> GLTFAnimation::samplers() {
+    boost::shared_ptr <JSONObject> GLTFAnimation::samplers() {
         return this->getObject(kSamplers);
     }
 
-    shared_ptr <JSONArray> GLTFAnimation::channels() {
+    boost::shared_ptr <JSONArray> GLTFAnimation::channels() {
         return this->getArray(kChannels);
     }
 
@@ -91,7 +91,7 @@
         return this->_id + "_" + name + "_sampler";
     }
     
-    shared_ptr<GLTFAnimationFlattener> GLTFAnimation::animationFlattenerForTargetUID(std::string targetUID) {
+    boost::shared_ptr<GLTFAnimationFlattener> GLTFAnimation::animationFlattenerForTargetUID(std::string targetUID) {
         
         return (*this->_animationFlattenerForTargetUID)[targetUID];
     }
@@ -108,7 +108,7 @@
         this->_animationFlattenerForTargetUID = animationFlattenerMaps;
     }
 
-    void GLTFAnimation::registerBufferView(std::string parameterName, shared_ptr <GLTFBufferView> bufferView) {
+    void GLTFAnimation::registerBufferView(std::string parameterName, boost::shared_ptr <GLTFBufferView> bufferView) {
         this->_bufferViews[parameterName] = bufferView;
     }
 
@@ -116,7 +116,7 @@
         this->_bufferViews.erase(parameterName);
     }
 
-    shared_ptr<GLTFBufferView> GLTFAnimation::getBufferViewForParameter(std::string parameterName) {
+    boost::shared_ptr<GLTFBufferView> GLTFAnimation::getBufferViewForParameter(std::string parameterName) {
         return this->_bufferViews[parameterName];
     }
 
@@ -126,8 +126,8 @@
     static void __AddChannel(GLTFAnimation* cvtAnimation,
                              const std::string &targetID,
                              const std::string &path) {
-        shared_ptr<JSONObject> trChannel(new JSONObject());
-        shared_ptr<JSONObject> trTarget(new JSONObject());
+        boost::shared_ptr<JSONObject> trChannel(new JSONObject());
+        boost::shared_ptr<JSONObject> trTarget(new JSONObject());
         
         trChannel->setString("sampler", cvtAnimation->getSamplerIDForName(path));
         trChannel->setValue(kTarget, trTarget);
@@ -137,8 +137,8 @@
     }
 
     void GLTFAnimation::writeAnimationForTargetID(const std::string &targetID, GLTFAsset* asset) {
-        shared_ptr <JSONObject> target =  this->targets()->getObject(targetID);
-        shared_ptr<GLTFAnimationFlattener> animationFlattener = this->animationFlattenerForTargetUID(targetID);
+        boost::shared_ptr <JSONObject> target =  this->targets()->getObject(targetID);
+        boost::shared_ptr<GLTFAnimationFlattener> animationFlattener = this->animationFlattenerForTargetUID(targetID);
         
         size_t count = 0;
         float* rotations = 0;
diff -ur collada2gltf.org/GLTF/GLTFAnimation.h collada2gltf/GLTF/GLTFAnimation.h
--- collada2gltf.org/GLTF/GLTFAnimation.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFAnimation.h	2014-09-29 15:34:40.000000000 +0200
@@ -24,6 +24,8 @@
 #ifndef __GLTF_ANIMATION_H__
 #define __GLTF_ANIMATION_H__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF 
 {
     class GLTFAnimationFlattener;
@@ -43,35 +45,35 @@
         void setOriginalID(std::string originalID);
         std::string getOriginalID();
         
-        std::shared_ptr <JSONObject> getParameterNamed(std::string parameter);
+        boost::shared_ptr <JSONObject> getParameterNamed(std::string parameter);
         void removeParameterNamed(std::string parameter);
         
-        std::shared_ptr <JSONObject> samplers();
-        std::shared_ptr <JSONArray> channels();
-        std::shared_ptr <JSONObject> targets();
-        std::shared_ptr <JSONObject> parameters();
+        boost::shared_ptr <JSONObject> samplers();
+        boost::shared_ptr <JSONArray> channels();
+        boost::shared_ptr <JSONObject> targets();
+        boost::shared_ptr <JSONObject> parameters();
 
         std::string getSamplerIDForName(std::string name);
         
         void registerAnimationFlatteners(AnimationFlattenerForTargetUIDSharedPtr);
         
-        std::shared_ptr<GLTFAnimationFlattener> animationFlattenerForTargetUID(std::string);
+        boost::shared_ptr<GLTFAnimationFlattener> animationFlattenerForTargetUID(std::string);
 
-        void registerBufferView(std::string parameterName, std::shared_ptr <GLTFBufferView>);
+        void registerBufferView(std::string parameterName, boost::shared_ptr <GLTFBufferView>);
         void unregisterBufferView(std::string parameterName);
 
-        std::shared_ptr<GLTFBufferView> getBufferViewForParameter(std::string);
+        boost::shared_ptr<GLTFBufferView> getBufferViewForParameter(std::string);
         
         void writeAnimationForTargetID(const std::string &targetID, GLTFAsset* asset);
         
     private:
         std::string _id;
         std::string _originalID;
-        std::shared_ptr <JSONObject> _targets;
+        boost::shared_ptr <JSONObject> _targets;
         AnimationFlattenerForTargetUIDSharedPtr _animationFlattenerForTargetUID;
-        std::map<std::string , std::shared_ptr<GLTFBufferView> > _bufferViews;
+        std::map<std::string , boost::shared_ptr<GLTFBufferView> > _bufferViews;
     };
     
 }
 
-#endif
\ No newline at end of file
+#endif
diff -ur collada2gltf.org/GLTF/GLTFAsset.cpp collada2gltf/GLTF/GLTFAsset.cpp
--- collada2gltf.org/GLTF/GLTFAsset.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFAsset.cpp	2014-09-29 15:58:18.418557209 +0200
@@ -14,21 +14,21 @@
 
 namespace GLTF
 {
-    bool writeMeshIndices(shared_ptr <GLTFMesh> mesh, size_t startOffset, GLTFAsset* asset) {
+    bool writeMeshIndices(boost::shared_ptr <GLTFMesh> mesh, size_t startOffset, GLTFAsset* asset) {
         GLTFOutputStream* indicesOutputStream = asset->createOutputStreamIfNeeded(asset->getSharedBufferId()).get();
-        typedef std::map<std::string , shared_ptr<GLTF::GLTFBuffer> > IDToBufferDef;
+        typedef std::map<std::string , boost::shared_ptr<GLTF::GLTFBuffer> > IDToBufferDef;
         IDToBufferDef IDToBuffer;
         
-        shared_ptr <MeshAttributeVector> allMeshAttributes = mesh->meshAttributes();
+        boost::shared_ptr <MeshAttributeVector> allMeshAttributes = mesh->meshAttributes();
         unsigned int indicesCount, allIndicesCount = 0;
         GLTF::JSONValueVector primitives = mesh->getPrimitives()->values();
         unsigned int primitivesCount =  (unsigned int)primitives.size();
         for (unsigned int i = 0 ; i < primitivesCount ; i++) {
-            shared_ptr<GLTF::GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
-            shared_ptr <GLTF::GLTFAccessor> uniqueIndices = primitive->getIndices();
+            boost::shared_ptr<GLTF::GLTFPrimitive> primitive = boost::static_pointer_cast<GLTFPrimitive>(primitives[i]);
+            boost::shared_ptr <GLTF::GLTFAccessor> uniqueIndices = primitive->getIndices();
 
             indicesCount = (unsigned int)uniqueIndices->getCount();
-            shared_ptr <GLTFBufferView> indicesBufferView = uniqueIndices->getBufferView();
+            boost::shared_ptr <GLTFBufferView> indicesBufferView = uniqueIndices->getBufferView();
             unsigned int* uniqueIndicesBuffer = (unsigned int*) indicesBufferView->getBufferDataByApplyingOffset();
             if (indicesCount > 0) {
                 allIndicesCount += indicesCount;
@@ -53,23 +53,23 @@
     }
     
     
-    bool writeMeshAttributes(shared_ptr <GLTFMesh> mesh, size_t startOffset, GLTFAsset* asset) {
+    bool writeMeshAttributes(boost::shared_ptr <GLTFMesh> mesh, size_t startOffset, GLTFAsset* asset) {
         GLTFOutputStream* vertexOutputStream = asset->createOutputStreamIfNeeded(asset->getSharedBufferId()).get();
-        typedef std::map<std::string , shared_ptr<GLTF::GLTFBuffer> > IDToBufferDef;
+        typedef std::map<std::string , boost::shared_ptr<GLTF::GLTFBuffer> > IDToBufferDef;
         IDToBufferDef IDToBuffer;
-        shared_ptr <MeshAttributeVector> allMeshAttributes = mesh->meshAttributes();
+        boost::shared_ptr <MeshAttributeVector> allMeshAttributes = mesh->meshAttributes();
         GLTF::JSONValueVector primitives = mesh->getPrimitives()->values();
         
-        shared_ptr<GLTFAccessor> positionAttribute = mesh->getMeshAttribute(GLTF::POSITION, 0);
+        boost::shared_ptr<GLTFAccessor> positionAttribute = mesh->getMeshAttribute(GLTF::POSITION, 0);
         size_t vertexCount = positionAttribute->getCount();
         unsigned int totalVerticesCount = asset->convertionResults()->getUnsignedInt32("verticesCount");
 		totalVerticesCount += (unsigned int)vertexCount;
         asset->convertionResults()->setUnsignedInt32("verticesCount", totalVerticesCount);
 
         for (unsigned int j = 0 ; j < allMeshAttributes->size() ; j++) {
-            shared_ptr <GLTFAccessor> meshAttribute = (*allMeshAttributes)[j];
-            shared_ptr <GLTFBufferView> bufferView = meshAttribute->getBufferView();
-            shared_ptr <GLTFBuffer> buffer = bufferView->getBuffer();
+            boost::shared_ptr <GLTFAccessor> meshAttribute = (*allMeshAttributes)[j];
+            boost::shared_ptr <GLTFBufferView> bufferView = meshAttribute->getBufferView();
+            boost::shared_ptr <GLTFBuffer> buffer = bufferView->getBuffer();
             
             if (!bufferView.get()) {
                 return false;
@@ -86,27 +86,27 @@
         return true;
     }
     
-    bool writeCompressedMesh(shared_ptr <GLTFMesh> mesh, GLTFAsset* asset) {
+    bool writeCompressedMesh(boost::shared_ptr <GLTFMesh> mesh, GLTFAsset* asset) {
         GLTFOutputStream* compressionOutputStream = asset->createOutputStreamIfNeeded(kCompressionOutputStream).get();
         
-        shared_ptr <JSONObject> floatAttributeIndexMapping(new JSONObject());
+        boost::shared_ptr <JSONObject> floatAttributeIndexMapping(new JSONObject());
 		unsigned compressedBufferStart = (unsigned int)compressionOutputStream->length();
         encodeOpen3DGCMesh(mesh, floatAttributeIndexMapping, asset);
-        typedef std::map<std::string , shared_ptr<GLTF::GLTFBuffer> > IDToBufferDef;
+        typedef std::map<std::string , boost::shared_ptr<GLTF::GLTFBuffer> > IDToBufferDef;
         IDToBufferDef IDToBuffer;
-        shared_ptr <MeshAttributeVector> allMeshAttributes = mesh->meshAttributes();
+        boost::shared_ptr <MeshAttributeVector> allMeshAttributes = mesh->meshAttributes();
         int vertexCount;
         unsigned int indicesCount, allIndicesCount = 0;
         GLTF::JSONValueVector primitives = mesh->getPrimitives()->values();
         unsigned int primitivesCount =  (unsigned int)primitives.size();
         for (unsigned int i = 0 ; i < primitivesCount ; i++) {
-            shared_ptr<GLTF::GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
-            shared_ptr <GLTF::GLTFAccessor> uniqueIndices = primitive->getIndices();
+            boost::shared_ptr<GLTF::GLTFPrimitive> primitive = boost::static_pointer_cast<GLTFPrimitive>(primitives[i]);
+            boost::shared_ptr <GLTF::GLTFAccessor> uniqueIndices = primitive->getIndices();
             /*
              Convert the indices to unsigned short and write the blob
              */
             indicesCount = (unsigned int)uniqueIndices->getCount();
-            shared_ptr <GLTFBufferView> indicesBufferView = uniqueIndices->getBufferView();
+            boost::shared_ptr <GLTFBufferView> indicesBufferView = uniqueIndices->getBufferView();
             if (indicesCount > 0) {
                 allIndicesCount += indicesCount;                
                 //FIXME: this is assuming triangles
@@ -119,16 +119,16 @@
             }
         }
         
-        shared_ptr<GLTFAccessor> positionAttribute = mesh->getMeshAttribute(GLTF::POSITION, 0);
+        boost::shared_ptr<GLTFAccessor> positionAttribute = mesh->getMeshAttribute(GLTF::POSITION, 0);
 		vertexCount = (unsigned int)positionAttribute->getCount();
         unsigned int totalVerticesCount = asset->convertionResults()->getUnsignedInt32("verticesCount");
         totalVerticesCount += vertexCount;
         asset->convertionResults()->setUnsignedInt32("verticesCount", totalVerticesCount);
 
         for (unsigned int j = 0 ; j < allMeshAttributes->size() ; j++) {
-            shared_ptr <GLTFAccessor> meshAttribute = (*allMeshAttributes)[j];
-            shared_ptr <GLTFBufferView> bufferView = meshAttribute->getBufferView();
-            shared_ptr <GLTFBuffer> buffer = bufferView->getBuffer();
+            boost::shared_ptr <GLTFAccessor> meshAttribute = (*allMeshAttributes)[j];
+            boost::shared_ptr <GLTFBufferView> bufferView = meshAttribute->getBufferView();
+            boost::shared_ptr <GLTFBuffer> buffer = bufferView->getBuffer();
             
             if (!bufferView.get()) { return false; }
             
@@ -150,25 +150,25 @@
     }
     
     GLTFAsset::GLTFAsset():_isBundle(false) {
-        this->_trackedResourcesPath = shared_ptr<JSONObject> (new JSONObject());
-        this->_trackedOutputResourcesPath = shared_ptr<JSONObject> (new JSONObject());
-        this->_converterConfig = shared_ptr<GLTFConfig> (new GLTFConfig());
-        this->_convertionResults = shared_ptr<JSONObject> (new JSONObject());
-        this->_originalResourcesPath = shared_ptr<JSONObject> (new JSONObject());
-        this->_convertionMetaData = shared_ptr<JSONObject> (new JSONObject());
-        this->_extras = shared_ptr<JSONObject> (new JSONObject());
-        this->_meshesForMaterialBindingKey = shared_ptr<JSONObject> (new JSONObject());
+        this->_trackedResourcesPath = boost::shared_ptr<JSONObject> (new JSONObject());
+        this->_trackedOutputResourcesPath = boost::shared_ptr<JSONObject> (new JSONObject());
+        this->_converterConfig = boost::shared_ptr<GLTFConfig> (new GLTFConfig());
+        this->_convertionResults = boost::shared_ptr<JSONObject> (new JSONObject());
+        this->_originalResourcesPath = boost::shared_ptr<JSONObject> (new JSONObject());
+        this->_convertionMetaData = boost::shared_ptr<JSONObject> (new JSONObject());
+        this->_extras = boost::shared_ptr<JSONObject> (new JSONObject());
+        this->_meshesForMaterialBindingKey = boost::shared_ptr<JSONObject> (new JSONObject());
 
         this->_prefix = 0;
         this->setGeometryByteLength(0);
         this->setAnimationByteLength(0);
     }
     
-    void GLTFAsset::setValueForUniqueId(const std::string& uniqueId, shared_ptr<JSONValue> obj) {
+    void GLTFAsset::setValueForUniqueId(const std::string& uniqueId, boost::shared_ptr<JSONValue> obj) {
         this->_uniqueIDToJSONValue[uniqueId] = obj;
     }
 
-    shared_ptr<JSONValue> GLTFAsset::getValueForUniqueId(const std::string& uniqueId) {
+    boost::shared_ptr<JSONValue> GLTFAsset::getValueForUniqueId(const std::string& uniqueId) {
         return this->_uniqueIDToJSONValue[uniqueId];
     }
     
@@ -189,13 +189,13 @@
         return this->_originalIDToUniqueID[original];
     }
 
-    shared_ptr<GLTFOutputStream> GLTFAsset::createOutputStreamIfNeeded(const std::string& streamName) {
+    boost::shared_ptr<GLTFOutputStream> GLTFAsset::createOutputStreamIfNeeded(const std::string& streamName) {
 
         if (this->_nameToOutputStream.count(streamName) == 0) {
             COLLADABU::URI outputURI(this->getOutputFilePath().c_str());
             
             std::string folder = COLLADABU::URI(outputURI.getPathDir()).toNativePath();
-            shared_ptr<GLTFOutputStream> outputStream = shared_ptr <GLTFOutputStream> (new GLTFOutputStream(folder, streamName, ""));
+            boost::shared_ptr<GLTFOutputStream> outputStream = boost::shared_ptr <GLTFOutputStream> (new GLTFOutputStream(folder, streamName, ""));
             this->_nameToOutputStream[streamName] = outputStream;
         }
         
@@ -205,7 +205,7 @@
     void GLTFAsset::closeOutputStream(const std::string& streamName, bool removeFile) {
         
         if (this->_nameToOutputStream.count(streamName) > 0) {
-            shared_ptr<GLTFOutputStream> outputStream = this->_nameToOutputStream[streamName];
+            boost::shared_ptr<GLTFOutputStream> outputStream = this->_nameToOutputStream[streamName];
             
             outputStream->close();
             if (removeFile) {
@@ -218,23 +218,23 @@
         }
     }
 
-    shared_ptr <GLTFConfig> GLTFAsset::converterConfig() {
+    boost::shared_ptr <GLTFConfig> GLTFAsset::converterConfig() {
         return this->_converterConfig;
     }
     
-    shared_ptr <JSONObject> GLTFAsset::convertionResults() {
+    boost::shared_ptr <JSONObject> GLTFAsset::convertionResults() {
         return this->_convertionResults;
     }
 
-    shared_ptr <JSONObject> GLTFAsset::convertionMetaData() {
+    boost::shared_ptr <JSONObject> GLTFAsset::convertionMetaData() {
         return this->_convertionMetaData;
     }
 
-    shared_ptr <GLTFProfile> GLTFAsset::profile() {
+    boost::shared_ptr <GLTFProfile> GLTFAsset::profile() {
         return this->_profile;
     }
     
-    shared_ptr <JSONObject> GLTFAsset::root() {
+    boost::shared_ptr <JSONObject> GLTFAsset::root() {
         return this->_root;
     }
     
@@ -359,12 +359,12 @@
     
     void GLTFAsset::copyImagesInsideBundleIfNeeded() {
         if (this->_isBundle == true) {
-            shared_ptr<JSONObject> images = this->_root->createObjectIfNeeded(kImages);
+            boost::shared_ptr<JSONObject> images = this->_root->createObjectIfNeeded(kImages);
             size_t imagesCount = images->getKeysCount();
             if (imagesCount > 0) {
                 std::vector <std::string> keys = images->getAllKeys();
                 for (size_t i = 0 ; i < imagesCount ; i++) {
-                    shared_ptr<JSONObject> image = images->getObject(keys[i]);
+                    boost::shared_ptr<JSONObject> image = images->getObject(keys[i]);
                     std::string path = image->getString("path");
                     
                     std::string originalPath = this->_originalResourcesPath->getString(path);
@@ -390,9 +390,9 @@
         }
     }
     
-    void GLTFAsset::prepareForProfile(shared_ptr<GLTFProfile> profile) {
+    void GLTFAsset::prepareForProfile(boost::shared_ptr<GLTFProfile> profile) {
         this->_profile = profile;
-        this->_root = shared_ptr <GLTF::JSONObject> (new GLTF::JSONObject());
+        this->_root = boost::shared_ptr <GLTF::JSONObject> (new GLTF::JSONObject());
         this->_root->createObjectIfNeeded(kNodes);
         
         COLLADABU::URI outputURI(this->getOutputFilePath().c_str());
@@ -414,7 +414,7 @@
     
     void GLTFAsset::launchModifiers() {
         for (size_t i = 0 ; i < this->_assetModifiers.size() ; i++) {
-            shared_ptr<GLTFAssetModifier> assetModifier = this->_assetModifiers[i];
+            boost::shared_ptr<GLTFAssetModifier> assetModifier = this->_assetModifiers[i];
             
             assetModifier->init();
             assetModifier->modify(this->_root);
@@ -422,7 +422,7 @@
         }
     }
     
-    void GLTFAsset::_writeJSONResource(const std::string &path, shared_ptr<JSONObject> obj) {
+    void GLTFAsset::_writeJSONResource(const std::string &path, boost::shared_ptr<JSONObject> obj) {
         GLTF::GLTFWriter resultsWriter;
         COLLADABU::URI outputURI(this->resourceOuputPathForPath(path));
         std::string aPath = COLLADABU::URI(this->getOutputFolderPath() + outputURI.getPathFile()).toNativePath();
@@ -435,83 +435,83 @@
     }
     
     
-    shared_ptr<JSONObject> GLTFAsset::getExtras() {
+    boost::shared_ptr<JSONObject> GLTFAsset::getExtras() {
         return this->_extras;
     }
     
-    void GLTFAsset::setExtras(shared_ptr<JSONObject> extras) {
+    void GLTFAsset::setExtras(boost::shared_ptr<JSONObject> extras) {
         this->_extras = extras;
     }
 
-    static shared_ptr <GLTF::JSONObject> serializeAttributeSemanticsForPrimitiveAtIndex(GLTFMesh* mesh, unsigned int idx) {
-        shared_ptr <GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(mesh->getPrimitives()->values()[idx]);
+    static boost::shared_ptr <GLTF::JSONObject> serializeAttributeSemanticsForPrimitiveAtIndex(GLTFMesh* mesh, unsigned int idx) {
+        boost::shared_ptr <GLTFPrimitive> primitive = boost::static_pointer_cast<GLTFPrimitive>(mesh->getPrimitives()->values()[idx]);
         
-        shared_ptr <GLTF::JSONObject> semantics(new GLTF::JSONObject());
-        shared_ptr<JSONArray> sets(new JSONArray());
+        boost::shared_ptr <GLTF::JSONObject> semantics(new GLTF::JSONObject());
+        boost::shared_ptr<JSONArray> sets(new JSONArray());
         
         size_t count = primitive->getVertexAttributesCount();
         for (size_t j = 0 ; j < count ; j++) {
             Semantic semantic = primitive->getSemanticAtIndex((unsigned int)j);
             std::string semanticString = GLTFUtils::getStringForSemantic(semantic);
             
-            shared_ptr<JSONObject> semanticInfo;
+            boost::shared_ptr<JSONObject> semanticInfo;
             if (semantics->contains(semanticString) == false) {
-                semanticInfo = shared_ptr<JSONObject> (new JSONObject());
+                semanticInfo = boost::shared_ptr<JSONObject> (new JSONObject());
                 semantics->setValue(semanticString, semanticInfo);
             }
             
             unsigned int indexOfSet = 0;
             indexOfSet = primitive->getIndexOfSetAtIndex((unsigned int)j);
             
-            sets->appendValue(shared_ptr<JSONNumber> (new JSONNumber(indexOfSet)));
+            sets->appendValue(boost::shared_ptr<JSONNumber> (new JSONNumber(indexOfSet)));
         }
         
         return semantics;
     }
 
-    static shared_ptr<GLTFEffect> createDefaultEffect(GLTFAsset* asset, shared_ptr <JSONObject> attributeSemantics, bool hasNormal) {
+    static boost::shared_ptr<GLTFEffect> createDefaultEffect(GLTFAsset* asset, boost::shared_ptr <JSONObject> attributeSemantics, bool hasNormal) {
         //we have no material, create default
-        shared_ptr<GLTFEffect> effect;
+        boost::shared_ptr<GLTFEffect> effect;
         std::string uniqueId = "__glTF__defaultMaterial";
         uniqueId += hasNormal ? "0" : "1";
         
-        effect = shared_ptr<GLTFEffect> (new GLTFEffect(uniqueId));
-        shared_ptr <JSONObject> values(new JSONObject());
+        effect = boost::shared_ptr<GLTFEffect> (new GLTFEffect(uniqueId));
+        boost::shared_ptr <JSONObject> values(new JSONObject());
         
         effect->setValues(values);
         effect->setLightingModel("Phong");
         
         //retrieve the type, parameterName -> symbol -> type
         double red = 1, green = 1, blue = 1, alpha = 1;
-        shared_ptr <JSONObject> slotObject(new JSONObject());
+        boost::shared_ptr <JSONObject> slotObject(new JSONObject());
         slotObject->setValue("value", serializeVec4(red, green, blue, alpha));
         slotObject->setUnsignedInt32("type", asset->profile()->getGLenumForString("FLOAT_VEC4"));
         values->setValue("diffuse", slotObject);
         
-        shared_ptr<JSONObject> techniqueGenerator(new JSONObject());
+        boost::shared_ptr<JSONObject> techniqueGenerator(new JSONObject());
         
         techniqueGenerator->setString("lightingModel", effect->getLightingModel());
         techniqueGenerator->setValue("attributeSemantics", attributeSemantics);
         techniqueGenerator->setValue("values", effect->getValues());
-        techniqueGenerator->setValue("techniqueExtras", shared_ptr<JSONObject>(new JSONObject()));
-        techniqueGenerator->setValue("texcoordBindings", shared_ptr<JSONObject>(new JSONObject()));
+        techniqueGenerator->setValue("techniqueExtras", boost::shared_ptr<JSONObject>(new JSONObject()));
+        techniqueGenerator->setValue("texcoordBindings", boost::shared_ptr<JSONObject>(new JSONObject()));
         
         effect->setTechniqueGenerator(techniqueGenerator);
         effect->setName(uniqueId);
         return effect;
     }
     
-    static std::string buildKeyForMaterialBindingMap(shared_ptr <MaterialBindingsPrimitiveMap> materialBindingPrimitiveMap,
-                                                     shared_ptr<JSONObject> meshExtras) {
+    static std::string buildKeyForMaterialBindingMap(boost::shared_ptr <MaterialBindingsPrimitiveMap> materialBindingPrimitiveMap,
+                                                     boost::shared_ptr<JSONObject> meshExtras) {
         std::string materialBindingKey = "";
         size_t size = materialBindingPrimitiveMap->size();
         
         if (size > 0) {
             MaterialBindingsPrimitiveMap::const_iterator iterator;
             for (iterator = materialBindingPrimitiveMap->begin() ; iterator != materialBindingPrimitiveMap->end() ; iterator++) {
-                std::shared_ptr <COLLADAFW::MaterialBinding> materialBinding = iterator->second;
+                boost::shared_ptr <COLLADAFW::MaterialBinding> materialBinding = iterator->second;
                 materialBindingKey += materialBinding->getReferencedMaterial().toAscii();
-                if (meshExtras != nullptr) {
+                if (meshExtras != 0) {
                     if (meshExtras->contains("double_sided")) {
                         materialBindingKey += "doubleSided:1";
                     }
@@ -526,21 +526,21 @@
         return materialBindingKey;
     }
 
-    void GLTFAsset::_applyMaterialBindings(shared_ptr<GLTFMesh> mesh,
-                                           shared_ptr <MaterialBindingsPrimitiveMap> materialBindingsPrimitiveMap,
-                                           shared_ptr <JSONArray> meshesArray,
-                                           shared_ptr<JSONObject> meshExtras) {
+    void GLTFAsset::_applyMaterialBindings(boost::shared_ptr<GLTFMesh> mesh,
+                                           boost::shared_ptr <MaterialBindingsPrimitiveMap> materialBindingsPrimitiveMap,
+                                           boost::shared_ptr <JSONArray> meshesArray,
+                                           boost::shared_ptr<JSONObject> meshExtras) {
         
         std::string meshOriginalID = mesh->getID();
         if (materialBindingsPrimitiveMap) {
             std::string materialBindingKey = buildKeyForMaterialBindingMap(materialBindingsPrimitiveMap, meshExtras);
             if (this->_meshesForMaterialBindingKey->contains(meshOriginalID) == false) {
-                shared_ptr<JSONObject> meshesForBindingKey = _meshesForMaterialBindingKey->createObjectIfNeeded(meshOriginalID);
+                boost::shared_ptr<JSONObject> meshesForBindingKey = _meshesForMaterialBindingKey->createObjectIfNeeded(meshOriginalID);
                 meshesForBindingKey->setValue(materialBindingKey, mesh);
             } else {
-                shared_ptr<JSONObject> meshesForBindingKey = _meshesForMaterialBindingKey->getObject(meshOriginalID);
+                boost::shared_ptr<JSONObject> meshesForBindingKey = _meshesForMaterialBindingKey->getObject(meshOriginalID);
                 if (meshesForBindingKey->contains(materialBindingKey)) {
-                    meshesArray->appendValue(shared_ptr<JSONString>(new JSONString(meshOriginalID)));
+                    meshesArray->appendValue(boost::shared_ptr<JSONString>(new JSONString(meshOriginalID)));
                     return;
                 } else {
                     mesh = mesh->clone();
@@ -553,25 +553,25 @@
         
         GLTF::JSONValueVector primitives = mesh->getPrimitives()->values();
         for (size_t j = 0 ; j < primitives.size() ; j++) {
-            shared_ptr <GLTFEffect> effect = nullptr;
-            shared_ptr<JSONObject> materials = this->root()->createObjectIfNeeded(kMaterials);
-            shared_ptr <GLTF::GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[j]);
+            boost::shared_ptr <GLTFEffect> effect;
+            boost::shared_ptr<JSONObject> materials = this->root()->createObjectIfNeeded(kMaterials);
+            boost::shared_ptr <GLTF::GLTFPrimitive> primitive = boost::static_pointer_cast<GLTFPrimitive>(primitives[j]);
             
             if (materialBindingsPrimitiveMap->count(primitive->getMaterialObjectID()) > 0) {
                 COLLADAFW::MaterialBinding *materialBinding =  (*materialBindingsPrimitiveMap)[primitive->getMaterialObjectID()].get();
-                shared_ptr<JSONObject> texcoordBindings(new JSONObject());
+                boost::shared_ptr<JSONObject> texcoordBindings(new JSONObject());
                 std::string referencedMaterialID = materialBinding->getReferencedMaterial().toAscii();
                 
                 /* will be needed to get semantic & set association to create the shader */
                 const COLLADAFW::TextureCoordinateBindingArray &textureCoordBindings = materialBinding->getTextureCoordinateBindingArray();
                 COLLADAFW::UniqueId effectUID = this->_materialUIDToEffectUID[referencedMaterialID];
                 std::string effectID = effectUID.toAscii();
-                shared_ptr<JSONObject> effectExtras = this->_extras->contains(effectID) ? this->_extras->getObject(effectID) : nullptr;
+                boost::shared_ptr<JSONObject> effectExtras = this->_extras->contains(effectID) ? this->_extras->getObject(effectID) : boost::shared_ptr<JSONObject>();
                 
                 std::string materialName = this->_materialUIDToName[referencedMaterialID];
                 
                 if (this->containsValueForUniqueId(effectID)) {
-                    effect = static_pointer_cast<GLTFEffect>(this->getValueForUniqueId(effectID));
+                    effect = boost::static_pointer_cast<GLTFEffect>(this->getValueForUniqueId(effectID));
                 }
                 
                 // retrieve the semantic to be associated
@@ -600,7 +600,7 @@
                             for (size_t semanticIndex = 0 ; semanticIndex < semanticArrayPtr->size() ; semanticIndex++){
                                 std::string slot = (*semanticArrayPtr)[semanticIndex];
                                 texcoordBindings->setString(slot, shaderSemantic);
-                                if (effectExtras != nullptr) {
+                                if (effectExtras != 0) {
                                     if ((slot == "diffuse") && effectExtras->getBool("ambient_diffuse_lock")) {
                                         texcoordBindings->setString("ambient", shaderSemantic);
                                     }
@@ -610,8 +610,8 @@
                     }
                 }
                 unsigned int jointsCount = 0;
-                shared_ptr<JSONObject> techniqueExtras(new JSONObject());
-                if (meshExtras != nullptr) {
+                boost::shared_ptr<JSONObject> techniqueExtras(new JSONObject());
+                if (meshExtras != 0) {
                     if (meshExtras->contains("double_sided")) {
                         techniqueExtras->setBool("double_sided", meshExtras->getBool("double_sided"));
                     }
@@ -621,13 +621,13 @@
                     }
                 }
                 
-                if ((effectExtras != nullptr) && effectExtras->contains("double_sided")) {
+                if ((effectExtras != 0) && effectExtras->contains("double_sided")) {
                     techniqueExtras->setBool("double_sided", effectExtras->getBool("double_sided"));
                 }
                 
                 //generate shaders if needed
-                shared_ptr <JSONObject> attributeSemantics = serializeAttributeSemanticsForPrimitiveAtIndex(mesh.get(), (unsigned int)j);
-                shared_ptr<JSONObject> techniqueGenerator(new JSONObject());
+                boost::shared_ptr <JSONObject> attributeSemantics = serializeAttributeSemanticsForPrimitiveAtIndex(mesh.get(), (unsigned int)j);
+                boost::shared_ptr<JSONObject> techniqueGenerator(new JSONObject());
                 
                 techniqueGenerator->setString("lightingModel", effect->getLightingModel());
                 techniqueGenerator->setValue("attributeSemantics", attributeSemantics);
@@ -635,13 +635,13 @@
                 techniqueGenerator->setValue("techniqueExtras", techniqueExtras);
                 techniqueGenerator->setValue("texcoordBindings", texcoordBindings);
                 
-                if (effect->getTechniqueGenerator() != nullptr) {
+                if (effect->getTechniqueGenerator() != 0) {
                     //here we have the same material that shared by different meshes.
                     //some of these meshes have different number of bones
                     //so, we'll have to clone the effect
                     std::string techniqueKey = getTechniqueKey(techniqueGenerator, this);
                     if (getTechniqueKey(effect->getTechniqueGenerator(), this) != techniqueKey) {
-                        shared_ptr<GLTFEffect> effectCopy = shared_ptr <GLTFEffect> (new GLTFEffect(*effect));
+                        boost::shared_ptr<GLTFEffect> effectCopy = boost::shared_ptr <GLTFEffect> (new GLTFEffect(*effect));
                         effectCopy->setID(effect->getID() + "-variant-" + GLTFUtils::toString(materials->getKeysCount()));
                         effect = effectCopy;
                         if (materials->contains(effect->getID()) == false) {
@@ -656,10 +656,10 @@
                 //https://github.com/KhronosGroup/glTF/issues/194
                 //We'll deal with two cases cases of default materials
                 //With or without NORMALS
-                shared_ptr <JSONObject> attributeSemantics = serializeAttributeSemanticsForPrimitiveAtIndex(mesh.get(), (unsigned int)j);
+                boost::shared_ptr <JSONObject> attributeSemantics = serializeAttributeSemanticsForPrimitiveAtIndex(mesh.get(), (unsigned int)j);
                 
-                static shared_ptr<GLTFEffect> defaultEffectNoNormal = createDefaultEffect(this, attributeSemantics, false);
-                static shared_ptr<GLTFEffect> defaultEffectWithNormal = createDefaultEffect(this, attributeSemantics, true);
+                static boost::shared_ptr<GLTFEffect> defaultEffectNoNormal = createDefaultEffect(this, attributeSemantics, false);
+                static boost::shared_ptr<GLTFEffect> defaultEffectWithNormal = createDefaultEffect(this, attributeSemantics, true);
                 
                 bool hasNormal = attributeSemantics->contains(GLTFUtils::getStringForSemantic(GLTF::NORMAL));
                 
@@ -672,7 +672,7 @@
                 }
             }
         }
-        meshesArray->appendValue(shared_ptr<JSONString>(new JSONString(meshOriginalID)));
+        meshesArray->appendValue(boost::shared_ptr<JSONString>(new JSONString(meshOriginalID)));
     }
     
     bool GLTFAsset::_applyMaterialBindingsForNode(const std::string &nodeUID) {
@@ -680,25 +680,25 @@
         if (this->containsValueForUniqueId(nodeUID) == false)
             return false;
         
-        shared_ptr <JSONObject> node = static_pointer_cast<JSONObject>(this->getValueForUniqueId(nodeUID));
+        boost::shared_ptr <JSONObject> node = boost::static_pointer_cast<JSONObject>(this->getValueForUniqueId(nodeUID));
         
-        shared_ptr <MaterialBindingsForMeshUID> materialBindings = this->_materialBindingsForNodeUID.count(nodeUID) > 0 ? this->_materialBindingsForNodeUID[nodeUID] : nullptr;
+        boost::shared_ptr <MaterialBindingsForMeshUID> materialBindings = this->_materialBindingsForNodeUID.count(nodeUID) > 0 ? this->_materialBindingsForNodeUID[nodeUID] : boost::shared_ptr <MaterialBindingsForMeshUID>();
         
-        if (materialBindings == nullptr)
+        if (materialBindings == 0)
             return false;
         
         size_t jointsCount = 0;
         if (node->contains(kInstanceSkin)) {
-            shared_ptr <JSONObject> instanceSkin = node->getObject(kInstanceSkin);
+            boost::shared_ptr <JSONObject> instanceSkin = node->getObject(kInstanceSkin);
             if (instanceSkin->contains(kSkin)) {
                 std::string skinOriginalID = instanceSkin->getString(kSkin);
-                shared_ptr <JSONObject> skins = this->_root->createObjectIfNeeded(kSkins);
+                boost::shared_ptr <JSONObject> skins = this->_root->createObjectIfNeeded(kSkins);
                 std::vector <std::string> skinUIDs = skins->getAllKeys();
-                shared_ptr <GLTFSkin> skin = static_pointer_cast<GLTFSkin>(skins->getObject(skinOriginalID) );
+                boost::shared_ptr <GLTFSkin> skin = boost::static_pointer_cast<GLTFSkin>(skins->getObject(skinOriginalID) );
                 jointsCount = skin->getJointsCount();
             }
         }
-        shared_ptr <JSONArray> meshesArray = nullptr;
+        boost::shared_ptr <JSONArray> meshesArray;
 
         MaterialBindingsForMeshUID::const_iterator materialBindingsIterator;
         for (materialBindingsIterator = materialBindings->begin() ; materialBindingsIterator != materialBindings->end() ; materialBindingsIterator++) {
@@ -723,28 +723,28 @@
             } else if (meshUID.find(meshesInSkinningPrefix) == 0) {
                 assert(node->contains(kInstanceSkin));
                 meshesInSkinning = true;
-                shared_ptr<JSONObject> instanceSkin = node->getObject(kInstanceSkin);
+                boost::shared_ptr<JSONObject> instanceSkin = node->getObject(kInstanceSkin);
                 meshUID = meshUID.substr(meshesInSkinningPrefix.length());
                 meshesArray = instanceSkin->createArrayIfNeeded(kSources);
             }
             
             assert(meshesInSkinning || meshesInNode);
 
-            shared_ptr <MaterialBindingsPrimitiveMap> materialBindingsPrimitiveMap = (*materialBindingsIterator).second;
-            shared_ptr<JSONObject> meshExtras = this->_extras->contains(meshUID) ? this->_extras->getObject(meshUID) : nullptr;
+            boost::shared_ptr <MaterialBindingsPrimitiveMap> materialBindingsPrimitiveMap = (*materialBindingsIterator).second;
+            boost::shared_ptr<JSONObject> meshExtras = this->_extras->contains(meshUID) ? this->_extras->getObject(meshUID) : boost::shared_ptr<JSONObject>();
             
             if (jointsCount > 0) {
-                if (meshExtras == nullptr)
-                    meshExtras = shared_ptr <JSONObject> (new JSONObject());
+                if (meshExtras == 0)
+                    meshExtras = boost::shared_ptr <JSONObject> (new JSONObject());
                 meshExtras->setUnsignedInt32("jointsCount", jointsCount);
             }
             
-            shared_ptr<GLTFMesh> mesh = static_pointer_cast<GLTFMesh>(this->getValueForUniqueId(meshUID));
+            boost::shared_ptr<GLTFMesh> mesh = boost::static_pointer_cast<GLTFMesh>(this->getValueForUniqueId(meshUID));
             
             this->_applyMaterialBindings(mesh, materialBindingsPrimitiveMap, meshesArray, meshExtras);
             JSONValueVectorRef subMeshes = mesh->subMeshes()->values();
             for (size_t subMeshIndex = 0 ; subMeshIndex < subMeshes.size() ; subMeshIndex++) {
-                this->_applyMaterialBindings(static_pointer_cast<GLTFMesh>(subMeshes[subMeshIndex]), materialBindingsPrimitiveMap, meshesArray, meshExtras);
+                this->_applyMaterialBindings(boost::static_pointer_cast<GLTFMesh>(subMeshes[subMeshIndex]), materialBindingsPrimitiveMap, meshesArray, meshExtras);
             }
         }
         
@@ -765,16 +765,16 @@
 
         }
         
-        shared_ptr<GLTFOutputStream> rawOutputStream = this->createOutputStreamIfNeeded(this->getSharedBufferId());
-        shared_ptr<GLTFOutputStream> compressionOutputStream = this->createOutputStreamIfNeeded(kCompressionOutputStream);
+        boost::shared_ptr<GLTFOutputStream> rawOutputStream = this->createOutputStreamIfNeeded(this->getSharedBufferId());
+        boost::shared_ptr<GLTFOutputStream> compressionOutputStream = this->createOutputStreamIfNeeded(kCompressionOutputStream);
 
-        shared_ptr <GLTF::JSONObject> animations = this->_root->createObjectIfNeeded("animations");
+        boost::shared_ptr <GLTF::JSONObject> animations = this->_root->createObjectIfNeeded("animations");
         std::vector <std::string> animationsUIDs = animations->getAllKeys();
         
         for (size_t animationIndex = 0 ; animationIndex < animationsUIDs.size() ; animationIndex++) {
             std::string inputParameterName = "TIME";
-            shared_ptr<GLTFAnimation> animation = static_pointer_cast<GLTFAnimation>(animations->getObject(animationsUIDs[animationIndex]));
-            shared_ptr<GLTFBufferView> timeBufferView = animation->getBufferViewForParameter(inputParameterName);
+            boost::shared_ptr<GLTFAnimation> animation = boost::static_pointer_cast<GLTFAnimation>(animations->getObject(animationsUIDs[animationIndex]));
+            boost::shared_ptr<GLTFBufferView> timeBufferView = animation->getBufferViewForParameter(inputParameterName);
             
             if (animation->parameters()->contains(inputParameterName) == false) {
                 setupAndWriteAnimationParameter(animation.get(),
@@ -789,7 +789,7 @@
             std::vector<GLTFAnimationFlattener*> flatteners;
             for (size_t i = 0 ; i < allTargets.size() ; i++) {
                 std::string targetID = allTargets[i];
-                shared_ptr<GLTFAnimationFlattener> animationFlattener = animation->animationFlattenerForTargetUID(targetID);
+                boost::shared_ptr<GLTFAnimationFlattener> animationFlattener = animation->animationFlattenerForTargetUID(targetID);
                 if (std::find(flatteners.begin(), flatteners.end(), animationFlattener.get()) != flatteners.end()) {
                     continue;
                 }
@@ -800,25 +800,25 @@
             animations->removeValue(animationsUIDs[animationIndex]);
         }
         
-        shared_ptr <GLTF::JSONObject> meshes = this->_root->createObjectIfNeeded(kMeshes);
-        shared_ptr <GLTF::JSONObject> accessors = this->_root->createObjectIfNeeded(kAccessors);
+        boost::shared_ptr <GLTF::JSONObject> meshes = this->_root->createObjectIfNeeded(kMeshes);
+        boost::shared_ptr <GLTF::JSONObject> accessors = this->_root->createObjectIfNeeded(kAccessors);
         
         std::vector <std::string> meshesUIDs = meshes->getAllKeys();
         
         //here we will split meshes as needed or just pass through
         for (size_t i = 0 ; i < meshesUIDs.size() ; i++) {
             const std::string &meshUID = meshesUIDs[i];
-            shared_ptr<GLTFMesh> mesh = static_pointer_cast<GLTFMesh>(meshes->getObject(meshUID));
+            boost::shared_ptr<GLTFMesh> mesh = boost::static_pointer_cast<GLTFMesh>(meshes->getObject(meshUID));
             if (mesh) {
-                shared_ptr<GLTFMesh> targetMesh = createMeshWithMaximumIndicesCountFromMeshIfNeeded(mesh.get(), 65535, this->profile());
-                if (targetMesh != nullptr) {
+                boost::shared_ptr<GLTFMesh> targetMesh = createMeshWithMaximumIndicesCountFromMeshIfNeeded(mesh.get(), 65535, this->profile());
+                if (targetMesh != 0) {
                     meshes->setValue(targetMesh->getID(), targetMesh);
                     this->setValueForUniqueId(this->getUniqueId(targetMesh->getID()), targetMesh);
                     JSONValueVectorRef meshesVector = targetMesh->subMeshes()->values();
                     size_t meshesCount = meshesVector.size();
                     if (meshesCount > 0) {
                         for (size_t j = 0 ; j < meshesCount ; j++) {
-                            mesh = static_pointer_cast<GLTFMesh>(meshesVector[j]);
+                            mesh = boost::static_pointer_cast<GLTFMesh>(meshesVector[j]);
                             meshes->setValue(mesh->getID(), mesh);
                         }
                     }
@@ -827,10 +827,10 @@
         }
         
         // ----
-        shared_ptr <GLTF::JSONObject> skins = this->_root->createObjectIfNeeded(kSkins);
+        boost::shared_ptr <GLTF::JSONObject> skins = this->_root->createObjectIfNeeded(kSkins);
         std::vector <std::string> skinsUIDs = skins->getAllKeys();
         for (size_t skinIndex = 0 ; skinIndex < skinsUIDs.size() ; skinIndex++) {
-            shared_ptr <GLTFSkin> skin = static_pointer_cast<GLTFSkin>(skins->getObject(skinsUIDs[skinIndex]));
+            boost::shared_ptr <GLTFSkin> skin = boost::static_pointer_cast<GLTFSkin>(skins->getObject(skinsUIDs[skinIndex]));
             skins->setValue(skin->getId(), skin);
             skins->removeValue(skinsUIDs[skinIndex]);
         }
@@ -840,7 +840,7 @@
         //Handle late binding of material in node
         //So we go through all nodes and if a mesh got different bindings than the ones needed we clone the "reference" mesh and assign the binding
         //we delay this operation to now, so that we get the reference mesh splitted.
-        shared_ptr <GLTF::JSONObject> nodes = this->root()->createObjectIfNeeded(kNodes);
+        boost::shared_ptr <GLTF::JSONObject> nodes = this->root()->createObjectIfNeeded(kNodes);
         
         std::vector <std::string> nodesOriginalIds = nodes->getAllKeys();
         for (size_t i = 0 ; i < nodesOriginalIds.size() ; i++) {
@@ -851,14 +851,14 @@
         meshesUIDs = meshes->getAllKeys();
         
         for (size_t i = 0 ; i < meshesUIDs.size() ; i++) {
-            shared_ptr<GLTFMesh> mesh = static_pointer_cast<GLTFMesh>(meshes->getObject(meshesUIDs[i]));
+            boost::shared_ptr<GLTFMesh> mesh = boost::static_pointer_cast<GLTFMesh>(meshes->getObject(meshesUIDs[i]));
             mesh->resolveAttributes();
             GLTF::JSONValueVector primitives = mesh->getPrimitives()->values();
             unsigned int primitivesCount =  (unsigned int)primitives.size();
             //WORK-AROUND: we don't want meshes without material, which can happen if a mesh is not associated with a node.
             //In this case, the material binding - isn't resolved.
             for (unsigned int k = 0 ; k < primitivesCount ; k++) {
-                shared_ptr<GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[k]);
+                boost::shared_ptr<GLTFPrimitive> primitive = boost::static_pointer_cast<GLTFPrimitive>(primitives[k]);
                 if (primitive->contains(kMaterial) ==  false) {
                     meshes->removeValue(mesh->getID());
                     break;
@@ -871,16 +871,16 @@
 
         // ----
         
-        shared_ptr <GLTF::JSONObject> materials = this->_root->createObjectIfNeeded(kMaterials);
+        boost::shared_ptr <GLTF::JSONObject> materials = this->_root->createObjectIfNeeded(kMaterials);
         vector <std::string> materialUIDs = materials->getAllKeys();
         for (size_t i = 0 ; i < materialUIDs.size() ; i++) {
-            shared_ptr <GLTF::GLTFEffect> material = static_pointer_cast<GLTFEffect>(materials->getObject(materialUIDs[i]));
+            boost::shared_ptr <GLTF::GLTFEffect> material = boost::static_pointer_cast<GLTFEffect>(materials->getObject(materialUIDs[i]));
             if (!material->getTechniqueGenerator()) {
                 materials->removeValue(material->getID());
             }
         }
         
-        this->assetModifiers().push_back(shared_ptr<GLTFFlipUVModifier> (new GLTFFlipUVModifier()));
+        this->assetModifiers().push_back(boost::shared_ptr<GLTFFlipUVModifier> (new GLTFFlipUVModifier()));
         
         this->launchModifiers();
         
@@ -891,17 +891,17 @@
                 
         //save all meshes as compressed
         for (size_t i = 0 ; i < meshesUIDs.size() ; i++) {
-            shared_ptr<GLTFMesh> mesh = static_pointer_cast<GLTFMesh>(meshes->getObject(meshesUIDs[i]));
+            boost::shared_ptr<GLTFMesh> mesh = boost::static_pointer_cast<GLTFMesh>(meshes->getObject(meshesUIDs[i]));
             bool compressMesh = (CONFIG_STRING(this, "compressionType") == "Open3DGC") && canEncodeOpen3DGCMesh(mesh,this->_profile);
             if (compressMesh)
                 writeCompressedMesh(mesh, this);
         }
         size_t compressionLength = compressionOutputStream->length();
-        shared_ptr <GLTFBuffer> compressionBuffer(new GLTFBuffer(compressionOutputStream->id(), compressionLength));
+        boost::shared_ptr <GLTFBuffer> compressionBuffer(new GLTFBuffer(compressionOutputStream->id(), compressionLength));
         
         //save all indices
         for (size_t i = 0 ; i < meshesUIDs.size() ; i++) {
-            shared_ptr<GLTFMesh> mesh = static_pointer_cast<GLTFMesh>(meshes->getObject(meshesUIDs[i]));
+            boost::shared_ptr<GLTFMesh> mesh = boost::static_pointer_cast<GLTFMesh>(meshes->getObject(meshesUIDs[i]));
             bool compressMesh = (CONFIG_STRING(this, "compressionType") == "Open3DGC") && canEncodeOpen3DGCMesh(mesh,this->_profile);
             if (!compressMesh)
                 writeMeshIndices(mesh, previousLength, this);
@@ -922,7 +922,7 @@
         
         //save all mesh attributes
         for (size_t i = 0 ; i < meshesUIDs.size() ; i++) {
-            shared_ptr<GLTFMesh> mesh = static_pointer_cast<GLTFMesh>(meshes->getObject(meshesUIDs[i]));
+            boost::shared_ptr<GLTFMesh> mesh = boost::static_pointer_cast<GLTFMesh>(meshes->getObject(meshesUIDs[i]));
             bool compressMesh = (CONFIG_STRING(this, "compressionType") == "Open3DGC") && canEncodeOpen3DGCMesh(mesh,this->_profile);
             if (!compressMesh)
                 writeMeshAttributes(mesh, previousLength, this);
@@ -930,17 +930,17 @@
         verticesLength = rawOutputStream->length() - previousLength;
         previousLength = rawOutputStream->length();
 
-        shared_ptr <GLTFBuffer> sharedBuffer(new GLTFBuffer(this->getSharedBufferId(), verticesLength + indicesLength + animationLength));
+        boost::shared_ptr <GLTFBuffer> sharedBuffer(new GLTFBuffer(this->getSharedBufferId(), verticesLength + indicesLength + animationLength));
 
         //---
-        shared_ptr <GLTFBufferView> genericBufferView(new GLTFBufferView(sharedBuffer, 0, animationLength));
-        shared_ptr <GLTFBufferView> indicesBufferView(new GLTFBufferView(sharedBuffer, animationLength, indicesLength));
-        shared_ptr <GLTFBufferView> verticesBufferView(new GLTFBufferView(sharedBuffer, indicesLength + animationLength, verticesLength));
-        shared_ptr <GLTFBufferView> compressionBufferView(new GLTFBufferView(compressionBuffer, 0, compressionLength));
+        boost::shared_ptr <GLTFBufferView> genericBufferView(new GLTFBufferView(sharedBuffer, 0, animationLength));
+        boost::shared_ptr <GLTFBufferView> indicesBufferView(new GLTFBufferView(sharedBuffer, animationLength, indicesLength));
+        boost::shared_ptr <GLTFBufferView> verticesBufferView(new GLTFBufferView(sharedBuffer, indicesLength + animationLength, verticesLength));
+        boost::shared_ptr <GLTFBufferView> compressionBufferView(new GLTFBufferView(compressionBuffer, 0, compressionLength));
         
         // ----
         for (size_t i = 0 ; i < meshesUIDs.size() ; i++) {
-            shared_ptr<GLTFMesh> mesh = static_pointer_cast<GLTFMesh>(meshes->getObject(meshesUIDs[i]));
+            boost::shared_ptr<GLTFMesh> mesh = boost::static_pointer_cast<GLTFMesh>(meshes->getObject(meshesUIDs[i]));
             
             GLTF::JSONValueVector primitives = mesh->getPrimitives()->values();
             
@@ -956,7 +956,7 @@
                 size_t attributesCount = mesh->getMeshAttributesCountForSemantic(semantic);
                 
                 for (size_t j = 0 ; j < attributesCount ; j++) {
-                    shared_ptr <GLTF::GLTFAccessor> meshAttribute = mesh->getMeshAttribute(semantic, j);
+                    boost::shared_ptr <GLTF::GLTFAccessor> meshAttribute = mesh->getMeshAttribute(semantic, j);
                     
                     meshAttribute->setBufferView(isCompressed ? compressionBufferView : verticesBufferView);
                     accessors->setValue(meshAttribute->getID(), meshAttribute);
@@ -966,8 +966,8 @@
             //serialize indices
             unsigned int primitivesCount =  (unsigned int)primitives.size();
             for (size_t k = 0 ; k < primitivesCount ; k++) {
-                shared_ptr<GLTF::GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[k]);
-                shared_ptr <GLTF::GLTFAccessor> uniqueIndices =  primitive->getIndices();
+                boost::shared_ptr<GLTF::GLTFPrimitive> primitive = boost::static_pointer_cast<GLTFPrimitive>(primitives[k]);
+                boost::shared_ptr <GLTF::GLTFAccessor> uniqueIndices =  primitive->getIndices();
                 
                 GLTFBufferView *bufferView = isCompressed ? (GLTFBufferView*)compressionBufferView.get() : (GLTFBufferView*)indicesBufferView.get();
                 
@@ -978,7 +978,7 @@
             
             //set the compression buffer view
             if (mesh->contains(kExtensions)) {
-                shared_ptr<JSONObject> compressionData = static_pointer_cast<JSONObject>(mesh->valueForKeyPath("extensions.Open3DGC-compression.compressedData"));
+                boost::shared_ptr<JSONObject> compressionData = boost::static_pointer_cast<JSONObject>(mesh->valueForKeyPath("extensions.Open3DGC-compression.compressedData"));
                 if (compressionData) {
                     compressionData->setString(kBufferView, compressionBufferView->getID());
                 }
@@ -987,21 +987,21 @@
 
         // ----
         for (size_t skinIndex = 0 ; skinIndex < skinsUIDs.size() ; skinIndex++) {
-            shared_ptr <GLTFSkin> skin = static_pointer_cast<GLTFSkin>(skins->getObject(skinsUIDs[skinIndex]));
-            shared_ptr<JSONArray> joints = skin->getJointsIds();
-            shared_ptr<JSONArray> jointsWithOriginalSids(new JSONArray());
+            boost::shared_ptr <GLTFSkin> skin = boost::static_pointer_cast<GLTFSkin>(skins->getObject(skinsUIDs[skinIndex]));
+            boost::shared_ptr<JSONArray> joints = skin->getJointsIds();
+            boost::shared_ptr<JSONArray> jointsWithOriginalSids(new JSONArray());
             
             //resolve the sid and use the original ones
-            std::vector <shared_ptr <JSONValue> > values = joints->values();
+            std::vector <boost::shared_ptr <JSONValue> > values = joints->values();
             for (size_t i = 0 ; i < values.size() ; i++) {
-                shared_ptr<JSONString> jointId = static_pointer_cast<JSONString>(values[i]);
-                shared_ptr<JSONObject> node = static_pointer_cast<JSONObject>(this->_uniqueIDToJSONValue[jointId->getString()]);
+                boost::shared_ptr<JSONString> jointId = boost::static_pointer_cast<JSONString>(values[i]);
+                boost::shared_ptr<JSONObject> node = boost::static_pointer_cast<JSONObject>(this->_uniqueIDToJSONValue[jointId->getString()]);
                 if (node->contains("jointId")) {
-                    jointsWithOriginalSids->appendValue(static_pointer_cast <JSONValue> (node->getValue("jointId")));
+                    jointsWithOriginalSids->appendValue(boost::static_pointer_cast <JSONValue> (node->getValue("jointId")));
                 }
             }
             skin->setJointsIds(jointsWithOriginalSids);
-            shared_ptr <JSONObject> inverseBindMatrices = static_pointer_cast<JSONObject>(skin->extras()->getValue(kInverseBindMatrices));
+            boost::shared_ptr <JSONObject> inverseBindMatrices = boost::static_pointer_cast<JSONObject>(skin->extras()->getValue(kInverseBindMatrices));
             inverseBindMatrices->setString(kBufferView, genericBufferView->getID());
             skin->setValue(kInverseBindMatrices, inverseBindMatrices);
         }
@@ -1009,14 +1009,14 @@
         // ----
         animationsUIDs = animations->getAllKeys();
         for (size_t animationIndex = 0 ; animationIndex < animationsUIDs.size() ; animationIndex++) {
-            shared_ptr<GLTFAnimation> animation = static_pointer_cast<GLTFAnimation>(animations->getObject(animationsUIDs[animationIndex]));
-            shared_ptr<JSONObject> parameters = animation->parameters();
+            boost::shared_ptr<GLTFAnimation> animation = boost::static_pointer_cast<GLTFAnimation>(animations->getObject(animationsUIDs[animationIndex]));
+            boost::shared_ptr<JSONObject> parameters = animation->parameters();
             
             //Replace OpenCOLLADA uniqueID by Original IDs
-            shared_ptr <JSONArray> channels = animation->channels();
+            boost::shared_ptr <JSONArray> channels = animation->channels();
             for (size_t i = 0 ; i < channels->values().size() ; i++) {
-                shared_ptr<JSONObject> channel = static_pointer_cast<JSONObject>(channels->values()[i]);
-                shared_ptr<JSONObject> target = channel->getObject(kTarget);
+                boost::shared_ptr<JSONObject> channel = boost::static_pointer_cast<JSONObject>(channels->values()[i]);
+                boost::shared_ptr<JSONObject> target = channel->getObject(kTarget);
                 std::string originalID = this->_uniqueIDToOriginalID[target->getString("id")];
                 target->setString("id", originalID);
             }
@@ -1024,8 +1024,8 @@
             std::vector <std::string> parameterKeys = parameters->getAllKeys();
             for (size_t i = 0 ; i <parameterKeys.size() ; i++) {
                 std::string parameterUID = parameters->getString(parameterKeys[i]);
-                shared_ptr <JSONObject> parameterObject = accessors->getObject(parameterUID);
-                shared_ptr <JSONObject> compressedData = static_pointer_cast<JSONObject>(parameterObject->valueForKeyPath("extensions.Open3DGC-compression.compressedData"));
+                boost::shared_ptr <JSONObject> parameterObject = accessors->getObject(parameterUID);
+                boost::shared_ptr <JSONObject> compressedData = boost::static_pointer_cast<JSONObject>(parameterObject->valueForKeyPath("extensions.Open3DGC-compression.compressedData"));
                 if (compressedData) {
                     compressedData->setString(kBufferView, compressionBufferView->getID());
                 }
@@ -1033,7 +1033,7 @@
             }            
         }
         
-        shared_ptr <JSONObject> buffersObject(new JSONObject());
+        boost::shared_ptr <JSONObject> buffersObject(new JSONObject());
         
         this->_root->setValue("buffers", buffersObject);
         
@@ -1055,7 +1055,7 @@
         
         //FIXME: below is an acceptable short-cut since in this converter we will always create one buffer view for vertices and one for indices.
         //Fabrice: Other pipeline tools should be built on top of the format & manipulate the buffers and end up with a buffer / bufferViews layout that matches the need of a given application for performance. For instance we might want to concatenate a set of geometry together that come from different file and call that a "level" for a game.
-        shared_ptr <JSONObject> bufferViews = this->_root->createObjectIfNeeded(kBufferViews);
+        boost::shared_ptr <JSONObject> bufferViews = this->_root->createObjectIfNeeded(kBufferViews);
         
         bufferViews->setValue(indicesBufferView->getID(), indicesBufferView);
         bufferViews->setValue(verticesBufferView->getID(), verticesBufferView);
diff -ur collada2gltf.org/GLTF/GLTFAsset.h collada2gltf/GLTF/GLTFAsset.h
--- collada2gltf.org/GLTF/GLTFAsset.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFAsset.h	2014-09-29 15:34:51.000000000 +0200
@@ -5,6 +5,8 @@
 #include "../GLTFOpenCOLLADA.h"
 #include "GLTFAccessorCache.h"
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF
 {
 #define CONFIG_BOOL(asset,X) (asset->converterConfig()->config()->getBool(X))
@@ -18,8 +20,8 @@
     
     class GLTFAnimationFlattener;
     
-    typedef std::vector <std::shared_ptr<JSONObject> > AnimatedTargets;
-    typedef std::shared_ptr <AnimatedTargets> AnimatedTargetsSharedPtr;
+    typedef std::vector <boost::shared_ptr<JSONObject> > AnimatedTargets;
+    typedef boost::shared_ptr <AnimatedTargets> AnimatedTargetsSharedPtr;
 
     typedef std::map<std::string  , std::string > ShaderIdToShaderString;
     typedef std::map<std::string /* openCOLLADA uniqueID */, COLLADAFW::UniqueId > MaterialUIDToEffectUID;
@@ -28,42 +30,42 @@
     typedef std::map<std::string /* openCOLLADA uniqueID */, std::string > MaterialUIDToName;
     typedef std::map<std::string /* openCOLLADA uniqueID from AnimationList*/, AnimatedTargetsSharedPtr > UniqueIDToAnimatedTargets;
     typedef std::map<std::string  , std::string > ImageIdToImagePath;
-    typedef std::map<std::string , std::shared_ptr<JSONArray> > UniqueIDToParentsOfInstanceNode;
-    typedef std::map<std::string , std::shared_ptr<GLTFAnimationFlattener> > UniqueIDToAnimationFlattener;
-    typedef std::map<std::string , std::shared_ptr<JSONArray> > UniqueIDTOfLightToNodes;
+    typedef std::map<std::string , boost::shared_ptr<JSONArray> > UniqueIDToParentsOfInstanceNode;
+    typedef std::map<std::string , boost::shared_ptr<GLTFAnimationFlattener> > UniqueIDToAnimationFlattener;
+    typedef std::map<std::string , boost::shared_ptr<JSONArray> > UniqueIDTOfLightToNodes;
     
-    typedef std::map<std::string , std::shared_ptr<JSONObject> > OriginalIDToTrackedObject;
+    typedef std::map<std::string , boost::shared_ptr<JSONObject> > OriginalIDToTrackedObject;
     typedef std::map<std::string , std::string > GLTFMapStringToString;
-    typedef std::map<std::string , std::shared_ptr<JSONValue> > UniqueIDToJSONValue;
+    typedef std::map<std::string , boost::shared_ptr<JSONValue> > UniqueIDToJSONValue;
 
     typedef std::map<GLTFAccessorCache , std::string> UniqueIDToAccessor;
 
-    typedef std::map<std::string , std::shared_ptr <COLLADAFW::Object> > UniqueIDToOpenCOLLADAObject;
+    typedef std::map<std::string , boost::shared_ptr <COLLADAFW::Object> > UniqueIDToOpenCOLLADAObject;
     
-    typedef std::map<std::string , std::shared_ptr<GLTFOutputStream> > NameToOutputStream;
+    typedef std::map<std::string , boost::shared_ptr<GLTFOutputStream> > NameToOutputStream;
     
     //types for late binding of material
-    typedef std::map<unsigned int , std::shared_ptr <COLLADAFW::MaterialBinding> > MaterialBindingsPrimitiveMap;
-    typedef std::map<std::string , std::shared_ptr <MaterialBindingsPrimitiveMap> > MaterialBindingsForMeshUID;
-    typedef std::map<std::string , std::shared_ptr <MaterialBindingsForMeshUID> > MaterialBindingsForNodeUID;
+    typedef std::map<unsigned int , boost::shared_ptr <COLLADAFW::MaterialBinding> > MaterialBindingsPrimitiveMap;
+    typedef std::map<std::string , boost::shared_ptr <MaterialBindingsPrimitiveMap> > MaterialBindingsForMeshUID;
+    typedef std::map<std::string , boost::shared_ptr <MaterialBindingsForMeshUID> > MaterialBindingsForNodeUID;
     
 	class GLTFAsset
     {
     public:
         GLTFAsset();
         
-        std::shared_ptr <GLTFConfig> converterConfig();
-        std::shared_ptr <JSONObject> convertionResults();
-        std::shared_ptr <JSONObject> convertionMetaData();
+        boost::shared_ptr <GLTFConfig> converterConfig();
+        boost::shared_ptr <JSONObject> convertionResults();
+        boost::shared_ptr <JSONObject> convertionMetaData();
 
-        std::shared_ptr <GLTFProfile> profile();
-        std::shared_ptr <JSONObject> root();
+        boost::shared_ptr <GLTFProfile> profile();
+        boost::shared_ptr <JSONObject> root();
 
         void write();
         
         const std::string resourceOuputPathForPath(const std::string& resourcePath);
 
-        std::shared_ptr<GLTFOutputStream> createOutputStreamIfNeeded(const std::string& streamName);
+        boost::shared_ptr<GLTFOutputStream> createOutputStreamIfNeeded(const std::string& streamName);
         void closeOutputStream(const std::string& streamName, bool removeFile);
         
         void log(const char * format, ... );
@@ -87,11 +89,11 @@
         std::string pathRelativeToInputPath(const std::string& path);
         void copyImagesInsideBundleIfNeeded();
         
-        void setValueForUniqueId(const std::string& uniqueId, std::shared_ptr<JSONValue> obj);
-        std::shared_ptr<JSONValue> getValueForUniqueId(const std::string& uniqueId);
+        void setValueForUniqueId(const std::string& uniqueId, boost::shared_ptr<JSONValue> obj);
+        boost::shared_ptr<JSONValue> getValueForUniqueId(const std::string& uniqueId);
         bool containsValueForUniqueId(const std::string& uniqueId);
         
-        void prepareForProfile(std::shared_ptr<GLTFProfile> profile);
+        void prepareForProfile(boost::shared_ptr<GLTFProfile> profile);
 
         std::string getSharedBufferId();
         
@@ -99,22 +101,22 @@
         std::string getOriginalId(const std::string& uniqueId);
         std::string getUniqueId(const std::string& originalId);
 
-        std::vector <std::shared_ptr<GLTFAssetModifier> > &assetModifiers() { return this->_assetModifiers; };
+        std::vector <boost::shared_ptr<GLTFAssetModifier> > &assetModifiers() { return this->_assetModifiers; };
                 
         MaterialBindingsForNodeUID& materialBindingsForNodeUID() { return this->_materialBindingsForNodeUID; }
         
-        std::shared_ptr<JSONObject> getExtras();
-        void setExtras(std::shared_ptr<JSONObject>);
+        boost::shared_ptr<JSONObject> getExtras();
+        void setExtras(boost::shared_ptr<JSONObject>);
         
     protected:
         void launchModifiers();
     private:
         bool _applyMaterialBindingsForNode(const std::string& nodeUID);
-        void _applyMaterialBindings(std::shared_ptr<GLTFMesh> mesh,
-                                    std::shared_ptr <MaterialBindingsPrimitiveMap> materialBindingPrimitiveMap,
-                                    std::shared_ptr <JSONArray> meshesArray,
-                                    std::shared_ptr<JSONObject> meshExtras);
-        void _writeJSONResource(const std::string &resourcePath, std::shared_ptr<JSONObject> obj);
+        void _applyMaterialBindings(boost::shared_ptr<GLTFMesh> mesh,
+                                    boost::shared_ptr <MaterialBindingsPrimitiveMap> materialBindingPrimitiveMap,
+                                    boost::shared_ptr <JSONArray> meshesArray,
+                                    boost::shared_ptr<JSONObject> meshExtras);
+        void _writeJSONResource(const std::string &resourcePath, boost::shared_ptr<JSONObject> obj);
     public:
         MaterialUIDToEffectUID          _materialUIDToEffectUID;
         MaterialUIDToName               _materialUIDToName;
@@ -130,20 +132,20 @@
         UniqueIDToAnimationFlattener    _targetUIDWithPathToAnimationFlattener;
         
     private:
-        std::shared_ptr <GLTFProfile>        _profile;
-        std::shared_ptr <JSONObject>         _root;
+        boost::shared_ptr <GLTFProfile>        _profile;
+        boost::shared_ptr <JSONObject>         _root;
 
         GLTFMapStringToString           _uniqueIDToOriginalID;
         GLTFMapStringToString           _originalIDToUniqueID;
 
-        std::shared_ptr <GLTFConfig>    _converterConfig;
-        std::shared_ptr <JSONObject>    _convertionResults;
-        std::shared_ptr <JSONObject>    _convertionMetaData;
-        std::shared_ptr<JSONObject>     _originalResourcesPath;
-        std::shared_ptr<JSONObject>     _trackedResourcesPath;
-        std::shared_ptr<JSONObject>     _trackedOutputResourcesPath;
-        std::shared_ptr<JSONObject>     _extras;
-        std::shared_ptr<JSONObject>     _meshesForMaterialBindingKey;
+        boost::shared_ptr <GLTFConfig>    _converterConfig;
+        boost::shared_ptr <JSONObject>    _convertionResults;
+        boost::shared_ptr <JSONObject>    _convertionMetaData;
+        boost::shared_ptr<JSONObject>     _originalResourcesPath;
+        boost::shared_ptr<JSONObject>     _trackedResourcesPath;
+        boost::shared_ptr<JSONObject>     _trackedOutputResourcesPath;
+        boost::shared_ptr<JSONObject>     _extras;
+        boost::shared_ptr<JSONObject>     _meshesForMaterialBindingKey;
 
         unsigned int                    _prefix;
         std::string                     _inputFilePath;
@@ -159,7 +161,7 @@
         NameToOutputStream              _nameToOutputStream;
         GLTF::GLTFWriter                _writer;
         
-        std::vector <std::shared_ptr<GLTFAssetModifier> > _assetModifiers;
+        std::vector <boost::shared_ptr<GLTFAssetModifier> > _assetModifiers;
         
         MaterialBindingsForNodeUID _materialBindingsForNodeUID;
     };
@@ -167,4 +169,4 @@
     std::string uniqueIdWithType(std::string type, const COLLADAFW::UniqueId& uniqueId);
 
 }
-#endif
\ No newline at end of file
+#endif
diff -ur collada2gltf.org/GLTF/GLTFBuffer.cpp collada2gltf/GLTF/GLTFBuffer.cpp
--- collada2gltf.org/GLTF/GLTFBuffer.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFBuffer.cpp	2014-09-29 15:35:13.000000000 +0200
@@ -91,12 +91,12 @@
     GLTFBufferView::~GLTFBufferView() {
     }
     
-    void GLTFBufferView::_setBuffer(shared_ptr <GLTFBuffer> buffer) {
+    void GLTFBufferView::_setBuffer(boost::shared_ptr <GLTFBuffer> buffer) {
         this->_buffer = buffer;
         this->setString(kBuffer, buffer->getID());
     }
     
-    GLTFBufferView::GLTFBufferView(shared_ptr <GLTF::GLTFBuffer> buffer, size_t byteOffset, size_t byteLength) : JSONObject() {
+    GLTFBufferView::GLTFBufferView(boost::shared_ptr <GLTF::GLTFBuffer> buffer, size_t byteOffset, size_t byteLength) : JSONObject() {
         this->_ID = GLTFUtils::generateIDForType(kBufferView.c_str());
         
         this->_setBuffer(buffer);
@@ -104,7 +104,7 @@
         this->setByteOffset(byteOffset);
     }
     
-    GLTFBufferView::GLTFBufferView(std::string ID, shared_ptr <GLTF::GLTFBuffer> buffer, size_t byteOffset, size_t byteLength) : JSONObject() {
+    GLTFBufferView::GLTFBufferView(std::string ID, boost::shared_ptr <GLTF::GLTFBuffer> buffer, size_t byteOffset, size_t byteLength) : JSONObject() {
         this->_setBuffer(buffer);
         this->setByteLength(byteLength);
         this->setByteOffset(byteOffset);
@@ -136,7 +136,7 @@
         return this->_ID;
     }
     
-    shared_ptr <GLTFBuffer> GLTFBufferView::getBuffer() {
+    boost::shared_ptr <GLTFBuffer> GLTFBufferView::getBuffer() {
         return this->_buffer;
     }
     
@@ -145,16 +145,16 @@
         return (void*)(data + this->getByteOffset());
     }
 
-    shared_ptr <GLTFBufferView>  createBufferViewWithAllocatedBuffer(std::string ID, void *data, size_t byteOffset, size_t byteLength, bool ownData) {
-        shared_ptr<GLTFBuffer> buffer(new GLTFBuffer(data, byteLength, ownData));
-        shared_ptr<GLTFBufferView> bufferView(new GLTFBufferView(ID, buffer, byteOffset, byteLength));
+    boost::shared_ptr <GLTFBufferView>  createBufferViewWithAllocatedBuffer(std::string ID, void *data, size_t byteOffset, size_t byteLength, bool ownData) {
+        boost::shared_ptr<GLTFBuffer> buffer(new GLTFBuffer(data, byteLength, ownData));
+        boost::shared_ptr<GLTFBufferView> bufferView(new GLTFBufferView(ID, buffer, byteOffset, byteLength));
 
         return bufferView;
     }
     
-    shared_ptr <GLTFBufferView>  createBufferViewWithAllocatedBuffer(void *data, size_t byteOffset, size_t byteLength, bool ownData) {
-        shared_ptr<GLTFBuffer> buffer(new GLTFBuffer(data, byteLength, ownData));
-        shared_ptr<GLTFBufferView> bufferView(new GLTFBufferView(buffer, byteOffset, byteLength));
+    boost::shared_ptr <GLTFBufferView>  createBufferViewWithAllocatedBuffer(void *data, size_t byteOffset, size_t byteLength, bool ownData) {
+        boost::shared_ptr<GLTFBuffer> buffer(new GLTFBuffer(data, byteLength, ownData));
+        boost::shared_ptr<GLTFBufferView> bufferView(new GLTFBufferView(buffer, byteOffset, byteLength));
         
         return bufferView;
     }
diff -ur collada2gltf.org/GLTF/GLTFBuffer.h collada2gltf/GLTF/GLTFBuffer.h
--- collada2gltf.org/GLTF/GLTFBuffer.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFBuffer.h	2014-09-29 15:35:08.000000000 +0200
@@ -27,6 +27,8 @@
 #ifndef __JSON_BUFFER_H__
 #define __JSON_BUFFER_H__
 
+#include <boost/shared_ptr.hpp>
+
 /* 
     A GLTFBuffer holds raw data to be exported as an ArrayBuffer i.e http://www.khronos.org/registry/typedarray/specs/latest/
     GLTFBuffer can take ownership of the data passed, in that case when a GLTFBuffer instance then the data is freed.
@@ -59,8 +61,8 @@
     class GLTFBufferView : public JSONObject {
     public:
         GLTFBufferView();
-        GLTFBufferView(std::shared_ptr <GLTF::GLTFBuffer> buffer, size_t byteOffset, size_t byteLength);
-        GLTFBufferView(std::string ID, std::shared_ptr <GLTF::GLTFBuffer> buffer, size_t byteOffset, size_t byteLength);
+        GLTFBufferView(boost::shared_ptr <GLTF::GLTFBuffer> buffer, size_t byteOffset, size_t byteLength);
+        GLTFBufferView(std::string ID, boost::shared_ptr <GLTF::GLTFBuffer> buffer, size_t byteOffset, size_t byteLength);
         
         virtual ~GLTFBufferView();
         
@@ -70,22 +72,22 @@
         void setByteOffset(size_t byteOffset);
         size_t getByteOffset();
         
-        std::shared_ptr <GLTFBuffer> getBuffer();
+        boost::shared_ptr <GLTFBuffer> getBuffer();
 
         std::string const getID();
     
         void* getBufferDataByApplyingOffset();
     private:
-        void _setBuffer(std::shared_ptr <GLTFBuffer>);
+        void _setBuffer(boost::shared_ptr <GLTFBuffer>);
     private:
         std::string  _ID;
-        std::shared_ptr<GLTFBuffer> _buffer;
+        boost::shared_ptr<GLTFBuffer> _buffer;
     };
     
     //conveniences functions
-    std::shared_ptr <GLTFBufferView>  createBufferViewWithAllocatedBuffer(std::string ID, void *data, size_t byteOffset, size_t byteLength, bool ownData);
-    std::shared_ptr <GLTFBufferView>  createBufferViewWithAllocatedBuffer(void *data, size_t byteOffset, size_t byteLength, bool ownData);
+    boost::shared_ptr <GLTFBufferView>  createBufferViewWithAllocatedBuffer(std::string ID, void *data, size_t byteOffset, size_t byteLength, bool ownData);
+    boost::shared_ptr <GLTFBufferView>  createBufferViewWithAllocatedBuffer(void *data, size_t byteOffset, size_t byteLength, bool ownData);
 
 }
 
-#endif
\ No newline at end of file
+#endif
diff -ur collada2gltf.org/GLTF/GLTFConfig.cpp collada2gltf/GLTF/GLTFConfig.cpp
--- collada2gltf.org/GLTF/GLTFConfig.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFConfig.cpp	2014-09-29 15:38:53.000000000 +0200
@@ -32,12 +32,12 @@
 namespace GLTF 
 {    
     GLTFConfig::GLTFConfig() {
-        this->_configObject = shared_ptr<JSONObject> (new JSONObject());
+        this->_configObject = boost::shared_ptr<JSONObject> (new JSONObject());
         this->_setupDefaultConfigOptions(this->_configObject);
     }
     GLTFConfig::~GLTFConfig() {}
     
-    void GLTFConfig::_setupDefaultConfigOptions(shared_ptr<JSONObject> optionsRoot) {
+    void GLTFConfig::_setupDefaultConfigOptions(boost::shared_ptr<JSONObject> optionsRoot) {
         optionsRoot->setBool("premultipliedAlpha", true);
         optionsRoot->setBool("invertTransparency", false);
         optionsRoot->setBool("exportAnimations", true);
@@ -63,9 +63,9 @@
         optionsRoot->setBool("verboseLogging", false);
         
         //create the path "extensions.Open3DGC.quantization" and set default for Open3DGC
-        shared_ptr<JSONObject> extensions(new JSONObject());
-        shared_ptr<JSONObject> Open3DGC(new JSONObject());
-        shared_ptr<JSONObject> quantization(new JSONObject());
+        boost::shared_ptr<JSONObject> extensions(new JSONObject());
+        boost::shared_ptr<JSONObject> Open3DGC(new JSONObject());
+        boost::shared_ptr<JSONObject> quantization(new JSONObject());
         
         optionsRoot->setValue("extensions", extensions);
         extensions->setValue("Open3DGC", Open3DGC);
@@ -78,7 +78,7 @@
         quantization->setUnsignedInt32("WEIGHT", 8);
         quantization->setUnsignedInt32("TIME", 10);
         
-        shared_ptr<JSONObject> prediction(new JSONObject());
+        boost::shared_ptr<JSONObject> prediction(new JSONObject());
         Open3DGC->setValue("prediction", prediction);
         
         prediction->setString("POSITION", "PARALLELOGRAM");
@@ -87,7 +87,7 @@
         prediction->setString("WEIGHT", "PARALLELOGRAM");
         prediction->setString("JOINT", "DIFFERENTIAL");
 
-        shared_ptr<JSONObject> transform(new JSONObject());
+        boost::shared_ptr<JSONObject> transform(new JSONObject());
         quantization->setValue("transform", transform);
 
         transform->setUnsignedInt32("translation", 17);
@@ -106,17 +106,17 @@
         return true;
     }
     
-    shared_ptr <JSONObject> GLTFConfig::config() {
+    boost::shared_ptr <JSONObject> GLTFConfig::config() {
         return this->_configObject;
     }
 
     
     unsigned int GLTFConfig::unsignedInt32ForKeyPath(const std::string &keyPath) {
         unsigned int resultValue = 0;
-        shared_ptr<JSONValue> value = this->_configObject->valueForKeyPath(keyPath);
+        boost::shared_ptr<JSONValue> value = this->_configObject->valueForKeyPath(keyPath);
         if (value) {
             if (value->getJSONType() == kJSONNumber) {
-                shared_ptr<JSONNumber> numberValue = static_pointer_cast<JSONNumber>(value);
+                boost::shared_ptr<JSONNumber> numberValue = boost::static_pointer_cast<JSONNumber>(value);
                 resultValue = numberValue->getUnsignedInt32();
             }
         }
@@ -126,10 +126,10 @@
     
     int GLTFConfig::int32ForKeyPath(const std::string &keyPath) {
         int resultValue = 0;
-        shared_ptr<JSONValue> value = this->_configObject->valueForKeyPath(keyPath);
+        boost::shared_ptr<JSONValue> value = this->_configObject->valueForKeyPath(keyPath);
         if (value) {
             if (value->getJSONType() == kJSONNumber) {
-                shared_ptr<JSONNumber> numberValue = static_pointer_cast<JSONNumber>(value);
+                boost::shared_ptr<JSONNumber> numberValue = boost::static_pointer_cast<JSONNumber>(value);
                 resultValue = numberValue->getInt32();
             }
         }
@@ -140,10 +140,10 @@
     
     double GLTFConfig::doubleForKeyPath(const std::string &keyPath) {
         double resultValue = 0;
-        shared_ptr<JSONValue> value = this->_configObject->valueForKeyPath(keyPath);
+        boost::shared_ptr<JSONValue> value = this->_configObject->valueForKeyPath(keyPath);
         if (value) {
             if (value->getJSONType() == kJSONNumber) {
-                shared_ptr<JSONNumber> numberValue = static_pointer_cast<JSONNumber>(value);
+                boost::shared_ptr<JSONNumber> numberValue = boost::static_pointer_cast<JSONNumber>(value);
                 resultValue = numberValue->getDouble();
             }
         }
@@ -154,10 +154,10 @@
     
     bool GLTFConfig::boolForKeyPath(const std::string &keyPath) {
         bool resultValue = false;
-        shared_ptr<JSONValue> value = this->_configObject->valueForKeyPath(keyPath);
+        boost::shared_ptr<JSONValue> value = this->_configObject->valueForKeyPath(keyPath);
         if (value) {
             if (value->getJSONType() == kJSONNumber) {
-                shared_ptr<JSONNumber> numberValue = static_pointer_cast<JSONNumber>(value);
+                boost::shared_ptr<JSONNumber> numberValue = boost::static_pointer_cast<JSONNumber>(value);
                 resultValue = numberValue->getBool();
             }
         }
@@ -167,10 +167,10 @@
     
     std::string GLTFConfig::stringForKeyPath(const std::string &keyPath) {
         std::string resultValue;
-        shared_ptr<JSONValue> value = this->_configObject->valueForKeyPath(keyPath);
+        boost::shared_ptr<JSONValue> value = this->_configObject->valueForKeyPath(keyPath);
         if (value) {
             if (value->getJSONType() == kJSONString) {
-                shared_ptr<JSONString> numberValue = static_pointer_cast<JSONString>(value);
+                boost::shared_ptr<JSONString> numberValue = boost::static_pointer_cast<JSONString>(value);
                 resultValue = numberValue->getString();
             }
         }
diff -ur collada2gltf.org/GLTF/GLTFConfig.h collada2gltf/GLTF/GLTFConfig.h
--- collada2gltf.org/GLTF/GLTFConfig.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFConfig.h	2014-09-29 15:35:27.000000000 +0200
@@ -24,6 +24,8 @@
 #ifndef __GLTF_CONFIG__
 #define __GLTF_CONFIG__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF
 {
     class GLTFConfig {
@@ -32,7 +34,7 @@
         bool initWithPath(const std::string& path);
         
         virtual ~GLTFConfig();
-        std::shared_ptr <JSONObject> config();
+        boost::shared_ptr <JSONObject> config();
 
         unsigned int unsignedInt32ForKeyPath(const std::string &keyPath);
         int int32ForKeyPath(const std::string &keyPath);
@@ -41,11 +43,11 @@
         std::string stringForKeyPath(const std::string &keyPath);
         
     private:
-        void _setupDefaultConfigOptions(std::shared_ptr<JSONObject> optionsRoot);
+        void _setupDefaultConfigOptions(boost::shared_ptr<JSONObject> optionsRoot);
     private:
-        std::shared_ptr<JSONObject> _configObject;
+        boost::shared_ptr<JSONObject> _configObject;
     };
 }
 
 
-#endif
\ No newline at end of file
+#endif
diff -ur collada2gltf.org/GLTF/GLTFEffect.cpp collada2gltf/GLTF/GLTFEffect.cpp
--- collada2gltf.org/GLTF/GLTFEffect.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFEffect.cpp	2014-09-29 15:42:01.000000000 +0200
@@ -36,7 +36,7 @@
 namespace GLTF
 {
     GLTFEffect::GLTFEffect(const std::string& ID): JSONObject(),
-    _ID(ID), _techniqueGenerator(nullptr) {
+    _ID(ID), _techniqueGenerator() {
     }
     
     GLTFEffect::GLTFEffect(const GLTFEffect &effect) : JSONObject() {
@@ -60,11 +60,11 @@
         this->_ID = id;
     }
     
-    void GLTFEffect::setTechniqueGenerator(shared_ptr <JSONObject> techniqueGenerator) {
+    void GLTFEffect::setTechniqueGenerator(boost::shared_ptr <JSONObject> techniqueGenerator) {
         this->_techniqueGenerator = techniqueGenerator;
     }
     
-    shared_ptr <JSONObject> GLTFEffect::getTechniqueGenerator() {
+    boost::shared_ptr <JSONObject> GLTFEffect::getTechniqueGenerator() {
         return this->_techniqueGenerator;
     }
         
@@ -76,11 +76,11 @@
         return this->getString(kName);
     }
     
-    void GLTFEffect::setValues(shared_ptr <JSONObject> values) {
+    void GLTFEffect::setValues(boost::shared_ptr <JSONObject> values) {
         this->_values = values;
     }
     
-    shared_ptr <JSONObject> GLTFEffect::getValues() {
+    boost::shared_ptr <JSONObject> GLTFEffect::getValues() {
         return this->_values;
     }
     
@@ -93,9 +93,9 @@
     }
     
     void GLTFEffect::addSemanticForTexcoordName(const std::string &texcoord, const std::string &semantic) {
-        shared_ptr <SemanticArray> semanticArrayPtr;
+        boost::shared_ptr <SemanticArray> semanticArrayPtr;
         if (this->_texcoordToSemantics.count(texcoord) == 0) {
-            semanticArrayPtr =  shared_ptr<SemanticArray> (new SemanticArray());
+            semanticArrayPtr =  boost::shared_ptr<SemanticArray> (new SemanticArray());
             this->_texcoordToSemantics[texcoord] = semanticArrayPtr;
         } else {
             semanticArrayPtr = this->_texcoordToSemantics[texcoord];
@@ -110,20 +110,20 @@
     
     void GLTFEffect::evaluate(void *context) {
         GLTFAsset* asset = (GLTFAsset*)context;
-        shared_ptr <GLTF::JSONObject> instanceTechnique(new GLTF::JSONObject());
-        shared_ptr <JSONObject> techniqueGenerator = this->getTechniqueGenerator();
+        boost::shared_ptr <GLTF::JSONObject> instanceTechnique(new GLTF::JSONObject());
+        boost::shared_ptr <JSONObject> techniqueGenerator = this->getTechniqueGenerator();
                 
         std::string techniqueID = GLTF::getReferenceTechniqueID(techniqueGenerator, asset);
         
         this->setValue(kInstanceTechnique, instanceTechnique);
         instanceTechnique->setString(kTechnique, techniqueID);
-        shared_ptr<JSONObject> outputs(new JSONObject());
-        shared_ptr <JSONObject> values = this->getValues();
+        boost::shared_ptr<JSONObject> outputs(new JSONObject());
+        boost::shared_ptr <JSONObject> values = this->getValues();
         std::vector <std::string> keys = values->getAllKeys();
         for (size_t i = 0 ; i < keys.size() ; i++) {
-            shared_ptr <JSONObject> parameter = static_pointer_cast <JSONObject> (values->getValue(keys[i]));
-            shared_ptr <JSONObject> parameterValue = static_pointer_cast <JSONObject> (parameter->getValue(kValue));
-            shared_ptr<JSONObject> output(new JSONObject());
+            boost::shared_ptr <JSONObject> parameter = boost::static_pointer_cast <JSONObject> (values->getValue(keys[i]));
+            boost::shared_ptr <JSONObject> parameterValue = boost::static_pointer_cast <JSONObject> (parameter->getValue(kValue));
+            boost::shared_ptr<JSONObject> output(new JSONObject());
             if (parameterValue) {
                 outputs->setValue(keys[i], parameterValue);
             }
diff -ur collada2gltf.org/GLTF/GLTFEffect.h collada2gltf/GLTF/GLTFEffect.h
--- collada2gltf.org/GLTF/GLTFEffect.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFEffect.h	2014-09-29 15:35:34.000000000 +0200
@@ -27,10 +27,12 @@
 #ifndef __JSON_EFFECT_H__
 #define __JSON_EFFECT_H__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF 
 {
     typedef std::vector <std::string > SemanticArray;
-    typedef std::shared_ptr<SemanticArray> SemanticArrayPtr;
+    typedef boost::shared_ptr<SemanticArray> SemanticArrayPtr;
     typedef std::map<std::string /* texcoord */, SemanticArrayPtr > TexCoordToSemanticsArrayPtr;
     
     class GLTFEffect : public JSONObject {
@@ -44,8 +46,8 @@
         const std::string& getID();
         void setID(const std::string& id);
 
-        void setTechniqueGenerator(std::shared_ptr <JSONObject> techniqueGenerator);
-        std::shared_ptr <JSONObject> getTechniqueGenerator();
+        void setTechniqueGenerator(boost::shared_ptr <JSONObject> techniqueGenerator);
+        boost::shared_ptr <JSONObject> getTechniqueGenerator();
 
         void setName(const std::string& name);
         std::string getName();
@@ -53,8 +55,8 @@
         void setLightingModel(const std::string& lightingModel);
         const std::string& getLightingModel();
 
-        void setValues(std::shared_ptr <JSONObject>);
-        std::shared_ptr <JSONObject> getValues();
+        void setValues(boost::shared_ptr <JSONObject>);
+        boost::shared_ptr <JSONObject> getValues();
         
         void addSemanticForTexcoordName(const std::string &texcoord, const std::string &semantic);
         SemanticArrayPtr getSemanticsForTexcoordName(const std::string &texcoord);
@@ -64,8 +66,8 @@
     private:
         std::string _ID;
         std::string _lightingModel;
-        std::shared_ptr <JSONObject> _techniqueGenerator;
-        std::shared_ptr <JSONObject> _values;
+        boost::shared_ptr <JSONObject> _techniqueGenerator;
+        boost::shared_ptr <JSONObject> _values;
         TexCoordToSemanticsArrayPtr _texcoordToSemantics ;
     };
 }
diff -ur collada2gltf.org/GLTF/GLTFExtraDataHandler.cpp collada2gltf/GLTF/GLTFExtraDataHandler.cpp
--- collada2gltf.org/GLTF/GLTFExtraDataHandler.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFExtraDataHandler.cpp	2014-09-29 15:42:18.000000000 +0200
@@ -38,7 +38,7 @@
 	//------------------------------
 	ExtraDataHandler::ExtraDataHandler() : mExtraTagType(EXTRA_TAG_TYPE_UNKNOWN)
 	{
-        _allExtras = shared_ptr<JSONObject> (new JSONObject());
+        _allExtras = boost::shared_ptr<JSONObject> (new JSONObject());
 	}
 
 	//------------------------------
@@ -48,14 +48,14 @@
     
     void ExtraDataHandler::determineBumpTextureSamplerAndTexCoord( const GeneratedSaxParser::xmlChar** attributes )
 	{
-        COLLADAFW::TextureAttributes *textureAttributes = nullptr;
+        COLLADAFW::TextureAttributes *textureAttributes = 0;
 
-        shared_ptr <JSONObject> bump = nullptr;
+        boost::shared_ptr <JSONObject> bump;
 		if(mCurrentObject) {
 			if( COLLADAFW::COLLADA_TYPE::EFFECT == mCurrentObject->getClassId()) {
-                shared_ptr <JSONObject> extras = this->getExtras(mCurrentElementUniqueId);
+                boost::shared_ptr <JSONObject> extras = this->getExtras(mCurrentElementUniqueId);
                 assert(extras);
-                shared_ptr <JSONObject> textures = extras->createObjectIfNeeded("textures");
+                boost::shared_ptr <JSONObject> textures = extras->createObjectIfNeeded("textures");
                 bump = textures->createObjectIfNeeded("bump");
                 
                 COLLADAFW::Effect* effect = (COLLADAFW::Effect*)mCurrentObject;
@@ -63,7 +63,7 @@
 			}
 		}
         
-        if ((bump == nullptr) || (textureAttributes == nullptr))
+        if ((bump == 0) || (textureAttributes == 0))
             return;
         
 		size_t index = 0;
@@ -149,15 +149,15 @@
 	}
 
     
-    shared_ptr <JSONObject> ExtraDataHandler::getExtras(COLLADAFW::UniqueId uniqueId)
+    boost::shared_ptr <JSONObject> ExtraDataHandler::getExtras(COLLADAFW::UniqueId uniqueId)
     {
         std::string id = uniqueId.toAscii();
         
         if (!this->_allExtras->contains(id)) {
-            this->_allExtras->setValue(id, shared_ptr<JSONObject> (new JSONObject()));
+            this->_allExtras->setValue(id, boost::shared_ptr<JSONObject> (new JSONObject()));
         }
         
-        return static_pointer_cast<JSONObject>(this->_allExtras->getValue(id));
+        return boost::static_pointer_cast<JSONObject>(this->_allExtras->getValue(id));
     }
     
     
@@ -167,7 +167,7 @@
         bool failed = false;
         if (mExtraTagType == EXTRA_TAG_TYPE_DOUBLE_SIDED) {
             const  COLLADASaxFWL::ParserChar* buffer = mTextBuffer.c_str();
-            shared_ptr <JSONObject> extras = getExtras(mCurrentElementUniqueId);
+            boost::shared_ptr <JSONObject> extras = getExtras(mCurrentElementUniqueId);
             bool val = GeneratedSaxParser::Utils::toBool(&buffer, failed);
             if ( !failed ) {
                 extras->setBool("double_sided", val);
@@ -176,7 +176,7 @@
         
         if (mExtraTagType == EXTRA_TAG_TYPE_LOCK_AMBIENT_DIFFUSE) {
             const  COLLADASaxFWL::ParserChar* buffer = mTextBuffer.c_str();
-            shared_ptr <JSONObject> extras = getExtras(mCurrentElementUniqueId);
+            boost::shared_ptr <JSONObject> extras = getExtras(mCurrentElementUniqueId);
             bool val = GeneratedSaxParser::Utils::toBool(&buffer, failed);
             if ( !failed ) {
                 extras->setBool("ambient_diffuse_lock", val);
diff -ur collada2gltf.org/GLTF/GLTFExtraDataHandler.h collada2gltf/GLTF/GLTFExtraDataHandler.h
--- collada2gltf.org/GLTF/GLTFExtraDataHandler.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFExtraDataHandler.h	2014-09-29 15:35:57.000000000 +0200
@@ -6,6 +6,8 @@
 
 #include "COLLADASaxFWLIExtraDataCallbackHandler.h"
 
+#include <boost/shared_ptr.hpp>
+
 #if (defined(WIN32) || defined(_LIBCPP_VERSION) || __cplusplus > 199711L)
 #include <memory>
 #include <unordered_map>
@@ -46,13 +48,13 @@
 		bool parseElement( const COLLADASaxFWL::ParserChar* profileName, const COLLADASaxFWL::StringHash& elementHash
 			, const COLLADAFW::UniqueId& uniqueId, COLLADAFW::Object* object );
         
-        std::shared_ptr <JSONObject> getExtras(COLLADAFW::UniqueId uniqueId);
-        std::shared_ptr <JSONObject> allExtras() { return this->_allExtras; }
+        boost::shared_ptr <JSONObject> getExtras(COLLADAFW::UniqueId uniqueId);
+        boost::shared_ptr <JSONObject> allExtras() { return this->_allExtras; }
         
         void determineBumpTextureSamplerAndTexCoord( const GeneratedSaxParser::xmlChar** attributes );
 
 	private:
-        std::shared_ptr <JSONObject> _allExtras;
+        boost::shared_ptr <JSONObject> _allExtras;
 	};
 }
 
diff -ur collada2gltf.org/GLTF/GLTF.h collada2gltf/GLTF/GLTF.h
--- collada2gltf.org/GLTF/GLTF.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTF.h	2014-09-29 15:43:27.000000000 +0200
@@ -40,7 +40,6 @@
 #include <vector>
 #include "assert.h"
 #include <cstddef>
-#include <cstdint>
 
 #if (defined(WIN32) || defined(_LIBCPP_VERSION) || __cplusplus > 199711L)
 #include <memory>
diff -ur collada2gltf.org/GLTF/GLTFMesh.cpp collada2gltf/GLTF/GLTFMesh.cpp
--- collada2gltf.org/GLTF/GLTFMesh.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFMesh.cpp	2014-09-29 15:42:43.000000000 +0200
@@ -36,9 +36,8 @@
 
 namespace GLTF
 {
-    GLTFMesh::GLTFMesh() : JSONObject() , _subMeshes(nullptr) {
-        this->_subMeshes = nullptr;
-        this->_remapTableForPositions = nullptr;
+    GLTFMesh::GLTFMesh() : JSONObject() , _subMeshes() {
+        this->_remapTableForPositions = 0;
         this->_ID = GLTFUtils::generateIDForType("mesh");
     }
     
@@ -48,8 +47,8 @@
     }
 
     //copy that retains elements
-    GLTFMesh::GLTFMesh(const GLTFMesh &mesh) : JSONObject(), _subMeshes(nullptr) {
-        this->_remapTableForPositions = nullptr;
+    GLTFMesh::GLTFMesh(const GLTFMesh &mesh) : JSONObject(), _subMeshes() {
+        this->_remapTableForPositions = 0;
         GLTFMesh *meshPtr = const_cast <GLTFMesh*>(&mesh);
         this->setPrimitives(meshPtr->getPrimitives());
         this->_semanticToMeshAttributes = mesh._semanticToMeshAttributes;
@@ -57,9 +56,9 @@
         this->setName(meshPtr->getName());
     }
 
-    shared_ptr<GLTFMesh> GLTFMesh::clone() {
+    boost::shared_ptr<GLTFMesh> GLTFMesh::clone() {
         
-        shared_ptr<GLTFMesh> clonedMesh(new GLTFMesh());
+        boost::shared_ptr<GLTFMesh> clonedMesh(new GLTFMesh());
         
         clonedMesh->setID(this->getID());
         clonedMesh->setName(this->getName());
@@ -67,15 +66,15 @@
         
         JSONValueVectorRef primitives =  this->getPrimitives()->values();
         for (size_t i = 0 ; i < primitives.size() ; i++) {
-            shared_ptr <GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
+            boost::shared_ptr <GLTFPrimitive> primitive = boost::static_pointer_cast<GLTFPrimitive>(primitives[i]);
             clonedMesh->appendPrimitive(primitive->clone());
         }
         
         return clonedMesh;
     }
 
-    shared_ptr <MeshAttributeVector> GLTFMesh::meshAttributes() {
-        shared_ptr <MeshAttributeVector> meshAttributes(new MeshAttributeVector());
+    boost::shared_ptr <MeshAttributeVector> GLTFMesh::meshAttributes() {
+        boost::shared_ptr <MeshAttributeVector> meshAttributes(new MeshAttributeVector());
         vector <GLTF::Semantic> allSemantics = this->allSemantics();
         std::map<string, unsigned int> semanticAndSetToIndex;
         
@@ -83,7 +82,7 @@
             GLTF::Semantic semantic = allSemantics[i];
             size_t attributesCount = this->getMeshAttributesCountForSemantic(semantic);
             for (size_t j = 0 ; j < attributesCount ; j++) {
-                shared_ptr <GLTF::GLTFAccessor> selectedMeshAttribute = this->getMeshAttribute(semantic, j);
+                boost::shared_ptr <GLTF::GLTFAccessor> selectedMeshAttribute = this->getMeshAttribute(semantic, j);
                 unsigned int indexSet = j;
                 std::string semanticIndexSetKey = keyWithSemanticAndSet(semantic, indexSet);
                 unsigned int size = (unsigned int)meshAttributes->size();
@@ -95,8 +94,8 @@
         return meshAttributes;
     }
     
-    bool GLTFMesh::appendPrimitive(shared_ptr <GLTF::GLTFPrimitive> primitive) {
-        shared_ptr<JSONArray> primitives = this->createArrayIfNeeded(kPrimitives);
+    bool GLTFMesh::appendPrimitive(boost::shared_ptr <GLTF::GLTFPrimitive> primitive) {
+        boost::shared_ptr<JSONArray> primitives = this->createArrayIfNeeded(kPrimitives);
         primitives->appendValue(primitive);
         return true;
     }
@@ -109,12 +108,12 @@
         return this->_semanticToMeshAttributes[semantic].size();
     }
     
-    shared_ptr<GLTFAccessor> GLTFMesh::getMeshAttribute(Semantic semantic, size_t indexOfSet) {
+    boost::shared_ptr<GLTFAccessor> GLTFMesh::getMeshAttribute(Semantic semantic, size_t indexOfSet) {
         IndexSetToMeshAttributeHashmap& hasmap = this->_semanticToMeshAttributes[semantic];
 		return hasmap[(unsigned int)indexOfSet];
     }
 
-    void GLTFMesh::setMeshAttribute(Semantic semantic, size_t indexOfSet, shared_ptr<GLTFAccessor> meshAttribute) {
+    void GLTFMesh::setMeshAttribute(Semantic semantic, size_t indexOfSet, boost::shared_ptr<GLTFAccessor> meshAttribute) {
         IndexSetToMeshAttributeHashmap& hasmap = this->_semanticToMeshAttributes[semantic];
 		hasmap[(unsigned int)indexOfSet] = meshAttribute;
     }
@@ -152,7 +151,7 @@
 
     size_t GLTFMesh::getPrimitivesCount() {
         size_t count = 0;
-        shared_ptr<JSONArray> primitives = this->getPrimitives();
+        boost::shared_ptr<JSONArray> primitives = this->getPrimitives();
         if (primitives) {
             JSONValueVectorRef values = primitives->values();
             count = values.size();
@@ -160,15 +159,15 @@
         return count;
     }
     
-    shared_ptr<JSONArray> GLTFMesh::getPrimitives() {
+    boost::shared_ptr<JSONArray> GLTFMesh::getPrimitives() {
         return this->getArray(kPrimitives);
     }
 
-    void GLTFMesh::setPrimitives(shared_ptr<JSONArray> primitives) {
+    void GLTFMesh::setPrimitives(boost::shared_ptr<JSONArray> primitives) {
         this->setValue(kPrimitives, primitives);
     }
 
-    shared_ptr<JSONObject> GLTFMesh::getExtensions() {
+    boost::shared_ptr<JSONObject> GLTFMesh::getExtensions() {
         return this->createObjectIfNeeded(kExtensions);
     }
     
@@ -181,13 +180,13 @@
     }
     
     void GLTFMesh::resolveAttributes() {
-        shared_ptr <GLTF::JSONArray> primitivesArray(new GLTF::JSONArray());
+        boost::shared_ptr <GLTF::JSONArray> primitivesArray(new GLTF::JSONArray());
         JSONValueVector primitives = this->getPrimitives()->values();
         unsigned int primitivesCount =  (unsigned int)primitives.size();
         for (unsigned int i = 0 ; i < primitivesCount ; i++) {
-            shared_ptr<GLTF::GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
+            boost::shared_ptr<GLTF::GLTFPrimitive> primitive = boost::static_pointer_cast<GLTFPrimitive>(primitives[i]);
                         
-            shared_ptr <GLTF::JSONObject> attributes(new GLTF::JSONObject());
+            boost::shared_ptr <GLTF::JSONObject> attributes(new GLTF::JSONObject());
             primitive->setValue(kAttributes, attributes);
             
             size_t count = primitive->getVertexAttributesCount();
diff -ur collada2gltf.org/GLTF/GLTFMesh.h collada2gltf/GLTF/GLTFMesh.h
--- collada2gltf.org/GLTF/GLTFMesh.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFMesh.h	2014-09-29 15:42:48.000000000 +0200
@@ -27,13 +27,15 @@
 #ifndef __GLTFMESH_H__
 #define __GLTFMESH_H__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF 
 {
     class GLTFMesh;
     
-    std::shared_ptr <GLTFMesh> createUnifiedIndexesMeshFromMesh(GLTFMesh *sourceMesh, std::vector< std::shared_ptr<IndicesVector> > &vectorOfIndicesVector, std::shared_ptr<GLTFProfile> profile);
+    boost::shared_ptr <GLTFMesh> createUnifiedIndexesMeshFromMesh(GLTFMesh *sourceMesh, std::vector< boost::shared_ptr<IndicesVector> > &vectorOfIndicesVector, boost::shared_ptr<GLTFProfile> profile);
     
-    typedef std::map<unsigned int /* IndexSet */, std::shared_ptr<GLTF::GLTFAccessor> > IndexSetToMeshAttributeHashmap;
+    typedef std::map<unsigned int /* IndexSet */, boost::shared_ptr<GLTF::GLTFAccessor> > IndexSetToMeshAttributeHashmap;
     typedef std::map<GLTF::Semantic , IndexSetToMeshAttributeHashmap > SemanticToMeshAttributeHashmap;
     
     class GLTFMesh : public JSONObject {
@@ -43,14 +45,14 @@
         
         virtual ~GLTFMesh();
         
-        std::shared_ptr <MeshAttributeVector> meshAttributes();
+        boost::shared_ptr <MeshAttributeVector> meshAttributes();
         
-        bool appendPrimitive(std::shared_ptr <GLTF::GLTFPrimitive> primitive);
+        bool appendPrimitive(boost::shared_ptr <GLTF::GLTFPrimitive> primitive);
         
         bool hasSemantic(Semantic semantic);
         
-        void setMeshAttribute(Semantic semantic, size_t indexOfSet, std::shared_ptr<GLTFAccessor> meshAttribute);
-        std::shared_ptr<GLTFAccessor> getMeshAttribute(Semantic semantic, size_t indexOfSet);
+        void setMeshAttribute(Semantic semantic, size_t indexOfSet, boost::shared_ptr<GLTFAccessor> meshAttribute);
+        boost::shared_ptr<GLTFAccessor> getMeshAttribute(Semantic semantic, size_t indexOfSet);
         
         size_t getMeshAttributesCountForSemantic(Semantic semantic);
         
@@ -62,32 +64,32 @@
         std::string getName();
         void setName(std::string name);
         
-        std::shared_ptr<JSONObject> getExtensions();
+        boost::shared_ptr<JSONObject> getExtensions();
 
         void setRemapTableForPositions(unsigned int* remapTableForPositions);
         unsigned int* getRemapTableForPositions();
 
-        std::shared_ptr<JSONArray> getPrimitives();
-        void setPrimitives(std::shared_ptr<JSONArray>);
+        boost::shared_ptr<JSONArray> getPrimitives();
+        void setPrimitives(boost::shared_ptr<JSONArray>);
         size_t getPrimitivesCount();
 
         bool writeAllBuffers(std::ofstream& verticesOutputStream, std::ofstream& indicesOutputStream, std::ofstream& genericStream);
         
         void resolveAttributes();
         
-        std::shared_ptr<JSONArray> subMeshes() {
-            if (this->_subMeshes == nullptr) {
-                this->_subMeshes = std::shared_ptr <JSONArray> (new JSONArray());
+        boost::shared_ptr<JSONArray> subMeshes() {
+            if (this->_subMeshes == 0) {
+                this->_subMeshes = boost::shared_ptr <JSONArray> (new JSONArray());
             }
             return this->_subMeshes;
         }
         
-        std::shared_ptr<GLTFMesh> clone();
+        boost::shared_ptr<GLTFMesh> clone();
 
     private:
         SemanticToMeshAttributeHashmap _semanticToMeshAttributes;
         std::string _ID;
-        std::shared_ptr<JSONArray> _subMeshes;
+        boost::shared_ptr<JSONArray> _subMeshes;
         
         //This is unfortunate that we need to keep this information,
         //but since we get skinning weights and bone indices after the mesh and the openCOLLADA mesh is not available anymore, we need to keep
@@ -98,4 +100,4 @@
 }
 
 
-#endif
\ No newline at end of file
+#endif
diff -ur collada2gltf.org/GLTF/GLTFOutputStream.cpp collada2gltf/GLTF/GLTFOutputStream.cpp
--- collada2gltf.org/GLTF/GLTFOutputStream.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFOutputStream.cpp	2014-09-29 15:36:33.000000000 +0200
@@ -69,11 +69,11 @@
         }
     }
     
-    void GLTFOutputStream::write(shared_ptr<GLTFBuffer> buffer) {        
+    void GLTFOutputStream::write(boost::shared_ptr<GLTFBuffer> buffer) {        
         this->write((const char*)(buffer->getData()), buffer->getByteLength());
     }
 
-    void GLTFOutputStream::write(shared_ptr<GLTFBufferView> bufferView) {
+    void GLTFOutputStream::write(boost::shared_ptr<GLTFBufferView> bufferView) {
         this->write((const char*)( bufferView->getBufferDataByApplyingOffset()), bufferView->getByteLength());
     }
     
diff -ur collada2gltf.org/GLTF/GLTFOutputStream.h collada2gltf/GLTF/GLTFOutputStream.h
--- collada2gltf.org/GLTF/GLTFOutputStream.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFOutputStream.h	2014-09-29 15:36:27.000000000 +0200
@@ -24,6 +24,8 @@
 #ifndef __GLTF_OUTPUT_STREAM__
 #define __GLTF_OUTPUT_STREAM__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF
 {
     class GLTFOutputStream {
@@ -33,8 +35,8 @@
         GLTFOutputStream(const std::string &folder, const std::string &file, const std::string &kind);
         
         size_t length();
-        void write(std::shared_ptr<GLTFBuffer> buffer);
-        void write(std::shared_ptr<GLTFBufferView> bufferView);
+        void write(boost::shared_ptr<GLTFBuffer> buffer);
+        void write(boost::shared_ptr<GLTFBufferView> bufferView);
         void write(const char* buffer, size_t length);
 
         const std::string& filename();
diff -ur collada2gltf.org/GLTF/GLTFPrimitive.cpp collada2gltf/GLTF/GLTFPrimitive.cpp
--- collada2gltf.org/GLTF/GLTFPrimitive.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFPrimitive.cpp	2014-09-29 15:36:40.000000000 +0200
@@ -55,9 +55,9 @@
         
     }
     
-    shared_ptr<GLTFPrimitive> GLTFPrimitive::clone()
+    boost::shared_ptr<GLTFPrimitive> GLTFPrimitive::clone()
     {
-        shared_ptr<GLTFPrimitive> primitive(new GLTFPrimitive(*this));
+        boost::shared_ptr<GLTFPrimitive> primitive(new GLTFPrimitive(*this));
         //FIXME: this should be done in GLTFPrimitive, but it's not possible at the moment, due to const signature that needs to be widely updated..
         primitive->setIndices(this->getIndices());
         
@@ -85,7 +85,7 @@
         return this->_allVertexAttributes;
     }
     
-    void GLTFPrimitive::appendVertexAttribute(shared_ptr <JSONVertexAttribute> VertexAttribute)
+    void GLTFPrimitive::appendVertexAttribute(boost::shared_ptr <JSONVertexAttribute> VertexAttribute)
     {
         this->_allVertexAttributes.push_back(VertexAttribute);
     }    
@@ -114,11 +114,11 @@
         this->_materialObjectID = materialID;
     }
     
-    shared_ptr <GLTF::GLTFAccessor>  GLTFPrimitive::getIndices() {
+    boost::shared_ptr <GLTF::GLTFAccessor>  GLTFPrimitive::getIndices() {
         return this->_uniqueIndices;
     }
     
-    void GLTFPrimitive::setIndices(shared_ptr <GLTF::GLTFAccessor> indices) {
+    void GLTFPrimitive::setIndices(boost::shared_ptr <GLTF::GLTFAccessor> indices) {
         this->setString(kIndices, indices->getID());
         this->_uniqueIndices = indices;
     }
diff -ur collada2gltf.org/GLTF/GLTFPrimitive.h collada2gltf/GLTF/GLTFPrimitive.h
--- collada2gltf.org/GLTF/GLTFPrimitive.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFPrimitive.h	2014-09-29 15:36:51.000000000 +0200
@@ -27,6 +27,8 @@
 #ifndef __JSON_PRIMITIVE_H__
 #define __JSON_PRIMITIVE_H__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF 
 {
     class JSONVertexAttribute
@@ -70,20 +72,20 @@
         size_t getVertexAttributesCount();
         
         VertexAttributeVector getVertexAttributes();
-        void appendVertexAttribute(std::shared_ptr <JSONVertexAttribute> VertexAttribute);
+        void appendVertexAttribute(boost::shared_ptr <JSONVertexAttribute> VertexAttribute);
         
-        std::shared_ptr <GLTF::GLTFAccessor>  getIndices();
-        void setIndices(std::shared_ptr <GLTF::GLTFAccessor> indices);
+        boost::shared_ptr <GLTF::GLTFAccessor>  getIndices();
+        void setIndices(boost::shared_ptr <GLTF::GLTFAccessor> indices);
         
-        std::shared_ptr<GLTFPrimitive> clone();
+        boost::shared_ptr<GLTFPrimitive> clone();
 
     private:
         unsigned int _materialObjectID;
-        std::shared_ptr <GLTF::GLTFAccessor> _uniqueIndices;
+        boost::shared_ptr <GLTF::GLTFAccessor> _uniqueIndices;
         VertexAttributeVector _allVertexAttributes;
     };
 
 }
 
 
-#endif
\ No newline at end of file
+#endif
diff -ur collada2gltf.org/GLTF/GLTFProfile.h collada2gltf/GLTF/GLTFProfile.h
--- collada2gltf.org/GLTF/GLTFProfile.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFProfile.h	2014-09-29 15:54:56.822549582 +0200
@@ -24,7 +24,9 @@
 #ifndef __GLTF_PROFILE__
 #define __GLTF_PROFILE__
 
-typedef std::unordered_map<std::string ,unsigned int> GLEnumForString;
+#include <boost/unordered_map.hpp>
+
+typedef boost::unordered_map<std::string ,unsigned int> GLEnumForString;
 
 namespace GLTF
 {
@@ -48,4 +50,4 @@
     };
 }
 
-#endif
\ No newline at end of file
+#endif
diff -ur collada2gltf.org/GLTF/GLTFSkin.cpp collada2gltf/GLTF/GLTFSkin.cpp
--- collada2gltf.org/GLTF/GLTFSkin.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFSkin.cpp	2014-09-29 15:37:15.000000000 +0200
@@ -33,14 +33,14 @@
 {
     //--- Controller
     GLTFController::GLTFController() : JSONObject() {
-        this->_extras = shared_ptr<JSONObject>(new JSONObject());
+        this->_extras = boost::shared_ptr<JSONObject>(new JSONObject());
     }
     
     GLTFController::~GLTFController() {
         
     }
 
-    shared_ptr <JSONObject> GLTFController::extras() {
+    boost::shared_ptr <JSONObject> GLTFController::extras() {
         return this->_extras;
     }
 
@@ -62,19 +62,19 @@
         return "skin";
     }
     
-    shared_ptr<JSONArray> GLTFSkin::getBindShapeMatrix() {
+    boost::shared_ptr<JSONArray> GLTFSkin::getBindShapeMatrix() {
         return this->getArray(kBindShapeMatrix);
     }
     
-    void GLTFSkin::setBindShapeMatrix(shared_ptr<JSONArray>  bindShapeMatrix) {
+    void GLTFSkin::setBindShapeMatrix(boost::shared_ptr<JSONArray>  bindShapeMatrix) {
         this->setValue(kBindShapeMatrix, bindShapeMatrix);
     }
     
-    shared_ptr<JSONArray> GLTFSkin::getJointsIds() {
+    boost::shared_ptr<JSONArray> GLTFSkin::getJointsIds() {
         return this->getArray(kJoints);
     }
     
-    void GLTFSkin::setJointsIds(shared_ptr<JSONArray> jointIds) {
+    void GLTFSkin::setJointsIds(boost::shared_ptr<JSONArray> jointIds) {
         this->setValue(kJoints, jointIds);
     }
     
@@ -82,19 +82,19 @@
         return this->_id;
     }
     
-    void GLTFSkin::setJoints(shared_ptr <GLTFAccessor> joints) {
+    void GLTFSkin::setJoints(boost::shared_ptr <GLTFAccessor> joints) {
         this->_joints = joints;
     }
     
-    shared_ptr <GLTFAccessor> GLTFSkin::getJoints() {
+    boost::shared_ptr <GLTFAccessor> GLTFSkin::getJoints() {
         return this->_joints;
     }
     
-    void GLTFSkin::setWeights(shared_ptr <GLTFAccessor> weights) {
+    void GLTFSkin::setWeights(boost::shared_ptr <GLTFAccessor> weights) {
         this->_weights = weights;
     }
 
-    shared_ptr <GLTFAccessor> GLTFSkin::getWeights() {
+    boost::shared_ptr <GLTFAccessor> GLTFSkin::getWeights() {
         return this->_weights;
     }
     
@@ -106,11 +106,11 @@
         return this->_sourceUID;
     }
     
-    void GLTFSkin::setInverseBindMatrices(shared_ptr <GLTFBufferView> inverseBindMatrices) {
+    void GLTFSkin::setInverseBindMatrices(boost::shared_ptr <GLTFBufferView> inverseBindMatrices) {
         this->_inverseBindMatrices = inverseBindMatrices;
     }
     
-    shared_ptr <GLTFBufferView> GLTFSkin::getInverseBindMatrices() {
+    boost::shared_ptr <GLTFBufferView> GLTFSkin::getInverseBindMatrices() {
         return this->_inverseBindMatrices;
     }
     
diff -ur collada2gltf.org/GLTF/GLTFSkin.h collada2gltf/GLTF/GLTFSkin.h
--- collada2gltf.org/GLTF/GLTFSkin.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFSkin.h	2014-09-29 15:37:09.000000000 +0200
@@ -24,6 +24,8 @@
 #ifndef __GLTFSKIN_H__
 #define __GLTFSKIN_H__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF 
 {
     class GLTFController : public JSONObject {
@@ -32,9 +34,9 @@
         virtual ~GLTFController();
         virtual std::string getType() = 0;
 
-        std::shared_ptr<JSONObject> extras();
+        boost::shared_ptr<JSONObject> extras();
     private:
-        std::shared_ptr<JSONObject> _extras;
+        boost::shared_ptr<JSONObject> _extras;
     };
 
     class GLTFSkin : public GLTFController
@@ -44,25 +46,25 @@
         GLTFSkin(std::string id);
         virtual ~GLTFSkin();
         
-        std::shared_ptr<JSONArray> getBindShapeMatrix();
-        void setBindShapeMatrix(std::shared_ptr<JSONArray>  bindShapeMatrix);
+        boost::shared_ptr<JSONArray> getBindShapeMatrix();
+        void setBindShapeMatrix(boost::shared_ptr<JSONArray>  bindShapeMatrix);
         
-        std::shared_ptr<JSONArray> getJointsIds();
-        void setJointsIds(std::shared_ptr<JSONArray> jointIds);
+        boost::shared_ptr<JSONArray> getJointsIds();
+        void setJointsIds(boost::shared_ptr<JSONArray> jointIds);
         
         const std::string& getId();
         
-        void setJoints(std::shared_ptr <GLTFAccessor> joints);
-        std::shared_ptr <GLTFAccessor> getJoints();
+        void setJoints(boost::shared_ptr <GLTFAccessor> joints);
+        boost::shared_ptr <GLTFAccessor> getJoints();
 
-        void setWeights(std::shared_ptr <GLTFAccessor> weights);
-        std::shared_ptr <GLTFAccessor> getWeights();
+        void setWeights(boost::shared_ptr <GLTFAccessor> weights);
+        boost::shared_ptr <GLTFAccessor> getWeights();
 
         void setSourceUID(std::string uniqueId);
         std::string getSourceUID();
         
-        void setInverseBindMatrices(std::shared_ptr <GLTFBufferView> inverseBindMatrices);
-        std::shared_ptr <GLTFBufferView> getInverseBindMatrices();
+        void setInverseBindMatrices(boost::shared_ptr <GLTFBufferView> inverseBindMatrices);
+        boost::shared_ptr <GLTFBufferView> getInverseBindMatrices();
                 
         //controller
         std::string getType();
@@ -71,10 +73,10 @@
         size_t getJointsCount();
         
     private:
-        std::shared_ptr <GLTFBufferView> _inverseBindMatrices;
+        boost::shared_ptr <GLTFBufferView> _inverseBindMatrices;
                 
-        std::shared_ptr<GLTFAccessor> _joints;
-        std::shared_ptr<GLTFAccessor> _weights;
+        boost::shared_ptr<GLTFAccessor> _joints;
+        boost::shared_ptr<GLTFAccessor> _weights;
         
         std::string _id;
         std::string _sourceUID;
@@ -84,4 +86,4 @@
 }
 
 
-#endif
\ No newline at end of file
+#endif
diff -ur collada2gltf.org/GLTF/GLTFTypesAndConstants.h collada2gltf/GLTF/GLTFTypesAndConstants.h
--- collada2gltf.org/GLTF/GLTFTypesAndConstants.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFTypesAndConstants.h	2014-09-29 15:37:30.000000000 +0200
@@ -29,6 +29,8 @@
 
 #define EXPORT_MATERIALS_AS_EFFECTS 1
 
+#include <boost/shared_ptr.hpp>
+
 const float glTFVersion = 0.6f;
 
 const std::string kCount = "count";
@@ -97,18 +99,18 @@
     class JSONVertexAttribute;
     class GLTFAnimationFlattener;
     //-- Args & Options
-    typedef std::vector <std::shared_ptr <GLTF::JSONValue> > JSONValueVector;
+    typedef std::vector <boost::shared_ptr <GLTF::JSONValue> > JSONValueVector;
     typedef JSONValueVector& JSONValueVectorRef;
-    typedef std::vector <std::shared_ptr <GLTF::GLTFPrimitive> > PrimitiveVector;
-    typedef std::vector <std::shared_ptr<GLTF::GLTFAccessor> > IndicesVector;
-    typedef std::vector <std::shared_ptr<GLTF::GLTFAccessor> > MeshAttributeVector;
-    typedef std::vector <std::shared_ptr<GLTF::JSONVertexAttribute> > VertexAttributeVector;
+    typedef std::vector <boost::shared_ptr <GLTF::GLTFPrimitive> > PrimitiveVector;
+    typedef std::vector <boost::shared_ptr<GLTF::GLTFAccessor> > IndicesVector;
+    typedef std::vector <boost::shared_ptr<GLTF::GLTFAccessor> > MeshAttributeVector;
+    typedef std::vector <boost::shared_ptr<GLTF::JSONVertexAttribute> > VertexAttributeVector;
     
-    typedef std::shared_ptr<GLTFMesh> GLTFMeshSharedPtr;
-    typedef std::vector <std::shared_ptr<GLTF::GLTFMesh> > MeshVector;
+    typedef boost::shared_ptr<GLTFMesh> GLTFMeshSharedPtr;
+    typedef std::vector <boost::shared_ptr<GLTF::GLTFMesh> > MeshVector;
 
-    typedef std::map<std::string , std::shared_ptr <GLTFAnimationFlattener> > AnimationFlattenerForTargetUID;
-    typedef std::shared_ptr<AnimationFlattenerForTargetUID> AnimationFlattenerForTargetUIDSharedPtr;
+    typedef std::map<std::string , boost::shared_ptr <GLTFAnimationFlattener> > AnimationFlattenerForTargetUID;
+    typedef boost::shared_ptr<AnimationFlattenerForTargetUID> AnimationFlattenerForTargetUIDSharedPtr;
     typedef std::map<std::string , AnimationFlattenerForTargetUIDSharedPtr > FlattenerMapsForAnimationID;
 
     std::string generateIDForType( const char* typeCStr, const char* suffix = 0);
diff -ur collada2gltf.org/GLTF/GLTFWriter.cpp collada2gltf/GLTF/GLTFWriter.cpp
--- collada2gltf.org/GLTF/GLTFWriter.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFWriter.cpp	2014-09-29 15:37:43.000000000 +0200
@@ -36,24 +36,24 @@
 
 namespace GLTF 
 {    
-    shared_ptr <JSONValue> serializeVec3(double x,double y, double z) {
-        shared_ptr <JSONArray> vec3(new GLTF::JSONArray());
+    boost::shared_ptr <JSONValue> serializeVec3(double x,double y, double z) {
+        boost::shared_ptr <JSONArray> vec3(new GLTF::JSONArray());
         
-        vec3->appendValue(shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(x)));
-        vec3->appendValue(shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(y)));
-        vec3->appendValue(shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(z)));
+        vec3->appendValue(boost::shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(x)));
+        vec3->appendValue(boost::shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(y)));
+        vec3->appendValue(boost::shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(z)));
         
         return vec3;
     }
     
-    shared_ptr <JSONValue> serializeVec4(double x,double y, double z, double w) {
-        shared_ptr <JSONArray> vec4(new GLTF::JSONArray());
+    boost::shared_ptr <JSONValue> serializeVec4(double x,double y, double z, double w) {
+        boost::shared_ptr <JSONArray> vec4(new GLTF::JSONArray());
         
-        vec4->appendValue(shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(x)));
-        vec4->appendValue(shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(y)));
-        vec4->appendValue(shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(z)));
+        vec4->appendValue(boost::shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(x)));
+        vec4->appendValue(boost::shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(y)));
+        vec4->appendValue(boost::shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(z)));
 
-        vec4->appendValue(shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(w)));
+        vec4->appendValue(boost::shared_ptr <GLTF::JSONNumber> (new GLTF::JSONNumber(w)));
 
         return vec4;
     }
@@ -90,7 +90,7 @@
     void GLTFWriter::writeArray(JSONArray* array, void *context) {
         this->_writer->StartArray();
         
-        vector <shared_ptr <JSONValue> > values = array->values();
+        vector <boost::shared_ptr <JSONValue> > values = array->values();
         size_t count = values.size();
         for (size_t i = 0 ; i < count ; i++) {
             values[i]->write(this, context);
@@ -106,7 +106,7 @@
         size_t count = keys.size();
         
         for (size_t i = 0 ; i < count ; i++) {
-            shared_ptr <JSONValue> value = object->getValue(keys[i]);
+            boost::shared_ptr <JSONValue> value = object->getValue(keys[i]);
             const std::string& key = keys[i];
             this->_writer->String(key.c_str());
             if (value)
diff -ur collada2gltf.org/GLTF/GLTFWriter.h collada2gltf/GLTF/GLTFWriter.h
--- collada2gltf.org/GLTF/GLTFWriter.h	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTF/GLTFWriter.h	2014-09-29 15:37:52.000000000 +0200
@@ -27,10 +27,12 @@
 #ifndef __JSON_WRITER_H__
 #define __JSON_WRITER_H__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF
 {
-    std::shared_ptr <JSONValue> serializeVec3(double x,double y, double z);
-    std::shared_ptr <JSONValue> serializeVec4(double x,double y, double z, double w);
+    boost::shared_ptr <JSONValue> serializeVec3(double x,double y, double z);
+    boost::shared_ptr <JSONValue> serializeVec4(double x,double y, double z, double w);
 
 	class GLTFWriter {
     private:
@@ -58,4 +60,4 @@
 }
 
 
-#endif
\ No newline at end of file
+#endif
diff -ur collada2gltf.org/GLTFOpenCOLLADAUtils.cpp collada2gltf/GLTFOpenCOLLADAUtils.cpp
--- collada2gltf.org/GLTFOpenCOLLADAUtils.cpp	2014-09-29 15:30:40.134494471 +0200
+++ collada2gltf/GLTFOpenCOLLADAUtils.cpp	2014-09-29 15:32:22.000000000 +0200
@@ -31,7 +31,7 @@
 using namespace std;
 
 void fillFloatPtrFromOpenCOLLADAMatrix4(const COLLADABU::Math::Matrix4 &matrix, float *m) {
-    shared_ptr <GLTF::JSONArray> array(new GLTF::JSONArray());
+    boost::shared_ptr <GLTF::JSONArray> array(new GLTF::JSONArray());
     
     COLLADABU::Math::Matrix4 transpose = matrix.transpose();
     
@@ -45,14 +45,14 @@
     }
 }
 
-shared_ptr <GLTF::JSONArray> serializeOpenCOLLADAMatrix4(const COLLADABU::Math::Matrix4 &matrix) {
+boost::shared_ptr <GLTF::JSONArray> serializeOpenCOLLADAMatrix4(const COLLADABU::Math::Matrix4 &matrix) {
     float m[16];
-    shared_ptr <GLTF::JSONArray> array(new GLTF::JSONArray());
+    boost::shared_ptr <GLTF::JSONArray> array(new GLTF::JSONArray());
     
     fillFloatPtrFromOpenCOLLADAMatrix4(matrix, m);
     
     for (int i = 0 ; i < 16; i++)  {
-        array->appendValue(shared_ptr <GLTF::JSONValue> (new GLTF::JSONNumber(m[i])));
+        array->appendValue(boost::shared_ptr <GLTF::JSONValue> (new GLTF::JSONNumber(m[i])));
     }
     
     return array;
diff -ur collada2gltf.org/GLTFOpenCOLLADAUtils.h collada2gltf/GLTFOpenCOLLADAUtils.h
--- collada2gltf.org/GLTFOpenCOLLADAUtils.h	2014-09-29 15:30:40.142494472 +0200
+++ collada2gltf/GLTFOpenCOLLADAUtils.h	2014-09-29 15:32:18.000000000 +0200
@@ -24,7 +24,9 @@
 #ifndef __GLTF_OPENCOLLADA_UTILS_H__
 #define __GLTF_OPENCOLLADA_UTILS_H__
 
-std::shared_ptr <GLTF::JSONArray> serializeOpenCOLLADAMatrix4(const COLLADABU::Math::Matrix4 &matrix);
+#include <boost/shared_ptr.hpp>
+
+boost::shared_ptr <GLTF::JSONArray> serializeOpenCOLLADAMatrix4(const COLLADABU::Math::Matrix4 &matrix);
 void fillFloatPtrFromOpenCOLLADAMatrix4(const COLLADABU::Math::Matrix4 &matrix, float *m);
 
 #endif
diff -ur collada2gltf.org/helpers/geometryHelpers.cpp collada2gltf/helpers/geometryHelpers.cpp
--- collada2gltf.org/helpers/geometryHelpers.cpp	2014-09-29 15:30:40.146494472 +0200
+++ collada2gltf/helpers/geometryHelpers.cpp	2014-09-29 16:01:12.134563781 +0200
@@ -193,8 +193,8 @@
         for (size_t meshAttributeIndex = 0 ; meshAttributeIndex < count; meshAttributeIndex++) {
             MeshAttributesBufferInfos *bufferInfos = &allBufferInfos[meshAttributeIndex];
             
-            shared_ptr <GLTF::GLTFAccessor> remappedMeshAttribute = allRemappedMeshAttributes[indicesInRemapping[meshAttributeIndex]];
-            shared_ptr <GLTF::GLTFAccessor> originalMeshAttribute = allOriginalMeshAttributes[indicesInRemapping[meshAttributeIndex]];
+            boost::shared_ptr <GLTF::GLTFAccessor> remappedMeshAttribute = allRemappedMeshAttributes[indicesInRemapping[meshAttributeIndex]];
+            boost::shared_ptr <GLTF::GLTFAccessor> originalMeshAttribute = allOriginalMeshAttributes[indicesInRemapping[meshAttributeIndex]];
             
             if (originalMeshAttribute->elementByteLength() != remappedMeshAttribute->elementByteLength()) {
                 // FIXME : report error
@@ -213,12 +213,12 @@
         return allBufferInfos;
     }
     
-    bool __RemapPrimitiveVertices(shared_ptr<GLTF::GLTFPrimitive> primitive,
-                                  std::vector< shared_ptr<GLTF::GLTFAccessor> > allIndices,
+    bool __RemapPrimitiveVertices(boost::shared_ptr<GLTF::GLTFPrimitive> primitive,
+                                  std::vector< boost::shared_ptr<GLTF::GLTFAccessor> > allIndices,
                                   MeshAttributeVector allOriginalMeshAttributes,
                                   MeshAttributeVector allRemappedMeshAttributes,
                                   unsigned int* indicesInRemapping,
-                                  shared_ptr<GLTF::GLTFPrimitiveRemapInfos> primitiveRemapInfos,
+                                  boost::shared_ptr<GLTF::GLTFPrimitiveRemapInfos> primitiveRemapInfos,
                                   unsigned int* remapTableForPositions /* we fill/keep this to be able to remap skin weight/bone indices later on*/)
     {
         size_t indicesSize = allIndices.size();
@@ -267,14 +267,14 @@
     }
     
     
-    shared_ptr<GLTF::GLTFPrimitiveRemapInfos> __BuildPrimitiveUniqueIndexes(shared_ptr<GLTF::GLTFPrimitive> primitive,
-                                                                            std::vector< shared_ptr<GLTF::GLTFAccessor> > allIndices,
+    boost::shared_ptr<GLTF::GLTFPrimitiveRemapInfos> __BuildPrimitiveUniqueIndexes(boost::shared_ptr<GLTF::GLTFPrimitive> primitive,
+                                                                            std::vector< boost::shared_ptr<GLTF::GLTFAccessor> > allIndices,
                                                                             RemappedMeshIndexesHashmap& remappedMeshIndexesMap,
                                                                             unsigned int* indicesInRemapping,
                                                                             size_t startIndex,
                                                                             unsigned int meshAttributesCount,
                                                                             size_t &endIndex,
-                                                                            shared_ptr<GLTFProfile> profile)
+                                                                            boost::shared_ptr<GLTFProfile> profile)
     {
         unsigned int generatedIndicesCount = 0;
 
@@ -317,10 +317,10 @@
         }
         
         endIndex = currentIndex;
-        shared_ptr <GLTF::GLTFPrimitiveRemapInfos> primitiveRemapInfos(new GLTF::GLTFPrimitiveRemapInfos(generatedIndices, generatedIndicesCount, originalCountAndIndexes));
-        shared_ptr <GLTF::GLTFBufferView> indicesBufferView = createBufferViewWithAllocatedBuffer(uniqueIndexes, 0, vertexIndicesCount * sizeof(unsigned int), true);
+        boost::shared_ptr <GLTF::GLTFPrimitiveRemapInfos> primitiveRemapInfos(new GLTF::GLTFPrimitiveRemapInfos(generatedIndices, generatedIndicesCount, originalCountAndIndexes));
+        boost::shared_ptr <GLTF::GLTFBufferView> indicesBufferView = createBufferViewWithAllocatedBuffer(uniqueIndexes, 0, vertexIndicesCount * sizeof(unsigned int), true);
         
-        shared_ptr <GLTF::GLTFAccessor> indices = shared_ptr <GLTF::GLTFAccessor> (new GLTFAccessor(profile, profile->getGLenumForString("UNSIGNED_SHORT")));
+        boost::shared_ptr <GLTF::GLTFAccessor> indices = boost::shared_ptr <GLTF::GLTFAccessor> (new GLTFAccessor(profile, profile->getGLenumForString("UNSIGNED_SHORT")));
         
         indices->setBufferView(indicesBufferView);
         indices->setCount(vertexIndicesCount);
@@ -334,20 +334,20 @@
 
 #define DUMP_UNIFIED_INDEXES_INFO 0
     
-    shared_ptr <GLTFMesh> createUnifiedIndexesMeshFromMesh( GLTFMesh *sourceMesh,
-                                                            std::vector< shared_ptr<IndicesVector> > &vectorOfIndicesVector,
-                                                            shared_ptr<GLTFProfile> profile)
+    boost::shared_ptr <GLTFMesh> createUnifiedIndexesMeshFromMesh( GLTFMesh *sourceMesh,
+                                                            std::vector< boost::shared_ptr<IndicesVector> > &vectorOfIndicesVector,
+                                                            boost::shared_ptr<GLTFProfile> profile)
     {
         MeshAttributeVector originalMeshAttributes;
         MeshAttributeVector remappedMeshAttributes;
-        shared_ptr <GLTFMesh> targetMesh(new GLTFMesh(*sourceMesh));
+        boost::shared_ptr <GLTFMesh> targetMesh(new GLTFMesh(*sourceMesh));
         
         GLTF::JSONValueVector sourcePrimitives = sourceMesh->getPrimitives()->values();
         GLTF::JSONValueVector targetPrimitives = targetMesh->getPrimitives()->values();
         
 #if DUMP_UNIFIED_INDEXES_INFO
         {
-        shared_ptr<GLTFAccessor> vertexSource = sourceMesh->getMeshAttribute(GLTF::POSITION, 0);
+        boost::shared_ptr<GLTFAccessor> vertexSource = sourceMesh->getMeshAttribute(GLTF::POSITION, 0);
         printf("vertex source cout :%d\n",(int)vertexSource->getCount());
         }
 #endif
@@ -358,7 +358,7 @@
         
         if (primitiveCount == 0) {
             // FIXME: report error
-            return nullptr;
+            return boost::shared_ptr <GLTFMesh>();
         }
         
         //in originalMeshAttributes we'll get the flattened list of all the meshAttributes as a vector.
@@ -370,7 +370,7 @@
             GLTF::Semantic semantic = allSemantics[i];
             size_t attributesCount = sourceMesh->getMeshAttributesCountForSemantic(semantic);
             for (size_t j = 0 ; j < attributesCount ; j ++) {
-                shared_ptr <GLTF::GLTFAccessor> selectedMeshAttribute = sourceMesh->getMeshAttribute(semantic, j);
+                boost::shared_ptr <GLTF::GLTFAccessor> selectedMeshAttribute = sourceMesh->getMeshAttribute(semantic, j);
                 unsigned int indexSet = j;
                 std::string semanticIndexSetKey = keyWithSemanticAndSet(semantic, indexSet);
                 unsigned int size = (unsigned int)originalMeshAttributes.size();
@@ -382,16 +382,16 @@
         
         maxVertexAttributes = (unsigned int)originalMeshAttributes.size();
         
-        vector <shared_ptr<GLTF::GLTFPrimitiveRemapInfos> > allPrimitiveRemapInfos;
+        vector <boost::shared_ptr<GLTF::GLTFPrimitiveRemapInfos> > allPrimitiveRemapInfos;
         
         //build a array that maps the meshAttributes that the indices points to with the index of the indice.
         GLTF::RemappedMeshIndexesHashmap remappedMeshIndexesMap;
         for (unsigned int i = 0 ; i < primitiveCount ; i++) {
-            shared_ptr<IndicesVector>  allIndicesSharedPtr = vectorOfIndicesVector[i];
+            boost::shared_ptr<IndicesVector>  allIndicesSharedPtr = vectorOfIndicesVector[i];
             IndicesVector *allIndices = allIndicesSharedPtr.get();
             unsigned int* indicesInRemapping = (unsigned int*)malloc(sizeof(unsigned int) * allIndices->size());
             
-            shared_ptr<GLTFPrimitive> sourcePrimitive = static_pointer_cast<GLTFPrimitive>(sourcePrimitives[i]);
+            boost::shared_ptr<GLTFPrimitive> sourcePrimitive = static_pointer_cast<GLTFPrimitive>(sourcePrimitives[i]);
             VertexAttributeVector vertexAttributes = sourcePrimitive->getVertexAttributes();
             for (unsigned int k = 0 ; k < allIndices->size() ; k++) {
                 GLTF::Semantic semantic = vertexAttributes[k]->getSemantic();
@@ -401,9 +401,9 @@
                 indicesInRemapping[k] = idx;
             }
             
-            shared_ptr<GLTFPrimitive> targetPrimitive = static_pointer_cast<GLTFPrimitive>(targetPrimitives[i]);
+            boost::shared_ptr<GLTFPrimitive> targetPrimitive = static_pointer_cast<GLTFPrimitive>(targetPrimitives[i]);
             
-            shared_ptr<GLTF::GLTFPrimitiveRemapInfos> primitiveRemapInfos = __BuildPrimitiveUniqueIndexes(targetPrimitive, *allIndices, remappedMeshIndexesMap, indicesInRemapping, startIndex, maxVertexAttributes, endIndex, profile);
+            boost::shared_ptr<GLTF::GLTFPrimitiveRemapInfos> primitiveRemapInfos = __BuildPrimitiveUniqueIndexes(targetPrimitive, *allIndices, remappedMeshIndexesMap, indicesInRemapping, startIndex, maxVertexAttributes, endIndex, profile);
             
             free(indicesInRemapping);
             
@@ -412,7 +412,7 @@
                 allPrimitiveRemapInfos.push_back(primitiveRemapInfos);
             } else {
                 // FIXME: report error
-                return nullptr;
+                return boost::shared_ptr <GLTFMesh>();
             }
         }
         
@@ -427,14 +427,14 @@
             GLTF::Semantic semantic = allSemantics[i];
             size_t attributesCount = sourceMesh->getMeshAttributesCountForSemantic(semantic);
             for (size_t j = 0 ; j < attributesCount ; j ++) {
-                shared_ptr <GLTF::GLTFAccessor> selectedMeshAttribute = sourceMesh->getMeshAttribute(semantic, j);
+                boost::shared_ptr <GLTF::GLTFAccessor> selectedMeshAttribute = sourceMesh->getMeshAttribute(semantic, j);
                 size_t sourceSize = vertexCount * selectedMeshAttribute->elementByteLength();
                 void* sourceData = malloc(sourceSize);
                 
-                shared_ptr <GLTFBufferView> referenceBufferView = selectedMeshAttribute->getBufferView();
-                shared_ptr <GLTFBufferView> remappedBufferView = createBufferViewWithAllocatedBuffer(referenceBufferView->getID(), sourceData, 0, sourceSize, true);
+                boost::shared_ptr <GLTFBufferView> referenceBufferView = selectedMeshAttribute->getBufferView();
+                boost::shared_ptr <GLTFBufferView> remappedBufferView = createBufferViewWithAllocatedBuffer(referenceBufferView->getID(), sourceData, 0, sourceSize, true);
 
-                shared_ptr <GLTFAccessor> remappedMeshAttribute(new GLTFAccessor(selectedMeshAttribute.get()));
+                boost::shared_ptr <GLTFAccessor> remappedMeshAttribute(new GLTFAccessor(selectedMeshAttribute.get()));
                 remappedMeshAttribute->setBufferView(remappedBufferView);
                 remappedMeshAttribute->setCount(vertexCount);
                 
@@ -452,10 +452,10 @@
          */
         
         for (unsigned int i = 0 ; i < primitiveCount ; i++) {
-            shared_ptr<IndicesVector>  allIndicesSharedPtr = vectorOfIndicesVector[i];
+            boost::shared_ptr<IndicesVector>  allIndicesSharedPtr = vectorOfIndicesVector[i];
             IndicesVector *allIndices = allIndicesSharedPtr.get();
             unsigned int* indicesInRemapping = (unsigned int*)calloc(sizeof(unsigned int) * (*allIndices).size(), 1);
-            shared_ptr<GLTFPrimitive> sourcePrimitive = static_pointer_cast<GLTFPrimitive>(sourcePrimitives[i]);
+            boost::shared_ptr<GLTFPrimitive> sourcePrimitive = static_pointer_cast<GLTFPrimitive>(sourcePrimitives[i]);
             VertexAttributeVector vertexAttributes = sourcePrimitive->getVertexAttributes();
             
             for (unsigned int k = 0 ; k < (*allIndices).size() ; k++) {
@@ -466,7 +466,7 @@
                 indicesInRemapping[k] = idx;
             }
             
-            shared_ptr<GLTFPrimitive> targetPrimitive = static_pointer_cast<GLTFPrimitive>(targetPrimitives[i]);
+            boost::shared_ptr<GLTFPrimitive> targetPrimitive = static_pointer_cast<GLTFPrimitive>(targetPrimitives[i]);
             bool status = __RemapPrimitiveVertices(targetPrimitive,
                                                    (*allIndices),
                                                    originalMeshAttributes ,
@@ -478,13 +478,13 @@
             
             if (!status) {
                 // FIXME: report error
-                return nullptr;
+                return boost::shared_ptr <GLTFMesh>();
             }
         }
         
 #if DUMP_UNIFIED_INDEXES_INFO
         {
-            shared_ptr<GLTFAccessor> vertexSource = targetMesh->getMeshAttribute(GLTF::POSITION, 0);
+            boost::shared_ptr<GLTFAccessor> vertexSource = targetMesh->getMeshAttribute(GLTF::POSITION, 0);
             printf("vertex dest count :%d\n",(int)vertexSource->getCount());
         }
 #endif
@@ -496,7 +496,7 @@
     
     class SubMeshContext {
     public:
-        shared_ptr <GLTFMesh> targetMesh;
+        boost::shared_ptr <GLTFMesh> targetMesh;
         //For each sub mesh being built, maintain 2 maps,
         //with key:indice value: remapped indice
         IndicesMap indexToRemappedIndex;
@@ -505,7 +505,7 @@
     SubMeshContext* __CreateSubMeshContext(const std::string& id)
     {
         SubMeshContext *subMesh = new SubMeshContext();
-        shared_ptr <GLTFMesh> targetMesh = shared_ptr <GLTFMesh> (new GLTFMesh());
+        boost::shared_ptr <GLTFMesh> targetMesh = boost::shared_ptr <GLTFMesh> (new GLTFMesh());
         targetMesh->setID(id);
         subMesh->targetMesh = targetMesh;
         
@@ -554,9 +554,9 @@
             GLTF::Semantic semantic = allSemantics[i];
             size_t attributesCount = sourceMesh->getMeshAttributesCountForSemantic(semantic);
             for (size_t j = 0 ; j < attributesCount ; j ++) {
-                shared_ptr <GLTFAccessor> selectedMeshAttribute = sourceMesh->getMeshAttribute(semantic, j);
+                boost::shared_ptr <GLTFAccessor> selectedMeshAttribute = sourceMesh->getMeshAttribute(semantic, j);
                 
-                shared_ptr <GLTFBufferView> referenceBufferView = selectedMeshAttribute->getBufferView();
+                boost::shared_ptr <GLTFBufferView> referenceBufferView = selectedMeshAttribute->getBufferView();
                 
 				unsigned int vertexAttributeCount = (unsigned int)subMesh->indexToRemappedIndex.size();
                 
@@ -568,10 +568,10 @@
                 context[1] = subMesh;
                 selectedMeshAttribute->applyOnAccessor(__RemapMeshAttribute, (void*)context);
                                         
-                shared_ptr <GLTFBufferView> remappedBufferView =
+                boost::shared_ptr <GLTFBufferView> remappedBufferView =
                 createBufferViewWithAllocatedBuffer(referenceBufferView->getID(), targetBufferPtr, 0, selectedMeshAttribute->elementByteLength() * vertexAttributeCount, true);
                 
-                shared_ptr <GLTFAccessor> remappedMeshAttribute(new GLTF::GLTFAccessor(selectedMeshAttribute.get()));
+                boost::shared_ptr <GLTFAccessor> remappedMeshAttribute(new GLTF::GLTFAccessor(selectedMeshAttribute.get()));
                 remappedMeshAttribute->setBufferView(remappedBufferView);
                 remappedMeshAttribute->setCount(vertexAttributeCount);
                 
@@ -580,35 +580,35 @@
         }
     }
     
-    shared_ptr <GLTFMesh> createMeshWithMaximumIndicesCountFromMeshIfNeeded(GLTFMesh *sourceMesh, size_t maximumIndicesCount, shared_ptr<GLTFProfile> profile)
+    boost::shared_ptr <GLTFMesh> createMeshWithMaximumIndicesCountFromMeshIfNeeded(GLTFMesh *sourceMesh, size_t maximumIndicesCount, boost::shared_ptr<GLTFProfile> profile)
     {
-        shared_ptr <GLTFMesh> destinationMesh = nullptr;
+        boost::shared_ptr <GLTFMesh> destinationMesh;
         bool splitNeeded = sourceMesh->getMeshAttribute(GLTF::POSITION, 0)->getCount()  >= maximumIndicesCount;
         GLTF::JSONValueVector primitives = sourceMesh->getPrimitives()->values();
         
         for (size_t i = 0 ; i < primitives.size() ; i++) {
-            shared_ptr<GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
+            boost::shared_ptr<GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
         }
         
         if (!splitNeeded)
-            return nullptr;
+            return boost::shared_ptr <GLTFMesh>();
         
-        SubMeshContext *subMesh = nullptr;
+        SubMeshContext *subMesh = 0;
 
         bool stillHavePrimitivesElementsToBeProcessed = false;
         bool primitiveCompleted = false;
         
         int *allNextPrimitiveIndices = (int*)calloc(primitives.size(), sizeof(int));
         size_t meshIndex = 0;
-        shared_ptr <GLTFMesh> targetMesh = nullptr;
+        boost::shared_ptr <GLTFMesh> targetMesh;
         
         for (size_t i = 0 ; i < primitives.size() ; i++) {
             if (allNextPrimitiveIndices[i] == -1)
                 continue;
             
-            if (subMesh == nullptr) {
+            if (subMesh == 0) {
                 
-                if (targetMesh == nullptr) {
+                if (targetMesh == 0) {
                     subMesh = __CreateSubMeshContext(sourceMesh->getID());
                     targetMesh = subMesh->targetMesh;
                 }
@@ -628,15 +628,15 @@
                 meshIndex++;
             }
             
-            shared_ptr <GLTFPrimitive> targetPrimitive;
+            boost::shared_ptr <GLTFPrimitive> targetPrimitive;
             //when we are done with a primitive we mark its nextIndice with a -1
-            shared_ptr<GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive> (primitives[i]);
+            boost::shared_ptr<GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive> (primitives[i]);
 
-            targetPrimitive = shared_ptr <GLTFPrimitive> (new GLTFPrimitive((*primitive)));
+            targetPrimitive = boost::shared_ptr <GLTFPrimitive> (new GLTFPrimitive((*primitive)));
             
             unsigned int nextPrimitiveIndex = (unsigned int)allNextPrimitiveIndices[i];
             
-            shared_ptr<GLTFAccessor> indices = primitive->getIndices();
+            boost::shared_ptr<GLTFAccessor> indices = primitive->getIndices();
             
             unsigned int* indicesPtr = (unsigned int*)indices->getBufferView()->getBufferDataByApplyingOffset();
             unsigned int* targetIndicesPtr = (unsigned int*)malloc(indices->getBufferView()->getBuffer()->getByteLength());
@@ -690,9 +690,9 @@
             allNextPrimitiveIndices[i] = nextPrimitiveIndex;
 
             if (targetIndicesCount > 0) {
-                shared_ptr <GLTFBufferView> targetBufferView = createBufferViewWithAllocatedBuffer(targetIndicesPtr, 0,targetIndicesCount * sizeof(unsigned int), true);
+                boost::shared_ptr <GLTFBufferView> targetBufferView = createBufferViewWithAllocatedBuffer(targetIndicesPtr, 0,targetIndicesCount * sizeof(unsigned int), true);
                 
-                shared_ptr <GLTFAccessor> indices(new GLTFAccessor(profile, profile->getGLenumForString("UNSIGNED_SHORT")));
+                boost::shared_ptr <GLTFAccessor> indices(new GLTFAccessor(profile, profile->getGLenumForString("UNSIGNED_SHORT")));
 
                 indices->setBufferView(targetBufferView);
                 indices->setCount(targetIndicesCount);
@@ -728,7 +728,7 @@
     //Not required anymore since Open3DGC supports now sharing same vertex buffer and WebGL is disabled
     //DO NOT REMOVE - might be useful again someday
     /*
-    bool createMeshesFromMeshPrimitives(GLTFMesh *sourceMesh, MeshVector &meshes, shared_ptr<GLTFProfile> profile) {
+    bool createMeshesFromMeshPrimitives(GLTFMesh *sourceMesh, MeshVector &meshes, boost::shared_ptr<GLTFProfile> profile) {
         GLTF::JSONValueVector primitives = sourceMesh->getPrimitives()->values();
         if (primitives.size() == 1) {
             return false;
@@ -738,9 +738,9 @@
         
         for (size_t i = 0 ; i < primitiveCount ; i++) {
             IndicesMap remappedIndices;
-            shared_ptr <GLTFMesh> targetMesh = shared_ptr <GLTFMesh> (new GLTFMesh());
-            shared_ptr <GLTFPrimitive> refPrimitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
-            shared_ptr <GLTFPrimitive> targetPrimitive = shared_ptr <GLTFPrimitive> (new GLTFPrimitive((*refPrimitive)));
+            boost::shared_ptr <GLTFMesh> targetMesh = boost::shared_ptr <GLTFMesh> (new GLTFMesh());
+            boost::shared_ptr <GLTFPrimitive> refPrimitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
+            boost::shared_ptr <GLTFPrimitive> targetPrimitive = boost::shared_ptr <GLTFPrimitive> (new GLTFPrimitive((*refPrimitive)));
 
             targetMesh->appendPrimitive(targetPrimitive);
             
@@ -759,9 +759,9 @@
                 }
             }
             
-            shared_ptr <GLTFBufferView> targetIndicesView = createBufferViewWithAllocatedBuffer(targetIndices, 0,indicesCount * sizeof(unsigned int), true);
+            boost::shared_ptr <GLTFBufferView> targetIndicesView = createBufferViewWithAllocatedBuffer(targetIndices, 0,indicesCount * sizeof(unsigned int), true);
             
-            shared_ptr <GLTFAccessor> indices(new GLTFAccessor(profile, profile->getGLenumForString("UNSIGNED_SHORT")));
+            boost::shared_ptr <GLTFAccessor> indices(new GLTFAccessor(profile, profile->getGLenumForString("UNSIGNED_SHORT")));
             
             indices->setBufferView(targetIndicesView);
             indices->setCount(indicesCount);
@@ -770,21 +770,21 @@
 
             
             // Now for each mesh attribute in the mesh, create another one just for the primitive
-            shared_ptr <GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
+            boost::shared_ptr <GLTFPrimitive> primitive = static_pointer_cast<GLTFPrimitive>(primitives[i]);
             VertexAttributeVector vertexAttributes = primitive->getVertexAttributes();
             for (size_t j = 0 ; j < vertexAttributes.size() ; j++) {
                 Semantic semantic = vertexAttributes[j]->getSemantic();
                 size_t indexOfSet = vertexAttributes[j]->getIndexOfSet();
-                shared_ptr <GLTFAccessor> meshAttribute = sourceMesh->getMeshAttribute(semantic, indexOfSet);
+                boost::shared_ptr <GLTFAccessor> meshAttribute = sourceMesh->getMeshAttribute(semantic, indexOfSet);
                 
                 size_t targetVertexCount = remappedIndices.size();
                 
                 unsigned char *sourcePtr = (unsigned char *)meshAttribute->getBufferView()->getBufferDataByApplyingOffset();
                 
-                shared_ptr<GLTFAccessor> targetAttribute = shared_ptr<GLTFAccessor> (new GLTFAccessor(meshAttribute.get()));
+                boost::shared_ptr<GLTFAccessor> targetAttribute = boost::shared_ptr<GLTFAccessor> (new GLTFAccessor(meshAttribute.get()));
                 size_t targetAttributeSize = targetVertexCount * meshAttribute->elementByteLength();
                 unsigned char *targetAttributePtr = (unsigned char*)malloc(targetAttributeSize);
-                shared_ptr <GLTFBufferView> targetAttributeBufferView = createBufferViewWithAllocatedBuffer(targetAttributePtr, 0, targetAttributeSize, true);
+                boost::shared_ptr <GLTFBufferView> targetAttributeBufferView = createBufferViewWithAllocatedBuffer(targetAttributePtr, 0, targetAttributeSize, true);
                 targetAttribute->setCount(targetVertexCount);
                 targetAttribute->setBufferView(targetAttributeBufferView);
 
@@ -811,4 +811,4 @@
     }
     */
     
-}
\ No newline at end of file
+}
diff -ur collada2gltf.org/helpers/geometryHelpers.h collada2gltf/helpers/geometryHelpers.h
--- collada2gltf.org/helpers/geometryHelpers.h	2014-09-29 15:30:40.142494472 +0200
+++ collada2gltf/helpers/geometryHelpers.h	2014-09-29 15:55:26.718550713 +0200
@@ -24,13 +24,15 @@
 #ifndef __GEOMETRY_HELPERS__
 #define __GEOMETRY_HELPERS__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF
 {
     std::string keyWithSemanticAndSet(GLTF::Semantic semantic, unsigned int indexSet);
 
-    std::shared_ptr <GLTFMesh> createUnifiedIndexesMeshFromMesh(GLTFMesh *sourceMesh, std::vector< std::shared_ptr<IndicesVector> > &vectorOfIndicesVector, std::shared_ptr<GLTFProfile> profile);
+    boost::shared_ptr <GLTFMesh> createUnifiedIndexesMeshFromMesh(GLTFMesh *sourceMesh, std::vector< boost::shared_ptr<IndicesVector> > &vectorOfIndicesVector, boost::shared_ptr<GLTFProfile> profile);
     
-    std::shared_ptr <GLTFMesh> createMeshWithMaximumIndicesCountFromMeshIfNeeded(GLTFMesh *sourceMesh, size_t maxiumIndicesCount, std::shared_ptr<GLTFProfile> profile);
+    boost::shared_ptr <GLTFMesh> createMeshWithMaximumIndicesCountFromMeshIfNeeded(GLTFMesh *sourceMesh, size_t maxiumIndicesCount, boost::shared_ptr<GLTFProfile> profile);
     
     unsigned int* createTrianglesFromPolylist(unsigned int *verticesCount /* array containing the count for each array of indices per face */,
                                               unsigned int *polylist /* array containing the indices of a face */,
@@ -43,4 +45,4 @@
 
 }
 
-#endif
\ No newline at end of file
+#endif
diff -ur collada2gltf.org/JSON/JSONArray.cpp collada2gltf/JSON/JSONArray.cpp
--- collada2gltf.org/JSON/JSONArray.cpp	2014-09-29 15:30:40.142494472 +0200
+++ collada2gltf/JSON/JSONArray.cpp	2014-09-29 15:48:30.998534985 +0200
@@ -50,30 +50,30 @@
                     break;
                 case kFalseType:
                 case kTrueType:
-                    this->appendValue(shared_ptr<JSONNumber> (new JSONNumber(kTrueType ? true: false)));
+                    this->appendValue(boost::shared_ptr<JSONNumber> (new JSONNumber(kTrueType ? true: false)));
                     break;
                 case kObjectType: {
-                    shared_ptr<JSONObject> obj(new JSONObject());
+                    boost::shared_ptr<JSONObject> obj(new JSONObject());
                     obj->_parseRapidJSONObject((void*)currentValue);
                     this->appendValue(obj);
                 }
                     break;
                 case kArrayType: {
-                    shared_ptr<JSONArray> obj(new JSONArray());
+                    boost::shared_ptr<JSONArray> obj(new JSONArray());
                     obj->_parseRapidJSONArray((void*)currentValue);
                     this->appendValue(obj);
                 }
                     break;
                 case kStringType:
-                    this->appendValue(shared_ptr<JSONString> (new JSONString(currentValue->GetString())));
+                    this->appendValue(boost::shared_ptr<JSONString> (new JSONString(currentValue->GetString())));
                     break;
                 case kNumberType:
                     if (rapidjsonValue->IsDouble()) {
-                        this->appendValue(shared_ptr<JSONNumber> (new JSONNumber(currentValue->GetDouble())));
+                        this->appendValue(boost::shared_ptr<JSONNumber> (new JSONNumber(currentValue->GetDouble())));
                     } else if (rapidjsonValue->IsInt() || currentValue->IsInt64()) {
-                        this->appendValue(shared_ptr<JSONNumber> (new JSONNumber(currentValue->GetInt())));
+                        this->appendValue(boost::shared_ptr<JSONNumber> (new JSONNumber(currentValue->GetInt())));
                     } else if (currentValue->IsUint() || currentValue->IsUint64()) {
-                        this->appendValue(shared_ptr<JSONNumber> (new JSONNumber(currentValue->GetUint())));
+                        this->appendValue(boost::shared_ptr<JSONNumber> (new JSONNumber(currentValue->GetUint())));
                     }
                     
                     break;
@@ -91,7 +91,7 @@
         return this->_values;
     }
     
-    void JSONArray::appendValue(shared_ptr <JSONValue> value) {
+    void JSONArray::appendValue(boost::shared_ptr <JSONValue> value) {
         this->_values.push_back(value);
     }
 
@@ -100,7 +100,7 @@
     }
     
     void JSONArray::apply(JSONValueApplierFunc func, void* context) {
-        vector <shared_ptr <JSONValue> > values = this->values();
+        vector <boost::shared_ptr <JSONValue> > values = this->values();
         size_t count = values.size();
         for (size_t i = 0 ; i < count ; i++) {
             values[i]->apply(func, context);
@@ -112,7 +112,7 @@
     }
 
     bool JSONArray::isEqualTo(JSONValue* value) {
-        assert(value != nullptr);
+        assert(value != 0);
         
         if (JSONValue::isEqualTo(value) == true)
             return true;
@@ -134,7 +134,7 @@
     }
     
     size_t JSONArray::indexOfValue(JSONValue* value) {
-        assert(value != nullptr);
+        assert(value != 0);
         size_t count = this->getCount();
         for (size_t i = 0 ; i < count ; i++) {
             if (this->_values[i]->isEqualTo(value)) {
diff -ur collada2gltf.org/JSON/JSONArray.h collada2gltf/JSON/JSONArray.h
--- collada2gltf.org/JSON/JSONArray.h	2014-09-29 15:30:40.142494472 +0200
+++ collada2gltf/JSON/JSONArray.h	2014-09-29 15:47:13.382532049 +0200
@@ -27,6 +27,8 @@
 #ifndef __JSON_ARRAY_H__
 #define __JSON_ARRAY_H__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF 
 {
     class JSONArray : public JSONValue {
@@ -38,7 +40,7 @@
         JSONArray();
         virtual ~JSONArray();
 
-        virtual void appendValue(std::shared_ptr <JSONValue>);
+        virtual void appendValue(boost::shared_ptr <JSONValue>);
         
         JSONValueVectorRef values();
         
@@ -63,4 +65,4 @@
 }
 
 
-#endif
\ No newline at end of file
+#endif
diff -ur collada2gltf.org/JSON/JSONNumber.cpp collada2gltf/JSON/JSONNumber.cpp
--- collada2gltf.org/JSON/JSONNumber.cpp	2014-09-29 15:30:40.142494472 +0200
+++ collada2gltf/JSON/JSONNumber.cpp	2014-09-29 15:48:20.566534590 +0200
@@ -171,7 +171,7 @@
     }
     
     bool JSONNumber::isEqualTo(JSONValue* value) {
-        assert(value != nullptr);
+        assert(value != 0);
         
         if (JSONValue::isEqualTo(value) == true)
             return true;
diff -ur collada2gltf.org/JSON/JSONObject.cpp collada2gltf/JSON/JSONObject.cpp
--- collada2gltf.org/JSON/JSONObject.cpp	2014-09-29 15:30:40.142494472 +0200
+++ collada2gltf/JSON/JSONObject.cpp	2014-09-29 15:48:14.562534363 +0200
@@ -38,8 +38,8 @@
 namespace GLTF 
 {
         
-    shared_ptr <JSONObject> JSONObjectWithContentsOfFile(std::string filepath, char** error) {
-        shared_ptr <GLTF::JSONObject> outObject(new JSONObject());
+    boost::shared_ptr <JSONObject> JSONObjectWithContentsOfFile(std::string filepath, char** error) {
+        boost::shared_ptr <GLTF::JSONObject> outObject(new JSONObject());
 
         outObject->initWithContentsOfFile(filepath.c_str(), error);
         
@@ -63,13 +63,13 @@
                     this->setBool(key, true);
                     break;
                 case kObjectType: {
-                    shared_ptr<JSONObject> obj(new JSONObject());
+                    boost::shared_ptr<JSONObject> obj(new JSONObject());
                     obj->_parseRapidJSONObject(currentValue);
                     this->setValue(key, obj);
                 }
                     break;
                 case kArrayType: {
-                    shared_ptr<JSONArray> array(new JSONArray());
+                    boost::shared_ptr<JSONArray> array(new JSONArray());
                     array->_parseRapidJSONArray(currentValue);
                     this->setValue(key, array);
                 }
@@ -128,10 +128,10 @@
     {
     }
     
-    shared_ptr <GLTF::JSONObject> JSONObject::createObjectIfNeeded(const std::string& key) {
-        shared_ptr <GLTF::JSONObject> outObject;
+    boost::shared_ptr <GLTF::JSONObject> JSONObject::createObjectIfNeeded(const std::string& key) {
+        boost::shared_ptr <GLTF::JSONObject> outObject;
         if (!contains(key)) {
-            outObject = shared_ptr <GLTF::JSONObject> (new GLTF::JSONObject());
+            outObject = boost::shared_ptr <GLTF::JSONObject> (new GLTF::JSONObject());
             setValue(key, outObject);
         } else {
             outObject = static_pointer_cast <GLTF::JSONObject> (getValue(key));
@@ -139,10 +139,10 @@
         return outObject;
     }
     
-    shared_ptr <GLTF::JSONArray> JSONObject::createArrayIfNeeded(const std::string& key) {
-        shared_ptr <GLTF::JSONArray> outObject;
+    boost::shared_ptr <GLTF::JSONArray> JSONObject::createArrayIfNeeded(const std::string& key) {
+        boost::shared_ptr <GLTF::JSONArray> outObject;
         if (!contains(key)) {
-            outObject = shared_ptr <GLTF::JSONArray> (new GLTF::JSONArray());
+            outObject = boost::shared_ptr <GLTF::JSONArray> (new GLTF::JSONArray());
             setValue(key, outObject);
         } else {
             outObject = static_pointer_cast <GLTF::JSONArray> (getValue(key));
@@ -151,7 +151,7 @@
     }
 
     
-    void JSONObject::setValue(const std::string &key, shared_ptr <JSONValue> value) {
+    void JSONObject::setValue(const std::string &key, boost::shared_ptr <JSONValue> value) {
         this->_keyToJSONValue[key] = value;
     }
     
@@ -160,39 +160,39 @@
     }
 
     
-    shared_ptr <JSONValue> JSONObject::getValue(std::string key) {
+    boost::shared_ptr <JSONValue> JSONObject::getValue(std::string key) {
         return this->_keyToJSONValue[key];
     }
     
-    shared_ptr <JSONObject> JSONObject::getObject(const std::string &key) {
-        shared_ptr <JSONValue> value = this->_keyToJSONValue[key];
+    boost::shared_ptr <JSONObject> JSONObject::getObject(const std::string &key) {
+        boost::shared_ptr <JSONValue> value = this->_keyToJSONValue[key];
         return static_pointer_cast <JSONObject> (value);
     }
 
-    shared_ptr <JSONArray> JSONObject::getArray(const std::string &key) {
-        shared_ptr <JSONValue> value = this->_keyToJSONValue[key];
+    boost::shared_ptr <JSONArray> JSONObject::getArray(const std::string &key) {
+        boost::shared_ptr <JSONValue> value = this->_keyToJSONValue[key];
         return static_pointer_cast <JSONArray> (value);
     }
 
     void JSONObject::setUnsignedInt32(const std::string &key, unsigned int value) {
-        this->setValue(key, shared_ptr <JSONNumber> (new JSONNumber((unsigned int)value)));
+        this->setValue(key, boost::shared_ptr <JSONNumber> (new JSONNumber((unsigned int)value)));
     }
 
     unsigned int JSONObject::getUnsignedInt32(const std::string &key) {
         if (this->contains(key)) {
-            shared_ptr <JSONNumber> number = static_pointer_cast <JSONNumber> (this->getValue(key));
+            boost::shared_ptr <JSONNumber> number = static_pointer_cast <JSONNumber> (this->getValue(key));
             return number->getUnsignedInt32();
         }
         return 0;
     }
     
     void JSONObject::setBool(const std::string &key, bool value) {
-        this->setValue(key, shared_ptr <JSONNumber> (new JSONNumber(value)));
+        this->setValue(key, boost::shared_ptr <JSONNumber> (new JSONNumber(value)));
     }
     
     bool JSONObject::getBool(const std::string &key) {
         if (this->contains(key)) {
-            shared_ptr <JSONNumber> number = static_pointer_cast <JSONNumber> (this->getValue(key));
+            boost::shared_ptr <JSONNumber> number = static_pointer_cast <JSONNumber> (this->getValue(key));
             
             return number->getBool();
         }
@@ -200,36 +200,36 @@
     }
     
     void JSONObject::setInt32(const std::string &key, int value) {
-        this->setValue(key, shared_ptr <JSONNumber> (new JSONNumber((int)value)));
+        this->setValue(key, boost::shared_ptr <JSONNumber> (new JSONNumber((int)value)));
     }
     
     int JSONObject::getInt32(const std::string &key) {
         if (this->contains(key)) {
-            shared_ptr <JSONNumber> number = static_pointer_cast <JSONNumber> (this->getValue(key));
+            boost::shared_ptr <JSONNumber> number = static_pointer_cast <JSONNumber> (this->getValue(key));
             return number->getInt32();
         }
         return 0;
     }
     
     void JSONObject::setDouble(const std::string &key, double value) {
-        this->setValue(key, shared_ptr <JSONNumber> (new JSONNumber((double)value)));
+        this->setValue(key, boost::shared_ptr <JSONNumber> (new JSONNumber((double)value)));
     }
     
     double JSONObject::getDouble(const std::string &key) {
         if (this->contains(key)) {
-            shared_ptr <JSONNumber> number = static_pointer_cast <JSONNumber> (this->getValue(key));
+            boost::shared_ptr <JSONNumber> number = static_pointer_cast <JSONNumber> (this->getValue(key));
             return number->getDouble();
         }
         return 0;
     }
     
     void JSONObject::setString(const std::string &key, const std::string &value) {
-        this->setValue(key, shared_ptr <JSONString> (new JSONString(value)));
+        this->setValue(key, boost::shared_ptr <JSONString> (new JSONString(value)));
     }
 
     const std::string JSONObject::getString(const std::string &key) {
         if (this->contains(key)) {
-            shared_ptr <JSONString> str = static_pointer_cast <JSONString> (this->getValue(key));
+            boost::shared_ptr <JSONString> str = static_pointer_cast <JSONString> (this->getValue(key));
             return str->getString();
         }
         return "";
@@ -252,12 +252,12 @@
         return allKeys;
     }
     
-    shared_ptr<JSONArray> JSONObject::keys() {
+    boost::shared_ptr<JSONArray> JSONObject::keys() {
         vector <std::string> allKeys = this->getAllKeys();
-        shared_ptr<JSONArray> keys(new JSONArray());
+        boost::shared_ptr<JSONArray> keys(new JSONArray());
         
         for (size_t i = 0 ; i < allKeys.size() ; i++) {
-            keys->appendValue(shared_ptr<JSONString> (new JSONString(allKeys[i])));
+            keys->appendValue(boost::shared_ptr<JSONString> (new JSONString(allKeys[i])));
         }
         
         return keys;
@@ -285,7 +285,7 @@
         vector <std::string> keys = this->getAllKeys();
         size_t count = keys.size();        
         for (size_t i = 0 ; i < count ; i++) {
-            shared_ptr <JSONValue> value = this->getValue(keys[i]);
+            boost::shared_ptr <JSONValue> value = this->getValue(keys[i]);
             if (value)
                 value->apply(func, context);
         }
@@ -293,7 +293,7 @@
 
     
     bool JSONObject::isEqualTo(JSONValue* value) {
-        assert(value != nullptr);
+        assert(value != 0);
         
         if (JSONValue::isEqualTo(value) == true)
             return true;
@@ -302,8 +302,8 @@
         
         //for this first pass/implementation, it will be a bit slow as many , we'll gather all the keys
         //then, if the number of keys is equal on both objects, then check if all the keys are equlals, and finally if these objects are equal one by one.
-        shared_ptr<JSONArray> keysA = this->keys();
-        shared_ptr<JSONArray> keysB = objectValue->keys();
+        boost::shared_ptr<JSONArray> keysA = this->keys();
+        boost::shared_ptr<JSONArray> keysB = objectValue->keys();
         
         if (keysA->getCount() != keysB->getCount())
             return false;
@@ -313,10 +313,10 @@
         
         JSONValueVectorRef allKeys = keysA->values();
         for (size_t i = 0 ; i < allKeys.size() ; i++) {
-            shared_ptr<JSONString> key = static_pointer_cast<JSONString>(allKeys[i]);
+            boost::shared_ptr<JSONString> key = static_pointer_cast<JSONString>(allKeys[i]);
             
-            shared_ptr<JSONValue> objA = this->getValue(key->getString());
-            shared_ptr<JSONValue> objB = objectValue->getValue(key->getString());
+            boost::shared_ptr<JSONValue> objA = this->getValue(key->getString());
+            boost::shared_ptr<JSONValue> objB = objectValue->getValue(key->getString());
             if (objA->isEqualTo(objB.get()) == false) {
                 return false;
             }
diff -ur collada2gltf.org/JSON/JSONObject.h collada2gltf/JSON/JSONObject.h
--- collada2gltf.org/JSON/JSONObject.h	2014-09-29 15:30:40.142494472 +0200
+++ collada2gltf/JSON/JSONObject.h	2014-09-29 15:47:38.762533009 +0200
@@ -27,13 +27,15 @@
 #ifndef __JSON_OBJECT_H__
 #define __JSON_OBJECT_H__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF 
 {
-    std::shared_ptr <JSONObject> JSONObjectWithContentsOfFile(std::string fileName);
+    boost::shared_ptr <JSONObject> JSONObjectWithContentsOfFile(std::string fileName);
 
     class JSONArray;
     
-    typedef std::map<std::string , std::shared_ptr <JSONValue> > KeyToJSONValue;
+    typedef std::map<std::string , boost::shared_ptr <JSONValue> > KeyToJSONValue;
     
     class JSONObject : public JSONValue {
         friend class JSONArray;
@@ -47,15 +49,15 @@
         bool initWithCString(const char *jsonString, char **error);
         bool initWithContentsOfFile(const char *filepath, char **error);
 
-        std::shared_ptr <JSONObject> createObjectIfNeeded(const std::string& key);
-        std::shared_ptr <JSONArray> createArrayIfNeeded(const std::string& key);
-        void setValue(const std::string &key, std::shared_ptr <JSONValue> value);
-        std::shared_ptr <JSONValue> getValue(std::string);
+        boost::shared_ptr <JSONObject> createObjectIfNeeded(const std::string& key);
+        boost::shared_ptr <JSONArray> createArrayIfNeeded(const std::string& key);
+        void setValue(const std::string &key, boost::shared_ptr <JSONValue> value);
+        boost::shared_ptr <JSONValue> getValue(std::string);
 
         void removeValue(const std::string &key);
         
-        std::shared_ptr <JSONObject> getObject(const std::string&);
-        std::shared_ptr <JSONArray> getArray(const std::string&);
+        boost::shared_ptr <JSONObject> getObject(const std::string&);
+        boost::shared_ptr <JSONArray> getArray(const std::string&);
 
         bool contains(const std::string &key);
         
@@ -76,7 +78,7 @@
         
         std::vector <std::string> getAllKeys();
         
-        std::shared_ptr<JSONArray> keys();
+        boost::shared_ptr<JSONArray> keys();
         
         size_t getKeysCount();
         
@@ -97,4 +99,4 @@
 }
 
 
-#endif
\ No newline at end of file
+#endif
diff -ur collada2gltf.org/JSON/JSONString.cpp collada2gltf/JSON/JSONString.cpp
--- collada2gltf.org/JSON/JSONString.cpp	2014-09-29 15:30:40.142494472 +0200
+++ collada2gltf/JSON/JSONString.cpp	2014-09-29 15:48:07.414534093 +0200
@@ -59,7 +59,7 @@
     }
     
     bool JSONString::isEqualTo(JSONValue* value) {
-        assert(value != nullptr);
+        assert(value != 0);
 
         if (JSONValue::isEqualTo(value) == true)
             return true;
diff -ur collada2gltf.org/JSON/JSONString.h collada2gltf/JSON/JSONString.h
--- collada2gltf.org/JSON/JSONString.h	2014-09-29 15:30:40.142494472 +0200
+++ collada2gltf/JSON/JSONString.h	2014-09-29 15:57:42.610555854 +0200
@@ -27,9 +27,11 @@
 #ifndef __JSON_STRING_H__
 #define __JSON_STRING_H__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF 
 {
-#define JSONSTRING(x) (shared_ptr <GLTF::JSONString> (new GLTF::JSONString(x)))
+#define JSONSTRING(x) (boost::shared_ptr <GLTF::JSONString> (new GLTF::JSONString(x)))
     
     class JSONString : public JSONValue {
     private:
@@ -54,4 +56,4 @@
 }
 
 
-#endif
\ No newline at end of file
+#endif
diff -ur collada2gltf.org/JSON/JSONValue.cpp collada2gltf/JSON/JSONValue.cpp
--- collada2gltf.org/JSON/JSONValue.cpp	2014-09-29 15:30:40.142494472 +0200
+++ collada2gltf/JSON/JSONValue.cpp	2014-09-29 15:47:51.954533508 +0200
@@ -44,7 +44,7 @@
         writer->write(this, context);
     }
     
-    shared_ptr<JSONValue> JSONValue::valueForKeyPath(std::string keyPath) {
+    boost::shared_ptr<JSONValue> JSONValue::valueForKeyPath(std::string keyPath) {
         std::size_t pos = keyPath.find(".");
         if (pos == std::string::npos) {
             if (this->getJSONType() == kJSONObject) {
@@ -61,14 +61,14 @@
                 std::string currentPath = keyPath.substr(0,pos);
                 JSONObject *currentObject = (JSONObject*)this;
                 if (currentObject->contains(currentPath)) {
-                    shared_ptr<JSONObject> nextObject = currentObject->getObject(currentPath);
+                    boost::shared_ptr<JSONObject> nextObject = currentObject->getObject(currentPath);
                     pos += 1; //skip the dot
                     std::string nextPath = keyPath.substr(pos);
                     return nextObject->valueForKeyPath(nextPath);
                 }
             }
         }
-        return shared_ptr<JSONValue> ((JSONValue*)0);
+        return boost::shared_ptr<JSONValue> ((JSONValue*)0);
     }
     
     void JSONValue::evaluate(void*) {
@@ -87,4 +87,4 @@
         return false;
     }
     
-}
\ No newline at end of file
+}
diff -ur collada2gltf.org/JSON/JSONValue.h collada2gltf/JSON/JSONValue.h
--- collada2gltf.org/JSON/JSONValue.h	2014-09-29 15:30:40.142494472 +0200
+++ collada2gltf/JSON/JSONValue.h	2014-09-29 15:47:48.158533364 +0200
@@ -27,6 +27,8 @@
 #ifndef __JSON_VALUE_H__
 #define __JSON_VALUE_H__
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF 
 {
     class JSONValue;
@@ -42,7 +44,7 @@
         
         virtual void write(GLTFWriter* , void* context = 0);
         
-        std::shared_ptr<JSONValue> valueForKeyPath(std::string keyPath);
+        boost::shared_ptr<JSONValue> valueForKeyPath(std::string keyPath);
         
         virtual void evaluate(void*);
         
@@ -59,4 +61,4 @@
 }
 
 
-#endif
\ No newline at end of file
+#endif
diff -ur collada2gltf.org/shaders/commonProfileShaders.cpp collada2gltf/shaders/commonProfileShaders.cpp
--- collada2gltf.org/shaders/commonProfileShaders.cpp	2014-09-29 15:30:40.146494472 +0200
+++ collada2gltf/shaders/commonProfileShaders.cpp	2014-09-29 16:02:03.522565725 +0200
@@ -95,13 +95,13 @@
     
     
     //Not yet implemented for everything
-    static bool slotIsContributingToLighting(const std::string &slot, shared_ptr <JSONObject> inputParameters,  GLTFAsset* asset) {
+    static bool slotIsContributingToLighting(const std::string &slot, boost::shared_ptr <JSONObject> inputParameters,  GLTFAsset* asset) {
         if (inputParameters->contains(slot)) {
             if (CONFIG_BOOL(asset, "optimizeParameters") == false)
                 return true;
             
             //FIXME: we need an explicit option to allow this, and make sure we get then consistent instanceTechnique and technique parameters
-            shared_ptr <JSONObject> param = inputParameters->getObject(slot);
+            boost::shared_ptr <JSONObject> param = inputParameters->getObject(slot);
             
             if (param->getUnsignedInt32("type") == asset->profile()->getGLenumForString("SAMPLER_2D"))
                 return true; //it is a texture, so presumably yes, this slot is not neutral
@@ -110,14 +110,14 @@
                 if (slot == "reflective")
                     return false;
                 
-                shared_ptr <JSONArray> color = static_pointer_cast<JSONArray>(param->getValue("value"));
-                vector <shared_ptr <JSONValue> >  values = color->values();
+                boost::shared_ptr <JSONArray> color = boost::static_pointer_cast<JSONArray>(param->getValue("value"));
+                vector <boost::shared_ptr <JSONValue> >  values = color->values();
                 size_t count = values.size();
                 if (count == 3) {
                     //FIXME: handling post processing of JSON Array with numbers is just overkill
-                    shared_ptr <JSONNumber> r = static_pointer_cast<JSONNumber>(values[0]);
-                    shared_ptr <JSONNumber> g = static_pointer_cast<JSONNumber>(values[1]);
-                    shared_ptr <JSONNumber> b = static_pointer_cast<JSONNumber>(values[2]);
+                    boost::shared_ptr <JSONNumber> r = boost::static_pointer_cast<JSONNumber>(values[0]);
+                    boost::shared_ptr <JSONNumber> g = boost::static_pointer_cast<JSONNumber>(values[1]);
+                    boost::shared_ptr <JSONNumber> b = boost::static_pointer_cast<JSONNumber>(values[2]);
                     return (r->getDouble() > 0 || r->getDouble() > 0 || b->getDouble());
                 }
             }
@@ -126,7 +126,7 @@
         return false;
     }
     
-    static double getTransparency(shared_ptr<JSONObject> parameters, GLTFAsset* asset) {
+    static double getTransparency(boost::shared_ptr<JSONObject> parameters, GLTFAsset* asset) {
         //super naive for now, also need to check sketchup work-around
         //if (effectCommon->getOpacity().isTexture()) {
         //    return 1;
@@ -136,34 +136,34 @@
             return 1;
         }
         
-        shared_ptr<JSONObject> tr = parameters->getObject("transparency");
+        boost::shared_ptr<JSONObject> tr = parameters->getObject("transparency");
         
         double transparency = tr->getDouble("value");
         
         return CONFIG_BOOL(asset, "invertTransparency") ? 1 - transparency : transparency;
     }
     
-    static bool hasTransparency(shared_ptr<JSONObject> parameters,
+    static bool hasTransparency(boost::shared_ptr<JSONObject> parameters,
                          GLTFAsset* asset) {
         return getTransparency(parameters, asset)  < 1;
     }
     
-    static bool isOpaque(shared_ptr <JSONObject> parameters, GLTFAsset* asset) {
+    static bool isOpaque(boost::shared_ptr <JSONObject> parameters, GLTFAsset* asset) {
 
         if (parameters->contains("diffuse")) {
-            shared_ptr <JSONObject> diffuse = parameters->getObject("diffuse");
+            boost::shared_ptr <JSONObject> diffuse = parameters->getObject("diffuse");
             
             if (diffuse->getUnsignedInt32("type") == asset->profile()->getGLenumForString("SAMPLER_2D")) {
-                shared_ptr<JSONObject> textures = asset->root()->createObjectIfNeeded("textures");
+                boost::shared_ptr<JSONObject> textures = asset->root()->createObjectIfNeeded("textures");
                 if (textures->getKeysCount() == 0) {
                     return false;
                 }
-                shared_ptr<JSONObject> texture = textures->getObject(diffuse->getString("value"));
+                boost::shared_ptr<JSONObject> texture = textures->getObject(diffuse->getString("value"));
                 std::string sourceUID = texture->getString(kSource);
-                shared_ptr<JSONObject> images = asset->root()->createObjectIfNeeded(kImages);
+                boost::shared_ptr<JSONObject> images = asset->root()->createObjectIfNeeded(kImages);
                 
                 if (images->contains(sourceUID)) {
-                    shared_ptr<JSONObject> image = images->getObject(sourceUID);
+                    boost::shared_ptr<JSONObject> image = images->getObject(sourceUID);
                     std::string imagePath = image->getString("path");
                     COLLADABU::URI inputURI(asset->getInputFilePath().c_str());
                     std::string imageFullPath = inputURI.getPathDir() + imagePath;
@@ -223,12 +223,12 @@
      GL_SAMPLER_CUBE
      */
     
-    static std::string buildSlotHash(shared_ptr<JSONObject> &parameters, std::string slot, GLTFAsset* asset) {
+    static std::string buildSlotHash(boost::shared_ptr<JSONObject> &parameters, std::string slot, GLTFAsset* asset) {
         std::string hash = slot + ":";
 
         if (slotIsContributingToLighting(slot, parameters, asset)) {
             if (parameters->contains(slot)) {
-                shared_ptr<JSONObject> parameter = parameters->getObject(slot);
+                boost::shared_ptr<JSONObject> parameter = parameters->getObject(slot);
                 if (parameter->contains("type")) {
                     hash += GLTFUtils::toString(parameter->getUnsignedInt32("type"));
                     return hash;
@@ -241,19 +241,19 @@
     }
     
     /*
-    static std::string buildLightsHash(shared_ptr<JSONObject> parameters, shared_ptr<JSONObject> techniqueExtras, GLTFAsset& context) {
+    static std::string buildLightsHash(boost::shared_ptr<JSONObject> parameters, boost::shared_ptr<JSONObject> techniqueExtras, GLTFAsset& context) {
         std::string lightsHash = "";
         
         if (context.root->contains("lightsIds")) {
-            shared_ptr<JSONArray> lightsIds = context.root->createArrayIfNeeded("lightsIds");
-            std::vector <shared_ptr <JSONValue> > ids = lightsIds->values();
+            boost::shared_ptr<JSONArray> lightsIds = context.root->createArrayIfNeeded("lightsIds");
+            std::vector <boost::shared_ptr <JSONValue> > ids = lightsIds->values();
             
             for (size_t i = 0 ; i < ids.size() ; i++) {
-                shared_ptr<JSONString> lightUID = static_pointer_cast<JSONString>(ids[i]);
+                boost::shared_ptr<JSONString> lightUID = boost::static_pointer_cast<JSONString>(ids[i]);
                 
-                shared_ptr<JSONArray> lightsNodesIds = static_pointer_cast<JSONArray>(context._uniqueIDOfLightToNodes[lightUID->getString()]);
+                boost::shared_ptr<JSONArray> lightsNodesIds = boost::static_pointer_cast<JSONArray>(context._uniqueIDOfLightToNodes[lightUID->getString()]);
                 
-                std::vector <shared_ptr <JSONValue> > nodesIds = lightsNodesIds->values();
+                std::vector <boost::shared_ptr <JSONValue> > nodesIds = lightsNodesIds->values();
                 for (size_t i = 0 ; i < ids.size() ; i++) {
                 }
            }
@@ -261,7 +261,7 @@
         return lightsHash;
     }
     */
-    static std::string buildTechniqueHash(shared_ptr<JSONObject> parameters, shared_ptr<JSONObject> techniqueExtras, GLTFAsset* asset) {
+    static std::string buildTechniqueHash(boost::shared_ptr<JSONObject> parameters, boost::shared_ptr<JSONObject> techniqueExtras, GLTFAsset* asset) {
         std::string techniqueHash = "";
         bool doubleSided = false;
         unsigned int jointsCount = 0;
@@ -290,11 +290,11 @@
     
     bool writeShaderIfNeeded(const std::string& shaderId,  const std::string& shaderString, GLTFAsset *asset, unsigned int type)
     {
-        shared_ptr <JSONObject> shadersObject = asset->root()->createObjectIfNeeded("shaders");
+        boost::shared_ptr <JSONObject> shadersObject = asset->root()->createObjectIfNeeded("shaders");
         
         if (shadersObject->contains(shaderId) == false) {
-            shared_ptr <JSONObject> shaderObject  = shadersObject->getObject(shaderId);
-            shaderObject = shared_ptr <GLTF::JSONObject> (new GLTF::JSONObject());
+            boost::shared_ptr <JSONObject> shaderObject  = shadersObject->getObject(shaderId);
+            shaderObject = boost::shared_ptr <GLTF::JSONObject> (new GLTF::JSONObject());
             
             std::string path = shaderId+".glsl";
             shadersObject->setValue(shaderId, shaderObject);
@@ -314,10 +314,10 @@
         return true;
     }
     
-    static shared_ptr <JSONObject> createStatesForTechnique(shared_ptr<JSONObject> parameters, shared_ptr<JSONObject> techniqueExtras, GLTFAsset* asset)
+    static boost::shared_ptr <JSONObject> createStatesForTechnique(boost::shared_ptr<JSONObject> parameters, boost::shared_ptr<JSONObject> techniqueExtras, GLTFAsset* asset)
     {
-        shared_ptr <JSONObject> states(new GLTF::JSONObject());
-        shared_ptr <GLTFProfile> profile = asset->profile();
+        boost::shared_ptr <JSONObject> states(new GLTF::JSONObject());
+        boost::shared_ptr <GLTFProfile> profile = asset->profile();
         unsigned int GLZero = 0;
         unsigned int GLOne = 1;
         
@@ -332,7 +332,7 @@
             states->setUnsignedInt32("depthTestEnable", GLOne);
             states->setUnsignedInt32("depthMask", GLOne); //should be true for images, and false for plain color
             states->setUnsignedInt32("blendEquation", profile->getGLenumForString("FUNC_ADD"));
-            shared_ptr <JSONObject> blendFunc(new GLTF::JSONObject());
+            boost::shared_ptr <JSONObject> blendFunc(new GLTF::JSONObject());
             
             
             if (CONFIG_BOOL(asset, "premultipliedAlpha")) {
@@ -366,8 +366,10 @@
     class GLSLShader {
     public:
         
-        GLSLShader(shared_ptr <GLTFProfile> profile) {
-            this->_declarations = "precision highp float;\n";;
+        GLSLShader(boost::shared_ptr <GLTFProfile> profile) {
+            this->_declarations = "#ifdef GL_ES_VERSION_2_0\n";
+            this->_declarations += "precision highp float;\n";
+            this->_declarations += "#endif\n";
             this->_body = "void main(void) {\n";
             this->_profile = profile;
         }
@@ -425,15 +427,15 @@
         std::string _declarations;
         std::string _body;
         
-        shared_ptr <GLTFProfile> _profile;
+        boost::shared_ptr <GLTFProfile> _profile;
     };
     
     class GLSLProgram {
     public:
-        GLSLProgram(shared_ptr<GLTFProfile> profile) {
+        GLSLProgram(boost::shared_ptr<GLTFProfile> profile) {
             this->_profile = profile;
-            this->_uniforms = shared_ptr <GLTF::JSONObject>(new GLTF::JSONObject());
-            this->_attributes = shared_ptr <GLTF::JSONObject>(new GLTF::JSONObject());
+            this->_uniforms = boost::shared_ptr <GLTF::JSONObject>(new GLTF::JSONObject());
+            this->_attributes = boost::shared_ptr <GLTF::JSONObject>(new GLTF::JSONObject());
             this->_vertexShader = new GLSLShader(profile);
             this->_fragmentShader = new GLSLShader(profile);
         }
@@ -457,11 +459,11 @@
             return this->_name;
         }
         
-        shared_ptr <JSONObject> attributes() {
+        boost::shared_ptr <JSONObject> attributes() {
             return this->_attributes;
         }
         
-        shared_ptr <JSONObject> uniforms() {
+        boost::shared_ptr <JSONObject> uniforms() {
             return this->_uniforms;
         }
         
@@ -483,42 +485,46 @@
         GLSLShader *_fragmentShader;
         std::string _name;
         
-        shared_ptr <GLTF::JSONObject> _attributes;
-        shared_ptr <GLTF::JSONObject> _uniforms;
+        boost::shared_ptr <GLTF::JSONObject> _attributes;
+        boost::shared_ptr <GLTF::JSONObject> _uniforms;
         
-        shared_ptr <GLTFProfile> _profile;
+        boost::shared_ptr <GLTFProfile> _profile;
     };
     
     class Pass {
     public:
-        Pass(shared_ptr <GLTFProfile> profile) {
+        Pass(boost::shared_ptr <GLTFProfile> profile) {
             this->_profile = profile;
             this->_instanceProgram = new GLSLProgram(profile);
         }
+
+        ~Pass() {
+            delete _instanceProgram;
+        }
         
         GLSLProgram* instanceProgram() {
             return this->_instanceProgram;
         }
         
-        shared_ptr <JSONObject> getDetails(const std::string &lightingModel,
-                                           shared_ptr<JSONObject> values,
-                                           shared_ptr<JSONObject> techniqueExtras,
-                                           shared_ptr<JSONObject> texcoordBindings,
+        boost::shared_ptr <JSONObject> getDetails(const std::string &lightingModel,
+                                           boost::shared_ptr<JSONObject> values,
+                                           boost::shared_ptr<JSONObject> techniqueExtras,
+                                           boost::shared_ptr<JSONObject> texcoordBindings,
                                            GLTFAsset *asset) {
-            shared_ptr <JSONObject> details(new JSONObject());
+            boost::shared_ptr <JSONObject> details(new JSONObject());
             
-            shared_ptr <JSONObject> commonProfile = details->createObjectIfNeeded("commonProfile");
-            shared_ptr <JSONObject> extras = commonProfile->createObjectIfNeeded("extras");
+            boost::shared_ptr <JSONObject> commonProfile = details->createObjectIfNeeded("commonProfile");
+            boost::shared_ptr <JSONObject> extras = commonProfile->createObjectIfNeeded("extras");
             
             details->setString("type", "COLLADA-1.4.1/commonProfile");
             
-            shared_ptr<JSONArray> parameters(new JSONArray());
+            boost::shared_ptr<JSONArray> parameters(new JSONArray());
             
-            shared_ptr <JSONObject> uniforms = _instanceProgram->uniforms();
+            boost::shared_ptr <JSONObject> uniforms = _instanceProgram->uniforms();
             vector <std::string> keys = uniforms->getAllKeys();
             for (size_t i = 0 ; i < keys.size() ; i++) {
                 std::string parameter = uniforms->getString(keys[i]);
-                parameters->appendValue(shared_ptr <JSONValue> (new JSONString( parameter)));
+                parameters->appendValue(boost::shared_ptr <JSONValue> (new JSONString( parameter)));
             }
             commonProfile->setValue("parameters", parameters);
             
@@ -535,8 +541,8 @@
         
     private:
         GLSLProgram* _instanceProgram;
-        shared_ptr <GLTFProfile> _profile;
-        shared_ptr <JSONObject> states;
+        boost::shared_ptr <GLTFProfile> _profile;
+        boost::shared_ptr <JSONObject> states;
     };
     
     class Technique {
@@ -592,7 +598,7 @@
                                     typeForSemanticUniform(semantic) :
                                     typeForSemanticAttribute(semantic);
             
-            shared_ptr <JSONObject> parameter(new GLTF::JSONObject());
+            boost::shared_ptr <JSONObject> parameter(new GLTF::JSONObject());
             parameter->setString("semantic", semantic);
             parameter->setUnsignedInt32("type",  type);
             _parameters->setValue(parameterID, parameter);
@@ -622,15 +628,15 @@
         }
         
         //FIXME: refactor with addSemantic
-        shared_ptr <JSONObject> addParameter(std::string parameterID, unsigned int type) {
-            shared_ptr <JSONObject> parameter(new GLTF::JSONObject());
+        boost::shared_ptr <JSONObject> addParameter(std::string parameterID, unsigned int type) {
+            boost::shared_ptr <JSONObject> parameter(new GLTF::JSONObject());
             parameter->setUnsignedInt32("type",  type);
             _parameters->setValue(parameterID, parameter);
             
             return parameter;
         }
         
-        shared_ptr <JSONObject> addValue(std::string vertexOrFragment,
+        boost::shared_ptr <JSONObject> addValue(std::string vertexOrFragment,
                                          std::string uniformOrAttribute,
                                          unsigned int type,
                                          size_t count,
@@ -660,11 +666,11 @@
         }
         
         Technique(const std::string &lightingModel,
-                  shared_ptr<JSONObject> attributeSemantics,
+                  boost::shared_ptr<JSONObject> attributeSemantics,
                   std::string techniqueID,
-                  shared_ptr<JSONObject> values,
-                  shared_ptr<JSONObject> techniqueExtras,
-                  shared_ptr<JSONObject> texcoordBindings,
+                  boost::shared_ptr<JSONObject> values,
+                  boost::shared_ptr<JSONObject> techniqueExtras,
+                  boost::shared_ptr<JSONObject> texcoordBindings,
                   GLTFAsset *asset) {
             
             this->_profile = asset->profile();
@@ -676,9 +682,9 @@
             unsigned int floatType = _GL(FLOAT);
             
             this->_pass = new Pass(this->_profile);
-            this->_parameters = shared_ptr<GLTF::JSONObject>(new GLTF::JSONObject());
+            this->_parameters = boost::shared_ptr<GLTF::JSONObject>(new GLTF::JSONObject());
             
-            shared_ptr <JSONObject> inputParameters = values;
+            boost::shared_ptr <JSONObject> inputParameters = values;
             
             bool useSimpleLambert = !(inputParameters->contains("specular") &&
                                      inputParameters->contains("shininess"));
@@ -687,7 +693,7 @@
             bool hasSkinning = false;
             bool hasNormalMap = false;
             
-            if (techniqueExtras != nullptr) {
+            if (techniqueExtras != 0) {
                 jointsCount = techniqueExtras->getUnsignedInt32("jointsCount");
                 hasSkinning =   attributeSemantics->contains("WEIGHT") &&
                                 attributeSemantics->contains("JOINT") &&
@@ -722,7 +728,7 @@
                 addSemantic("vs", "attribute",
                             "WEIGHT", "weight", 1, false);
                 
-                assert(techniqueExtras != nullptr);
+                assert(techniqueExtras != 0);
                 addSemantic("vs", "uniform",
                             "JOINT_MATRIX", "jointMat", jointsCount, false, true /* force as an array */);
             }
@@ -773,17 +779,17 @@
             
             bool modelContainsLights = false;
             if (asset->root()->contains("lightsIds")) {
-                shared_ptr<JSONArray> lightsIds = asset->root()->createArrayIfNeeded("lightsIds");
-                std::vector <shared_ptr <JSONValue> > ids = lightsIds->values();
+                boost::shared_ptr<JSONArray> lightsIds = asset->root()->createArrayIfNeeded("lightsIds");
+                std::vector <boost::shared_ptr <JSONValue> > ids = lightsIds->values();
                 if (ids.size() > 0) {
                     for (size_t i = 0 ; i < ids.size() ; i++) {
-                        shared_ptr<JSONString> lightUID = static_pointer_cast<JSONString>(ids[i]);
-                        shared_ptr<JSONArray> lightsNodesIds = static_pointer_cast<JSONArray>(asset->_uniqueIDOfLightToNodes[lightUID->getString()]);
+                        boost::shared_ptr<JSONString> lightUID = boost::static_pointer_cast<JSONString>(ids[i]);
+                        boost::shared_ptr<JSONArray> lightsNodesIds = boost::static_pointer_cast<JSONArray>(asset->_uniqueIDOfLightToNodes[lightUID->getString()]);
                         
-                        shared_ptr<JSONObject> lights = asset->root()->createObjectIfNeeded("lights");
-                        shared_ptr<JSONObject> light = lights->getObject(lightUID->getString());
+                        boost::shared_ptr<JSONObject> lights = asset->root()->createObjectIfNeeded("lights");
+                        boost::shared_ptr<JSONObject> light = lights->getObject(lightUID->getString());
                         
-                        if (light != nullptr) {
+                        if (light != 0) {
                             std::string lightType = light->getString("type");
                             
                             //we ignore lighting if the only light we have is ambient
@@ -849,7 +855,7 @@
                 if (!slotIsContributingToLighting(slot, inputParameters, asset))
                     continue;
                 
-                shared_ptr <JSONObject> param = inputParameters->getObject(slot);
+                boost::shared_ptr <JSONObject> param = inputParameters->getObject(slot);
                 unsigned int slotType = param->getUnsignedInt32("type");
 
                 if ((!lightingIsEnabled) && ((slot == "ambient") || (slot == "specular"))) {
@@ -926,7 +932,7 @@
                     std::string textureSymbol = "u_"+ slot;
                     
                     //get the texture
-                    shared_ptr <JSONObject> textureParameter = inputParameters->getObject(slot);
+                    boost::shared_ptr <JSONObject> textureParameter = inputParameters->getObject(slot);
                     //FIXME:this should eventually not come from the inputParameter
                     addValue("fs", "uniform", textureParameter->getUnsignedInt32("type"), 1, slot, asset);
                     
@@ -946,20 +952,20 @@
              Handle lighting
              */
             
-            shared_ptr <JSONObject> shininessObject;
+            boost::shared_ptr <JSONObject> shininessObject;
             
             size_t lightIndex = 0;
             if (lightingIsEnabled && asset->root()->contains("lightsIds")) {
-                shared_ptr<JSONArray> lightsIds = asset->root()->createArrayIfNeeded("lightsIds");
-                std::vector <shared_ptr <JSONValue> > ids = lightsIds->values();
+                boost::shared_ptr<JSONArray> lightsIds = asset->root()->createArrayIfNeeded("lightsIds");
+                std::vector <boost::shared_ptr <JSONValue> > ids = lightsIds->values();
                 
                 for (size_t i = 0 ; i < ids.size() ; i++) {
-                    shared_ptr<JSONString> lightUID = static_pointer_cast<JSONString>(ids[i]);
-                    shared_ptr<JSONArray> lightsNodesIds = static_pointer_cast<JSONArray>(asset->_uniqueIDOfLightToNodes[lightUID->getString()]);
+                    boost::shared_ptr<JSONString> lightUID = boost::static_pointer_cast<JSONString>(ids[i]);
+                    boost::shared_ptr<JSONArray> lightsNodesIds = boost::static_pointer_cast<JSONArray>(asset->_uniqueIDOfLightToNodes[lightUID->getString()]);
                     
-                    shared_ptr<JSONObject> lights = asset->root()->createObjectIfNeeded("lights");
-                    shared_ptr<JSONObject> light = lights->getObject(lightUID->getString());
-                    if (light == nullptr)
+                    boost::shared_ptr<JSONObject> lights = asset->root()->createObjectIfNeeded("lights");
+                    boost::shared_ptr<JSONObject> light = lights->getObject(lightUID->getString());
+                    if (light == 0)
                         continue;
                     std::string lightType = light->getString("type");
                     
@@ -967,8 +973,8 @@
                     if ((lightType == "ambient") && ids.size() == 1)
                         continue;
                     
-                    shared_ptr<JSONObject> description = light->getObject(lightType);
-                    std::vector <shared_ptr <JSONValue> > nodesIds = lightsNodesIds->values();
+                    boost::shared_ptr<JSONObject> description = light->getObject(lightType);
+                    std::vector <boost::shared_ptr <JSONValue> > nodesIds = lightsNodesIds->values();
                     for (size_t j = 0 ; j < nodesIds.size() ; j++, lightIndex++) {
                         //each light needs to be re-processed for each node
                         char lightIndexCStr[100];
@@ -992,7 +998,7 @@
                             
                             fragmentShader->appendCode("{\n");
                             
-                            shared_ptr <JSONObject> lightColorParameter = addValue("fs", "uniform", vec3Type, 1, lightColor, asset);
+                            boost::shared_ptr <JSONObject> lightColorParameter = addValue("fs", "uniform", vec3Type, 1, lightColor, asset);
                             lightColorParameter->setValue("value", description->getValue("color"));
                             
                             //FIXME: what happens if multiple ambient light ?
@@ -1007,7 +1013,7 @@
                             
                             fragmentShader->appendCode("{\n");
                             
-                            shared_ptr <JSONObject> lightColorParameter = addValue("fs", "uniform", vec3Type, 1, lightColor, asset);
+                            boost::shared_ptr <JSONObject> lightColorParameter = addValue("fs", "uniform", vec3Type, 1, lightColor, asset);
                             lightColorParameter->setValue("value", description->getValue("color"));
                             
                             fragmentShader->appendCode("float diffuseIntensity;\n");
@@ -1016,7 +1022,7 @@
                             char varyingLightDirection[100];
                             sprintf(varyingLightDirection, "v_%sDirection", lightIndexCStr);
                             
-                            shared_ptr <JSONObject> lightTransformParameter = addValue("vs", "uniform", mat4Type, 1, lightTransform, asset);
+                            boost::shared_ptr <JSONObject> lightTransformParameter = addValue("vs", "uniform", mat4Type, 1, lightTransform, asset);
                             
                             vertexShader->appendCode("%s = normalize(mat3(u_%s) * vec3(0.,0.,1.));\n", varyingLightDirection, lightTransform);
                             
@@ -1056,16 +1062,16 @@
                              
                              fragmentShader->appendCode("{\n");
                             
-                             shared_ptr <JSONObject> lightConstantAttenuationParameter = addValue("fs", "uniform", floatType, 1, lightConstantAttenuation, asset);
+                             boost::shared_ptr <JSONObject> lightConstantAttenuationParameter = addValue("fs", "uniform", floatType, 1, lightConstantAttenuation, asset);
                              lightConstantAttenuationParameter->setValue("value", description->getValue("constantAttenuation"));
 
-                             shared_ptr <JSONObject> lightLinearAttenuationParameter = addValue("fs", "uniform", floatType, 1, lightLinearAttenuation, asset);
+                             boost::shared_ptr <JSONObject> lightLinearAttenuationParameter = addValue("fs", "uniform", floatType, 1, lightLinearAttenuation, asset);
                              lightLinearAttenuationParameter->setValue("value", description->getValue("linearAttenuation"));
 
-                             shared_ptr <JSONObject> lightQuadraticAttenuationParameter = addValue("fs", "uniform", floatType, 1, lightQuadraticAttenuation, asset);
+                             boost::shared_ptr <JSONObject> lightQuadraticAttenuationParameter = addValue("fs", "uniform", floatType, 1, lightQuadraticAttenuation, asset);
                              lightQuadraticAttenuationParameter->setValue("value", description->getValue("quadraticAttenuation"));
 
-                             shared_ptr <JSONObject> lightColorParameter = addValue("fs", "uniform", vec3Type, 1, lightColor, asset);
+                             boost::shared_ptr <JSONObject> lightColorParameter = addValue("fs", "uniform", vec3Type, 1, lightColor, asset);
                              lightColorParameter->setValue("value", description->getValue("color"));
                              
                              fragmentShader->appendCode("float diffuseIntensity;\n");
@@ -1074,7 +1080,7 @@
                              char varyingLightDirection[100];
                              sprintf(varyingLightDirection, "v_%sDirection", lightIndexCStr);
                              
-                             shared_ptr <JSONObject> lightTransformParameter = addValue("vs", "uniform", mat4Type, 1, lightTransform, asset);
+                             boost::shared_ptr <JSONObject> lightTransformParameter = addValue("vs", "uniform", mat4Type, 1, lightTransform, asset);
                              
                              vertexShader->appendCode("%s = vec3(u_%s[3][0], u_%s[3][1],u_%s[3][2]) - pos.xyz;\n", varyingLightDirection, lightTransform, lightTransform, lightTransform) ;
                              
@@ -1161,7 +1167,7 @@
             bool hasTransparency = inputParameters->contains("transparency");
             if (hasTransparency) {
                 std::string slot = "transparency";
-                shared_ptr <JSONObject> transparencyParam = inputParameters->getObject(slot);
+                boost::shared_ptr <JSONObject> transparencyParam = inputParameters->getObject(slot);
                 
                 addValue("fs", "uniform",   transparencyParam->getUnsignedInt32("type"), 1, slot, asset);
                 
@@ -1172,8 +1178,8 @@
             
             if (CONFIG_BOOL(asset, "alwaysExportFilterColor")) {
                 if (inputParameters->contains("filterColor")) {
-                    shared_ptr<JSONObject> filterColor = inputParameters->getObject("filterColor");
-                    shared_ptr <JSONObject> filterColorParameter = addValue("fs", "uniform", vec4Type, 1, "filterColor", asset);
+                    boost::shared_ptr<JSONObject> filterColor = inputParameters->getObject("filterColor");
+                    boost::shared_ptr <JSONObject> filterColorParameter = addValue("fs", "uniform", vec4Type, 1, "filterColor", asset);
                     filterColorParameter->setValue("value", filterColor->getValue("value"));
                     fragmentShader->appendCode("color *= u_filterColor;\n");
                 }
@@ -1188,35 +1194,39 @@
             fragmentShader->appendCode("}\n");
             
         }
+
+        ~Technique() {
+            delete _pass;
+        }
         
-        shared_ptr <GLTF::JSONObject> parameters() {
+        boost::shared_ptr <GLTF::JSONObject> parameters() {
             return _parameters;
         }
         
     private:
         Pass *_pass;
-        shared_ptr <GLTF::JSONObject> _parameters;
-        shared_ptr <GLTFProfile> _profile;
+        boost::shared_ptr <GLTF::JSONObject> _parameters;
+        boost::shared_ptr <GLTFProfile> _profile;
         
     };
 
-    std::string getTechniqueKey(shared_ptr<JSONObject> techniqueGenerator, GLTFAsset* asset)  {
-        shared_ptr<JSONObject> values = techniqueGenerator->getObject("values");
-        shared_ptr<JSONObject> techniqueExtras = techniqueGenerator->getObject("techniqueExtras");
+    std::string getTechniqueKey(boost::shared_ptr<JSONObject> techniqueGenerator, GLTFAsset* asset)  {
+        boost::shared_ptr<JSONObject> values = techniqueGenerator->getObject("values");
+        boost::shared_ptr<JSONObject> techniqueExtras = techniqueGenerator->getObject("techniqueExtras");
                 
         return buildTechniqueHash(values, techniqueExtras, asset);
     }
     
-    std::string getReferenceTechniqueID(shared_ptr<JSONObject> techniqueGenerator, GLTFAsset* asset) {
+    std::string getReferenceTechniqueID(boost::shared_ptr<JSONObject> techniqueGenerator, GLTFAsset* asset) {
         
         std::string techniqueHash = getTechniqueKey(techniqueGenerator, asset);
-        shared_ptr<JSONObject> values = techniqueGenerator->getObject("values");
-        shared_ptr<JSONObject> techniqueExtras = techniqueGenerator->getObject("techniqueExtras");
+        boost::shared_ptr<JSONObject> values = techniqueGenerator->getObject("values");
+        boost::shared_ptr<JSONObject> techniqueExtras = techniqueGenerator->getObject("techniqueExtras");
         std::string lightingModel = techniqueGenerator->getString("lightingModel");
-        shared_ptr<JSONObject> attributeSemantics = techniqueGenerator->getObject("attributeSemantics");
-        shared_ptr<JSONObject> texcoordBindings = techniqueGenerator->getObject("texcoordBindings");
+        boost::shared_ptr<JSONObject> attributeSemantics = techniqueGenerator->getObject("attributeSemantics");
+        boost::shared_ptr<JSONObject> texcoordBindings = techniqueGenerator->getObject("texcoordBindings");
 
-        shared_ptr <JSONObject> techniquesObject = asset->root()->createObjectIfNeeded("techniques");
+        boost::shared_ptr <JSONObject> techniquesObject = asset->root()->createObjectIfNeeded("techniques");
 
         static TechniqueHashToTechniqueID techniqueHashToTechniqueID;
         if (techniqueHashToTechniqueID.count(techniqueHash) == 0) {
@@ -1232,9 +1242,9 @@
         
         std::string passName("defaultPass");
         //if the technique has not been serialized, first thing create the default pass for this technique
-        shared_ptr <GLTF::JSONObject> pass(new GLTF::JSONObject());
+        boost::shared_ptr <GLTF::JSONObject> pass(new GLTF::JSONObject());
         
-        shared_ptr <GLTF::JSONObject> states = createStatesForTechnique(values, techniqueExtras, asset);
+        boost::shared_ptr <GLTF::JSONObject> states = createStatesForTechnique(values, techniqueExtras, asset);
         pass->setValue("states", states);
         
         GLSLProgram* glTFProgram = glTFPass->instanceProgram();
@@ -1243,7 +1253,7 @@
         
         //create shader name made of the input file name to avoid file name conflicts
         COLLADABU::URI outputFileURI(asset->getOutputFilePath().c_str());
-        shared_ptr <JSONObject> shaders = asset->root()->createObjectIfNeeded("shaders");
+        boost::shared_ptr <JSONObject> shaders = asset->root()->createObjectIfNeeded("shaders");
         
         std::string shaderBaseId = outputFileURI.getPathFileBase() + GLTFUtils::toString(shaders->getKeysCount() / 2);
         std::string shaderFS = shaderBaseId + "FS";
@@ -1252,10 +1262,10 @@
         writeShaderIfNeeded(shaderVS, vs->source(), asset, asset->profile()->getGLenumForString("VERTEX_SHADER"));
         writeShaderIfNeeded(shaderFS, fs->source(), asset, asset->profile()->getGLenumForString("FRAGMENT_SHADER"));
         
-        shared_ptr <JSONObject> programsObject = asset->root()->createObjectIfNeeded("programs");
+        boost::shared_ptr <JSONObject> programsObject = asset->root()->createObjectIfNeeded("programs");
         std::string programID = "program_" + GLTFUtils::toString(programsObject->getKeysCount());
-        shared_ptr <GLTF::JSONObject> program(new GLTF::JSONObject());
-        shared_ptr <GLTF::JSONObject> instanceProgram(new GLTF::JSONObject());
+        boost::shared_ptr <GLTF::JSONObject> program(new GLTF::JSONObject());
+        boost::shared_ptr <GLTF::JSONObject> instanceProgram(new GLTF::JSONObject());
         
         instanceProgram->setValue("uniforms", glTFProgram->uniforms());
         instanceProgram->setValue("attributes", glTFProgram->attributes());
@@ -1267,18 +1277,18 @@
         program->setString("vertexShader", shaderVS);
         program->setString("fragmentShader", shaderFS);
         
-        shared_ptr<JSONObject> referenceTechnique(new JSONObject());
+        boost::shared_ptr<JSONObject> referenceTechnique(new JSONObject());
         
         referenceTechnique->setValue("parameters", glTFTechnique.parameters());
         referenceTechnique->setString("pass", passName);
         
-        shared_ptr <GLTF::JSONObject> passes = referenceTechnique->createObjectIfNeeded("passes");
+        boost::shared_ptr <GLTF::JSONObject> passes = referenceTechnique->createObjectIfNeeded("passes");
         
         passes->setValue(passName, pass);
         techniquesObject->setValue(techniqueID, referenceTechnique);
         
         if (CONFIG_BOOL(asset, "exportPassDetails")) {
-            shared_ptr <JSONObject> details = glTFPass->getDetails(lightingModel, values, techniqueExtras, texcoordBindings, asset);
+            boost::shared_ptr <JSONObject> details = glTFPass->getDetails(lightingModel, values, techniqueExtras, texcoordBindings, asset);
             pass->setValue("details", details);
         }
         
diff -ur collada2gltf.org/shaders/commonProfileShaders.h collada2gltf/shaders/commonProfileShaders.h
--- collada2gltf.org/shaders/commonProfileShaders.h	2014-09-29 15:30:40.146494472 +0200
+++ collada2gltf/shaders/commonProfileShaders.h	2014-09-29 15:59:18.346559476 +0200
@@ -27,10 +27,12 @@
 #define SHADER_STR(Src) #Src
 #define SHADER(Src) SHADER_STR(Src)
 
+#include <boost/shared_ptr.hpp>
+
 namespace GLTF
 {
-    std::string getReferenceTechniqueID(std::shared_ptr<JSONObject> techniqueGenerator, GLTF::GLTFAsset* asset);
-    std::string getTechniqueKey(std::shared_ptr<JSONObject> techniqueGenerator, GLTFAsset* asset);
+    std::string getReferenceTechniqueID(boost::shared_ptr<JSONObject> techniqueGenerator, GLTF::GLTFAsset* asset);
+    std::string getTechniqueKey(boost::shared_ptr<JSONObject> techniqueGenerator, GLTFAsset* asset);
 };
 
-#endif
\ No newline at end of file
+#endif
