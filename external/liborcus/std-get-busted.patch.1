From d1108eca5b40ffcfd788a5d52772354df863ee57 Mon Sep 17 00:00:00 2001
From: Kohei Yoshida <kohei.yoshida@gmail.com>
Date: Tue, 2 Nov 2021 22:07:51 -0400
Subject: [PATCH] std::get<T>(...) may be flaky with some version of clang.

Use std::get_if as a workaround.

c.f. https://stackoverflow.com/questions/52521388/stdvariantget-does-not-compile-with-apple-llvm-10-0
---
 include/orcus/threaded_json_parser.hpp      | 25 ++++--
 include/orcus/threaded_sax_token_parser.hpp | 24 ++++--
 src/liborcus/css_document_tree.cpp          |  7 +-
 src/liborcus/css_selector.cpp               | 88 ++++++++++++++-------
 src/liborcus/orcus_csv.cpp                  |  9 ++-
 src/orcus_csv_main.cpp                      | 13 +--
 src/orcus_test_csv.cpp                      | 11 ++-
 src/parser/json_parser_thread.cpp           | 27 +++++--
 src/python/sheet_rows.cpp                   | 40 ++++++++--
 src/spreadsheet/factory_pivot.cpp           | 10 ++-
 src/spreadsheet/formula_global.cpp          | 16 +++-
 11 files changed, 198 insertions(+), 72 deletions(-)

diff --git a/include/orcus/threaded_json_parser.hpp b/include/orcus/threaded_json_parser.hpp
index 51cdaced..5d04947a 100644
--- a/include/orcus/threaded_json_parser.hpp
+++ b/include/orcus/threaded_json_parser.hpp
@@ -151,24 +151,35 @@ void threaded_json_parser<_Handler>::process_tokens(json::parse_tokens_t& tokens
                     m_handler.null();
                     break;
                 case json::parse_token_t::number:
-                    m_handler.number(std::get<double>(t.value));
+                {
+                    if (const double* p = std::get_if<double>(&t.value); p)
+                        m_handler.number(*p);
+                    else
+                        throw general_error("double type expected of t.value");
                     break;
+                }
                 case json::parse_token_t::object_key:
                 {
-                    auto s = std::get<std::string_view>(t.value);
-                    m_handler.object_key(s.data(), s.size(), false);
+                    if (const std::string_view* p = std::get_if<std::string_view>(&t.value); p)
+                        m_handler.object_key(p->data(), p->size(), false);
+                    else
+                        throw general_error("std::string_view type expected of t.value");
                     break;
                 }
                 case json::parse_token_t::string:
                 {
-                    auto s = std::get<std::string_view>(t.value);
-                    m_handler.string(s.data(), s.size(), false);
+                    if (const std::string_view* p = std::get_if<std::string_view>(&t.value); p)
+                        m_handler.string(p->data(), p->size(), false);
+                    else
+                        throw general_error("std::string_view type expected of t.value");
                     break;
                 }
                 case json::parse_token_t::parse_error:
                 {
-                    auto v = std::get<parse_error_value_t>(t.value);
-                    throw json::parse_error(std::string{v.str}, v.offset);
+                    if (const parse_error_value_t* p = std::get_if<parse_error_value_t>(&t.value); p)
+                        throw json::parse_error(std::string{p->str}, p->offset);
+                    else
+                        throw general_error("parse_error_value_t type expected of t.value");
                 }
                 case json::parse_token_t::unknown:
                 default:
diff --git a/include/orcus/threaded_sax_token_parser.hpp b/include/orcus/threaded_sax_token_parser.hpp
index 59ea967a..d15e944f 100644
--- a/include/orcus/threaded_sax_token_parser.hpp
+++ b/include/orcus/threaded_sax_token_parser.hpp
@@ -131,26 +131,34 @@ void threaded_sax_token_parser<_Handler>::process_tokens(const sax::parse_tokens
         {
             case sax::parse_token_t::start_element:
             {
-                const auto* elem = std::get<const xml_token_element_t*>(t.value);
-                m_handler.start_element(*elem);
+                const auto* const* elem = std::get_if<const xml_token_element_t*>(&t.value);
+                if (!elem)
+                    throw general_error("xml_token_element_t* type expected.");
+                m_handler.start_element(**elem);
                 break;
             }
             case sax::parse_token_t::end_element:
             {
-                const auto* elem = std::get<const xml_token_element_t*>(t.value);
-                m_handler.end_element(*elem);
+                const auto* const* elem = std::get_if<const xml_token_element_t*>(&t.value);
+                if (!elem)
+                    throw general_error("xml_token_element_t* type expected.");
+                m_handler.end_element(**elem);
                 break;
             }
             case sax::parse_token_t::characters:
             {
-                auto s = std::get<std::string_view>(t.value);
-                m_handler.characters(s, false);
+                const std::string_view* s = std::get_if<std::string_view>(&t.value);
+                if (!s)
+                    throw general_error("std::string_view type expected.");
+                m_handler.characters(*s, false);
                 break;
             }
             case sax::parse_token_t::parse_error:
             {
-                auto v = std::get<parse_error_value_t>(t.value);
-                throw sax::malformed_xml_error(std::string{v.str}, v.offset);
+                const parse_error_value_t* v = std::get_if<parse_error_value_t>(&t.value);
+                if (!v)
+                    throw general_error("parse_error_value_t expected.");
+                throw sax::malformed_xml_error(std::string{v->str}, v->offset);
             }
             default:
                 throw general_error("unknown token type encountered.");
diff --git a/src/liborcus/css_document_tree.cpp b/src/liborcus/css_document_tree.cpp
index 46bf7e91..e45c5026 100644
--- a/src/liborcus/css_document_tree.cpp
+++ b/src/liborcus/css_document_tree.cpp
@@ -317,8 +317,11 @@ public:
             {
                 // String value needs interning.
                 css_property_value_t interned = v;
-                auto s = std::get<std::string_view>(v.value);
-                interned.value = m_sp.intern(s).first;
+                const std::string_view* p = std::get_if<std::string_view>(&v.value);
+                if (!p)
+                    throw css_document_tree::insertion_error("std::string_view type expected.");
+
+                interned.value = m_sp.intern(*p).first;
                 m_dest.push_back(interned);
                 break;
             }
diff --git a/src/liborcus/css_selector.cpp b/src/liborcus/css_selector.cpp
index b7b63f37..29828431 100644
--- a/src/liborcus/css_selector.cpp
+++ b/src/liborcus/css_selector.cpp
@@ -155,52 +155,84 @@ std::ostream& operator<< (std::ostream& os, const css_property_value_t& v)
     {
         case css::property_value_t::hsl:
         {
-            auto c = std::get<css::hsla_color_t>(v.value);
-            os << "hsl("
-                << (int)c.hue << sep
-                << (int)c.saturation << sep
-                << (int)c.lightness
-                << ")";
+            auto* c = std::get_if<css::hsla_color_t>(&v.value);
+            if (c)
+            {
+                os << "hsl("
+                    << (int)c->hue << sep
+                    << (int)c->saturation << sep
+                    << (int)c->lightness
+                    << ")";
+            }
+            else
+                os << "hsl(?)";
             break;
         }
         case css::property_value_t::hsla:
         {
-            auto c = std::get<css::hsla_color_t>(v.value);
-            os << "hsla("
-                << (int)c.hue << sep
-                << (int)c.saturation << sep
-                << (int)c.lightness << sep
-                << c.alpha
-                << ")";
+            auto* c = std::get_if<css::hsla_color_t>(&v.value);
+            if (c)
+            {
+                os << "hsla("
+                    << (int)c->hue << sep
+                    << (int)c->saturation << sep
+                    << (int)c->lightness << sep
+                    << c->alpha
+                    << ")";
+            }
+            else
+                os << "hsla(?)";
             break;
         }
         case css::property_value_t::rgb:
         {
-            auto c = std::get<css::rgba_color_t>(v.value);
-            os << "rgb("
-                << (int)c.red << sep
-                << (int)c.green << sep
-                << (int)c.blue
-                << ")";
+            auto* c = std::get_if<css::rgba_color_t>(&v.value);
+            if (c)
+            {
+                os << "rgb("
+                    << (int)c->red << sep
+                    << (int)c->green << sep
+                    << (int)c->blue
+                    << ")";
+            }
+            else
+                os << "rgb(?)";
             break;
         }
         case css::property_value_t::rgba:
         {
-            auto c = std::get<css::rgba_color_t>(v.value);
-            os << "rgba("
-                << (int)c.red << sep
-                << (int)c.green << sep
-                << (int)c.blue << sep
-                << c.alpha
-                << ")";
+            auto* c = std::get_if<css::rgba_color_t>(&v.value);
+            if (c)
+            {
+                os << "rgba("
+                    << (int)c->red << sep
+                    << (int)c->green << sep
+                    << (int)c->blue << sep
+                    << c->alpha
+                    << ")";
+            }
+            else
+                os << "rgba(?)";
             break;
         }
         case css::property_value_t::string:
-            os << std::get<std::string_view>(v.value);
+        {
+            const std::string_view* p = std::get_if<std::string_view>(&v.value);
+            if (p)
+                os << *p;
+            else
+                os << "?";
             break;
+        }
         case css::property_value_t::url:
-            os << "url(" << std::get<std::string_view>(v.value) << ")";
+        {
+            const std::string_view* p = std::get_if<std::string_view>(&v.value);
+            if (p)
+                os << "url(" << *p << ")";
+            else
+                os << "?";
             break;
+        }
         case css::property_value_t::none:
         default:
             ;
diff --git a/src/liborcus/orcus_csv.cpp b/src/liborcus/orcus_csv.cpp
index 5c71bcf5..e5ddd42c 100644
--- a/src/liborcus/orcus_csv.cpp
+++ b/src/liborcus/orcus_csv.cpp
@@ -63,9 +63,12 @@ public:
         // 0.
         if (m_row >= mp_sheet->get_sheet_size().rows)
         {
-            auto csv = std::get<config::csv_config>(m_app_config.data);
+            auto* csv = std::get_if<config::csv_config>(&m_app_config.data);
 
-            if (!csv.split_to_multiple_sheets)
+            if (!csv)
+                throw std::runtime_error("csv_config type expected.");
+
+            if (!csv->split_to_multiple_sheets)
                 throw max_row_size_reached();
 
             // The next row will be outside the boundary of the current sheet.
@@ -80,7 +83,7 @@ public:
                 for (const header_cell& c : m_header_cells)
                     mp_sheet->set_auto(c.row, c.col, c.value);
 
-                m_row += csv.header_row_size;
+                m_row += csv->header_row_size;
             }
         }
     }
diff --git a/src/orcus_csv_main.cpp b/src/orcus_csv_main.cpp
index 4f6d7173..d728ec09 100644
--- a/src/orcus_csv_main.cpp
+++ b/src/orcus_csv_main.cpp
@@ -45,14 +45,15 @@ public:
 
     virtual void map_to_config(config& opt, const po::variables_map& vm) override
     {
-        auto csv = std::get<config::csv_config>(opt.data);
+        if (config::csv_config* p = std::get_if<config::csv_config>(&opt.data); p)
+        {
+            if (vm.count("row-header"))
+                p->header_row_size = vm["row-header"].as<size_t>();
 
-        if (vm.count("row-header"))
-            csv.header_row_size = vm["row-header"].as<size_t>();
+            p->split_to_multiple_sheets = vm.count("split") > 0;
 
-        csv.split_to_multiple_sheets = vm.count("split") > 0;
-
-        opt.data = csv;
+            opt.data = *p;
+        }
     }
 };
 
diff --git a/src/orcus_test_csv.cpp b/src/orcus_test_csv.cpp
index 310ace9d..5bf3f7e8 100644
--- a/src/orcus_test_csv.cpp
+++ b/src/orcus_test_csv.cpp
@@ -95,8 +95,11 @@ void test_csv_import_split_sheet()
     std::cout << "checking " << path << "..." << std::endl;
 
     config conf(format_t::csv);
-    std::get<config::csv_config>(conf.data).header_row_size = 0;
-    std::get<config::csv_config>(conf.data).split_to_multiple_sheets = true;
+    config::csv_config* conf_data = std::get_if<config::csv_config>(&conf.data);
+    assert(conf_data);
+
+    conf_data->header_row_size = 0;
+    conf_data->split_to_multiple_sheets = true;
 
     // Set the row size to 11 to make sure the split occurs.
     spreadsheet::range_size_t ss{11, 4};
@@ -126,7 +129,7 @@ void test_csv_import_split_sheet()
     path = dir;
     path.append("input.csv");
     doc.clear();
-    std::get<config::csv_config>(conf.data).header_row_size = 1;
+    conf_data->header_row_size = 1;
     {
         spreadsheet::import_factory factory(doc);
         orcus_csv app(&factory);
@@ -149,7 +152,7 @@ void test_csv_import_split_sheet()
 
     // Re-import it again, but this time disable the splitting.  The data should
     // get trucated on the first sheet.
-    std::get<config::csv_config>(conf.data).split_to_multiple_sheets = false;
+    conf_data->split_to_multiple_sheets = false;
 
     path = dir;
     path.append("input.csv");
diff --git a/src/parser/json_parser_thread.cpp b/src/parser/json_parser_thread.cpp
index 36bbe6e6..0b8b481d 100644
--- a/src/parser/json_parser_thread.cpp
+++ b/src/parser/json_parser_thread.cpp
@@ -237,20 +237,37 @@ std::ostream& operator<< (std::ostream& os, const parse_tokens_t& tokens)
                     os << "- null" << endl;
                     break;
                 case parse_token_t::number:
-                    os << "- number (v=" << std::get<double>(t.value) << ")" << endl;
+                {
+                    if (const double* p = std::get_if<double>(&t.value); p)
+                        os << "- number (v=" << *p << ")" << endl;
+                    else
+                        os << "- number (v=?)" << endl;
                     break;
+                }
                 case parse_token_t::object_key:
-                    os << "- object_key (v=" << std::get<std::string_view>(t.value) << ")" << endl;
+                {
+                    if (const std::string_view* p = std::get_if<std::string_view>(&t.value); p)
+                        os << "- object_key (v=" << *p << ")" << endl;
+                    else
+                        os << "- object_key (v=?)" << endl;
                     break;
+                }
                 case parse_token_t::parse_error:
                 {
-                    auto v = std::get<parse_error_value_t>(t.value);
-                    os << "- parse_error (v=" << v.str << ", offset=" << v.offset << ")" << endl;
+                    if (const parse_error_value_t* p = std::get_if<parse_error_value_t>(&t.value); p)
+                        os << "- parse_error (v=" << p->str << ", offset=" << p->offset << ")" << endl;
+                    else
+                        os << "- parse_error (v=?, offset=?)" << endl;
                     break;
                 }
                 case parse_token_t::string:
-                    os << "- string (" << std::get<std::string_view>(t.value) << ")" << endl;
+                {
+                    if (const std::string_view* p = std::get_if<std::string_view>(&t.value); p)
+                        os << "- string (" << *p << ")" << endl;
+                    else
+                        os << "- string (?)" << endl;
                     break;
+                }
                 case parse_token_t::unknown:
                     os << "- unknown" << endl;
                     break;
diff --git a/src/python/sheet_rows.cpp b/src/python/sheet_rows.cpp
index be495894..3232b5e9 100644
--- a/src/python/sheet_rows.cpp
+++ b/src/python/sheet_rows.cpp
@@ -111,31 +111,59 @@ PyObject* sheet_rows_iternext(PyObject* self)
             }
             case ixion::celltype_t::boolean:
             {
-                obj = create_cell_object_boolean(std::get<bool>(cell.value));
+                const bool* p = std::get_if<bool>(&cell.value);
+                if (!p)
+                {
+                    PyErr_SetString(PyExc_RuntimeError, "Failed to get the boolean value from cell value storage.");
+                    break;
+                }
+
+                obj = create_cell_object_boolean(*p);
                 break;
             }
             case ixion::celltype_t::numeric:
             {
-                obj = create_cell_object_numeric(std::get<double>(cell.value));
+                const double* p = std::get_if<double>(&cell.value);
+                if (!p)
+                {
+                    PyErr_SetString(PyExc_RuntimeError, "Failed to get the double value from cell value storage.");
+                    break;
+                }
+
+                obj = create_cell_object_numeric(*p);
                 break;
             }
             case ixion::celltype_t::string:
             {
-                ixion::string_id_t sid = std::get<ixion::string_id_t>(cell.value);
+                const ixion::string_id_t* sid = std::get_if<ixion::string_id_t>(&cell.value);
+                if (!sid)
+                {
+                    PyErr_SetString(PyExc_RuntimeError, "Failed to get the string ID from cell value storage.");
+                    break;
+                }
+
                 const ixion::model_context& cxt = data->m_doc->get_model_context();
-                const std::string* ps = cxt.get_string(sid);
+                const std::string* ps = cxt.get_string(*sid);
                 obj = create_cell_object_string(ps);
                 break;
             }
             case ixion::celltype_t::formula:
             {
-                const ixion::formula_cell* fc = std::get<const ixion::formula_cell*>(cell.value);
+                const ixion::formula_cell* const* fc = std::get_if<const ixion::formula_cell*>(&cell.value);
+                if (!fc)
+                {
+                    PyErr_SetString(PyExc_RuntimeError, "Failed to get the formula cell pointer from cell value storage.");
+                    break;
+                }
                 ixion::abs_address_t pos(data->m_sheet->get_index(), cell.row, cell.col);
-                obj = create_cell_object_formula(*data->m_doc, pos, fc);
+                obj = create_cell_object_formula(*data->m_doc, pos, *fc);
                 break;
             }
             case ixion::celltype_t::unknown:
+            {
+                PyErr_SetString(PyExc_RuntimeError, "Unknown cell type.");
                 break;
+            }
         }
 
         if (!obj)
diff --git a/src/spreadsheet/factory_pivot.cpp b/src/spreadsheet/factory_pivot.cpp
index 7e7a067c..8cce4594 100644
--- a/src/spreadsheet/factory_pivot.cpp
+++ b/src/spreadsheet/factory_pivot.cpp
@@ -152,7 +152,15 @@ void import_pivot_cache_def::set_worksheet_source(std::string_view ref, std::str
         throw xml_structure_error(os.str());
     }
 
-    m_src_range = std::get<ixion::range_t>(fn.value).to_abs(ixion::abs_address_t(0,0,0));
+    const ixion::range_t* p = std::get_if<ixion::range_t>(&fn.value);
+    if (!p)
+    {
+        std::ostringstream os;
+        os << __FILE__ << ":" << __LINE__ << ": ixion::range_t type was expected of the variant value.";
+        throw xml_structure_error(os.str());
+    }
+
+    m_src_range = p->to_abs(ixion::abs_address_t(0,0,0));
 }
 
 void import_pivot_cache_def::set_worksheet_source(std::string_view table_name)
diff --git a/src/spreadsheet/formula_global.cpp b/src/spreadsheet/formula_global.cpp
index a4d7c6d6..ff34020f 100644
--- a/src/spreadsheet/formula_global.cpp
+++ b/src/spreadsheet/formula_global.cpp
@@ -22,14 +22,26 @@ ixion::abs_range_t to_abs_range(
     switch (res.type)
     {
         case ixion::formula_name_t::cell_reference:
+        {
             // Single cell reference.
-            range.first = std::get<ixion::address_t>(res.value).to_abs(pos);
+            const ixion::address_t* p = std::get_if<ixion::address_t>(&res.value);
+            if (!p)
+                break;
+
+            range.first = p->to_abs(pos);
             range.last = range.first;
             break;
+        }
         case ixion::formula_name_t::range_reference:
+        {
             // Range reference.
-            range = std::get<ixion::range_t>(res.value).to_abs(pos);
+            const ixion::range_t* p = std::get_if<ixion::range_t>(&res.value);
+            if (!p)
+                break;
+
+            range = p->to_abs(pos);
             break;
+        }
         default:
             ; // Unsupported range.  Leave it invalid.
     }
-- 
2.25.1

