From d0603cd8764fe60bf6f05215d0b59aa4ee6c55dc Mon Sep 17 00:00:00 2001
From: Alexander Wilms <f.alexander.wilms@gmail.com>
Date: Sat, 22 Feb 2014 11:56:38 +0100
Subject: [PATCH] Translate German comments and remove visual noise

Change-Id: Ibe6bdf26ff80a9cb5bdd5e52092aa943a62fe8e4
---
 .../extended/AccessibleGridControlHeaderCell.hxx   |    6 +-
 .../inc/accessibility/helper/accessiblestrings.hrc |    8 +-
 .../extended/AccessibleToolPanelDeckTabBar.cxx     |   46 +-
 accessibility/source/helper/acc_factory.cxx        |   52 +-
 .../source/standard/floatingwindowaccessible.cxx   |    9 -
 .../source/standard/vclxaccessibletoolbox.cxx      |   80 +-
 comphelper/source/misc/sequence.cxx                |   16 +-
 dbaccess/source/ui/dlg/advancedsettings.hxx        |    8 +-
 .../source/ui/relationdesign/RTableConnection.cxx  |    8 +-
 .../ui/relationdesign/RTableConnectionData.cxx     |   18 +-
 .../source/ui/relationdesign/RelationTableView.cxx |   18 +-
 dbaccess/source/ui/tabledesign/FieldDescGenWin.cxx |    5 +-
 dbaccess/source/ui/tabledesign/FieldDescGenWin.hxx |    4 +-
 dbaccess/source/ui/tabledesign/TEditControl.cxx    |    6 +-
 dbaccess/source/ui/tabledesign/TableController.cxx |   18 +-
 .../source/ui/tabledesign/TableDesignControl.cxx   |    6 +-
 .../source/ui/tabledesign/TableFieldControl.hxx    |    2 +-
 .../source/ui/tabledesign/TableFieldDescWin.cxx    |   34 +-
 dbaccess/source/ui/uno/dbinteraction.cxx           |   10 +-
 dtrans/source/win32/dnd/target.cxx                 |    1 -
 editeng/source/editeng/editeng.cxx                 |    6 +-
 filter/source/graphicfilter/epict/epict.cxx        |   34 +-
 filter/source/graphicfilter/icgm/cgm.cxx           |   73 +-
 filter/source/msfilter/escherex.cxx                |   73 +-
 filter/source/msfilter/util.cxx                    |   61 +-
 forms/source/component/FormComponent.cxx           | 4764 +++++++++-----------
 forms/source/component/FormattedField.cxx          |  206 +-
 forms/source/component/FormattedField.hxx          |   58 +-
 forms/source/component/Grid.cxx                    |  204 +-
 forms/source/component/GroupManager.cxx            |   65 +-
 forms/source/component/ImageButton.cxx             |   30 +-
 i18npool/source/search/levdis.cxx                  |   68 +-
 sc/source/filter/lotus/lotform.cxx                 |  226 +-
 sw/source/filter/ww8/ww8graf.cxx                   |  188 +-
 34 files changed, 2649 insertions(+), 3762 deletions(-)

diff --git a/accessibility/inc/accessibility/extended/AccessibleGridControlHeaderCell.hxx b/accessibility/inc/accessibility/extended/AccessibleGridControlHeaderCell.hxx
index b79b89c..14ca947 100644
--- a/accessibility/inc/accessibility/extended/AccessibleGridControlHeaderCell.hxx
+++ b/accessibility/inc/accessibility/extended/AccessibleGridControlHeaderCell.hxx
@@ -44,7 +44,7 @@ namespace accessibility
         /** Grabs the focus to the GridControl. */
         virtual void SAL_CALL grabFocus() throw ( ::com::sun::star::uno::RuntimeException );
 
-        // XInterface -------------------------------------------------------------
+        // XInterface
 
         /** Queries for a new interface. */
         ::com::sun::star::uno::Any SAL_CALL queryInterface(
@@ -56,14 +56,14 @@ namespace accessibility
 
         /** Releases the object (calls release() on base class). */
         virtual void SAL_CALL release() throw ();
-        // XAccessible ------------------------------------------------------------
+        // XAccessible
 
         /** @return  The XAccessibleContext interface of this object. */
         virtual ::com::sun::star::uno::Reference<
             ::com::sun::star::accessibility::XAccessibleContext > SAL_CALL
         getAccessibleContext()
             throw ( ::com::sun::star::uno::RuntimeException );
-        //-------------------------------------------------------------------------
+
         inline sal_Bool isRowBarCell() const
         {
             return getType() == ::svt::table::TCTYPE_ROWHEADERCELL;
diff --git a/accessibility/inc/accessibility/helper/accessiblestrings.hrc b/accessibility/inc/accessibility/helper/accessiblestrings.hrc
index 03815d8..12454d4 100644
--- a/accessibility/inc/accessibility/helper/accessiblestrings.hrc
+++ b/accessibility/inc/accessibility/helper/accessiblestrings.hrc
@@ -20,14 +20,10 @@
 #ifndef ACCESSIBILITY_HELPER_ACCESSIBLESTRINGS_HRC_
 #define ACCESSIBILITY_HELPER_ACCESSIBLESTRINGS_HRC_
 
-
-//------------------------------------------------------------------------------
-
 #define RID_TK_ACC_START        1000
 
 
-// Accessible Action Id's ------------------------------------------------------
-
+// Accessible Action Id's
 #define RID_STR_ACC_ACTION_CLICK            ( RID_TK_ACC_START +    0 )
 #define RID_STR_ACC_ACTION_TOGGLEPOPUP      ( RID_TK_ACC_START +    1 )
 #define RID_STR_ACC_ACTION_SELECT           ( RID_TK_ACC_START +    2 )
@@ -51,8 +47,6 @@
 #define RID_STR_ACC_NAME_BROWSEBUTTON       ( RID_TK_ACC_START + 100 )
 #define RID_STR_ACC_DESC_PANELDECL_TABBAR   ( RID_TK_ACC_START + 101 )
 
-// -----------------------------------------------------------------------------
-
 #endif          // ACCESSIBILITY_HELPER_ACCESSIBLESTRINGS_HRC_
 
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/accessibility/source/extended/AccessibleToolPanelDeckTabBar.cxx b/accessibility/source/extended/AccessibleToolPanelDeckTabBar.cxx
index fc83bd5..0253b57 100644
--- a/accessibility/source/extended/AccessibleToolPanelDeckTabBar.cxx
+++ b/accessibility/source/extended/AccessibleToolPanelDeckTabBar.cxx
@@ -17,7 +17,6 @@
  *   the License at http://www.apache.org/licenses/LICENSE-2.0 .
  */
 
-
 #include "accessibility/extended/AccessibleToolPanelDeckTabBar.hxx"
 #include "accessibility/extended/AccessibleToolPanelDeckTabBarItem.hxx"
 #include "accessibility/helper/accresmgr.hxx"
@@ -40,11 +39,8 @@
 
 #include <vector>
 
-//......................................................................................................................
 namespace accessibility
 {
-//......................................................................................................................
-
     using ::com::sun::star::uno::Reference;
     using ::com::sun::star::uno::XInterface;
     using ::com::sun::star::uno::UNO_QUERY;
@@ -67,9 +63,7 @@ namespace accessibility
 
     typedef ::com::sun::star::awt::Point        UnoPoint;
 
-    //==================================================================================================================
-    //= AccessibleWrapper
-    //==================================================================================================================
+    // AccessibleWrapper
     typedef ::cppu::WeakImplHelper1< XAccessible > AccessibleWrapper_Base;
     class AccessibleWrapper : public AccessibleWrapper_Base
     {
@@ -89,9 +83,7 @@ namespace accessibility
         const Reference< XAccessibleContext >   m_xContext;
     };
 
-    //==================================================================================================================
-    //= AccessibleToolPanelTabBar_Impl
-    //==================================================================================================================
+    // AccessibleToolPanelTabBar_Impl
     class AccessibleToolPanelTabBar_Impl    :public ::boost::noncopyable
                                             ,public ::svt::IToolPanelDeckListener
     {
@@ -132,7 +124,6 @@ namespace accessibility
         ::std::vector< Reference< XAccessible > >   m_aChildren;
     };
 
-    //------------------------------------------------------------------------------------------------------------------
     AccessibleToolPanelTabBar_Impl::AccessibleToolPanelTabBar_Impl( AccessibleToolPanelTabBar& i_rAntiImpl,
             const Reference< XAccessible >& i_rAccessibleParent, ::svt::IToolPanelDeck& i_rPanelDeck, ::svt::PanelTabBar& i_rTabBar )
         :m_rAntiImpl( i_rAntiImpl )
@@ -152,21 +143,18 @@ namespace accessibility
         i_rTabBar.GetScrollButton( false ).AddEventListener( LINK( this, AccessibleToolPanelTabBar_Impl, OnWindowEvent ) );
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     void AccessibleToolPanelTabBar_Impl::checkDisposed()
     {
         if ( isDisposed() )
             throw DisposedException( OUString(), *&m_rAntiImpl );
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     AccessibleToolPanelTabBar_Impl::~AccessibleToolPanelTabBar_Impl()
     {
         if ( !isDisposed() )
             dispose();
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     void AccessibleToolPanelTabBar_Impl::dispose()
     {
         ENSURE_OR_RETURN_VOID( !isDisposed(), "disposed twice" );
@@ -180,7 +168,6 @@ namespace accessibility
         m_xAccessibleParent.clear();
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     Reference< XAccessible > AccessibleToolPanelTabBar_Impl::getAccessiblePanelItem( size_t i_nPosition )
     {
         ENSURE_OR_RETURN( !isDisposed(), "AccessibleToolPanelTabBar_Impl::getAccessiblePanelItem: already disposed!", NULL );
@@ -197,7 +184,6 @@ namespace accessibility
         return rAccessibleChild;
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     Reference< XAccessible > AccessibleToolPanelTabBar_Impl::getOwnAccessible() const
     {
         Reference< XAccessible > xOwnAccessible( static_cast< XAccessible* >( m_rAntiImpl.GetVCLXWindow() ) );
@@ -206,7 +192,6 @@ namespace accessibility
         return xOwnAccessible;
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     void AccessibleToolPanelTabBar_Impl::PanelInserted( const ::svt::PToolPanel& i_pPanel, const size_t i_nPosition )
     {
         ENSURE_OR_RETURN_VOID( i_nPosition <= m_aChildren.size(), "AccessibleToolPanelTabBar_Impl::PanelInserted: illegal position (or invalid cache!)" );
@@ -215,7 +200,6 @@ namespace accessibility
         m_rAntiImpl.NotifyAccessibleEvent( AccessibleEventId::CHILD, Any(), makeAny( getAccessiblePanelItem( i_nPosition ) ) );
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     void AccessibleToolPanelTabBar_Impl::PanelRemoved( const size_t i_nPosition )
     {
         ENSURE_OR_RETURN_VOID( i_nPosition < m_aChildren.size(), "AccessibleToolPanelTabBar_Impl::PanelInserted: illegal position (or invalid cache!)" );
@@ -225,27 +209,23 @@ namespace accessibility
         m_rAntiImpl.NotifyAccessibleEvent( AccessibleEventId::CHILD, makeAny( xOldChild ), Any() );
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     void AccessibleToolPanelTabBar_Impl::ActivePanelChanged( const ::boost::optional< size_t >& i_rOldActive, const ::boost::optional< size_t >& i_rNewActive )
     {
         (void)i_rOldActive;
         (void)i_rNewActive;
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     void AccessibleToolPanelTabBar_Impl::LayouterChanged( const ::svt::PDeckLayouter& i_rNewLayouter )
     {
         (void)i_rNewLayouter;
         m_rAntiImpl.dispose();
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     void AccessibleToolPanelTabBar_Impl::Dying()
     {
         m_rAntiImpl.dispose();
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     IMPL_LINK( AccessibleToolPanelTabBar_Impl, OnWindowEvent, const VclSimpleEvent*, i_pEvent )
     {
         ENSURE_OR_RETURN( !isDisposed(), "AccessibleToolPanelTabBar_Impl::OnWindowEvent: already disposed!", 0L );
@@ -272,9 +252,7 @@ namespace accessibility
         return 1L;
     }
 
-    //==================================================================================================================
-    //= MethodGuard
-    //==================================================================================================================
+    // MethodGuard
     namespace
     {
         class MethodGuard
@@ -294,10 +272,7 @@ namespace accessibility
         };
     }
 
-    //==================================================================================================================
-    //= AccessibleToolPanelTabBar
-    //==================================================================================================================
-    //------------------------------------------------------------------------------------------------------------------
+    // AccessibleToolPanelTabBar
     AccessibleToolPanelTabBar::AccessibleToolPanelTabBar( const Reference< XAccessible >& i_rAccessibleParent,
             ::svt::IToolPanelDeck& i_rPanelDeck, ::svt::PanelTabBar& i_rTabBar )
         :AccessibleToolPanelTabBar_Base( i_rTabBar.GetWindowPeer() )
@@ -305,12 +280,10 @@ namespace accessibility
     {
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     AccessibleToolPanelTabBar::~AccessibleToolPanelTabBar()
     {
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     sal_Int32 SAL_CALL AccessibleToolPanelTabBar::getAccessibleChildCount(  ) throw (RuntimeException)
     {
         MethodGuard aGuard( *m_pImpl );
@@ -323,7 +296,6 @@ namespace accessibility
             +   ( bHasScrollForward ? 1 : 0 );
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     Reference< XAccessible > SAL_CALL AccessibleToolPanelTabBar::getAccessibleChild( sal_Int32 i_nIndex ) throw (IndexOutOfBoundsException, RuntimeException)
     {
         MethodGuard aGuard( *m_pImpl );
@@ -351,21 +323,18 @@ namespace accessibility
         return m_pImpl->getAccessiblePanelItem( i_nIndex - ( bHasScrollBack ? 1 : 0 ) );
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     Reference< XAccessible > SAL_CALL AccessibleToolPanelTabBar::getAccessibleParent(  ) throw (RuntimeException)
     {
         MethodGuard aGuard( *m_pImpl );
         return m_pImpl->getAccessibleParent();
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     sal_Int16 SAL_CALL AccessibleToolPanelTabBar::getAccessibleRole(  ) throw (RuntimeException)
     {
         MethodGuard aGuard( *m_pImpl );
         return AccessibleRole::PAGE_TAB_LIST;
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     namespace
     {
         bool lcl_covers( const ::Window& i_rWindow, const ::Point& i_rPoint )
@@ -375,7 +344,6 @@ namespace accessibility
         }
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     Reference< XAccessible > SAL_CALL AccessibleToolPanelTabBar::getAccessibleAtPoint( const UnoPoint& i_rPoint ) throw (RuntimeException)
     {
         MethodGuard aGuard( *m_pImpl );
@@ -406,14 +374,12 @@ namespace accessibility
         return NULL;
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     void SAL_CALL AccessibleToolPanelTabBar::disposing()
     {
         AccessibleToolPanelTabBar_Base::disposing();
         m_pImpl->dispose();
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     Reference< XAccessible > AccessibleToolPanelTabBar::GetChildAccessible( const VclWindowEvent& i_rVclWindowEvent )
     {
         // don't let the base class generate any A11Y events from VclWindowEvent, we completely manage those
@@ -422,7 +388,6 @@ namespace accessibility
         return NULL;
     }
 
-    //------------------------------------------------------------------------------------------------------------------
     void AccessibleToolPanelTabBar::FillAccessibleStateSet( ::utl::AccessibleStateSetHelper& i_rStateSet )
     {
         AccessibleToolPanelTabBar_Base::FillAccessibleStateSet( i_rStateSet );
@@ -434,9 +399,6 @@ namespace accessibility
         else
             i_rStateSet.AddState( AccessibleStateType::HORIZONTAL );
     }
-
-//......................................................................................................................
 } // namespace accessibility
-//......................................................................................................................
 
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/accessibility/source/helper/acc_factory.cxx b/accessibility/source/helper/acc_factory.cxx
index 640c2d5..f59ffe6 100644
--- a/accessibility/source/helper/acc_factory.cxx
+++ b/accessibility/source/helper/acc_factory.cxx
@@ -63,7 +63,6 @@
 
 #include "floatingwindowaccessible.hxx"
 
-//........................................................................
 namespace accessibility
 {
 
@@ -76,7 +75,6 @@ inline bool hasFloatingChild(Window *pWindow)
     return false;
 }
 
-//........................................................................
 
     using namespace ::com::sun::star::uno;
     using namespace ::com::sun::star::awt;
@@ -84,9 +82,7 @@ inline bool hasFloatingChild(Window *pWindow)
     using namespace ::svt;
     using namespace ::svt::table;
 
-    //================================================================
-    //= IAccessibleFactory
-    //================================================================
+    // IAccessibleFactory
     class AccessibleFactory :public ::toolkit::IAccessibleFactory
                             ,public ::svt::IAccessibleFactory
     {
@@ -230,25 +226,20 @@ inline bool hasFloatingChild(Window *pWindow)
         virtual ~AccessibleFactory();
     };
 
-
-    //--------------------------------------------------------------------
     AccessibleFactory::AccessibleFactory()
         :m_refCount( 0 )
     {
     }
 
-    //--------------------------------------------------------------------
     AccessibleFactory::~AccessibleFactory()
     {
     }
 
-    //--------------------------------------------------------------------
     oslInterlockedCount SAL_CALL AccessibleFactory::acquire()
     {
         return osl_atomic_increment( &m_refCount );
     }
 
-    //--------------------------------------------------------------------
     oslInterlockedCount SAL_CALL AccessibleFactory::release()
     {
         if ( 0 == osl_atomic_decrement( &m_refCount ) )
@@ -256,10 +247,10 @@ inline bool hasFloatingChild(Window *pWindow)
             delete this;
             return 0;
         }
+
         return m_refCount;
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessible > AccessibleFactory::createAccessible( Menu* _pMenu, sal_Bool _bIsMenuBar )
     {
         OAccessibleMenuBaseComponent* pAccessible;
@@ -271,25 +262,21 @@ inline bool hasFloatingChild(Window *pWindow)
         return pAccessible;
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessibleContext > AccessibleFactory::createAccessibleContext( VCLXButton* _pXWindow )
     {
         return new VCLXAccessibleButton( _pXWindow );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessibleContext > AccessibleFactory::createAccessibleContext( VCLXCheckBox* _pXWindow )
     {
         return new VCLXAccessibleCheckBox( _pXWindow );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessibleContext > AccessibleFactory::createAccessibleContext( VCLXRadioButton* _pXWindow )
     {
         return new VCLXAccessibleRadioButton( _pXWindow );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessibleContext > AccessibleFactory::createAccessibleContext( VCLXListBox* _pXWindow )
     {
         sal_Bool bIsDropDownBox = sal_False;
@@ -303,31 +290,26 @@ inline bool hasFloatingChild(Window *pWindow)
             return new VCLXAccessibleListBox( _pXWindow );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessibleContext > AccessibleFactory::createAccessibleContext( VCLXFixedText* _pXWindow )
     {
         return new VCLXAccessibleFixedText( _pXWindow );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessibleContext > AccessibleFactory::createAccessibleContext( VCLXFixedHyperlink* _pXWindow )
     {
         return new VCLXAccessibleFixedHyperlink( _pXWindow );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessibleContext > AccessibleFactory::createAccessibleContext( VCLXScrollBar* _pXWindow )
     {
         return new VCLXAccessibleScrollBar( _pXWindow );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessibleContext > AccessibleFactory::createAccessibleContext( VCLXEdit* _pXWindow )
     {
         return new VCLXAccessibleEdit( _pXWindow );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessibleContext > AccessibleFactory::createAccessibleContext( VCLXComboBox* _pXWindow )
     {
         sal_Bool bIsDropDownBox = sal_False;
@@ -341,7 +323,6 @@ inline bool hasFloatingChild(Window *pWindow)
             return new VCLXAccessibleComboBox( _pXWindow );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessibleContext > AccessibleFactory::createAccessibleContext( VCLXWindow* _pXWindow )
     {
         Reference< XAccessibleContext > xContext;
@@ -364,22 +345,27 @@ inline bool hasFloatingChild(Window *pWindow)
                     }
                 }
             }
+
             else if ( nType == WINDOW_STATUSBAR )
             {
                 xContext = (XAccessibleContext*) new VCLXAccessibleStatusBar( _pXWindow );
             }
+
             else if ( nType == WINDOW_TABCONTROL )
             {
                 xContext = (XAccessibleContext*) new VCLXAccessibleTabControl( _pXWindow );
             }
+
             else if ( nType == WINDOW_TABPAGE && pWindow->GetAccessibleParentWindow() && pWindow->GetAccessibleParentWindow()->GetType() == WINDOW_TABCONTROL )
             {
                 xContext = new VCLXAccessibleTabPageWindow( _pXWindow );
             }
+
             else if ( nType == WINDOW_FLOATINGWINDOW )
             {
                 xContext = new FloatingWindowAccessible( _pXWindow );
             }
+
             else if ( nType == WINDOW_BORDERWINDOW && hasFloatingChild( pWindow ) )
             {
                 // The logic here has to match that of Window::GetAccessibleParentWindow in
@@ -396,6 +382,7 @@ inline bool hasFloatingChild(Window *pWindow)
                 else
                     xContext = new FloatingWindowAccessible( _pXWindow );
             }
+
             else if ( ( nType == WINDOW_HELPTEXTWINDOW ) || ( nType == WINDOW_FIXEDLINE ) )
             {
                xContext = (accessibility::XAccessibleContext*) new VCLXAccessibleFixedText( _pXWindow );
@@ -405,65 +392,55 @@ inline bool hasFloatingChild(Window *pWindow)
                xContext = (accessibility::XAccessibleContext*) new VCLXAccessibleComponent( _pXWindow );
             }
         }
-
         return xContext;
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessibleContext > AccessibleFactory::createAccessibleContext( VCLXToolBox* _pXWindow )
     {
         return new VCLXAccessibleToolBox( _pXWindow );
     }
 
-    //--------------------------------------------------------------------
     IAccessibleTabListBox* AccessibleFactory::createAccessibleTabListBox(
         const Reference< XAccessible >& rxParent, SvHeaderTabListBox& rBox ) const
     {
         return new AccessibleTabListBox( rxParent, rBox );
     }
 
-    //--------------------------------------------------------------------
     IAccessibleBrowseBox* AccessibleFactory::createAccessibleBrowseBox(
         const Reference< XAccessible >& _rxParent, IAccessibleTableProvider& _rBrowseBox ) const
     {
         return new AccessibleBrowseBoxAccess( _rxParent, _rBrowseBox );
     }
 
-    //--------------------------------------------------------------------
     IAccessibleTableControl* AccessibleFactory::createAccessibleTableControl(
         const Reference< XAccessible >& _rxParent, IAccessibleTable& _rTable ) const
     {
         return new AccessibleGridControlAccess( _rxParent, _rTable );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessible > AccessibleFactory::createAccessibleIconChoiceCtrl(
         SvtIconChoiceCtrl& _rIconCtrl, const Reference< XAccessible >& _xParent ) const
     {
         return new AccessibleIconChoiceCtrl( _rIconCtrl, _xParent );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessible > AccessibleFactory::createAccessibleTabBar( TabBar& _rTabBar ) const
     {
         return new AccessibleTabBar( &_rTabBar );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessibleContext > AccessibleFactory::createAccessibleTextWindowContext(
         VCLXWindow* pVclXWindow, TextEngine& rEngine, TextView& rView ) const
     {
         return new Document( pVclXWindow, rEngine, rView );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessible > AccessibleFactory::createAccessibleTreeListBox(
         SvTreeListBox& _rListBox, const Reference< XAccessible >& _xParent ) const
     {
         return new AccessibleListBox( _rListBox, _xParent );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessible > AccessibleFactory::createAccessibleBrowseBoxHeaderBar(
         const Reference< XAccessible >& rxParent, IAccessibleTableProvider& _rOwningTable,
         AccessibleBrowseBoxObjType _eObjType ) const
@@ -471,7 +448,6 @@ inline bool hasFloatingChild(Window *pWindow)
         return new AccessibleBrowseBoxHeaderBar( rxParent, _rOwningTable, _eObjType );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessible > AccessibleFactory::createAccessibleBrowseBoxTableCell(
         const Reference< XAccessible >& _rxParent, IAccessibleTableProvider& _rBrowseBox,
         const Reference< XWindow >& _xFocusWindow, sal_Int32 _nRowId, sal_uInt16 _nColId, sal_Int32 _nOffset ) const
@@ -480,7 +456,6 @@ inline bool hasFloatingChild(Window *pWindow)
             _nRowId, _nColId, _nOffset );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessible > AccessibleFactory::createAccessibleBrowseBoxHeaderCell(
         sal_Int32 _nColumnRowId, const Reference< XAccessible >& rxParent, IAccessibleTableProvider& _rBrowseBox,
         const Reference< XWindow >& _xFocusWindow, AccessibleBrowseBoxObjType  _eObjType ) const
@@ -489,7 +464,6 @@ inline bool hasFloatingChild(Window *pWindow)
             _xFocusWindow, _eObjType );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessible > AccessibleFactory::createAccessibleCheckBoxCell(
         const Reference< XAccessible >& _rxParent, IAccessibleTableProvider& _rBrowseBox,
         const Reference< XWindow >& _xFocusWindow, sal_Int32 _nRowPos, sal_uInt16 _nColPos,
@@ -499,7 +473,6 @@ inline bool hasFloatingChild(Window *pWindow)
             _nRowPos, _nColPos, _eState, _bIsTriState );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessible > AccessibleFactory::createEditBrowseBoxTableCellAccess(
         const Reference< XAccessible >& _rxParent, const Reference< XAccessible >& _rxControlAccessible,
         const Reference< XWindow >& _rxFocusWindow, IAccessibleTableProvider& _rBrowseBox,
@@ -509,27 +482,21 @@ inline bool hasFloatingChild(Window *pWindow)
             _rxFocusWindow, _rBrowseBox, _nRowPos, _nColPos );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessibleContext > AccessibleFactory::createAccessibleToolPanelDeck(
             const Reference< XAccessible >& i_rAccessibleParent, ::svt::ToolPanelDeck& i_rPanelDeck )
     {
         return new AccessibleToolPanelDeck( i_rAccessibleParent, i_rPanelDeck );
     }
 
-    //--------------------------------------------------------------------
     Reference< XAccessibleContext > AccessibleFactory::createAccessibleToolPanelTabBar(
         const Reference< XAccessible >& i_rAccessibleParent, ::svt::IToolPanelDeck& i_rPanelDeck, ::svt::PanelTabBar& i_rTabBar )
     {
         return new AccessibleToolPanelTabBar( i_rAccessibleParent, i_rPanelDeck, i_rTabBar );
     }
 
-//........................................................................
 }   // namespace accessibility
-//........................................................................
 
-//========================================================================
-
-/** this is the entry point to retrieve a factory for the toolkit-level Accessible/Contexts supplied
+/* this is the entry point to retrieve a factory for the toolkit-level Accessible/Contexts supplied
     by this library
 
     This function implements the factory function needed in toolkit
@@ -545,6 +512,7 @@ extern "C"
     }
 }
 
+
 /** this is the entry point to retrieve a factory for the svtools-level Accessible/Contexts supplied
     by this library
 
diff --git a/accessibility/source/standard/floatingwindowaccessible.cxx b/accessibility/source/standard/floatingwindowaccessible.cxx
index be71fab..f75e7ce 100644
--- a/accessibility/source/standard/floatingwindowaccessible.cxx
+++ b/accessibility/source/standard/floatingwindowaccessible.cxx
@@ -19,7 +19,6 @@
 
 #include <floatingwindowaccessible.hxx>
 
-
 #include <com/sun/star/accessibility/AccessibleRelationType.hpp>
 #include <unotools/accessiblerelationsethelper.hxx>
 #include <vcl/window.hxx>
@@ -28,22 +27,14 @@ namespace uno = ::com::sun::star::uno;
 
 using ::com::sun::star::accessibility::AccessibleRelation;
 namespace AccessibleRelationType = ::com::sun::star::accessibility::AccessibleRelationType;
-
-//-------------------------------------------------------------------
-
 FloatingWindowAccessible::FloatingWindowAccessible(VCLXWindow* pWindow) :
     VCLXAccessibleComponent(pWindow)
 {
 }
-
-//-------------------------------------------------------------------
-
 FloatingWindowAccessible::~FloatingWindowAccessible()
 {
 }
 
-//-------------------------------------------------------------------
-
 void FloatingWindowAccessible::FillAccessibleRelationSet(utl::AccessibleRelationSetHelper& rRelationSet)
 {
     Window* pWindow = GetWindow();
diff --git a/accessibility/source/standard/vclxaccessibletoolbox.cxx b/accessibility/source/standard/vclxaccessibletoolbox.cxx
index 4492fde..2003a32 100644
--- a/accessibility/source/standard/vclxaccessibletoolbox.cxx
+++ b/accessibility/source/standard/vclxaccessibletoolbox.cxx
@@ -173,20 +173,19 @@ namespace
     }
 }
 
-// -----------------------------------------------------------------------------
 // VCLXAccessibleToolBox
-// -----------------------------------------------------------------------------
+
 VCLXAccessibleToolBox::VCLXAccessibleToolBox( VCLXWindow* pVCLXWindow ) :
 
     VCLXAccessibleComponent( pVCLXWindow )
 
 {
 }
-// -----------------------------------------------------------------------------
+
 VCLXAccessibleToolBox::~VCLXAccessibleToolBox()
 {
 }
-// -----------------------------------------------------------------------------
+
 VCLXAccessibleToolBoxItem* VCLXAccessibleToolBox::GetItem_Impl( sal_Int32 _nPos, bool _bMustHaveFocus )
 {
     VCLXAccessibleToolBoxItem* pItem = NULL;
@@ -201,7 +200,6 @@ VCLXAccessibleToolBoxItem* VCLXAccessibleToolBox::GetItem_Impl( sal_Int32 _nPos,
 
     return pItem;
 }
-// -----------------------------------------------------------------------------
 
 void VCLXAccessibleToolBox::UpdateFocus_Impl()
 {
@@ -254,7 +252,7 @@ void VCLXAccessibleToolBox::UpdateFocus_Impl()
         }
     }
 }
-// -----------------------------------------------------------------------------
+
 void VCLXAccessibleToolBox::ReleaseFocus_Impl( sal_Int32 _nPos )
 {
     ToolBox* pToolBox = static_cast< ToolBox* >( GetWindow() );
@@ -270,7 +268,7 @@ void VCLXAccessibleToolBox::ReleaseFocus_Impl( sal_Int32 _nPos )
         }
     }
 }
-// -----------------------------------------------------------------------------
+
 void VCLXAccessibleToolBox::UpdateChecked_Impl( sal_Int32 _nPos )
 {
     ToolBox* pToolBox = static_cast< ToolBox* >( GetWindow() );
@@ -295,7 +293,7 @@ void VCLXAccessibleToolBox::UpdateChecked_Impl( sal_Int32 _nPos )
             pFocusItem->SetFocus( sal_True );
     }
 }
-// -----------------------------------------------------------------------------
+
 void VCLXAccessibleToolBox::UpdateIndeterminate_Impl( sal_Int32 _nPos )
 {
     ToolBox* pToolBox = static_cast< ToolBox* >( GetWindow() );
@@ -313,7 +311,7 @@ void VCLXAccessibleToolBox::UpdateIndeterminate_Impl( sal_Int32 _nPos )
         }
     }
 }
-// -----------------------------------------------------------------------------
+
 void VCLXAccessibleToolBox::implReleaseToolboxItem( ToolBoxItemsMap::iterator& _rMapPos,
         bool _bNotifyRemoval, bool _bDispose )
 {
@@ -346,7 +344,6 @@ void VCLXAccessibleToolBox::implReleaseToolboxItem( ToolBoxItemsMap::iterator& _
     }
 }
 
-// -----------------------------------------------------------------------------
 void VCLXAccessibleToolBox::UpdateItem_Impl( sal_Int32 _nPos, sal_Bool _bItemAdded )
 {
     if ( _nPos < sal_Int32( m_aAccessibleChildren.size() ) )
@@ -408,7 +405,7 @@ void VCLXAccessibleToolBox::UpdateItem_Impl( sal_Int32 _nPos, sal_Bool _bItemAdd
         }
     }
 }
-// -----------------------------------------------------------------------------
+
 void VCLXAccessibleToolBox::UpdateAllItems_Impl()
 {
     ToolBox* pToolBox = static_cast< ToolBox* >( GetWindow() );
@@ -433,8 +430,6 @@ void VCLXAccessibleToolBox::UpdateAllItems_Impl()
     }
 }
 
-// -----------------------------------------------------------------------------
-
 void VCLXAccessibleToolBox::UpdateCustomPopupItemp_Impl( Window* pWindow, bool bOpen )
 {
     ToolBox* pToolBox = static_cast< ToolBox* >( GetWindow() );
@@ -452,21 +447,20 @@ void VCLXAccessibleToolBox::UpdateCustomPopupItemp_Impl( Window* pWindow, bool b
     }
 }
 
-// -----------------------------------------------------------------------------
 void VCLXAccessibleToolBox::UpdateItemName_Impl( sal_Int32 _nPos )
 {
     VCLXAccessibleToolBoxItem* pItem = GetItem_Impl( _nPos, false );
     if ( pItem )
         pItem->NameChanged();
 }
-// -----------------------------------------------------------------------------
+
 void VCLXAccessibleToolBox::UpdateItemEnabled_Impl( sal_Int32 _nPos )
 {
     VCLXAccessibleToolBoxItem* pItem = GetItem_Impl( _nPos, false );
     if ( pItem )
         pItem->ToggleEnableState();
 }
-// -----------------------------------------------------------------------------
+
 void VCLXAccessibleToolBox::HandleSubToolBarEvent( const VclWindowEvent& rVclWindowEvent, bool _bShow )
 {
     Window* pChildWindow = (Window *) rVclWindowEvent.GetData();
@@ -488,7 +482,7 @@ void VCLXAccessibleToolBox::HandleSubToolBarEvent( const VclWindowEvent& rVclWin
         }
     }
 }
-// -----------------------------------------------------------------------------
+
 void VCLXAccessibleToolBox::ReleaseSubToolBox( ToolBox* _pSubToolBox )
 {
     ToolBox* pToolBox = static_cast< ToolBox* >( GetWindow() );
@@ -512,7 +506,7 @@ void VCLXAccessibleToolBox::ReleaseSubToolBox( ToolBox* _pSubToolBox )
         pItem->NotifyChildEvent( xChild, false );
     }
 }
-// -----------------------------------------------------------------------------
+
 void VCLXAccessibleToolBox::FillAccessibleStateSet( utl::AccessibleStateSetHelper& rStateSet )
 {
     VCLXAccessibleComponent::FillAccessibleStateSet( rStateSet );
@@ -527,7 +521,7 @@ void VCLXAccessibleToolBox::FillAccessibleStateSet( utl::AccessibleStateSetHelpe
             rStateSet.AddState( AccessibleStateType::VERTICAL );
     }
 }
-// -----------------------------------------------------------------------------
+
 void VCLXAccessibleToolBox::ProcessWindowEvent( const VclWindowEvent& rVclWindowEvent )
 {
     // to prevent an early release of the toolbox (VCLEVENT_OBJECT_DYING)
@@ -648,7 +642,7 @@ void VCLXAccessibleToolBox::ProcessWindowEvent( const VclWindowEvent& rVclWindow
             VCLXAccessibleComponent::ProcessWindowEvent( rVclWindowEvent );
     }
 }
-// -----------------------------------------------------------------------------
+
 void VCLXAccessibleToolBox::ProcessWindowChildEvent( const VclWindowEvent& rVclWindowEvent )
 {
     switch ( rVclWindowEvent.GetId() )
@@ -668,17 +662,17 @@ void VCLXAccessibleToolBox::ProcessWindowChildEvent( const VclWindowEvent& rVclW
 
     }
 }
-// -----------------------------------------------------------------------------
+
 // XInterface
-// -----------------------------------------------------------------------------
+
 IMPLEMENT_FORWARD_XINTERFACE2( VCLXAccessibleToolBox, VCLXAccessibleComponent, VCLXAccessibleToolBox_BASE )
-// -----------------------------------------------------------------------------
+
 // XTypeProvider
-// -----------------------------------------------------------------------------
+
 IMPLEMENT_FORWARD_XTYPEPROVIDER2( VCLXAccessibleToolBox, VCLXAccessibleComponent, VCLXAccessibleToolBox_BASE )
-// -----------------------------------------------------------------------------
+
 // XComponent
-// -----------------------------------------------------------------------------
+
 void SAL_CALL VCLXAccessibleToolBox::disposing()
 {
     VCLXAccessibleComponent::disposing();
@@ -691,14 +685,14 @@ void SAL_CALL VCLXAccessibleToolBox::disposing()
     }
     m_aAccessibleChildren.clear();
 }
-// -----------------------------------------------------------------------------
+
 // XServiceInfo
-// -----------------------------------------------------------------------------
+
 OUString VCLXAccessibleToolBox::getImplementationName() throw (RuntimeException)
 {
     return OUString( "com.sun.star.comp.toolkit.AccessibleToolBox" );
 }
-// -----------------------------------------------------------------------------
+
 Sequence< OUString > VCLXAccessibleToolBox::getSupportedServiceNames() throw (RuntimeException)
 {
     Sequence< OUString > aNames = VCLXAccessibleComponent::getSupportedServiceNames();
@@ -707,9 +701,9 @@ Sequence< OUString > VCLXAccessibleToolBox::getSupportedServiceNames() throw (Ru
     aNames[nLength] = "com.sun.star.accessibility.AccessibleToolBox";
     return aNames;
 }
-// -----------------------------------------------------------------------------
+
 // XAccessibleContext
-// -----------------------------------------------------------------------------
+
 sal_Int32 SAL_CALL VCLXAccessibleToolBox::getAccessibleChildCount(  ) throw (RuntimeException)
 {
     comphelper::OExternalLockGuard aGuard( this );
@@ -721,7 +715,7 @@ sal_Int32 SAL_CALL VCLXAccessibleToolBox::getAccessibleChildCount(  ) throw (Run
 
     return nCount;
 }
-// -----------------------------------------------------------------------------
+
 Reference< XAccessible > SAL_CALL VCLXAccessibleToolBox::getAccessibleChild( sal_Int32 i ) throw (IndexOutOfBoundsException, RuntimeException)
 {
     if ( i < 0 || i >= getAccessibleChildCount() )
@@ -768,7 +762,7 @@ Reference< XAccessible > SAL_CALL VCLXAccessibleToolBox::getAccessibleChild( sal
 
     return NULL;
 }
-// -----------------------------------------------------------------------------
+
 Reference< XAccessible > SAL_CALL VCLXAccessibleToolBox::getAccessibleAtPoint( const awt::Point& _rPoint ) throw (RuntimeException)
 {
     comphelper::OExternalLockGuard aGuard( this );
@@ -784,7 +778,7 @@ Reference< XAccessible > SAL_CALL VCLXAccessibleToolBox::getAccessibleAtPoint( c
 
     return xAccessible;
 }
-// -----------------------------------------------------------------------------
+
 Reference< XAccessible > VCLXAccessibleToolBox::GetItemWindowAccessible( const VclWindowEvent& rVclWindowEvent )
 {
     Reference< XAccessible > xReturn;
@@ -803,7 +797,7 @@ Reference< XAccessible > VCLXAccessibleToolBox::GetItemWindowAccessible( const V
     }
     return xReturn;
 }
-// -----------------------------------------------------------------------------
+
 Reference< XAccessible > VCLXAccessibleToolBox::GetChildAccessible( const VclWindowEvent& rVclWindowEvent )
 {
     Reference< XAccessible > xReturn = GetItemWindowAccessible(rVclWindowEvent);
@@ -812,9 +806,8 @@ Reference< XAccessible > VCLXAccessibleToolBox::GetChildAccessible( const VclWin
         xReturn = VCLXAccessibleComponent::GetChildAccessible(rVclWindowEvent);
     return xReturn;
 }
-// -----------------------------------------------------------------------------
+
 // XAccessibleSelection
-// -----------------------------------------------------------------------------
 void VCLXAccessibleToolBox::selectAccessibleChild( sal_Int32 nChildIndex ) throw (IndexOutOfBoundsException, RuntimeException)
 {
     OExternalLockGuard aGuard( this );
@@ -824,7 +817,7 @@ void VCLXAccessibleToolBox::selectAccessibleChild( sal_Int32 nChildIndex ) throw
     sal_uInt16 nPos = static_cast < sal_uInt16 > (nChildIndex);
     pToolBox->ChangeHighlight( nPos );
 }
-// -----------------------------------------------------------------------------
+
 sal_Bool VCLXAccessibleToolBox::isAccessibleChildSelected( sal_Int32 nChildIndex ) throw (IndexOutOfBoundsException, RuntimeException)
 {
     OExternalLockGuard aGuard( this );
@@ -837,20 +830,20 @@ sal_Bool VCLXAccessibleToolBox::isAccessibleChildSelected( sal_Int32 nChildIndex
     else
         return sal_False;
 }
-// -----------------------------------------------------------------------------
+
 void VCLXAccessibleToolBox::clearAccessibleSelection(  ) throw (RuntimeException)
 {
     OExternalLockGuard aGuard( this );
     ToolBox * pToolBox = static_cast < ToolBox * > ( GetWindow() );
     pToolBox -> LoseFocus();
 }
-// -----------------------------------------------------------------------------
+
 void VCLXAccessibleToolBox::selectAllAccessibleChildren(  ) throw (RuntimeException)
 {
     OExternalLockGuard aGuard( this );
     // intentionally empty. makes no sense for a toolbox
 }
-// -----------------------------------------------------------------------------
+
 sal_Int32 VCLXAccessibleToolBox::getSelectedAccessibleChildCount(  ) throw (RuntimeException)
 {
     OExternalLockGuard aGuard( this );
@@ -865,7 +858,7 @@ sal_Int32 VCLXAccessibleToolBox::getSelectedAccessibleChildCount(  ) throw (Runt
     }
     return nRet;
 }
-// -----------------------------------------------------------------------------
+
 Reference< XAccessible > VCLXAccessibleToolBox::getSelectedAccessibleChild( sal_Int32 nSelectedChildIndex ) throw (IndexOutOfBoundsException, RuntimeException)
 {
     OExternalLockGuard aGuard( this );
@@ -882,7 +875,7 @@ Reference< XAccessible > VCLXAccessibleToolBox::getSelectedAccessibleChild( sal_
     }
     return xChild;
 }
-// -----------------------------------------------------------------------------
+
 void VCLXAccessibleToolBox::deselectAccessibleChild( sal_Int32 nChildIndex ) throw (IndexOutOfBoundsException, RuntimeException)
 {
     OExternalLockGuard aGuard( this );
@@ -890,6 +883,5 @@ void VCLXAccessibleToolBox::deselectAccessibleChild( sal_Int32 nChildIndex ) thr
         throw IndexOutOfBoundsException();
     clearAccessibleSelection(); // a toolbox can only have (n)one selected child
 }
-// -----------------------------------------------------------------------------
 
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/comphelper/source/misc/sequence.cxx b/comphelper/source/misc/sequence.cxx
index ea0cfe1..cebd52c 100644
--- a/comphelper/source/misc/sequence.cxx
+++ b/comphelper/source/misc/sequence.cxx
@@ -19,20 +19,15 @@
 
 #include <comphelper/sequence.hxx>
 
-//.........................................................................
 namespace comphelper
 {
-//.........................................................................
-
-//------------------------------------------------------------------------------
 staruno::Sequence<sal_Int16> findValue(const staruno::Sequence< OUString >& _rList, const OUString& _rValue, bool _bOnlyFirst)
 {
     sal_Int32 nLength = _rList.getLength();
 
     if( _bOnlyFirst )
     {
-        //////////////////////////////////////////////////////////////////////
-        // An welcher Position finde ich den Wert?
+        // at which position do I find the value?
         sal_Int32 nPos = -1;
         const OUString* pTArray = _rList.getConstArray();
         for (sal_Int32 i = 0; i < nLength; ++i, ++pTArray)
@@ -43,9 +38,8 @@ staruno::Sequence<sal_Int16> findValue(const staruno::Sequence< OUString >& _rLi
                 break;
             }
         }
-
-        //////////////////////////////////////////////////////////////////////
-        // Sequence fuellen
+        
+        // fill sequence
         if( nPos>-1 )
         {
             staruno::Sequence<sal_Int16> aRetSeq( 1 );
@@ -62,8 +56,7 @@ staruno::Sequence<sal_Int16> findValue(const staruno::Sequence< OUString >& _rLi
         staruno::Sequence<sal_Int16> aRetSeq( nLength );
         sal_Int16* pReturn = aRetSeq.getArray();
 
-        //////////////////////////////////////////////////////////////////////
-        // Wie oft kommt der Wert vor?
+        // how often does the value occur?
         const OUString* pTArray = _rList.getConstArray();
         for (sal_Int32 i = 0; i < nLength; ++i, ++pTArray)
         {
@@ -80,6 +73,5 @@ staruno::Sequence<sal_Int16> findValue(const staruno::Sequence< OUString >& _rLi
     }
 }
 }   // namespace comphelper
-//.........................................................................
 
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/dbaccess/source/ui/dlg/advancedsettings.hxx b/dbaccess/source/ui/dlg/advancedsettings.hxx
index 4ae9f84..de51629 100644
--- a/dbaccess/source/ui/dlg/advancedsettings.hxx
+++ b/dbaccess/source/ui/dlg/advancedsettings.hxx
@@ -32,13 +32,11 @@
 
 namespace dbaui
 {
-
     struct BooleanSettingDesc;
     typedef ::std::vector< BooleanSettingDesc > BooleanSettingDescs;
 
     // SpecialSettingsPage
-    /** implements the "Special Settings" page of the advanced database settings
-    */
+    // implements the "Special Settings" page of the advanced database settings
     class SpecialSettingsPage : public OGenericAdministrationPage
     {
     protected:
@@ -115,7 +113,7 @@ namespace dbaui
         GeneratedValuesPage( Window* pParent, const SfxItemSet& _rCoreAttrs );
     protected:
 
-            // nControlFlags ist eine Kombination der CBTP_xxx-Konstanten
+        // nControlFlags ist eine Kombination der CBTP_xxx-Konstanten
         virtual ~GeneratedValuesPage();
 
         // must be overloaded by subclasses, but it isn't pure virtual
@@ -131,7 +129,7 @@ namespace dbaui
         DECL_LINK( OnCheckBoxClick, CheckBox * );
     };
 
-} // namespace dbaui
+}
 
 #endif // INCLUDED_DBACCESS_SOURCE_UI_DLG_ADVANCEDSETTINGS_HXX
 
diff --git a/dbaccess/source/ui/relationdesign/RTableConnection.cxx b/dbaccess/source/ui/relationdesign/RTableConnection.cxx
index f84984f..c05f561 100644
--- a/dbaccess/source/ui/relationdesign/RTableConnection.cxx
+++ b/dbaccess/source/ui/relationdesign/RTableConnection.cxx
@@ -35,7 +35,7 @@ ORelationTableConnection::ORelationTableConnection( ORelationTableView* pContain
 ORelationTableConnection::ORelationTableConnection( const ORelationTableConnection& rConn )
     : OTableConnection( rConn )
 {
-    // keine eigenen Members, also reicht die Basisklassenfunktionalitaet
+    // no own members, thus the base class functionality is enough
 }
 
 ORelationTableConnection::~ORelationTableConnection()
@@ -44,7 +44,7 @@ ORelationTableConnection::~ORelationTableConnection()
 
 ORelationTableConnection& ORelationTableConnection::operator=( const ORelationTableConnection& rConn )
 {
-    // nicht dass es was aendern wuerde, da die Basisklasse das auch testet und ich keine eigenen Members zu kopieren habe
+    // this doesn't change anything, since the base class tests this, too and I don't have my own members to copy
     if (&rConn == this)
         return *this;
 
@@ -59,7 +59,7 @@ void ORelationTableConnection::Draw( const Rectangle& rRect )
     if ( pData && (pData->GetCardinality() == CARDINAL_UNDEFINED) )
         return;
 
-    // Linien nach oberster Linie durchsuchen
+    // search lines for top line
     Rectangle aBoundingRect;
     long nTop = GetBoundingRect().Bottom();
     long nTemp;
@@ -82,7 +82,7 @@ void ORelationTableConnection::Draw( const Rectangle& rRect )
         }
     }
 
-    // Kardinalitaet antragen
+    // cardinality
     if( !pTopLine )
         return;
 
diff --git a/dbaccess/source/ui/relationdesign/RTableConnectionData.cxx b/dbaccess/source/ui/relationdesign/RTableConnectionData.cxx
index aa7c5c8..a046a0e 100644
--- a/dbaccess/source/ui/relationdesign/RTableConnectionData.cxx
+++ b/dbaccess/source/ui/relationdesign/RTableConnectionData.cxx
@@ -78,7 +78,7 @@ ORelationTableConnectionData::~ORelationTableConnectionData()
 sal_Bool ORelationTableConnectionData::DropRelation()
 {
     ::osl::MutexGuard aGuard( m_aMutex );
-    // Relation loeschen
+    // delete relation
     Reference< XIndexAccess> xKeys = getReferencingTable()->getKeys();
     if( !m_aConnName.isEmpty() && xKeys.is() )
     {
@@ -107,7 +107,7 @@ sal_Bool ORelationTableConnectionData::DropRelation()
 
 void ORelationTableConnectionData::ChangeOrientation()
 {
-    // Source- und DestFieldName der Linien austauschen
+    // exchange Source- and DestFieldName of the lines
     OUString sTempString;
     OConnectionLineDataVec::iterator aIter = m_vConnLineData.begin();
     OConnectionLineDataVec::iterator aEnd = m_vConnLineData.end();
@@ -118,7 +118,7 @@ void ORelationTableConnectionData::ChangeOrientation()
         (*aIter)->SetDestFieldName( sTempString );
     }
 
-    // Member anpassen
+    // adapt member
     TTableWindowData::value_type pTemp = m_pReferencingTable;
     m_pReferencingTable = m_pReferencedTable;
     m_pReferencedTable = pTemp;
@@ -184,7 +184,7 @@ sal_Bool ORelationTableConnectionData::IsConnectionPossible()
 {
     ::osl::MutexGuard aGuard( m_aMutex );
 
-    // Wenn die SourceFelder ein PrimKey sind, ist nur die Orientierung falsch
+    // if the SourceFields are a PrimKey, it's only the orientation which is wrong
     if ( IsSourcePrimKey() && !IsDestPrimKey() )
         ChangeOrientation();
 
@@ -203,7 +203,7 @@ OConnectionLineDataRef ORelationTableConnectionData::CreateLineDataObj( const OC
 
 void ORelationTableConnectionData::CopyFrom(const OTableConnectionData& rSource)
 {
-    // wie in der Basisklasse zurueckziehen auf das (nicht-virtuelle) operator=
+    // retract to the (non-virtual) operator= like in the base class
     *this = *static_cast<const ORelationTableConnectionData*>(&rSource);
 }
 
@@ -251,7 +251,7 @@ bool operator==(const ORelationTableConnectionData& lhs, const ORelationTableCon
 sal_Bool ORelationTableConnectionData::Update()
 {
     ::osl::MutexGuard aGuard( m_aMutex );
-    // Alte Relation loeschen
+    // delete old relation
     {
         DropRelation();
         if( !IsConnectionPossible() )
@@ -264,7 +264,7 @@ sal_Bool ORelationTableConnectionData::Update()
 
     if ( !xKeys.is() )
         return sal_False;
-    // Neue Relation erzeugen
+    // create new relation
     Reference<XDataDescriptorFactory> xKeyFactory(xKeys,UNO_QUERY);
     OSL_ENSURE(xKeyFactory.is(),"No XDataDescriptorFactory Interface!");
     Reference<XAppend> xAppend(xKeyFactory,UNO_QUERY);
@@ -318,7 +318,7 @@ sal_Bool ORelationTableConnectionData::Update()
         // to get the key we have to reget it because after append it is no longer valid
     }
 
-    // get the name of foreign key // search for columns
+    // get the name of foreign key; search for columns
     m_aConnName = OUString();
 xKey.clear();
     bool bDropRelation = false;
@@ -418,7 +418,7 @@ xKey.clear();
     }
     // NOTE : the caller is responsible for updating any other objects referencing the old LineDatas (for instance a ConnLine)
 
-    // Kardinalitaet bestimmen
+    // determine cardinality
     SetCardinality();
 
     return sal_True;
diff --git a/dbaccess/source/ui/relationdesign/RelationTableView.cxx b/dbaccess/source/ui/relationdesign/RelationTableView.cxx
index ea7b142..07214a9 100644
--- a/dbaccess/source/ui/relationdesign/RelationTableView.cxx
+++ b/dbaccess/source/ui/relationdesign/RelationTableView.cxx
@@ -114,14 +114,14 @@ void ORelationTableView::ReSync()
         }
 
         (*GetTabWinMap())[pData->GetComposedName()] = pTabWin;  // am Anfang einfuegen, da ich die DataList ja rueckwaerts durchlaufe
-        // wenn in den Daten keine Position oder Groesse steht -> Default
+        // if there's no position or size contained in the data -> Default
         if (!pData->HasPosition() && !pData->HasSize())
             SetDefaultTabWinPosSize(pTabWin);
 
         pTabWin->Show();
     }
 
-    // Verbindungen einfuegen
+    // insert connection
     TTableConnectionData* pTabConnDataList = m_pView->getController().getTableConnectionData();
     TTableConnectionData::reverse_iterator aConIter = pTabConnDataList->rbegin();
 
@@ -137,7 +137,8 @@ void ORelationTableView::ReSync()
             bInvalid = bInvalid || ::std::find(arrInvalidTables.begin(),arrInvalidTables.end(),strTabExistenceTest) != arrInvalidTables.end();
 
             if (bInvalid)
-            {   // nein -> Pech gehabt, die Connection faellt weg
+            {   
+                // no -> bad luck, die Connection faellt weg
                 pTabConnDataList->erase( ::std::remove(pTabConnDataList->begin(),pTabConnDataList->end(),*aConIter),pTabConnDataList->end() );
                 continue;
             }
@@ -176,15 +177,14 @@ void ORelationTableView::AddConnection(const OJoinExchangeData& jxdSource, const
         }
     }
     // insert table connection into view
-
     TTableConnectionData::value_type pTabConnData(new ORelationTableConnectionData(pSourceWin->GetData(),
                                                                                    pDestWin->GetData()));
 
-    // die Namen der betroffenen Felder
+    // the names of the affected fields
     OUString sSourceFieldName = jxdSource.pListBox->GetEntryText(jxdSource.pEntry);
     OUString sDestFieldName = jxdDest.pListBox->GetEntryText(jxdDest.pEntry);
 
-    // die Anzahl der PKey-Felder in der Quelle
+    // the number of PKey-Fields in the source
     const Reference< XNameAccess> xPrimaryKeyColumns = getPrimaryKeyColumns_throw(pSourceWin->GetData()->getTable());
     bool bAskUser = xPrimaryKeyColumns.is() && Reference< XIndexAccess>(xPrimaryKeyColumns,UNO_QUERY)->getCount() > 1;
 
@@ -196,10 +196,10 @@ void ORelationTableView::AddConnection(const OJoinExchangeData& jxdSource, const
     {
         try
         {
-            // Daten der Datenbank uebergeben
+            // hand over data to the database
             if( pTabConnData->Update() )
             {
-                // UI-Object in ConnListe eintragen
+                // enter UI-object into ConnList
                 addConnection( new ORelationTableConnection( this, pTabConnData ) );
             }
         }
@@ -288,7 +288,7 @@ void ORelationTableView::AddTabWin(const OUString& _rComposedName, const OUStrin
         return;
     }
 
-    // Neue Datenstruktur in DocShell eintragen
+    // enter the new data structure into DocShell
     TTableWindowData::value_type pNewTabWinData(createTableWindowData( _rComposedName, rWinName,rWinName ));
     pNewTabWinData->ShowAll(sal_False);
 
diff --git a/dbaccess/source/ui/tabledesign/FieldDescGenWin.cxx b/dbaccess/source/ui/tabledesign/FieldDescGenWin.cxx
index 8ddece2..d621476 100644
--- a/dbaccess/source/ui/tabledesign/FieldDescGenWin.cxx
+++ b/dbaccess/source/ui/tabledesign/FieldDescGenWin.cxx
@@ -27,7 +27,6 @@
 using namespace dbaui;
 
 // class OFieldDescGenWin
-
 OFieldDescGenWin::OFieldDescGenWin( Window* pParent, OTableDesignHelpBar* pHelp ) :
      TabPage( pParent, WB_3DLOOK | WB_DIALOGCONTROL )
 {
@@ -68,7 +67,7 @@ OUString OFieldDescGenWin::GetControlText( sal_uInt16 nControlId )
 
 void OFieldDescGenWin::SetControlText( sal_uInt16 nControlId, const OUString& rText )
 {
-    // Texte der Controls setzen
+    // set texts of the controls
     m_pFieldControl->SetControlText(nControlId,rText);
 }
 
@@ -93,7 +92,7 @@ void OFieldDescGenWin::SaveData( OFieldDescription* pFieldDescr )
 
 void OFieldDescGenWin::GetFocus()
 {
-    // Setzt den Focus auf das zuletzt aktive Control
+    // sets the focus to the control that was active last
     TabPage::GetFocus();
     if(m_pFieldControl)
         m_pFieldControl->GetFocus();
diff --git a/dbaccess/source/ui/tabledesign/FieldDescGenWin.hxx b/dbaccess/source/ui/tabledesign/FieldDescGenWin.hxx
index 545e89a..40f8e07 100644
--- a/dbaccess/source/ui/tabledesign/FieldDescGenWin.hxx
+++ b/dbaccess/source/ui/tabledesign/FieldDescGenWin.hxx
@@ -52,8 +52,8 @@ namespace dbaui
 #if OSL_DEBUG_LEVEL > 0
         OTableEditorCtrl* GetEditorCtrl();
 #endif
-        //  short GetFormatCategory(OFieldDescription* pFieldDescr);
-            // liefert zum am Feld eingestellten Format einen der CAT_xxx-Werte (CAT_NUMBER, CAT_DATE ...)
+        // short GetFormatCategory(OFieldDescription* pFieldDescr);
+        // gives you one of the CAT_xxx-values (CAT_NUMBER, CAT_DATE ...) belonging to the format specified by the field
 
         OUString BoolStringPersistent(const OUString& rUIString) const;
         OUString BoolStringUI(const OUString& rPersistentString) const;
diff --git a/dbaccess/source/ui/tabledesign/TEditControl.cxx b/dbaccess/source/ui/tabledesign/TEditControl.cxx
index fe794e2..f0b5492 100644
--- a/dbaccess/source/ui/tabledesign/TEditControl.cxx
+++ b/dbaccess/source/ui/tabledesign/TEditControl.cxx
@@ -105,7 +105,7 @@ void OTableEditorCtrl::Init()
 {
     OTableRowView::Init();
 
-    // Should it be opened ReadOnly ?
+    // Should it be opened ReadOnly?
     sal_Bool bRead(GetView()->getController().isReadOnly());
 
     SetReadOnly( bRead );
@@ -474,7 +474,7 @@ void OTableEditorCtrl::DisplayData(long nRow, sal_Bool bGrabFocus)
 
 void OTableEditorCtrl::CursorMoved()
 {
-    // New line ?
+    // New line?
     m_nDataPos = GetCurRow();
     if( m_nDataPos != nOldDataPos && m_nDataPos != -1)
     {
@@ -549,7 +549,7 @@ sal_Bool OTableEditorCtrl::SaveData(long nRow, sal_uInt16 nColId)
         // Store DescrCell
         case HELP_TEXT:
         {
-            // Wenn aktuelle Feldbeschreibung NULL, Default setzen
+            // if the current field description is NULL, set Default
             if( !pActFieldDescr )
             {
                 pHelpTextCell->SetText(OUString());
diff --git a/dbaccess/source/ui/tabledesign/TableController.cxx b/dbaccess/source/ui/tabledesign/TableController.cxx
index f6dace2..d47bbe7 100644
--- a/dbaccess/source/ui/tabledesign/TableController.cxx
+++ b/dbaccess/source/ui/tabledesign/TableController.cxx
@@ -94,7 +94,7 @@ using namespace ::dbtools;
 using namespace ::dbaui;
 using namespace ::comphelper;
 
-// Anzahl Spalten beim Neuanlegen
+// number of columns when creating it from scratch
 #define NEWCOLS        128
 
 namespace
@@ -182,7 +182,7 @@ void OTableController::disposing()
 FeatureState OTableController::GetState(sal_uInt16 _nId) const
 {
     FeatureState aReturn;
-    // (disabled automatically)
+    // disabled automatically
 
     switch (_nId)
     {
@@ -785,12 +785,12 @@ void OTableController::appendPrimaryKey(Reference<XKeysSupplier>& _rxSup,sal_Boo
 
 void OTableController::loadData()
 {
-    // Wenn Datenstruktur bereits vorhanden, Struktur leeren
+    // if the data structure already exists, empty it
     m_vRowList.clear();
 
     ::boost::shared_ptr<OTableRow>  pTabEdRow;
     Reference< XDatabaseMetaData> xMetaData = getMetaData( );
-    // Datenstruktur mit Daten aus DatenDefinitionsObjekt fuellen
+    // fill data structure with data from DataDefinitionObject
     if(m_xTable.is() && xMetaData.is())
     {
         Reference<XColumnsSupplier> xColSup(m_xTable,UNO_QUERY);
@@ -798,9 +798,9 @@ void OTableController::loadData()
         Reference<XNameAccess> xColumns = xColSup->getColumns();
         OFieldDescription* pActFieldDescr = NULL;
         // ReadOnly-Flag
-        // Bei Drop darf keine Zeile editierbar sein.
-        // Bei Add duerfen nur die leeren Zeilen editierbar sein.
-        // Bei Add und Drop koennen alle Zeilen editiert werden.
+        // For Drop no row may be editable
+        // For Add only the empty rows may be editable
+        // For Add and Drop all rows can be edited
         //  sal_Bool bReadOldRow = xMetaData->supportsAlterTableWithAddColumn() && xMetaData->supportsAlterTableWithDropColumn();
         sal_Bool bIsAlterAllowed = isAlterAllowed();
         Sequence< OUString> aColumns = xColumns->getElementNames();
@@ -865,7 +865,7 @@ void OTableController::loadData()
                 pActFieldDescr->SetHorJustify(dbaui::mapTextJustify(nAlign));
                 pActFieldDescr->SetCurrency(bIsCurrency);
 
-                // Spezielle Daten
+                // special data
                 pActFieldDescr->SetIsNullable(nNullable);
                 pActFieldDescr->SetControlDefault(aControlDefault);
                 pActFieldDescr->SetPrecision(nPrecision);
@@ -897,7 +897,7 @@ void OTableController::loadData()
         }
     }
 
-    // Leere Zeilen fuellen
+    // fill empty rows
 
     OTypeInfoMap::iterator aTypeIter = m_aTypeInfo.find(DataType::VARCHAR);
     if(aTypeIter == m_aTypeInfo.end())
diff --git a/dbaccess/source/ui/tabledesign/TableDesignControl.cxx b/dbaccess/source/ui/tabledesign/TableDesignControl.cxx
index ec7986da..90dafa2 100644
--- a/dbaccess/source/ui/tabledesign/TableDesignControl.cxx
+++ b/dbaccess/source/ui/tabledesign/TableDesignControl.cxx
@@ -31,7 +31,7 @@ using namespace ::svt;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::beans;
 using namespace ::com::sun::star::util;
-//--- Defines
+// Defines
 #define HANDLE_ID 0
 
 OTableRowView::OTableRowView(Window* pParent)
@@ -61,12 +61,12 @@ void OTableRowView::Init()
     aFont.SetWeight( WEIGHT_NORMAL );
     GetDataWindow().SetFont( aFont );
 
-    // Font fuer die Ueberschriften auf Light setzen
+    // set font for the headings to light
     aFont = GetFont();
     aFont.SetWeight( WEIGHT_LIGHT );
     SetFont(aFont);
 
-    // HandleColumn, fuer maximal fuenf Ziffern einrichten
+    // set up HandleColumn for at maximum 5 digits
     InsertHandleColumn(static_cast<sal_uInt16>(GetTextWidth(OUString('0')) * 4)/*, sal_True */);
 
     BrowserMode nMode = BROWSER_COLUMNSELECTION | BROWSER_MULTISELECTION | BROWSER_KEEPSELECTION |
diff --git a/dbaccess/source/ui/tabledesign/TableFieldControl.hxx b/dbaccess/source/ui/tabledesign/TableFieldControl.hxx
index 08e7d92..4cceb45 100644
--- a/dbaccess/source/ui/tabledesign/TableFieldControl.hxx
+++ b/dbaccess/source/ui/tabledesign/TableFieldControl.hxx
@@ -32,7 +32,7 @@ namespace dbaui
     protected:
         virtual void        ActivateAggregate( EControlType eType );
         virtual void        DeactivateAggregate( EControlType eType );
-        // Sind von den abgeleiteten Klassen zu impl.
+        // are to be implemented by the derived classes
         virtual void        CellModified(long nRow, sal_uInt16 nColId );
         virtual sal_Bool        IsReadOnly();
         virtual void        SetModified(sal_Bool bModified);
diff --git a/dbaccess/source/ui/tabledesign/TableFieldDescWin.cxx b/dbaccess/source/ui/tabledesign/TableFieldDescWin.cxx
index 2f28b09..b87c999 100644
--- a/dbaccess/source/ui/tabledesign/TableFieldDescWin.cxx
+++ b/dbaccess/source/ui/tabledesign/TableFieldDescWin.cxx
@@ -66,7 +66,7 @@ OTableFieldDescWin::OTableFieldDescWin( Window* pParent)
 
 OTableFieldDescWin::~OTableFieldDescWin()
 {
-    // Children zerstoeren
+    // destroy children
     m_pHelpBar->Hide();
     getGenPage()->Hide();
     m_pHeader->Hide();
@@ -108,13 +108,13 @@ void OTableFieldDescWin::SaveData( OFieldDescription* pFieldDescr )
 
 void OTableFieldDescWin::Paint( const Rectangle& /*rRect*/ )
 {
-    // 3D-Linie am oberen Fensterrand
+    // 3D-line at the top window border
     const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
 
     SetLineColor( rStyleSettings.GetLightColor() );
     DrawLine( Point(0,0), Point(GetSizePixel().Width(),0) );
 
-    // 3D-Linie zum Abtrennen des Headers
+    // 3D-line for the separation of the header
     DrawLine( Point(3, DETAILS_HEADER_HEIGHT), Point(GetSizePixel().Width()-6, DETAILS_HEADER_HEIGHT) );
     SetLineColor( rStyleSettings.GetShadowColor() );
     DrawLine( Point(3, DETAILS_HEADER_HEIGHT-1), Point(GetSizePixel().Width()-6, DETAILS_HEADER_HEIGHT-1) );
@@ -122,56 +122,56 @@ void OTableFieldDescWin::Paint( const Rectangle& /*rRect*/ )
 
 void OTableFieldDescWin::Resize()
 {
-    // Abmessungen parent window
+    // dimensions of the parent window
     Size aOutputSize( GetOutputSizePixel() );
     long nOutputWidth = aOutputSize.Width();
     long nOutputHeight = aOutputSize.Height();
 
-    // da die GenPage scrollen kann, ich selber aber nicht, positioniere ich das HelpFenster, wenn ich zu schmal werde,
-    // _unter_ der Genpage, nicht rechts daneben. Zuvor versuche ich aber noch, es etwas schmaler zu machen
+    // since the GenPage can scroll, but I can't, I position the HelpWindow, in case I become too slim,
+    // _below_ the Genpage, not on the right side. But before that I try to make it a bit smaller
 
     long nHelpX, nHelpY;
     long nHelpWidth, nHelpHeight;
     long nPageWidth, nPageHeight;
 
-    // passen beide nebeneinander (Rand + Page + Rand + Help) ?
+    // do both fit next to each other (margin + page + margin + help)?
     if (STANDARD_MARGIN + DETAILS_OPT_PAGE_WIDTH + STANDARD_MARGIN + DETAILS_MIN_HELP_WIDTH <= nOutputWidth)
-    {   // ja -> dann ist die Frage, ob man der Hilfe ihre Optimal-Breite geben kann
+    {   // yes -> then we wonder if can give the help its optimum width
         nHelpWidth = DETAILS_OPT_HELP_WIDTH;
         nPageWidth = nOutputWidth - nHelpWidth - STANDARD_MARGIN - STANDARD_MARGIN;
         if (nPageWidth < DETAILS_OPT_PAGE_WIDTH)
-        {   // dann doch lieber die Hilfe von ihrer optimalen in Richtung auf die minimale Groesse
+        {   // rather resize the help from its optimal width to it's minimum width
             long nTransfer = DETAILS_OPT_PAGE_WIDTH - nPageWidth;
             nPageWidth += nTransfer;
             nHelpWidth -= nTransfer;
         }
         nHelpX = nOutputWidth - nHelpWidth;
-        // die Hoehen sind dann einfach ...
+        // the heights are simple in that case...
         nHelpY = DETAILS_HEADER_HEIGHT + 1;
         nHelpHeight = nOutputHeight - nHelpY;
         nPageHeight = nOutputHeight - STANDARD_MARGIN - DETAILS_HEADER_HEIGHT - STANDARD_MARGIN;
     }
     else
-    {   // nebeneinander geht nicht, also untereinander (Rand + Header + Page + Help)
+    {   // doesn't work next to each other, thus below each other (margin + header + page + help)
         if (STANDARD_MARGIN + DETAILS_HEADER_HEIGHT + DETAILS_OPT_PAGE_HEIGHT + DETAILS_MIN_HELP_HEIGHT <= nOutputHeight)
-        {   // es reicht zumindest, um beide untereinander (Page optimal, Help minimal) unterzubringen
+        {   // it's at least enough, to fit both below each other (page optimal, help minimal)
             nHelpHeight = DETAILS_OPT_HELP_HEIGHT;
             nPageHeight = nOutputHeight - nHelpHeight - DETAILS_HEADER_HEIGHT - STANDARD_MARGIN;
             if (nPageHeight < DETAILS_OPT_PAGE_HEIGHT)
-            {   // wie oben : Page optimal, Hilfe soviel wie eben bleibt (das ist groesser/gleich ihrem Minimum)
+            {   // like above: page optimal, help gets whatever is left (which is bigger/equal to its minimum)
                 long nTransfer = DETAILS_OPT_PAGE_HEIGHT - nPageHeight;
                 nPageHeight += nTransfer;
                 nHelpHeight -= nTransfer;
             }
             nHelpY = nOutputHeight - nHelpHeight;
-            // und ueber die ganze Breite
-            nHelpX = 0;                 // ohne Margin, da das HelpCtrl einen eigenen hat
+            // and across the entire width
+            nHelpX = 0;                 // without margin, since the HelpCtrl has its own one
             nHelpWidth = nOutputWidth;  // dito
             nPageWidth = nOutputWidth - STANDARD_MARGIN - STANDARD_MARGIN;
         }
         else
-        {   // dummerweise reicht es nicht mal, um Page optimal und Help minimal zu zeigen
-            nHelpX = nHelpY = nHelpWidth = nHelpHeight = 0; // -> kein Help-Fenster
+        {   // unfortunately that's not even enough, to show page at its optimum and help with minimum widthn
+            nHelpX = nHelpY = nHelpWidth = nHelpHeight = 0; // thus no help window
             nPageWidth = nOutputWidth - STANDARD_MARGIN - STANDARD_MARGIN;
             nPageHeight = nOutputHeight - STANDARD_MARGIN - DETAILS_HEADER_HEIGHT - STANDARD_MARGIN;
         }
diff --git a/dbaccess/source/ui/uno/dbinteraction.cxx b/dbaccess/source/ui/uno/dbinteraction.cxx
index 31d84a7..d079c82 100644
--- a/dbaccess/source/ui/uno/dbinteraction.cxx
+++ b/dbaccess/source/ui/uno/dbinteraction.cxx
@@ -116,7 +116,7 @@ namespace dbaui
     void BasicInteractionHandler::implHandle(const ParametersRequest& _rParamRequest, const Sequence< Reference< XInteractionContinuation > >& _rContinuations)
     {
         SolarMutexGuard aGuard;
-            // want to open a dialog ....
+        // want to open a dialog...
 
         sal_Int32 nAbortPos = getContinuation(ABORT, _rContinuations);
         sal_Int32 nParamPos = getContinuation(SUPPLY_PARAMETERS, _rContinuations);
@@ -154,7 +154,7 @@ namespace dbaui
     void BasicInteractionHandler::implHandle(const SQLExceptionInfo& _rSqlInfo, const Sequence< Reference< XInteractionContinuation > >& _rContinuations)
     {
         SolarMutexGuard aGuard;
-            // want to open a dialog ....
+        // want to open a dialog...
 
         sal_Int32 nApprovePos = getContinuation(APPROVE, _rContinuations);
         sal_Int32 nDisapprovePos = getContinuation(DISAPPROVE, _rContinuations);
@@ -182,7 +182,7 @@ namespace dbaui
 
         // execute the dialog
         OSQLMessageBox aDialog(NULL, _rSqlInfo, nDialogStyle);
-            // TODO: need a way to specify the parent window
+        // TODO: need a way to specify the parent window
         sal_Int16 nResult = aDialog.Execute();
         try
         {
@@ -227,7 +227,7 @@ namespace dbaui
     void BasicInteractionHandler::implHandle(const DocumentSaveRequest& _rDocuRequest, const Sequence< Reference< XInteractionContinuation > >& _rContinuations)
     {
         SolarMutexGuard aGuard;
-            // want to open a dialog ....
+        // want to open a dialog ....
 
         sal_Int32 nApprovePos = getContinuation(APPROVE, _rContinuations);
         sal_Int32 nDisApprovePos = getContinuation(DISAPPROVE, _rContinuations);
@@ -236,7 +236,7 @@ namespace dbaui
         short nRet = RET_YES;
         if ( -1 != nApprovePos )
         {
-            // fragen, ob gespeichert werden soll
+            // ask whether it should be saved
             nRet = ExecuteQuerySaveDocument(NULL,_rDocuRequest.Name);
         }
 
diff --git a/dtrans/source/win32/dnd/target.cxx b/dtrans/source/win32/dnd/target.cxx
index bdc0b05..036ae96 100644
--- a/dtrans/source/win32/dnd/target.cxx
+++ b/dtrans/source/win32/dnd/target.cxx
@@ -624,5 +624,4 @@ inline sal_Int8 DropTarget::getFilteredActions( DWORD grfKeyState, DWORD dwEffec
     return actions &  m_nDefaultActions;
 }
 
-
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/editeng/source/editeng/editeng.cxx b/editeng/source/editeng/editeng.cxx
index 5a8f0a6..71c8593 100644
--- a/editeng/source/editeng/editeng.cxx
+++ b/editeng/source/editeng/editeng.cxx
@@ -17,7 +17,6 @@
  *   the License at http://www.apache.org/licenses/LICENSE-2.0 .
  */
 
-
 #include <vcl/wrkwin.hxx>
 #include <vcl/dialog.hxx>
 #include <vcl/msgbox.hxx>
@@ -94,9 +93,6 @@ static bool bDebugPaint = false;
 
 static SfxItemPool* pGlobalPool=0;
 
-// ----------------------------------------------------------------------
-// EditEngine
-// ----------------------------------------------------------------------
 EditEngine::EditEngine( SfxItemPool* pItemPool )
 {
     pImpEditEngine = new ImpEditEngine( this, pItemPool );
@@ -248,7 +244,7 @@ void EditEngine::Draw( OutputDevice* pOutDev, const Rectangle& rOutRect, const P
 #endif
 
     // Align to the pixel boundary, so that it becomes exactly the same
-    // as Paint ().
+    // as Paint ()
     Rectangle aOutRect( pOutDev->LogicToPixel( rOutRect ) );
     aOutRect = pOutDev->PixelToLogic( aOutRect );
 
diff --git a/filter/source/graphicfilter/epict/epict.cxx b/filter/source/graphicfilter/epict/epict.cxx
index 5a6e8df..a241382 100644
--- a/filter/source/graphicfilter/epict/epict.cxx
+++ b/filter/source/graphicfilter/epict/epict.cxx
@@ -38,8 +38,7 @@
 #include <basegfx/polygon/b2dpolygon.hxx>
 #include <basegfx/polygon/b2dpolypolygon.hxx>
 
-//============================== PictWriter ===================================
-
+// PictWriter
 struct PictWriterAttrStackMember {
     struct PictWriterAttrStackMember *  pSucc;
     Color                               aLineColor;
@@ -172,9 +171,7 @@ public:
 };
 
 
-//========================== Methods of PictWriter ==========================
-
-
+// Methods of PictWriter
 void PictWriter::MayCallback()
 {
     if ( xStatusIndicator.is() )
@@ -235,8 +232,7 @@ Polygon PictWriter::PolyPolygonToPolygon(const PolyPolygon & rPolyPoly)
     for (np=1; np<nCount; np++) {
         aPoly2=rPolyPoly.GetObject(np);
 
-        //-----------------The following code merges aPoly1 and aPoly2 to aPoly1-----------------
-
+        // The following code merges aPoly1 and aPoly2 to aPoly1
         nSize1=aPoly1.GetSize();
         nSize2=aPoly2.GetSize();
 
@@ -277,9 +273,6 @@ Polygon PictWriter::PolyPolygonToPolygon(const PolyPolygon & rPolyPoly)
         for (i2=0;         i2<=nBestIdx2; i2++) aPoly3.SetPoint(aPoly2.GetPoint(i2),i3++);
 
         aPoly1=aPoly3;
-
-        //-----------------------------------------------------------------------------------
-
     }
     return aPoly1;
 }
@@ -1150,13 +1143,12 @@ void PictWriter::WriteOpcode_BitsRect(const Point & rPoint, const Size & rSize,
         // allocate memory for a row:
         pPix = new sal_uInt8[ nSrcRowBytes ];
 
-        // Position der Map-Daten in Ziel merken:
+        // remember position of the map-data in the target:
         nDstMapPos=pPict->Tell();
 
         // loop trough rows:
         for ( ny = 0; ny < nHeight; ny++ )
         {
-
             // read line ny of source into the buffer:
             switch ( nBitsPerPixel )
             {
@@ -1600,7 +1592,7 @@ void PictWriter::WriteOpcodes( const GDIMetaFile & rMTF )
 
             case META_CHORD_ACTION:
             {
-//                OSL_FAIL( "Unsupported PICT-Action: META_CHORD_ACTION!" );
+                // OSL_FAIL( "Unsupported PICT-Action: META_CHORD_ACTION!" );
             }
             break;
 
@@ -1775,7 +1767,7 @@ void PictWriter::WriteOpcodes( const GDIMetaFile & rMTF )
 
             case META_TEXTRECT_ACTION:
             {
-//                OSL_FAIL( "Unsupported PICT-Action: META_TEXTRECT_ACTION!" );
+                // OSL_FAIL( "Unsupported PICT-Action: META_TEXTRECT_ACTION!" );
             }
             break;
 
@@ -1858,7 +1850,7 @@ void PictWriter::WriteOpcodes( const GDIMetaFile & rMTF )
             case META_MASKSCALE_ACTION:
             case META_MASKSCALEPART_ACTION:
             {
-//                OSL_FAIL( "Unsupported PICT-Action: META_MASK..._ACTION!" );
+                // OSL_FAIL( "Unsupported PICT-Action: META_MASK..._ACTION!" );
             }
             break;
 
@@ -1888,13 +1880,13 @@ void PictWriter::WriteOpcodes( const GDIMetaFile & rMTF )
 
             case META_WALLPAPER_ACTION:
             {
-//                OSL_FAIL( "Unsupported PICT-Action: META_WALLPAPER_ACTION!" );
+                // OSL_FAIL( "Unsupported PICT-Action: META_WALLPAPER_ACTION!" );
             }
             break;
 
             case META_CLIPREGION_ACTION:
             {
-//                OSL_FAIL( "Unsupported PICT-Action: META_CLIPREGION_ACTION!" );
+                // OSL_FAIL( "Unsupported PICT-Action: META_CLIPREGION_ACTION!" );
             }
             break;
 
@@ -1907,13 +1899,13 @@ void PictWriter::WriteOpcodes( const GDIMetaFile & rMTF )
 
             case META_ISECTREGIONCLIPREGION_ACTION:
             {
-//                OSL_FAIL( "Unsupported PICT-Action: META_ISECTREGIONCLIPREGION_ACTION!" );
+                // OSL_FAIL( "Unsupported PICT-Action: META_ISECTREGIONCLIPREGION_ACTION!" );
             }
             break;
 
             case META_MOVECLIPREGION_ACTION:
             {
-//                OSL_FAIL( "Unsupported PICT-Action: META_MOVECLIPREGION_ACTION!" );
+                // OSL_FAIL( "Unsupported PICT-Action: META_MOVECLIPREGION_ACTION!" );
             }
             break;
 
@@ -1959,7 +1951,7 @@ void PictWriter::WriteOpcodes( const GDIMetaFile & rMTF )
 
             case META_TEXTALIGN_ACTION:
             {
-//                OSL_FAIL( "Unsupported PICT-Action: META_TEXTALIGN_ACTION!" );
+                // OSL_FAIL( "Unsupported PICT-Action: META_TEXTALIGN_ACTION!" );
             }
             break;
 
@@ -2262,7 +2254,7 @@ sal_Bool PictWriter::WritePict(const GDIMetaFile & rMTF, SvStream & rTargetStrea
     return bStatus;
 }
 
-//================== GraphicExport - the exported Function ================
+// GraphicExport - the exported Function
 
 // this needs to be kept in sync with
 // ImpFilterLibCacheEntry::GetImportFunction() from
diff --git a/filter/source/graphicfilter/icgm/cgm.cxx b/filter/source/graphicfilter/icgm/cgm.cxx
index b2055b3..08e81ad 100644
--- a/filter/source/graphicfilter/icgm/cgm.cxx
+++ b/filter/source/graphicfilter/icgm/cgm.cxx
@@ -31,8 +31,6 @@
 
 using namespace ::com::sun::star;
 
-// ---------------------------------------------------------------
-
 void CGM::ImplCGMInit()
 {
     mbIsFinished = mbPicture = mbMetaFile = mbPictureBody = sal_False;
@@ -49,8 +47,6 @@ void CGM::ImplCGMInit()
     pElement = new CGMElements( *this );
 }
 
-// ---------------------------------------------------------------
-
 #ifdef CGM_EXPORT_IMPRESS
 
 CGM::CGM( sal_uInt32 nMode, uno::Reference< frame::XModel > & rModel )  :
@@ -64,8 +60,6 @@ CGM::CGM( sal_uInt32 nMode, uno::Reference< frame::XModel > & rModel )  :
 }
 #endif
 
-// ---------------------------------------------------------------
-
 CGM::~CGM()
 {
 
@@ -91,15 +85,11 @@ CGM::~CGM()
     delete [] mpBuf;
 };
 
-// ---------------------------------------------------------------
-
 sal_uInt32 CGM::GetBackGroundColor()
 {
     return ( pElement ) ? pElement->aColorTable[ 0 ] : 0;
 }
 
-// ---------------------------------------------------------------
-
 sal_uInt32 CGM::ImplGetUI16( sal_uInt32 /*nAlign*/ )
 {
     sal_uInt8* pSource = mpSource + mnParaSize;
@@ -107,15 +97,11 @@ sal_uInt32 CGM::ImplGetUI16( sal_uInt32 /*nAlign*/ )
     return ( pSource[ 0 ] << 8 ) +  pSource[ 1 ];
 };
 
-// ---------------------------------------------------------------
-
 sal_uInt8 CGM::ImplGetByte( sal_uInt32 nSource, sal_uInt32 nPrecision )
 {
     return (sal_uInt8)( nSource >> ( ( nPrecision - 1 ) << 3 ) );
 };
 
-// ---------------------------------------------------------------
-
 long CGM::ImplGetI( sal_uInt32 nPrecision )
 {
     sal_uInt8* pSource = mpSource + mnParaSize;
@@ -146,8 +132,6 @@ long CGM::ImplGetI( sal_uInt32 nPrecision )
     }
 }
 
-// ---------------------------------------------------------------
-
 sal_uInt32 CGM::ImplGetUI( sal_uInt32 nPrecision )
 {
     sal_uInt8* pSource = mpSource + mnParaSize;
@@ -174,8 +158,6 @@ sal_uInt32 CGM::ImplGetUI( sal_uInt32 nPrecision )
     }
 }
 
-// ---------------------------------------------------------------
-
 void CGM::ImplGetSwitch4( sal_uInt8* pSource, sal_uInt8* pDest )
 {
     for ( int i = 0; i < 4; i++ )
@@ -184,8 +166,6 @@ void CGM::ImplGetSwitch4( sal_uInt8* pSource, sal_uInt8* pDest )
     }
 }
 
-// ---------------------------------------------------------------
-
 void CGM::ImplGetSwitch8( sal_uInt8* pSource, sal_uInt8* pDest )
 {
     for ( int i = 0; i < 8; i++ )
@@ -194,8 +174,6 @@ void CGM::ImplGetSwitch8( sal_uInt8* pSource, sal_uInt8* pDest )
     }
 }
 
-// ---------------------------------------------------------------
-
 double CGM::ImplGetFloat( RealPrecision eRealPrecision, sal_uInt32 nRealSize )
 {
     void*   pPtr;
@@ -265,8 +243,6 @@ double CGM::ImplGetFloat( RealPrecision eRealPrecision, sal_uInt32 nRealSize )
     return nRetValue;
 }
 
-// ---------------------------------------------------------------
-
 sal_uInt32 CGM::ImplGetPointSize()
 {
     if ( pElement->eVDCType == VDC_INTEGER )
@@ -275,36 +251,26 @@ sal_uInt32 CGM::ImplGetPointSize()
         return pElement->nVDCRealSize << 1;
 }
 
-// ---------------------------------------------------------------
-
 inline double CGM::ImplGetIX()
 {
     return ( ( ImplGetI( pElement->nVDCIntegerPrecision ) + mnVDCXadd ) * mnVDCXmul );
 }
 
-// ---------------------------------------------------------------
-
 inline double CGM::ImplGetFX()
 {
     return ( ( ImplGetFloat( pElement->eVDCRealPrecision, pElement->nVDCRealSize ) + mnVDCXadd ) * mnVDCXmul );
 }
 
-// ---------------------------------------------------------------
-
 inline double CGM::ImplGetIY()
 {
     return ( ( ImplGetI( pElement->nVDCIntegerPrecision ) + mnVDCYadd ) * mnVDCYmul );
 }
 
-// ---------------------------------------------------------------
-
 inline double CGM::ImplGetFY()
 {
     return ( ( ImplGetFloat( pElement->eVDCRealPrecision, pElement->nVDCRealSize ) + mnVDCYadd ) * mnVDCYmul );
 }
 
-// ---------------------------------------------------------------
-
 void CGM::ImplGetPoint( FloatPoint& rFloatPoint, sal_Bool bMap )
 {
     if ( pElement->eVDCType == VDC_INTEGER )
@@ -321,8 +287,6 @@ void CGM::ImplGetPoint( FloatPoint& rFloatPoint, sal_Bool bMap )
         ImplMapPoint( rFloatPoint );
 }
 
-// ---------------------------------------------------------------
-
 void CGM::ImplGetRectangle( FloatRect& rFloatRect, sal_Bool bMap )
 {
     if ( pElement->eVDCType == VDC_INTEGER )
@@ -349,8 +313,6 @@ void CGM::ImplGetRectangle( FloatRect& rFloatRect, sal_Bool bMap )
     }
 }
 
-// ---------------------------------------------------------------
-
 void CGM::ImplGetRectangleNS( FloatRect& rFloatRect )
 {
     if ( pElement->eVDCType == VDC_INTEGER )
@@ -369,8 +331,6 @@ void CGM::ImplGetRectangleNS( FloatRect& rFloatRect )
     }
 }
 
-// ---------------------------------------------------------------
-
 sal_uInt32 CGM::ImplGetBitmapColor( sal_Bool bDirect )
 {
     // the background color is always a direct color
@@ -408,8 +368,6 @@ sal_uInt32 CGM::ImplGetBitmapColor( sal_Bool bDirect )
     return nTmp;
 }
 
-// ---------------------------------------------------------------
-
 // call this function each time after the mapmode settings has been changed
 void CGM::ImplSetMapMode()
 {
@@ -453,8 +411,6 @@ void CGM::ImplSetMapMode()
     }
 }
 
-// ---------------------------------------------------------------
-
 void CGM::ImplMapDouble( double& nNumb )
 {
     if ( pElement->eDeviceViewPortMap == DVPM_FORCED )
@@ -470,7 +426,7 @@ void CGM::ImplMapDouble( double& nNumb )
 
             case DVPM_METRIC :
             {
-//              nNumb *= ( 100 * pElement->nDeviceViewPortScale );
+                // nNumb *= ( 100 * pElement->nDeviceViewPortScale );
                 nNumb *= ( mnXFraction + mnYFraction ) / 2;
                 if ( pElement->nDeviceViewPortScale < 0 )
                     nNumb = -nNumb;
@@ -495,8 +451,6 @@ void CGM::ImplMapDouble( double& nNumb )
     }
 }
 
-// ---------------------------------------------------------------
-
 void CGM::ImplMapX( double& nNumb )
 {
     if ( pElement->eDeviceViewPortMap == DVPM_FORCED )
@@ -512,7 +466,7 @@ void CGM::ImplMapX( double& nNumb )
 
             case DVPM_METRIC :
             {
-//              nNumb *= ( 100 * pElement->nDeviceViewPortScale );
+                // nNumb *= ( 100 * pElement->nDeviceViewPortScale );
                 nNumb *= mnXFraction;
                 if ( pElement->nDeviceViewPortScale < 0 )
                     nNumb = -nNumb;
@@ -537,9 +491,6 @@ void CGM::ImplMapX( double& nNumb )
     }
 }
 
-
-// ---------------------------------------------------------------
-
 void CGM::ImplMapY( double& nNumb )
 {
     if ( pElement->eDeviceViewPortMap == DVPM_FORCED )
@@ -555,7 +506,7 @@ void CGM::ImplMapY( double& nNumb )
 
             case DVPM_METRIC :
             {
-//              nNumb *= ( 100 * pElement->nDeviceViewPortScale );
+                // nNumb *= ( 100 * pElement->nDeviceViewPortScale );
                 nNumb *= mnYFraction;
                 if ( pElement->nDeviceViewPortScale < 0 )
                     nNumb = -nNumb;
@@ -580,9 +531,6 @@ void CGM::ImplMapY( double& nNumb )
     }
 }
 
-
-// ---------------------------------------------------------------
-
 // convert a point to the current VC mapmode (1/100TH mm)
 void CGM::ImplMapPoint( FloatPoint& rFloatPoint )
 {
@@ -628,8 +576,6 @@ void CGM::ImplMapPoint( FloatPoint& rFloatPoint )
     }
 }
 
-// ---------------------------------------------------------------
-
 void CGM::ImplDoClass()
 {
 #ifdef CGM_USER_BREAKPOINT
@@ -662,8 +608,6 @@ void CGM::ImplDoClass()
     mnActCount++;
 };
 
-// ---------------------------------------------------------------
-
 void CGM::ImplDefaultReplacement()
 {
     if ( !maDefRepList.empty() )
@@ -709,8 +653,6 @@ void CGM::ImplDefaultReplacement()
     }
 }
 
-// ---------------------------------------------------------------
-
 sal_Bool CGM::Write( SvStream& rIStm )
 {
     if ( !mpBuf )
@@ -748,20 +690,13 @@ sal_Bool CGM::Write( SvStream& rIStm )
     return mbStatus;
 };
 
-// ---------------------------------------------------------------
-
 SvStream& operator>>( SvStream& rOStm, CGM& /*rCGM*/ )
 {
 
     return rOStm;
 };
 
-// ---------------------------------------------------------------
-
-
-
-//================== GraphicImport - the exported function ================
-
+// GraphicImport - the exported function
 extern "C" SAL_DLLPUBLIC_EXPORT sal_uInt32 SAL_CALL
 ImportCGM( OUString& rFileName, uno::Reference< frame::XModel > & rXModel, sal_uInt32 nMode, void* pProgressBar )
 {
diff --git a/filter/source/msfilter/escherex.cxx b/filter/source/msfilter/escherex.cxx
index a6423fc..27afb07 100644
--- a/filter/source/msfilter/escherex.cxx
+++ b/filter/source/msfilter/escherex.cxx
@@ -435,10 +435,10 @@ void EscherPropertyContainer::CreateGradientProperties(
     sal_uInt32  nFillFocus = 0;
     sal_uInt32  nFillLR = 0;
     sal_uInt32  nFillTB = 0;
-    sal_uInt32  nFirstColor = 0;//like the control var nChgColors in import logic
+    sal_uInt32  nFirstColor = 0;// like the control var nChgColors in import logic
     bool        bWriteFillTo = false;
 
-    //Transparency gradient: Means the third setting in transparency page is set
+    // Transparency gradient: Means the third setting in transparency page is set
     if (bTransparentGradient &&  EscherPropertyValueHelper::GetPropertyValue(
         aAny, rXPropSet, OUString( "FillTransparenceGradient" ), sal_False ) )
     {
@@ -452,7 +452,7 @@ void EscherPropertyContainer::CreateGradientProperties(
             ::com::sun::star::drawing::FillStyle eFS;
             if ( ! ( aAnyTemp >>= eFS ) )
                 eFS = ::com::sun::star::drawing::FillStyle_SOLID;
-            //solid and transparency
+            // solid and transparency
             if ( eFS == ::com::sun::star::drawing::FillStyle_SOLID)
             {
                 if ( EscherPropertyValueHelper::GetPropertyValue(
@@ -462,7 +462,7 @@ void EscherPropertyContainer::CreateGradientProperties(
                     pGradient->EndColor = ImplGetColor( *((sal_uInt32*)aAnyTemp.getValue()), sal_False );
                 }
             }
-            //gradient and transparency.
+            // gradient and transparency.
             else if( eFS == ::com::sun::star::drawing::FillStyle_GRADIENT )
             {
                 if ( EscherPropertyValueHelper::GetPropertyValue(
@@ -472,7 +472,7 @@ void EscherPropertyContainer::CreateGradientProperties(
         }
 
     }
-    //Not transparency gradient
+    // Not transparency gradient
     else if ( EscherPropertyValueHelper::GetPropertyValue(
         aAny, rXPropSet, OUString( "FillGradient" ), sal_False ) )
     {
@@ -490,7 +490,7 @@ void EscherPropertyContainer::CreateGradientProperties(
                 nAngle = pGradient->Angle;
                 while ( nAngle > 0 ) nAngle -= 3600;
                 while ( nAngle <= -3600 ) nAngle += 3600;
-                //Value of the real number = Integral + (Fractional / 65536.0)
+                // Value of the real number = Integral + (Fractional / 65536.0)
                 nAngle = ( nAngle * 0x10000) / 10;
 
                 nFillFocus = (pGradient->Style == ::com::sun::star::awt::GradientStyle_LINEAR) ?
@@ -506,7 +506,7 @@ void EscherPropertyContainer::CreateGradientProperties(
         case ::com::sun::star::awt::GradientStyle_SQUARE :
         case ::com::sun::star::awt::GradientStyle_RECT :
             {
-                //according to the import logic and rect type fill** value
+                // according to the import logic and rect type fill** value
                 nFillLR = (pGradient->XOffset * 0x10000) / 100;
                 nFillTB = (pGradient->YOffset * 0x10000) / 100;
                 if ( ((nFillLR > 0) && (nFillLR < 0x10000)) || ((nFillTB > 0) && (nFillTB < 0x10000)) )
@@ -528,7 +528,7 @@ void EscherPropertyContainer::CreateGradientProperties(
     AddOpt( ESCHER_Prop_fillFocus, nFillFocus );
     if ( bWriteFillTo )
     {
-        //according to rect type fillTo** value
+        // according to rect type fillTo** value
         if(nFillLR)
         {
             AddOpt( ESCHER_Prop_fillToLeft, nFillLR );
@@ -541,7 +541,7 @@ void EscherPropertyContainer::CreateGradientProperties(
         }
     }
 
-    //Transparency gradient
+    // Transparency gradient
     if (bTransparentGradient &&  EscherPropertyValueHelper::GetPropertyValue(
         aAny, rXPropSet, OUString( "FillTransparenceGradient" ), sal_False ) )
     {
@@ -566,7 +566,7 @@ void    EscherPropertyContainer::CreateFillProperties(
         if ( pObj )
         {
             SfxItemSet aAttr( pObj->GetMergedItemSet() );
-            //tranparency with gradient. Means the third setting in transparency page is set
+            // tranparency with gradient. Means the third setting in transparency page is set
             sal_Bool bTransparentGradient =  ( aAttr.GetItemState( XATTR_FILLFLOATTRANSPARENCE ) == SFX_ITEM_SET ) &&
                 ( (const XFillFloatTransparenceItem&) aAttr.Get( XATTR_FILLFLOATTRANSPARENCE ) ).IsEnabled();
             CreateFillProperties(  rXPropSet, bEdge, bTransparentGradient );
@@ -693,7 +693,7 @@ void EscherPropertyContainer::CreateTextProperties(
 
 // i63936 not setting autogrowheight, because otherwise
 // the minframeheight of the text will be ignored
-//
+// 
 //      if ( EscherPropertyValueHelper::GetPropertyValue( aAny, rXPropSet, "TextAutoGrowHeight", sal_True ) )
 //          aAny >>= bAutoGrowHeight;
     }
@@ -880,9 +880,7 @@ sal_Bool EscherPropertyContainer::GetLineArrow( const sal_Bool bLineStart,
                 if ( !aApiName.isEmpty() )
                 {
 
-                    /* todo:
-                    calculate the best option for ArrowLength and ArrowWidth
-                    */
+                    // TODO: calculate the best option for ArrowLength and ArrowWidth
                     if ( aApiName == "Arrow concave" )
                         reLineEnd = ESCHER_LineArrowStealthEnd;
                     else if ( aApiName == "Square 45" )
@@ -1610,7 +1608,7 @@ sal_Bool EscherPropertyContainer::CreateGraphicProperties(
 
                         if ( nErrCode == ERRCODE_NONE )
                         {
-                            // no.
+                            // no
                             aGraphicObject = aGraphic;
                             aUniqueId = aGraphicObject.GetUniqueID();
                         }
@@ -2195,9 +2193,8 @@ sal_Int32 lcl_GetAdjustValueCount( const XPolygon& rPoly )
     }
     return nRet;
 }
-/*
- Adjust value decide the position which connector should turn a corner
-*/
+
+// Adjust value decide the position which connector should turn a corner
 sal_Int32 lcl_GetConnectorAdjustValue ( const XPolygon& rPoly, sal_uInt16 nIndex )
 {
     sal_uInt16 k =  rPoly.GetSize();
@@ -2212,7 +2209,7 @@ sal_Int32 lcl_GetConnectorAdjustValue ( const XPolygon& rPoly, sal_uInt16 nIndex
         aEnd.X() = aStart.X() +4;
 
     sal_Bool bVertical = ( rPoly[1].X()-aStart.X() ) == 0 ;
-    //vertical and horizon alternate
+    // vertical and horizon alternate
     if ( nIndex%2 == 1 ) bVertical = !bVertical;
     aPt = rPoly[ nIndex + 1];
 
@@ -2306,7 +2303,7 @@ sal_Bool lcl_GetAngle(Polygon &rPoly,sal_uInt16& rShapeFlags,sal_Int32& nAngle )
         // Set angle properties
         nAngle *= 655;
         nAngle += 0x8000;
-        nAngle &=~0xffff;                                  // nAngle auf volle Gradzahl runden
+        nAngle &=~0xffff;                                  // round nAngle to whole number of degrees
         return sal_True;
     }
     return sal_False;
@@ -2348,7 +2345,7 @@ sal_Bool EscherPropertyContainer::CreateConnectorProperties(
                         rShapeFlags = SHAPEFLAG_HAVEANCHOR | SHAPEFLAG_HAVESPT | SHAPEFLAG_CONNECTOR;
                         rGeoRect = ::com::sun::star::awt::Rectangle( aStartPoint.X, aStartPoint.Y,
                                                             ( aEndPoint.X - aStartPoint.X ) + 1, ( aEndPoint.Y - aStartPoint.Y ) + 1 );
-                        //set standard's FLIP in below code
+                        // set standard's FLIP in below code
                         if ( eCt != ::com::sun::star::drawing::ConnectorType_STANDARD)
                         {
                             if ( rGeoRect.Height < 0 )          // justify
@@ -2646,7 +2643,7 @@ sal_Bool EscherPropertyContainer::IsDefaultObject( SdrObjCustomShape* pCustoShap
     sal_Bool bIsDefaultObject = sal_False;
     switch(eShapeType)
     {
-        //if the custom shape is not default shape of ppt, return sal_Fasle;
+        // if the custom shape is not default shape of ppt, return sal_Fasle;
         case mso_sptTearDrop:
             return bIsDefaultObject;
 
@@ -3562,7 +3559,7 @@ void EscherPropertyContainer::CreateCustomShapeProperties( const MSO_SPT eShapeT
                                         nTextPathFlags &=~0x20;
                                 }
                             }
-                            //export gTextAlign attr
+                            // export gTextAlign attr
                             if ( EscherPropertyValueHelper::GetPropertyValue( aAny, aXPropSet, "TextHorizontalAdjust", sal_True ) )
                             {
                                 MSO_GeoTextAlign  gTextAlign = mso_alignTextCenter;
@@ -3598,7 +3595,7 @@ void EscherPropertyContainer::CreateCustomShapeProperties( const MSO_SPT eShapeT
                                 AddOpt(DFF_Prop_gtextAlign,gTextAlign);
                             }
                         }
-                        if((nTextPathFlags & 0x4000) != 0)  //Is Font work
+                        if((nTextPathFlags & 0x4000) != 0)  // Is Font work
                         {
                             OutlinerParaObject* pOutlinerParaObject = pCustoShape->GetOutlinerParaObject();
                             if ( pOutlinerParaObject && pOutlinerParaObject->IsVertical() )
@@ -3917,7 +3914,7 @@ MSO_SPT EscherPropertyContainer::GetCustomShapeType( const uno::Reference< drawi
     return GetCustomShapeType( rXShape, nMirrorFlags, aShapeType );
 }
 
-//Implement for form control export
+// Implement for form control export
 sal_Bool   EscherPropertyContainer::CreateBlipPropertiesforOLEControl(const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rXPropSet, const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > & rXShape)
 {
     SdrObject* pShape = GetSdrObjectFromXShape( rXShape );
@@ -4583,7 +4580,7 @@ sal_uInt32 EscherConnectorListEntry::GetClosestPoint( const Polygon& rPoly, cons
 
 // ---------------------------------------------------------------------------------------------
 // for rectangles          for ellipses     for polygons
-//
+// 
 // nRule =  0 ->Top         0 ->Top         nRule = Index auf ein (Poly)Polygon Punkt
 //          1 ->Left        2 ->Left
 //          2 ->Bottom      4 ->Bottom
@@ -4856,8 +4853,8 @@ void EscherSolverContainer::WriteSolver( SvStream& rStrm )
     {
         sal_uInt32  nRecHdPos, nCurrentPos, nSize;
         rStrm  .WriteUInt16( (sal_uInt16)( ( nCount << 4 ) | 0xf ) )    // open an ESCHER_SolverContainer
-               .WriteUInt16( (sal_uInt16)ESCHER_SolverContainer )       //
-               .WriteUInt32( (sal_uInt32)0 );                           //
+               .WriteUInt16( (sal_uInt16)ESCHER_SolverContainer )       // 
+               .WriteUInt32( (sal_uInt32)0 );                           // 
 
         nRecHdPos = rStrm.Tell() - 4;
 
@@ -4879,7 +4876,7 @@ void EscherSolverContainer::WriteSolver( SvStream& rStrm )
                     aConnectorRule.ncptiB = pPtr->GetConnectorRule( sal_False );
             }
             rStrm  .WriteUInt32( (sal_uInt32)( ( ESCHER_ConnectorRule << 16 ) | 1 ) )   // atom hd
-                   .WriteUInt32( (sal_uInt32)24 )                                       //
+                   .WriteUInt32( (sal_uInt32)24 )                                       // 
                    .WriteUInt32( aConnectorRule.nRuleId )
                    .WriteUInt32( aConnectorRule.nShapeA )
                    .WriteUInt32( aConnectorRule.nShapeB )
@@ -4891,10 +4888,10 @@ void EscherSolverContainer::WriteSolver( SvStream& rStrm )
         }
 
         nCurrentPos = rStrm.Tell();             // close the ESCHER_SolverContainer
-        nSize = ( nCurrentPos - nRecHdPos ) - 4;//
-        rStrm.Seek( nRecHdPos );                //
-        rStrm.WriteUInt32( nSize );                         //
-        rStrm.Seek( nCurrentPos );              //
+        nSize = ( nCurrentPos - nRecHdPos ) - 4;// 
+        rStrm.Seek( nRecHdPos );                // 
+        rStrm.WriteUInt32( nSize );                         // 
+        rStrm.Seek( nCurrentPos );              // 
     }
 }
 
@@ -5022,11 +5019,11 @@ SvStream* EscherExGlobal::ImplQueryPictureStream()
     return 0;
 }
 
-/// Implementation of an empty stream that silently succeeds, but does nothing.
-///
-/// In fact, this is a hack.  The right solution is to abstract EscherEx to be
-/// able to work without SvStream; but at the moment it is better to live with
-/// this I guess.
+// /Implementation of an empty stream that silently succeeds, but does nothing.
+// /
+// /In fact, this is a hack.  The right solution is to abstract EscherEx to be
+// /able to work without SvStream; but at the moment it is better to live with
+// /this I guess.
 class SvNullStream : public SvStream
 {
 protected:
diff --git a/filter/source/msfilter/util.cxx b/filter/source/msfilter/util.cxx
index abd50ef..246368f 100644
--- a/filter/source/msfilter/util.cxx
+++ b/filter/source/msfilter/util.cxx
@@ -20,8 +20,8 @@ namespace util {
 
 rtl_TextEncoding getBestTextEncodingFromLocale(const ::com::sun::star::lang::Locale &rLocale)
 {
-    //Obviously not comprehensive, feel free to expand these, they're for ultimate fallbacks
-    //in last-ditch broken-file-format cases to guess the right 8bit encodings
+    // Obviously not comprehensive, feel free to expand these, they're for ultimate fallbacks
+    // in last-ditch broken-file-format cases to guess the right 8bit encodings
     const OUString &rLanguage = rLocale.Language;
     if (rLanguage == "cs" || rLanguage == "hu" || rLanguage == "pl")
         return RTL_TEXTENCODING_MS_1250;
@@ -358,7 +358,7 @@ sal_Int32 PaperSizeConv::getMSPaperSizeIndex( const com::sun::star::awt::Size& r
     {
         sal_Int32 nCurDeltaHeight = std::abs( pItem->mnHeight - rSize.Height );
         sal_Int32 nCurDeltaWidth = std::abs( pItem->mnWidth - rSize.Width );
-        if ( pItem == spPaperSizeTable ) // initialise delta with first item
+        if ( pItem == spPaperSizeTable ) // initialize delta with first item
         {
             nDeltaWidth = nCurDeltaWidth;
             nDeltaHeight = nCurDeltaHeight;
@@ -412,10 +412,9 @@ WW8ReadFieldParams::WW8ReadFieldParams( const OUString& _rData )
     , nNext( 0 )
     , nSavPtr( 0 )
 {
+
     /*
-        erstmal nach einer oeffnenden Klammer oder einer Leerstelle oder einem
-        Anfuehrungszeichen oder einem Backslash suchen, damit der Feldbefehl
-        (also INCLUDEPICTURE bzw EINFUeGENGRAFIK bzw ...) ueberlesen wird
+        First look for an opening bracket or a space or a quatation mark or a backslash, so that the field (i.e. INCLUDEPICTURE or EINFUEGENGRAFIK or...) gets oread over
     */
     const sal_Int32 nLen = aData.getLength();
 
@@ -461,7 +460,7 @@ bool WW8ReadFieldParams::GoToTokenParam()
     return false;
 }
 
-// ret: -2: NOT a '\' parameter but normal Text
+// ret: -2: NOT a '\' parameter but normal text
 sal_Int32 WW8ReadFieldParams::SkipToNextToken()
 {
     if ( nNext<0 || nNext>=aData.getLength() )
@@ -476,7 +475,7 @@ sal_Int32 WW8ReadFieldParams::SkipToNextToken()
     if (nFnd+1<aData.getLength() && aData[nFnd+1]!='\\' && aData[nFnd]=='\\')
     {
         const sal_Int32 nRet = aData[++nFnd];
-        nNext = ++nFnd;             // und dahinter setzen
+        nNext = ++nFnd;             // and set after
         return nRet;
     }
 
@@ -487,22 +486,22 @@ sal_Int32 WW8ReadFieldParams::SkipToNextToken()
     return -2;
 }
 
-// FindNextPara sucht naechsten Backslash-Parameter oder naechste Zeichenkette
-// bis zum Blank oder naechsten "\" oder zum schliessenden Anfuehrungszeichen
-// oder zum String-Ende von pStr.
-//
-// Ausgabe ppNext (falls ppNext != 0) Suchbeginn fuer naechsten Parameter bzw. 0
-//
-// Returnwert: 0 falls String-Ende erreicht,
+// FindNextPara searches the next backslash parameter or the next string
+// until the next blank or "\" or closing quatation mark
+// or the end of the string of pStr.
+// 
+// Output ppNext (if ppNext != 0) Suchbeginn fuer naechsten Parameter bzw. 0
+// 
+// Return value: 0 if end of string reached,
 //             ansonsten Anfang des Paramters bzw. der Zeichenkette
-//
+// 
 sal_Int32 WW8ReadFieldParams::FindNextStringPiece(const sal_Int32 nStart)
 {
     const sal_Int32 nLen = aData.getLength();
-    sal_Int32  n = nStart<0  ? nFnd : nStart;  // Anfang
-    sal_Int32 n2;          // Ende
+    sal_Int32  n = nStart<0  ? nFnd : nStart;  // start
+    sal_Int32 n2;          // end
 
-    nNext = -1;        // Default fuer nicht gefunden
+    nNext = -1;        // if not found -> Default
 
     while ( n<nLen && aData[n]==' ' )
         ++n;
@@ -519,36 +518,36 @@ sal_Int32 WW8ReadFieldParams::FindNextStringPiece(const sal_Int32 nStart)
             return -1;
     }
 
-    // Anfuehrungszeichen vor Para?
+    // quotation marks before paragraph?
     if ( aData[n]=='"' || aData[n]==0x201c || aData[n]==132 || aData[n]==0x14 )
     {
-        n++;                        // Anfuehrungszeichen ueberlesen
-        n2 = n;                     // ab hier nach Ende suchen
+        n++;                        // read over quatation marks
+        n2 = n;                     // search for the end from here on
         while(     (nLen > n2)
                 && (aData[n2] != '"')
                 && (aData[n2] != 0x201d)
                 && (aData[n2] != 147)
                 && (aData[n2] != 0x15) )
-            n2++;                   // Ende d. Paras suchen
+            n2++;                   // search for the end of the paragraph
     }
-    else                        // keine Anfuehrungszeichen
+    else                        // no quotation mark
     {
-        n2 = n;                     // ab hier nach Ende suchen
-        while ( n2<nLen && aData[n2]!=' ' ) // Ende d. Paras suchen
+        n2 = n;                     // search for the end from here on
+        while ( n2<nLen && aData[n2]!=' ' ) // search for the end of the paragraph
         {
             if ( aData[n2]=='\\' )
             {
                 if ( n2+1<nLen && aData[n2+1]=='\\' )
-                    n2 += 2;        // Doppel-Backslash -> OK
+                    n2 += 2;        // double backslash -> OK
                 else
                 {
                     if( n2 > n )
                         n2--;
-                    break;          // einfach-Backslash -> Ende
+                    break;          // single backslash -> end
                 }
             }
             else
-                n2++;               // kein Backslash -> OK
+                n2++;               // no backslash -> OK
         }
     }
     if( nLen > n2 )
@@ -622,8 +621,8 @@ EquationResult Read_SubF_Combined(WW8ReadFieldParams& rReadParam)
                                 OUString sPart = rReadParam.GetResult();
                                 sal_Int32 nBegin = sPart.indexOf('(');
 
-                                //Word disallows brackets in this field, which
-                                //aids figuring out the case of an end of )) vs )
+                                // Word disallows brackets in this field, which
+                                // aids figuring out the case of an end of )) vs )
                                 sal_Int32 nEnd = sPart.indexOf(')');
 
                                 if (nBegin != -1 && nEnd != -1)
diff --git a/forms/source/component/FormComponent.cxx b/forms/source/component/FormComponent.cxx
index e77b677..1e54868 100644
--- a/forms/source/component/FormComponent.cxx
+++ b/forms/source/component/FormComponent.cxx
@@ -16,15 +16,12 @@
  *   except in compliance with the License. You may obtain a copy of
  *   the License at http://www.apache.org/licenses/LICENSE-2.0 .
  */
-
-
 #include "componenttools.hxx"
 #include "FormComponent.hxx"
 #include "frm_resource.hrc"
 #include "frm_resource.hxx"
 #include "property.hrc"
 #include "services.hxx"
-
 #include <com/sun/star/awt/XTextComponent.hpp>
 #include <com/sun/star/awt/XVclWindowPeer.hpp>
 #include <com/sun/star/awt/XWindow.hpp>
@@ -37,7 +34,6 @@
 #include <com/sun/star/sdbc/ColumnValue.hpp>
 #include <com/sun/star/sdbc/DataType.hpp>
 #include <com/sun/star/util/XModifyBroadcaster.hpp>
-
 #include <comphelper/basicio.hxx>
 #include <comphelper/guarding.hxx>
 #include <comphelper/listenernotification.hxx>
@@ -48,16 +44,10 @@
 #include <toolkit/helper/emptyfontdescriptor.hxx>
 #include <tools/debug.hxx>
 #include <tools/diagnose_ex.h>
-
 #include <functional>
 #include <algorithm>
-
-
-//... namespace frm .......................................................
 namespace frm
 {
-//.........................................................................
-
     using namespace ::com::sun::star::uno;
     using namespace ::com::sun::star::sdb;
     using namespace ::com::sun::star::sdbc;
@@ -73,17 +63,11 @@ namespace frm
     using namespace ::com::sun::star::form::validation;
     using namespace ::dbtools;
     using namespace ::comphelper;
-
-    //=========================================================================
-    //= FieldChangeNotifier
-    //=========================================================================
-    //-------------------------------------------------------------------------
+    // FieldChangeNotifier
     void ControlModelLock::impl_notifyAll_nothrow()
     {
         m_rModel.firePropertyChanges( m_aHandles, m_aOldValues, m_aNewValues, OControlModel::LockAccess() );
     }
-
-    //-------------------------------------------------------------------------
     void ControlModelLock::addPropertyNotification( const sal_Int32 _nHandle, const Any& _rOldValue, const Any& _rNewValue )
     {
         sal_Int32 nOldLength = m_aHandles.getLength();
@@ -91,7 +75,6 @@ namespace frm
             ||  ( nOldLength != m_aNewValues.getLength() )
             )
             throw RuntimeException( OUString(), m_rModel );
-
         m_aHandles.realloc( nOldLength + 1 );
         m_aHandles[ nOldLength ] = _nHandle;
         m_aOldValues.realloc( nOldLength + 1 );
@@ -99,11 +82,6 @@ namespace frm
         m_aNewValues.realloc( nOldLength + 1 );
         m_aNewValues[ nOldLength ] = _rNewValue;
     }
-
-    //=========================================================================
-    //= FieldChangeNotifier
-    //=========================================================================
-    //-------------------------------------------------------------------------
     class FieldChangeNotifier
     {
     public:
@@ -113,2972 +91,2522 @@ namespace frm
         {
             m_xOldField = m_rModel.getField();
         }
-
         ~FieldChangeNotifier()
         {
             Reference< XPropertySet > xNewField( m_rModel.getField() );
             if ( m_xOldField != xNewField )
                 m_rLock.addPropertyNotification( PROPERTY_ID_BOUNDFIELD, makeAny( m_xOldField ), makeAny( xNewField ) );
         }
-
     private:
         ControlModelLock&           m_rLock;
         OBoundControlModel&         m_rModel;
         Reference< XPropertySet >   m_xOldField;
     };
-
-//=============================================================================
-//= base class for form layer controls
-//=============================================================================
-//------------------------------------------------------------------------------
-OControl::OControl( const Reference< XComponentContext >& _rxContext, const OUString& _rAggregateService, const sal_Bool _bSetDelegator )
-            :OComponentHelper(m_aMutex)
-            ,m_xContext( _rxContext )
-{
-    // VCL-Control aggregieren
-    // bei Aggregation den Refcount um eins erhoehen da im setDelegator
-    // das Aggregat selbst den Refcount erhoeht
-    increment( m_refCount );
+    // base class for form layer controls
+    OControl::OControl( const Reference< XComponentContext >& _rxContext, const OUString& _rAggregateService, const sal_Bool _bSetDelegator )
+                :OComponentHelper(m_aMutex)
+                ,m_xContext( _rxContext )
+    {
+        // aggregate VCL-Control
+        // bei Aggregation den Refcount um eins erhoehen da im setDelegator
+        // das Aggregat selbst den Refcount erhoeht
+        increment( m_refCount );
+        {
+            m_xAggregate = m_xAggregate.query( _rxContext->getServiceManager()->createInstanceWithContext(_rAggregateService, _rxContext) );
+            m_xControl = m_xControl.query( m_xAggregate );
+        }
+        decrement( m_refCount );
+        if ( _bSetDelegator )
+            doSetDelegator();
+    }
+    OControl::~OControl()
     {
-        m_xAggregate = m_xAggregate.query( _rxContext->getServiceManager()->createInstanceWithContext(_rAggregateService, _rxContext) );
-        m_xControl = m_xControl.query( m_xAggregate );
+        doResetDelegator();
     }
-    decrement( m_refCount );
-
-    if ( _bSetDelegator )
-        doSetDelegator();
-}
-
-//------------------------------------------------------------------------------
-OControl::~OControl()
-{
-    doResetDelegator();
-}
-
-//------------------------------------------------------------------------------
-void OControl::doResetDelegator()
-{
-    if ( m_xAggregate.is() )
-        m_xAggregate->setDelegator( NULL );
-}
-
-//------------------------------------------------------------------------------
-void OControl::doSetDelegator()
-{
-    increment( m_refCount );
-    if ( m_xAggregate.is() )
-    {   // those brackets are important for some compilers, don't remove!
-        // (they ensure that the temporary object created in the line below
-        // is destroyed *before* the refcount-decrement)
-        m_xAggregate->setDelegator( static_cast< XWeak* >( this ) );
-    }
-    decrement( m_refCount );
-}
-
-// UNO Anbindung
-//------------------------------------------------------------------------------
-Any SAL_CALL OControl::queryAggregation( const Type& _rType ) throw(RuntimeException)
-{
-    // ask the base class
-    Any aReturn( OComponentHelper::queryAggregation(_rType) );
-    // ask our own interfaces
-    if (!aReturn.hasValue())
+    void OControl::doResetDelegator()
     {
-        aReturn = OControl_BASE::queryInterface(_rType);
-        // ask our aggregate
-        if (!aReturn.hasValue() && m_xAggregate.is())
-            aReturn = m_xAggregate->queryAggregation(_rType);
+        if ( m_xAggregate.is() )
+            m_xAggregate->setDelegator( NULL );
     }
-
-    return aReturn;
-}
-
-//------------------------------------------------------------------------------
-Sequence<sal_Int8> SAL_CALL OControl::getImplementationId() throw(RuntimeException)
-{
-    return OImplementationIds::getImplementationId(getTypes());
-}
-
-//------------------------------------------------------------------------------
-Sequence<Type> SAL_CALL OControl::getTypes() throw(RuntimeException)
-{
-    TypeBag aTypes( _getTypes() );
-
-    Reference< XTypeProvider > xProv;
-    if ( query_aggregation( m_xAggregate, xProv ) )
-        aTypes.addTypes( xProv->getTypes() );
-
-    return aTypes.getTypes();
-}
-
-//------------------------------------------------------------------------------
-Sequence<Type> OControl::_getTypes()
-{
-    return TypeBag( OComponentHelper::getTypes(), OControl_BASE::getTypes() ).getTypes();
-}
-
-//------------------------------------------------------------------------------
-void OControl::initFormControlPeer( const Reference< XWindowPeer >& /*_rxPeer*/ )
-{
-    // nothing to do here
-}
-
-// OComponentHelper
-void OControl::disposing()
-{
-    OComponentHelper::disposing();
-
-    m_aWindowStateGuard.attach( NULL, NULL );
-
-    Reference< XComponent > xComp;
-    if (query_aggregation(m_xAggregate, xComp))
-        xComp->dispose();
-}
-
-// XServiceInfo
-sal_Bool SAL_CALL OControl::supportsService(const OUString& _rsServiceName) throw ( RuntimeException)
-{
-    return cppu::supportsService(this, _rsServiceName);
-}
-
-Sequence< OUString > OControl::getAggregateServiceNames()
-{
-    Sequence< OUString > aAggServices;
-    Reference< XServiceInfo > xInfo;
-    if ( query_aggregation( m_xAggregate, xInfo ) )
-        aAggServices = xInfo->getSupportedServiceNames();
-    return aAggServices;
-}
-
-Sequence<OUString> SAL_CALL OControl::getSupportedServiceNames() throw(RuntimeException)
-{
-    return ::comphelper::concatSequences(
-        getAggregateServiceNames(),
-        getSupportedServiceNames_Static()
-   );
-}
-
-//------------------------------------------------------------------------------
-Sequence< OUString > SAL_CALL OControl::getSupportedServiceNames_Static() throw( RuntimeException )
-{
-    // no own supported service names
-    return Sequence< OUString >();
-}
-
-// XEventListener
-//------------------------------------------------------------------------------
-void SAL_CALL OControl::disposing(const com::sun::star::lang::EventObject& _rEvent) throw (RuntimeException)
-{
-    Reference< XInterface > xAggAsIface;
-    query_aggregation(m_xAggregate, xAggAsIface);
-
-    // does the disposing come from the aggregate ?
-    if (xAggAsIface != Reference< XInterface >(_rEvent.Source, UNO_QUERY))
-    {   // no -> forward it
-                Reference<com::sun::star::lang::XEventListener> xListener;
-        if (query_aggregation(m_xAggregate, xListener))
-            xListener->disposing(_rEvent);
+    void OControl::doSetDelegator()
+    {
+        increment( m_refCount );
+        if ( m_xAggregate.is() )
+        {   // those brackets are important for some compilers, don't remove!
+            // (they ensure that the temporary object created in the line below
+            // is destroyed *before* the refcount-decrement)
+            m_xAggregate->setDelegator( static_cast< XWeak* >( this ) );
+        }
+        decrement( m_refCount );
     }
-}
 
-// XControl
-//------------------------------------------------------------------------------
-void SAL_CALL OControl::setContext(const Reference< XInterface >& Context) throw (RuntimeException)
-{
-    if (m_xControl.is())
-        m_xControl->setContext(Context);
-}
+    // UNO Anbindung
+    Any SAL_CALL OControl::queryAggregation( const Type& _rType ) throw(RuntimeException)
+    {
+        // ask the base class
+        Any aReturn( OComponentHelper::queryAggregation(_rType) );
+        // ask our own interfaces
+        if (!aReturn.hasValue())
+        {
+            aReturn = OControl_BASE::queryInterface(_rType);
+            // ask our aggregate
+            if (!aReturn.hasValue() && m_xAggregate.is())
+                aReturn = m_xAggregate->queryAggregation(_rType);
+        }
+        return aReturn;
+    }
+    Sequence<sal_Int8> SAL_CALL OControl::getImplementationId() throw(RuntimeException)
+    {
+        return OImplementationIds::getImplementationId(getTypes());
+    }
+    Sequence<Type> SAL_CALL OControl::getTypes() throw(RuntimeException)
+    {
+        TypeBag aTypes( _getTypes() );
+        Reference< XTypeProvider > xProv;
+        if ( query_aggregation( m_xAggregate, xProv ) )
+            aTypes.addTypes( xProv->getTypes() );
+        return aTypes.getTypes();
+    }
+    Sequence<Type> OControl::_getTypes()
+    {
+        return TypeBag( OComponentHelper::getTypes(), OControl_BASE::getTypes() ).getTypes();
+    }
+    void OControl::initFormControlPeer( const Reference< XWindowPeer >& /*_rxPeer*/ )
+    {
+        // nothing to do here
+    }
 
-//------------------------------------------------------------------------------
-Reference< XInterface > SAL_CALL OControl::getContext() throw (RuntimeException)
-{
-    return m_xControl.is() ? m_xControl->getContext() : Reference< XInterface >();
-}
+    // OComponentHelper
+    void OControl::disposing()
+    {
+        OComponentHelper::disposing();
+        m_aWindowStateGuard.attach( NULL, NULL );
+        Reference< XComponent > xComp;
+        if (query_aggregation(m_xAggregate, xComp))
+            xComp->dispose();
+    }
 
-//------------------------------------------------------------------------------
-void OControl::impl_resetStateGuard_nothrow()
-{
-    Reference< XWindow2 > xWindow;
-    Reference< XControlModel > xModel;
-    try
+    // XServiceInfo
+    sal_Bool SAL_CALL OControl::supportsService(const OUString& _rsServiceName) throw ( RuntimeException)
     {
-        xWindow.set( getPeer(), UNO_QUERY );
-        xModel.set( getModel(), UNO_QUERY );
+        return cppu::supportsService(this, _rsServiceName);
     }
-    catch( const Exception& )
+    Sequence< OUString > OControl::getAggregateServiceNames()
     {
-        DBG_UNHANDLED_EXCEPTION();
+        Sequence< OUString > aAggServices;
+        Reference< XServiceInfo > xInfo;
+        if ( query_aggregation( m_xAggregate, xInfo ) )
+            aAggServices = xInfo->getSupportedServiceNames();
+        return aAggServices;
     }
-    m_aWindowStateGuard.attach( xWindow, xModel );
-}
-
-//------------------------------------------------------------------------------
-void SAL_CALL OControl::createPeer(const Reference<XToolkit>& _rxToolkit, const Reference<XWindowPeer>& _rxParent) throw (RuntimeException)
-{
-    if ( m_xControl.is() )
+    Sequence<OUString> SAL_CALL OControl::getSupportedServiceNames() throw(RuntimeException)
+    {
+        return ::comphelper::concatSequences(
+            getAggregateServiceNames(),
+            getSupportedServiceNames_Static()
+       );
+    }
+    Sequence< OUString > SAL_CALL OControl::getSupportedServiceNames_Static() throw( RuntimeException )
     {
-        m_xControl->createPeer( _rxToolkit, _rxParent );
+        // no own supported service names
+        return Sequence< OUString >();
+    }
 
-        initFormControlPeer( getPeer() );
+    // XEventListener
+    void SAL_CALL OControl::disposing(const com::sun::star::lang::EventObject& _rEvent) throw (RuntimeException)
+    {
+        Reference< XInterface > xAggAsIface;
+        query_aggregation(m_xAggregate, xAggAsIface);
+        // does the disposing come from the aggregate ?
+        if (xAggAsIface != Reference< XInterface >(_rEvent.Source, UNO_QUERY))
+        {   // no -> forward it
+                    Reference<com::sun::star::lang::XEventListener> xListener;
+            if (query_aggregation(m_xAggregate, xListener))
+                xListener->disposing(_rEvent);
+        }
+    }
 
+    // XControl
+    void SAL_CALL OControl::setContext(const Reference< XInterface >& Context) throw (RuntimeException)
+    {
+        if (m_xControl.is())
+            m_xControl->setContext(Context);
+    }
+    Reference< XInterface > SAL_CALL OControl::getContext() throw (RuntimeException)
+    {
+        return m_xControl.is() ? m_xControl->getContext() : Reference< XInterface >();
+    }
+    void OControl::impl_resetStateGuard_nothrow()
+    {
+        Reference< XWindow2 > xWindow;
+        Reference< XControlModel > xModel;
+        try
+        {
+            xWindow.set( getPeer(), UNO_QUERY );
+            xModel.set( getModel(), UNO_QUERY );
+        }
+        catch( const Exception& )
+        {
+            DBG_UNHANDLED_EXCEPTION();
+        }
+        m_aWindowStateGuard.attach( xWindow, xModel );
+    }
+    void SAL_CALL OControl::createPeer(const Reference<XToolkit>& _rxToolkit, const Reference<XWindowPeer>& _rxParent) throw (RuntimeException)
+    {
+        if ( m_xControl.is() )
+        {
+            m_xControl->createPeer( _rxToolkit, _rxParent );
+            initFormControlPeer( getPeer() );
+            impl_resetStateGuard_nothrow();
+        }
+    }
+    Reference<XWindowPeer> SAL_CALL OControl::getPeer() throw ( RuntimeException)
+    {
+        return m_xControl.is() ? m_xControl->getPeer() : Reference<XWindowPeer>();
+    }
+    sal_Bool SAL_CALL OControl::setModel(const Reference<XControlModel>& Model) throw ( RuntimeException)
+    {
+        if ( !m_xControl.is() )
+            return sal_False;
+        sal_Bool bSuccess = m_xControl->setModel( Model );
         impl_resetStateGuard_nothrow();
+        return bSuccess;
     }
-}
-
-//------------------------------------------------------------------------------
-Reference<XWindowPeer> SAL_CALL OControl::getPeer() throw ( RuntimeException)
-{
-    return m_xControl.is() ? m_xControl->getPeer() : Reference<XWindowPeer>();
-}
-
-//------------------------------------------------------------------------------
-sal_Bool SAL_CALL OControl::setModel(const Reference<XControlModel>& Model) throw ( RuntimeException)
-{
-    if ( !m_xControl.is() )
-        return sal_False;
-
-    sal_Bool bSuccess = m_xControl->setModel( Model );
-    impl_resetStateGuard_nothrow();
-    return bSuccess;
-}
-
-//------------------------------------------------------------------------------
-Reference<XControlModel> SAL_CALL OControl::getModel() throw ( RuntimeException)
-{
-    return m_xControl.is() ? m_xControl->getModel() : Reference<XControlModel>();
-}
-
-//------------------------------------------------------------------------------
-Reference<XView> SAL_CALL OControl::getView() throw ( RuntimeException)
-{
-    return m_xControl.is() ? m_xControl->getView() : Reference<XView>();
-}
-
-//------------------------------------------------------------------------------
-void SAL_CALL OControl::setDesignMode(sal_Bool bOn) throw ( RuntimeException)
-{
-    if (m_xControl.is())
-        m_xControl->setDesignMode(bOn);
-}
-
-//------------------------------------------------------------------------------
-sal_Bool SAL_CALL OControl::isDesignMode() throw ( RuntimeException)
-{
-    return m_xControl.is() ? m_xControl->isDesignMode() : sal_True;
-}
-
-//------------------------------------------------------------------------------
-sal_Bool SAL_CALL OControl::isTransparent() throw ( RuntimeException)
-{
-    return m_xControl.is() ? m_xControl->isTransparent() : sal_True;
-}
-
-//==================================================================
-//= OBoundControl
-//==================================================================
-//------------------------------------------------------------------
-OBoundControl::OBoundControl( const Reference< XComponentContext >& _rxContext,
-            const OUString& _rAggregateService, const sal_Bool _bSetDelegator )
-    :OControl( _rxContext, _rAggregateService, _bSetDelegator )
-    ,m_bLocked(sal_False)
-    ,m_aOriginalFont( EmptyFontDescriptor() )
-    ,m_nOriginalTextLineColor( 0 )
-{
-}
-
-//------------------------------------------------------------------
-OBoundControl::~OBoundControl()
-{
-}
-// -----------------------------------------------------------------------------
-Sequence< Type> OBoundControl::_getTypes()
-{
-    return TypeBag( OControl::_getTypes(), OBoundControl_BASE::getTypes() ).getTypes();
-}
-//------------------------------------------------------------------
-Any SAL_CALL OBoundControl::queryAggregation(const Type& _rType) throw(RuntimeException)
-{
-    Any aReturn;
-
-    // XTypeProvider first - don't ask the OBoundControl_BASE, it would deliver incomplete types
-    if ( _rType.equals( ::getCppuType( static_cast< Reference< XTypeProvider >* >( NULL ) ) ) )
-        aReturn = OControl::queryAggregation( _rType );
-
-    // ask our own interfaces
-    // (do this first (except XTypeProvider ) - we want to "overwrite" XPropertiesChangeListener)
-    if ( !aReturn.hasValue() )
-        aReturn = OBoundControl_BASE::queryInterface( _rType );
-
-    // ask the base class
-    if ( !aReturn.hasValue() )
-        aReturn = OControl::queryAggregation( _rType );
-
-    return aReturn;
-}
-
-//------------------------------------------------------------------
-sal_Bool SAL_CALL OBoundControl::getLock() throw(RuntimeException)
-{
-    return m_bLocked;
-}
-
-//------------------------------------------------------------------
-void SAL_CALL OBoundControl::setLock(sal_Bool _bLock) throw(RuntimeException)
-{
-    if (m_bLocked == _bLock)
-        return;
-
-    osl::MutexGuard aGuard(m_aMutex);
-    _setLock(_bLock);
-    m_bLocked = _bLock;
-}
-
-//------------------------------------------------------------------
-void OBoundControl::_setLock(sal_Bool _bLock)
-{
-    // try to set the text component to readonly
-    Reference< XWindowPeer > xPeer = getPeer();
-    Reference< XTextComponent > xText( xPeer, UNO_QUERY );
-
-    if ( xText.is() )
-        xText->setEditable( !_bLock );
-    else
+    Reference<XControlModel> SAL_CALL OControl::getModel() throw ( RuntimeException)
     {
-        // disable the window
-        Reference< XWindow > xComp( xPeer, UNO_QUERY );
-        if ( xComp.is() )
-            xComp->setEnable( !_bLock );
+        return m_xControl.is() ? m_xControl->getModel() : Reference<XControlModel>();
+    }
+    Reference<XView> SAL_CALL OControl::getView() throw ( RuntimeException)
+    {
+        return m_xControl.is() ? m_xControl->getView() : Reference<XView>();
     }
-}
-
-//--------------------------------------------------------------------
-sal_Bool SAL_CALL OBoundControl::setModel( const Reference< XControlModel >& _rxModel ) throw (RuntimeException)
-{
-    return OControl::setModel( _rxModel );
-}
-
-//--------------------------------------------------------------------
-void SAL_CALL OBoundControl::disposing(const EventObject& Source) throw (RuntimeException)
-{
-    // just disambiguate
-    OControl::disposing(Source);
-}
-
-//--------------------------------------------------------------------
-void OBoundControl::disposing()
-{
-    OControl::disposing();
-}
-
-//==================================================================
-//= OControlModel
-//==================================================================
-//------------------------------------------------------------------
-Sequence<sal_Int8> SAL_CALL OControlModel::getImplementationId() throw(RuntimeException)
-{
-    return OImplementationIds::getImplementationId(getTypes());
-}
-
-//------------------------------------------------------------------
-Sequence<Type> SAL_CALL OControlModel::getTypes() throw(RuntimeException)
-{
-    TypeBag aTypes( _getTypes() );
-
-    Reference< XTypeProvider > xProv;
-    if ( query_aggregation( m_xAggregate, xProv ) )
-        aTypes.addTypes( xProv->getTypes() );
-
-    return aTypes.getTypes();
-}
-
-//------------------------------------------------------------------------------
-Sequence<Type> OControlModel::_getTypes()
-{
-    return TypeBag( OComponentHelper::getTypes(),
-        OPropertySetAggregationHelper::getTypes(),
-        OControlModel_BASE::getTypes()
-    ).getTypes();
-}
 
-//------------------------------------------------------------------
-Any SAL_CALL OControlModel::queryAggregation(const Type& _rType) throw (RuntimeException)
-{
-    // base class 1
-    Any aReturn(OComponentHelper::queryAggregation(_rType));
+    void SAL_CALL OControl::setDesignMode(sal_Bool bOn) throw ( RuntimeException)
+    {
+        if (m_xControl.is())
+            m_xControl->setDesignMode(bOn);
+    }
+    sal_Bool SAL_CALL OControl::isDesignMode() throw ( RuntimeException)
+    {
+        return m_xControl.is() ? m_xControl->isDesignMode() : sal_True;
+    }
 
-    // base class 2
-    if (!aReturn.hasValue())
+    sal_Bool SAL_CALL OControl::isTransparent() throw ( RuntimeException)
     {
-        aReturn = OControlModel_BASE::queryInterface(_rType);
+        return m_xControl.is() ? m_xControl->isTransparent() : sal_True;
+    }
 
-        // our own interfaces
-        if (!aReturn.hasValue())
+    // OBoundControl
+    OBoundControl::OBoundControl( const Reference< XComponentContext >& _rxContext,
+                const OUString& _rAggregateService, const sal_Bool _bSetDelegator )
+        :OControl( _rxContext, _rAggregateService, _bSetDelegator )
+        ,m_bLocked(sal_False)
+        ,m_aOriginalFont( EmptyFontDescriptor() )
+        ,m_nOriginalTextLineColor( 0 )
+    {
+    }
+    OBoundControl::~OBoundControl()
+    {
+    }
+    Sequence< Type> OBoundControl::_getTypes()
+    {
+        return TypeBag( OControl::_getTypes(), OBoundControl_BASE::getTypes() ).getTypes();
+    }
+    Any SAL_CALL OBoundControl::queryAggregation(const Type& _rType) throw(RuntimeException)
+    {
+        Any aReturn;
+        // XTypeProvider first - don't ask the OBoundControl_BASE, it would deliver incomplete types
+        if ( _rType.equals( ::getCppuType( static_cast< Reference< XTypeProvider >* >( NULL ) ) ) )
+            aReturn = OControl::queryAggregation( _rType );
+        // ask our own interfaces
+        // (do this first (except XTypeProvider ) - we want to "overwrite" XPropertiesChangeListener)
+        if ( !aReturn.hasValue() )
+            aReturn = OBoundControl_BASE::queryInterface( _rType );
+        // ask the base class
+        if ( !aReturn.hasValue() )
+            aReturn = OControl::queryAggregation( _rType );
+        return aReturn;
+    }
+    sal_Bool SAL_CALL OBoundControl::getLock() throw(RuntimeException)
+    {
+        return m_bLocked;
+    }
+    void SAL_CALL OBoundControl::setLock(sal_Bool _bLock) throw(RuntimeException)
+    {
+        if (m_bLocked == _bLock)
+            return;
+        osl::MutexGuard aGuard(m_aMutex);
+        _setLock(_bLock);
+        m_bLocked = _bLock;
+    }
+    void OBoundControl::_setLock(sal_Bool _bLock)
+    {
+        // try to set the text component to readonly
+        Reference< XWindowPeer > xPeer = getPeer();
+        Reference< XTextComponent > xText( xPeer, UNO_QUERY );
+        if ( xText.is() )
+            xText->setEditable( !_bLock );
+        else
         {
-            aReturn = OPropertySetAggregationHelper::queryInterface(_rType);
-            // our aggregate
-            if (!aReturn.hasValue() && m_xAggregate.is() && !_rType.equals(::getCppuType(static_cast< Reference< XCloneable>* >(NULL))))
-                aReturn = m_xAggregate->queryAggregation(_rType);
+            // disable the window
+            Reference< XWindow > xComp( xPeer, UNO_QUERY );
+            if ( xComp.is() )
+                xComp->setEnable( !_bLock );
         }
     }
-    return aReturn;
-}
-
-//------------------------------------------------------------------------------
-void OControlModel::readHelpTextCompatibly(const staruno::Reference< stario::XObjectInputStream >& _rxInStream)
-{
-    OUString sHelpText;
-    ::comphelper::operator>>( _rxInStream, sHelpText);
-    try
+    sal_Bool SAL_CALL OBoundControl::setModel( const Reference< XControlModel >& _rxModel ) throw (RuntimeException)
     {
-        if (m_xAggregateSet.is())
-            m_xAggregateSet->setPropertyValue(PROPERTY_HELPTEXT, makeAny(sHelpText));
+        return OControl::setModel( _rxModel );
     }
-    catch(const Exception&)
+    void SAL_CALL OBoundControl::disposing(const EventObject& Source) throw (RuntimeException)
     {
-        SAL_WARN("forms.component", "OControlModel::readHelpTextCompatibly: could not forward the property value to the aggregate!");
-        DBG_UNHANDLED_EXCEPTION();
+        // just disambiguate
+        OControl::disposing(Source);
+    }
+    void OBoundControl::disposing()
+    {
+        OControl::disposing();
     }
-}
 
-//------------------------------------------------------------------------------
-void OControlModel::writeHelpTextCompatibly(const staruno::Reference< stario::XObjectOutputStream >& _rxOutStream)
-{
-    OUString sHelpText;
-    try
+    // OControlModel
+    Sequence<sal_Int8> SAL_CALL OControlModel::getImplementationId() throw(RuntimeException)
     {
-        if (m_xAggregateSet.is())
-            m_xAggregateSet->getPropertyValue(PROPERTY_HELPTEXT) >>= sHelpText;
+        return OImplementationIds::getImplementationId(getTypes());
     }
-    catch(const Exception&)
+    Sequence<Type> SAL_CALL OControlModel::getTypes() throw(RuntimeException)
     {
-        SAL_WARN("forms.component", "OControlModel::writeHelpTextCompatibly: could not retrieve the property value from the aggregate!");
-        DBG_UNHANDLED_EXCEPTION();
+        TypeBag aTypes( _getTypes() );
+        Reference< XTypeProvider > xProv;
+        if ( query_aggregation( m_xAggregate, xProv ) )
+            aTypes.addTypes( xProv->getTypes() );
+        return aTypes.getTypes();
     }
-    ::comphelper::operator<<( _rxOutStream, sHelpText);
-}
 
-//------------------------------------------------------------------
-OControlModel::OControlModel(
-            const Reference<XComponentContext>& _rxContext,
-            const OUString& _rUnoControlModelTypeName,
-            const OUString& rDefault, const sal_Bool _bSetDelegator)
-    :OComponentHelper(m_aMutex)
-    ,OPropertySetAggregationHelper(OComponentHelper::rBHelper)
-    ,m_xContext( _rxContext )
-    ,m_lockCount( 0 )
-    ,m_aPropertyBagHelper( *this )
-    ,m_nTabIndex(FRM_DEFAULT_TABINDEX)
-    ,m_nClassId(FormComponentType::CONTROL)
-    ,m_bNativeLook( sal_False )
-    ,m_bGenerateVbEvents( sal_False )
-    ,m_nControlTypeinMSO(0) // 0 : default value is create from AOO
-    ,m_nObjIDinMSO(INVALID_OBJ_ID_IN_MSO)
-        // form controls are usually embedded into documents, not dialogs, and in documents
-        // the native look is ugly ....
-        // #i37342#
-{
-    if (!_rUnoControlModelTypeName.isEmpty())  // the is a model we have to aggregate
+    Sequence<Type> OControlModel::_getTypes()
     {
-        increment(m_refCount);
-
+        return TypeBag( OComponentHelper::getTypes(),
+            OPropertySetAggregationHelper::getTypes(),
+            OControlModel_BASE::getTypes()
+        ).getTypes();
+    }
+    Any SAL_CALL OControlModel::queryAggregation(const Type& _rType) throw (RuntimeException)
+    {
+        // base class 1
+        Any aReturn(OComponentHelper::queryAggregation(_rType));
+        // base class 2
+        if (!aReturn.hasValue())
         {
-            m_xAggregate = Reference<XAggregation>(m_xContext->getServiceManager()->createInstanceWithContext(_rUnoControlModelTypeName, m_xContext), UNO_QUERY);
-            setAggregation(m_xAggregate);
-
-            if ( m_xAggregateSet.is() )
+            aReturn = OControlModel_BASE::queryInterface(_rType);
+            // our own interfaces
+            if (!aReturn.hasValue())
             {
-                try
-                {
-                    if ( !rDefault.isEmpty() )
-                        m_xAggregateSet->setPropertyValue( PROPERTY_DEFAULTCONTROL, makeAny( rDefault ) );
-                }
-                catch( const Exception& )
-                {
-                    SAL_WARN("forms.component",  "OControlModel::OControlModel: caught an exception!");
-                    DBG_UNHANDLED_EXCEPTION();
-                }
+                aReturn = OPropertySetAggregationHelper::queryInterface(_rType);
+                // our aggregate
+                if (!aReturn.hasValue() && m_xAggregate.is() && !_rType.equals(::getCppuType(static_cast< Reference< XCloneable>* >(NULL))))
+                    aReturn = m_xAggregate->queryAggregation(_rType);
             }
         }
-
-        if (_bSetDelegator)
-            doSetDelegator();
-
-        // Refcount wieder bei NULL
-        decrement(m_refCount);
+        return aReturn;
     }
 
-}
-
-//------------------------------------------------------------------
-OControlModel::OControlModel( const OControlModel* _pOriginal, const Reference< XComponentContext>& _rxFactory, const sal_Bool _bCloneAggregate, const sal_Bool _bSetDelegator )
-    :OComponentHelper( m_aMutex )
-    ,OPropertySetAggregationHelper( OComponentHelper::rBHelper )
-    ,m_xContext( _rxFactory )
-    ,m_lockCount( 0 )
-    ,m_aPropertyBagHelper( *this )
-    ,m_nTabIndex( FRM_DEFAULT_TABINDEX )
-    ,m_nClassId( FormComponentType::CONTROL )
-{
-    DBG_ASSERT( _pOriginal, "OControlModel::OControlModel: invalid original!" );
-
-    // copy members
-    m_aName = _pOriginal->m_aName;
-    m_aTag = _pOriginal->m_aTag;
-    m_nTabIndex = _pOriginal->m_nTabIndex;
-    m_nClassId = _pOriginal->m_nClassId;
-    m_bNativeLook = _pOriginal->m_bNativeLook;
-    m_bGenerateVbEvents = _pOriginal->m_bGenerateVbEvents;
-    m_nControlTypeinMSO = _pOriginal->m_nControlTypeinMSO;
-    m_nObjIDinMSO = _pOriginal->m_nObjIDinMSO;
-
-    if ( _bCloneAggregate )
+    void OControlModel::readHelpTextCompatibly(const staruno::Reference< stario::XObjectInputStream >& _rxInStream)
     {
-        // temporarily increment refcount because of temporary references to ourself in the following
-        increment( m_refCount );
-
+        OUString sHelpText;
+        ::comphelper::operator>>( _rxInStream, sHelpText);
+        try
         {
-            // transfer the (only, at the very moment!) ref count
-            m_xAggregate = createAggregateClone( _pOriginal );
-
-            // set aggregation (retrieve other direct interfaces of the aggregate)
-            setAggregation( m_xAggregate );
+            if (m_xAggregateSet.is())
+                m_xAggregateSet->setPropertyValue(PROPERTY_HELPTEXT, makeAny(sHelpText));
+        }
+        catch(const Exception&)
+        {
+            SAL_WARN("forms.component", "OControlModel::readHelpTextCompatibly: could not forward the property value to the aggregate!");
+            DBG_UNHANDLED_EXCEPTION();
         }
-
-        // set the delegator, if allowed by our derived class
-        if ( _bSetDelegator )
-            doSetDelegator();
-
-        // decrement ref count
-        decrement( m_refCount );
     }
 
-}
-
-//------------------------------------------------------------------
-OControlModel::~OControlModel()
-{
-    // release the aggregate
-    doResetDelegator( );
-
-}
-
-//------------------------------------------------------------------
-void OControlModel::clonedFrom( const OControlModel* /*_pOriginal*/ )
-{
-    // nothing to do in this base class
-}
-
-//------------------------------------------------------------------------------
-void OControlModel::doResetDelegator()
-{
-    if (m_xAggregate.is())
-        m_xAggregate->setDelegator(NULL);
-}
-
-//------------------------------------------------------------------------------
-void OControlModel::doSetDelegator()
-{
-    increment(m_refCount);
-    if (m_xAggregate.is())
+    void OControlModel::writeHelpTextCompatibly(const staruno::Reference< stario::XObjectOutputStream >& _rxOutStream)
     {
-        m_xAggregate->setDelegator(static_cast<XWeak*>(this));
+        OUString sHelpText;
+        try
+        {
+            if (m_xAggregateSet.is())
+                m_xAggregateSet->getPropertyValue(PROPERTY_HELPTEXT) >>= sHelpText;
+        }
+        catch(const Exception&)
+        {
+            SAL_WARN("forms.component", "OControlModel::writeHelpTextCompatibly: could not retrieve the property value from the aggregate!");
+            DBG_UNHANDLED_EXCEPTION();
+        }
+        ::comphelper::operator<<( _rxOutStream, sHelpText);
+    }
+    OControlModel::OControlModel(
+                const Reference<XComponentContext>& _rxContext,
+                const OUString& _rUnoControlModelTypeName,
+                const OUString& rDefault, const sal_Bool _bSetDelegator)
+        :OComponentHelper(m_aMutex)
+        ,OPropertySetAggregationHelper(OComponentHelper::rBHelper)
+        ,m_xContext( _rxContext )
+        ,m_lockCount( 0 )
+        ,m_aPropertyBagHelper( *this )
+        ,m_nTabIndex(FRM_DEFAULT_TABINDEX)
+        ,m_nClassId(FormComponentType::CONTROL)
+        ,m_bNativeLook( sal_False )
+        ,m_bGenerateVbEvents( sal_False )
+        ,m_nControlTypeinMSO(0) // 0 : default value is create from AOO
+        ,m_nObjIDinMSO(INVALID_OBJ_ID_IN_MSO)
+            // form controls are usually embedded into documents, not dialogs, and in documents
+            // the native look is ugly ....
+            // #i37342#
+    {
+        if (!_rUnoControlModelTypeName.isEmpty())  // the is a model we have to aggregate
+        {
+            increment(m_refCount);
+            {
+                m_xAggregate = Reference<XAggregation>(m_xContext->getServiceManager()->createInstanceWithContext(_rUnoControlModelTypeName, m_xContext), UNO_QUERY);
+                setAggregation(m_xAggregate);
+                if ( m_xAggregateSet.is() )
+                {
+                    try
+                    {
+                        if ( !rDefault.isEmpty() )
+                            m_xAggregateSet->setPropertyValue( PROPERTY_DEFAULTCONTROL, makeAny( rDefault ) );
+                    }
+                    catch( const Exception& )
+                    {
+                        SAL_WARN("forms.component",  "OControlModel::OControlModel: caught an exception!");
+                        DBG_UNHANDLED_EXCEPTION();
+                    }
+                }
+            }
+            if (_bSetDelegator)
+                doSetDelegator();
+            // Refcount wieder bei NULL
+            decrement(m_refCount);
+        }
     }
-    decrement(m_refCount);
-}
-
-// XChild
-//------------------------------------------------------------------------------
-Reference< XInterface > SAL_CALL OControlModel::getParent() throw(RuntimeException)
-{
-    return m_xParent;
-}
-
-//------------------------------------------------------------------------------
-void SAL_CALL OControlModel::setParent(const Reference< XInterface >& _rxParent) throw(com::sun::star::lang::NoSupportException, RuntimeException)
-{
-    osl::MutexGuard aGuard(m_aMutex);
-
-    Reference<XComponent> xComp(m_xParent, UNO_QUERY);
-    if (xComp.is())
-        xComp->removeEventListener(static_cast<XPropertiesChangeListener*>(this));
-
-    m_xParent = _rxParent;
-    xComp = xComp.query( m_xParent );
-
-    if ( xComp.is() )
-        xComp->addEventListener(static_cast<XPropertiesChangeListener*>(this));
-}
-
-// XNamed
-OUString SAL_CALL OControlModel::getName() throw(RuntimeException)
-{
-    OUString aReturn;
-    OPropertySetHelper::getFastPropertyValue(PROPERTY_ID_NAME) >>= aReturn;
-    return aReturn;
-}
-
-void SAL_CALL OControlModel::setName(const OUString& _rName) throw(RuntimeException)
-{
-        setFastPropertyValue(PROPERTY_ID_NAME, makeAny(_rName));
-}
-
-// XServiceInfo
-sal_Bool SAL_CALL OControlModel::supportsService(const OUString& _rServiceName) throw ( RuntimeException)
-{
-    return cppu::supportsService(this, _rServiceName);
-}
-
-Sequence< OUString > OControlModel::getAggregateServiceNames()
-{
-    Sequence< OUString > aAggServices;
-    Reference< XServiceInfo > xInfo;
-    if ( query_aggregation( m_xAggregate, xInfo ) )
-        aAggServices = xInfo->getSupportedServiceNames();
-    return aAggServices;
-}
-
-Sequence<OUString> SAL_CALL OControlModel::getSupportedServiceNames() throw(RuntimeException)
-{
-    return ::comphelper::concatSequences(
-        getAggregateServiceNames(),
-        getSupportedServiceNames_Static()
-    );
-}
-
-Sequence< OUString > SAL_CALL OControlModel::getSupportedServiceNames_Static() throw( RuntimeException )
-{
-    Sequence< OUString > aServiceNames( 2 );
-    aServiceNames[ 0 ] = FRM_SUN_FORMCOMPONENT;
-    aServiceNames[ 1 ] = "com.sun.star.form.FormControlModel";
-    return aServiceNames;
-}
-
-// XEventListener
-//------------------------------------------------------------------------------
-void SAL_CALL OControlModel::disposing(const com::sun::star::lang::EventObject& _rSource) throw (RuntimeException)
-{
-    // release the parent
-    if (_rSource.Source == m_xParent)
+    OControlModel::OControlModel( const OControlModel* _pOriginal, const Reference< XComponentContext>& _rxFactory, const sal_Bool _bCloneAggregate, const sal_Bool _bSetDelegator )
+        :OComponentHelper( m_aMutex )
+        ,OPropertySetAggregationHelper( OComponentHelper::rBHelper )
+        ,m_xContext( _rxFactory )
+        ,m_lockCount( 0 )
+        ,m_aPropertyBagHelper( *this )
+        ,m_nTabIndex( FRM_DEFAULT_TABINDEX )
+        ,m_nClassId( FormComponentType::CONTROL )
+    {
+        DBG_ASSERT( _pOriginal, "OControlModel::OControlModel: invalid original!" );
+        // copy members
+        m_aName = _pOriginal->m_aName;
+        m_aTag = _pOriginal->m_aTag;
+        m_nTabIndex = _pOriginal->m_nTabIndex;
+        m_nClassId = _pOriginal->m_nClassId;
+        m_bNativeLook = _pOriginal->m_bNativeLook;
+        m_bGenerateVbEvents = _pOriginal->m_bGenerateVbEvents;
+        m_nControlTypeinMSO = _pOriginal->m_nControlTypeinMSO;
+        m_nObjIDinMSO = _pOriginal->m_nObjIDinMSO;
+        if ( _bCloneAggregate )
+        {
+            // temporarily increment refcount because of temporary references to ourself in the following
+            increment( m_refCount );
+            {
+                // transfer the (only, at the very moment!) ref count
+                m_xAggregate = createAggregateClone( _pOriginal );
+                // set aggregation (retrieve other direct interfaces of the aggregate)
+                setAggregation( m_xAggregate );
+            }
+            // set the delegator, if allowed by our derived class
+            if ( _bSetDelegator )
+                doSetDelegator();
+            // decrement ref count
+            decrement( m_refCount );
+        }
+    }
+    OControlModel::~OControlModel()
     {
-        osl::MutexGuard aGuard(m_aMutex);
-        m_xParent = NULL;
+        // release the aggregate
+        doResetDelegator( );
     }
-    else
+    void OControlModel::clonedFrom( const OControlModel* /*_pOriginal*/ )
     {
-        Reference<com::sun::star::lang::XEventListener> xEvtLst;
-        if (query_aggregation(m_xAggregate, xEvtLst))
+        // nothing to do in this base class
+    }
+    void OControlModel::doResetDelegator()
+    {
+        if (m_xAggregate.is())
+            m_xAggregate->setDelegator(NULL);
+    }
+    void OControlModel::doSetDelegator()
+    {
+        increment(m_refCount);
+        if (m_xAggregate.is())
         {
-            osl::MutexGuard aGuard(m_aMutex);
-            xEvtLst->disposing(_rSource);
+            m_xAggregate->setDelegator(static_cast<XWeak*>(this));
         }
+        decrement(m_refCount);
     }
-}
-
-// OComponentHelper
-//-----------------------------------------------------------------------------
-void OControlModel::disposing()
-{
-    OPropertySetAggregationHelper::disposing();
-
-    Reference<com::sun::star::lang::XComponent> xComp;
-    if (query_aggregation(m_xAggregate, xComp))
-        xComp->dispose();
-
-    setParent(Reference<XFormComponent>());
-
-    m_aPropertyBagHelper.dispose();
-}
-
-//------------------------------------------------------------------------------
-void OControlModel::writeAggregate( const Reference< XObjectOutputStream >& _rxOutStream ) const
-{
-    Reference< XPersistObject > xPersist;
-    if ( query_aggregation( m_xAggregate, xPersist ) )
-        xPersist->write( _rxOutStream );
-}
 
-//------------------------------------------------------------------------------
-void OControlModel::readAggregate( const Reference< XObjectInputStream >& _rxInStream )
-{
-    Reference< XPersistObject > xPersist;
-    if ( query_aggregation( m_xAggregate, xPersist ) )
-        xPersist->read( _rxInStream );
-}
-
-//------------------------------------------------------------------------------
-void SAL_CALL OControlModel::write(const Reference<stario::XObjectOutputStream>& _rxOutStream)
-                        throw(stario::IOException, RuntimeException)
-{
-    osl::MutexGuard aGuard(m_aMutex);
-
-    // 1. Schreiben des UnoControls
-    Reference<stario::XMarkableStream> xMark(_rxOutStream, UNO_QUERY);
-    if ( !xMark.is() )
+    // XChild
+    Reference< XInterface > SAL_CALL OControlModel::getParent() throw(RuntimeException)
     {
-        throw IOException(
-            FRM_RES_STRING( RID_STR_INVALIDSTREAM ),
-            static_cast< ::cppu::OWeakObject* >( this )
-        );
+        return m_xParent;
     }
-
-    sal_Int32 nMark = xMark->createMark();
-    sal_Int32 nLen = 0;
-
-    _rxOutStream->writeLong(nLen);
-
-    writeAggregate( _rxOutStream );
-
-    // feststellen der Laenge
-    nLen = xMark->offsetToMark(nMark) - 4;
-    xMark->jumpToMark(nMark);
-    _rxOutStream->writeLong(nLen);
-    xMark->jumpToFurthest();
-    xMark->deleteMark(nMark);
-
-    // 2. Schreiben einer VersionsNummer
-    _rxOutStream->writeShort(0x0003);
-
-    // 3. Schreiben der allgemeinen Properties
-    ::comphelper::operator<<( _rxOutStream, m_aName);
-    _rxOutStream->writeShort(m_nTabIndex);
-    ::comphelper::operator<<( _rxOutStream, m_aTag); // 3. version
-
-    // !!! IMPORTANT NOTE !!!
-    // don't write any new members here : this wouldn't be compatible with older versions, as OControlModel
-    // is a base class which is called in derived classes "read" method. So if you increment the version
-    // and write new stuff, older office versions will read this in the _derived_ classes, which may result
-    // in anything from data loss to crash.
-    // !!! EOIN !!!
-}
-
-//------------------------------------------------------------------------------
-void OControlModel::read(const Reference<stario::XObjectInputStream>& InStream) throw (::com::sun::star::io::IOException, RuntimeException)
-{
-    osl::MutexGuard aGuard(m_aMutex);
-
-    Reference<stario::XMarkableStream> xMark(InStream, UNO_QUERY);
-    if ( !xMark.is() )
+    void SAL_CALL OControlModel::setParent(const Reference< XInterface >& _rxParent) throw(com::sun::star::lang::NoSupportException, RuntimeException)
     {
-        throw IOException(
-            FRM_RES_STRING( RID_STR_INVALIDSTREAM ),
-            static_cast< ::cppu::OWeakObject* >( this )
-        );
+        osl::MutexGuard aGuard(m_aMutex);
+        Reference<XComponent> xComp(m_xParent, UNO_QUERY);
+        if (xComp.is())
+            xComp->removeEventListener(static_cast<XPropertiesChangeListener*>(this));
+        m_xParent = _rxParent;
+        xComp = xComp.query( m_xParent );
+        if ( xComp.is() )
+            xComp->addEventListener(static_cast<XPropertiesChangeListener*>(this));
     }
 
-    // 1. Lesen des UnoControls
-    sal_Int32 nLen = InStream->readLong();
-    if (nLen)
+    // XNamed
+    OUString SAL_CALL OControlModel::getName() throw(RuntimeException)
     {
-        sal_Int32 nMark = xMark->createMark();
-
-        try
-        {
-            readAggregate( InStream );
-        }
-        catch( const Exception& )
-        {
-            DBG_UNHANDLED_EXCEPTION();
-        }
-
-        xMark->jumpToMark(nMark);
-        InStream->skipBytes(nLen);
-        xMark->deleteMark(nMark);
+        OUString aReturn;
+        OPropertySetHelper::getFastPropertyValue(PROPERTY_ID_NAME) >>= aReturn;
+        return aReturn;
     }
-
-    // 2. Lesen des Versionsnummer
-    sal_uInt16 nVersion = InStream->readShort();
-
-    // 3. Lesen der allgemeinen Properties
-    ::comphelper::operator>>( InStream, m_aName);
-    m_nTabIndex  = InStream->readShort();
-
-    if (nVersion > 0x0002)
-        ::comphelper::operator>>( InStream, m_aTag);
-
-    // we had a version where we wrote the help text
-    if (nVersion == 0x0004)
-        readHelpTextCompatibly(InStream);
-
-    DBG_ASSERT(nVersion < 5, "OControlModel::read : suspicious version number !");
-    // 4 was the version where we wrote the help text
-    // later versions shouldn't exist (see write for a detailed comment)
-}
-
-//------------------------------------------------------------------------------
-PropertyState OControlModel::getPropertyStateByHandle( sal_Int32 _nHandle )
-{
-    // simply compare the current and the default value
-    Any aCurrentValue = getPropertyDefaultByHandle( _nHandle );
-    Any aDefaultValue;  getFastPropertyValue( aDefaultValue, _nHandle );
-
-    sal_Bool bEqual = uno_type_equalData(
-            const_cast< void* >( aCurrentValue.getValue() ), aCurrentValue.getValueType().getTypeLibType(),
-            const_cast< void* >( aDefaultValue.getValue() ), aDefaultValue.getValueType().getTypeLibType(),
-            reinterpret_cast< uno_QueryInterfaceFunc >(cpp_queryInterface),
-            reinterpret_cast< uno_ReleaseFunc >(cpp_release)
-        );
-    return bEqual ? PropertyState_DEFAULT_VALUE : PropertyState_DIRECT_VALUE;
-}
-
-//------------------------------------------------------------------------------
-void OControlModel::setPropertyToDefaultByHandle( sal_Int32 _nHandle)
-{
-    Any aDefault = getPropertyDefaultByHandle( _nHandle );
-
-    Any aConvertedValue, aOldValue;
-    if ( convertFastPropertyValue( aConvertedValue, aOldValue, _nHandle, aDefault ) )
+    void SAL_CALL OControlModel::setName(const OUString& _rName) throw(RuntimeException)
     {
-        setFastPropertyValue_NoBroadcast( _nHandle, aConvertedValue );
-        // TODO: fire the property change
+            setFastPropertyValue(PROPERTY_ID_NAME, makeAny(_rName));
     }
-}
 
-//------------------------------------------------------------------------------
-Any OControlModel::getPropertyDefaultByHandle( sal_Int32 _nHandle ) const
-{
-    Any aReturn;
-    switch ( _nHandle )
+    // XServiceInfo
+    sal_Bool SAL_CALL OControlModel::supportsService(const OUString& _rServiceName) throw ( RuntimeException)
     {
-        case PROPERTY_ID_NAME:
-        case PROPERTY_ID_TAG:
-            aReturn <<= OUString();
-            break;
-
-        case PROPERTY_ID_CLASSID:
-            aReturn <<= (sal_Int16)FormComponentType::CONTROL;
-            break;
-
-        case PROPERTY_ID_TABINDEX:
-            aReturn <<= (sal_Int16)FRM_DEFAULT_TABINDEX;
-            break;
-
-        case PROPERTY_ID_NATIVE_LOOK:
-            aReturn <<= (sal_Bool)sal_True;
-            break;
-
-        case PROPERTY_ID_GENERATEVBAEVENTS:
-            aReturn <<= (sal_Bool)sal_False;
-            break;
-        //added for exporting OCX control
-        case PROPERTY_ID_CONTROL_TYPE_IN_MSO:
-            aReturn <<= (sal_Int16)0;
-            break;
-        case PROPERTY_ID_OBJ_ID_IN_MSO:
-            aReturn <<= (sal_uInt16)INVALID_OBJ_ID_IN_MSO;
-            break;
-        default:
-            if ( m_aPropertyBagHelper.hasDynamicPropertyByHandle( _nHandle ) )
-                m_aPropertyBagHelper.getDynamicPropertyDefaultByHandle( _nHandle, aReturn );
-            else
-                SAL_WARN("forms.component",  "OControlModel::convertFastPropertyValue: unknown handle " << _nHandle);
+        return cppu::supportsService(this, _rServiceName);
     }
-    return aReturn;
-}
-
-//------------------------------------------------------------------------------
-void OControlModel::getFastPropertyValue( Any& _rValue, sal_Int32 _nHandle ) const
-{
-    switch ( _nHandle )
+    Sequence< OUString > OControlModel::getAggregateServiceNames()
     {
-        case PROPERTY_ID_NAME:
-            _rValue <<= m_aName;
-            break;
-        case PROPERTY_ID_TAG:
-            _rValue <<= m_aTag;
-            break;
-        case PROPERTY_ID_CLASSID:
-            _rValue <<= m_nClassId;
-            break;
-        case PROPERTY_ID_TABINDEX:
-            _rValue <<= m_nTabIndex;
-            break;
-        case PROPERTY_ID_NATIVE_LOOK:
-            _rValue <<= (sal_Bool)m_bNativeLook;
-            break;
-        case PROPERTY_ID_GENERATEVBAEVENTS:
-            _rValue <<= (sal_Bool)m_bGenerateVbEvents;
-        //added for exporting OCX control
-        case PROPERTY_ID_CONTROL_TYPE_IN_MSO:
-            _rValue <<= (sal_Int16)m_nControlTypeinMSO;
-            break;
-        case PROPERTY_ID_OBJ_ID_IN_MSO:
-            _rValue <<= (sal_uInt16)m_nObjIDinMSO;
-            break;
-        default:
-            if ( m_aPropertyBagHelper.hasDynamicPropertyByHandle( _nHandle ) )
-                m_aPropertyBagHelper.getDynamicFastPropertyValue( _nHandle, _rValue );
-            else
-                OPropertySetAggregationHelper::getFastPropertyValue( _rValue, _nHandle );
-            break;
+        Sequence< OUString > aAggServices;
+        Reference< XServiceInfo > xInfo;
+        if ( query_aggregation( m_xAggregate, xInfo ) )
+            aAggServices = xInfo->getSupportedServiceNames();
+        return aAggServices;
     }
-}
-
-//------------------------------------------------------------------------------
-sal_Bool OControlModel::convertFastPropertyValue(
-                        Any& _rConvertedValue, Any& _rOldValue, sal_Int32 _nHandle, const Any& _rValue)
-                        throw (com::sun::star::lang::IllegalArgumentException)
-{
-    sal_Bool bModified(sal_False);
-    switch (_nHandle)
+    Sequence<OUString> SAL_CALL OControlModel::getSupportedServiceNames() throw(RuntimeException)
     {
-        case PROPERTY_ID_NAME:
-            bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_aName);
-            break;
-        case PROPERTY_ID_TAG:
-            bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_aTag);
-            break;
-        case PROPERTY_ID_TABINDEX:
-            bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_nTabIndex);
-            break;
-        case PROPERTY_ID_NATIVE_LOOK:
-            bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_bNativeLook);
-            break;
-        case PROPERTY_ID_GENERATEVBAEVENTS:
-            bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_bGenerateVbEvents);
-            break;
-        //added for exporting OCX control
-        case PROPERTY_ID_CONTROL_TYPE_IN_MSO:
-            bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_nControlTypeinMSO);
-            break;
-        case PROPERTY_ID_OBJ_ID_IN_MSO:
-            bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_nObjIDinMSO);
-            break;
-        default:
-            if ( m_aPropertyBagHelper.hasDynamicPropertyByHandle( _nHandle ) )
-                bModified = m_aPropertyBagHelper.convertDynamicFastPropertyValue( _nHandle, _rValue, _rConvertedValue, _rOldValue );
-            else
-                SAL_WARN("forms.component",  "OControlModel::convertFastPropertyValue: unknown handle " << _nHandle);
-            break;
+        return ::comphelper::concatSequences(
+            getAggregateServiceNames(),
+            getSupportedServiceNames_Static()
+        );
     }
-    return bModified;
-}
-
-//------------------------------------------------------------------------------
-void OControlModel::setFastPropertyValue_NoBroadcast(sal_Int32 _nHandle, const Any& _rValue)
-                        throw (Exception)
-{
-    switch (_nHandle)
+    Sequence< OUString > SAL_CALL OControlModel::getSupportedServiceNames_Static() throw( RuntimeException )
     {
-        case PROPERTY_ID_NAME:
-            DBG_ASSERT(_rValue.getValueType() == getCppuType((const OUString*)NULL),
-                "OControlModel::setFastPropertyValue_NoBroadcast : invalid type" );
-            _rValue >>= m_aName;
-            break;
-        case PROPERTY_ID_TAG:
-            DBG_ASSERT(_rValue.getValueType() == getCppuType((const OUString*)NULL),
-                "OControlModel::setFastPropertyValue_NoBroadcast : invalid type" );
-            _rValue >>= m_aTag;
-            break;
-        case PROPERTY_ID_TABINDEX:
-            DBG_ASSERT(_rValue.getValueType() == getCppuType((const sal_Int16*)NULL),
-                "OControlModel::setFastPropertyValue_NoBroadcast : invalid type" );
-            _rValue >>= m_nTabIndex;
-            break;
-        case PROPERTY_ID_NATIVE_LOOK:
-            OSL_VERIFY( _rValue >>= m_bNativeLook );
-            break;
-        case PROPERTY_ID_GENERATEVBAEVENTS:
-            OSL_VERIFY( _rValue >>= m_bGenerateVbEvents );
-            break;
-        //added for exporting OCX control
-        case PROPERTY_ID_CONTROL_TYPE_IN_MSO:
-            OSL_VERIFY( _rValue >>= m_nControlTypeinMSO );
-            break;
-        case PROPERTY_ID_OBJ_ID_IN_MSO:
-            OSL_VERIFY( _rValue >>= m_nObjIDinMSO );
-            break;
-        default:
-            if ( m_aPropertyBagHelper.hasDynamicPropertyByHandle( _nHandle ) )
-                m_aPropertyBagHelper.setDynamicFastPropertyValue( _nHandle, _rValue );
-            else
-                SAL_WARN("forms.component",  "OControlModel::setFastPropertyValue_NoBroadcast: unknown handle " << _nHandle );
-            break;
+        Sequence< OUString > aServiceNames( 2 );
+        aServiceNames[ 0 ] = FRM_SUN_FORMCOMPONENT;
+        aServiceNames[ 1 ] = "com.sun.star.form.FormControlModel";
+        return aServiceNames;
     }
-}
 
-//------------------------------------------------------------------------------
-void OControlModel::describeFixedProperties( Sequence< Property >& _rProps ) const
-{
-    BEGIN_DESCRIBE_BASE_PROPERTIES( 7 )
-        DECL_PROP2      (CLASSID,     sal_Int16,        READONLY, TRANSIENT);
-        DECL_PROP1      (NAME,        OUString,  BOUND);
-        DECL_BOOL_PROP2 (NATIVE_LOOK,                   BOUND, TRANSIENT);
-        DECL_PROP1      (TAG,         OUString,  BOUND);
-        DECL_PROP1      (GENERATEVBAEVENTS,         sal_Bool,  TRANSIENT);
-        DECL_PROP1      (CONTROL_TYPE_IN_MSO,sal_Int16,     BOUND);
-        DECL_PROP1      (OBJ_ID_IN_MSO,sal_uInt16,      BOUND);
-    END_DESCRIBE_PROPERTIES()
-}
-
-//------------------------------------------------------------------------------
-void OControlModel::describeAggregateProperties( Sequence< Property >& /* [out] */ _rAggregateProps ) const
-{
-    if ( m_xAggregateSet.is() )
+    // XEventListener
+    void SAL_CALL OControlModel::disposing(const com::sun::star::lang::EventObject& _rSource) throw (RuntimeException)
     {
-        Reference< XPropertySetInfo > xPSI( m_xAggregateSet->getPropertySetInfo() );
-        if ( xPSI.is() )
-            _rAggregateProps = xPSI->getProperties();
+        // release the parent
+        if (_rSource.Source == m_xParent)
+        {
+            osl::MutexGuard aGuard(m_aMutex);
+            m_xParent = NULL;
+        }
+        else
+        {
+            Reference<com::sun::star::lang::XEventListener> xEvtLst;
+            if (query_aggregation(m_xAggregate, xEvtLst))
+            {
+                osl::MutexGuard aGuard(m_aMutex);
+                xEvtLst->disposing(_rSource);
+            }
+        }
     }
-}
-
-//------------------------------------------------------------------------------
-::osl::Mutex& OControlModel::getMutex()
-{
-    return m_aMutex;
-}
-
-//------------------------------------------------------------------------------
-void OControlModel::describeFixedAndAggregateProperties( Sequence< Property >& _out_rFixedProperties, Sequence< Property >& _out_rAggregateProperties ) const
-{
-    describeFixedProperties( _out_rFixedProperties );
-    describeAggregateProperties( _out_rAggregateProperties );
-}
-
-//------------------------------------------------------------------------------
-Reference< XMultiPropertySet > OControlModel::getPropertiesInterface()
-{
-    return Reference< XMultiPropertySet >( *this, UNO_QUERY );
-}
-
-//------------------------------------------------------------------------------
-Reference< XPropertySetInfo> SAL_CALL OControlModel::getPropertySetInfo() throw( RuntimeException)
-{
-    return createPropertySetInfo( getInfoHelper() );
-}
 
-//------------------------------------------------------------------------------
-::cppu::IPropertyArrayHelper& OControlModel::getInfoHelper()
-{
-    return m_aPropertyBagHelper.getInfoHelper();
-}
-
-//--------------------------------------------------------------------
-void SAL_CALL OControlModel::addProperty( const OUString& _rName, ::sal_Int16 _nAttributes, const Any& _rInitialValue ) throw (PropertyExistException, IllegalTypeException, IllegalArgumentException, RuntimeException)
-{
-    m_aPropertyBagHelper.addProperty( _rName, _nAttributes, _rInitialValue );
-}
-
-//--------------------------------------------------------------------
-void SAL_CALL OControlModel::removeProperty( const OUString& _rName ) throw (UnknownPropertyException, NotRemoveableException, RuntimeException)
-{
-    m_aPropertyBagHelper.removeProperty( _rName );
-}
-
-//--------------------------------------------------------------------
-Sequence< PropertyValue > SAL_CALL OControlModel::getPropertyValues() throw (RuntimeException)
-{
-    return m_aPropertyBagHelper.getPropertyValues();
-}
-
-//--------------------------------------------------------------------
-void SAL_CALL OControlModel::setPropertyValues( const Sequence< PropertyValue >& _rProps ) throw (UnknownPropertyException, PropertyVetoException, IllegalArgumentException, WrappedTargetException, RuntimeException)
-{
-    m_aPropertyBagHelper.setPropertyValues( _rProps );
-}
-
-//--------------------------------------------------------------------
-void OControlModel::lockInstance( LockAccess )
-{
-    m_aMutex.acquire();
-    osl_atomic_increment( &m_lockCount );
-}
-
-//--------------------------------------------------------------------
-oslInterlockedCount OControlModel::unlockInstance( LockAccess )
-{
-    OSL_ENSURE( m_lockCount > 0, "OControlModel::unlockInstance: not locked!" );
-    oslInterlockedCount lockCount = osl_atomic_decrement( &m_lockCount );
-    m_aMutex.release();
-    return lockCount;
-}
-
-//--------------------------------------------------------------------
-void OControlModel::firePropertyChanges( const Sequence< sal_Int32 >& _rHandles, const Sequence< Any >& _rOldValues,
-                                        const Sequence< Any >& _rNewValues, LockAccess )
-{
-    OPropertySetHelper::fire(
-        const_cast< Sequence< sal_Int32 >& >( _rHandles ).getArray(),
-        _rNewValues.getConstArray(),
-        _rOldValues.getConstArray(),
-        _rHandles.getLength(),
-        sal_False
-    );
-}
-
-//==================================================================
-//= OBoundControlModel
-//==================================================================
-//------------------------------------------------------------------
-Any SAL_CALL OBoundControlModel::queryAggregation( const Type& _rType ) throw (RuntimeException)
-{
-    Any aReturn( OControlModel::queryAggregation(_rType) );
-    if (!aReturn.hasValue())
+    // OComponentHelper
+    void OControlModel::disposing()
     {
-        aReturn = OBoundControlModel_BASE1::queryInterface(_rType);
-
-        if ( !aReturn.hasValue() && m_bCommitable )
-            aReturn = OBoundControlModel_COMMITTING::queryInterface( _rType );
-
-        if ( !aReturn.hasValue() && m_bSupportsExternalBinding )
-            aReturn = OBoundControlModel_BINDING::queryInterface( _rType );
-
-        if ( !aReturn.hasValue() && m_bSupportsValidation )
-            aReturn = OBoundControlModel_VALIDATION::queryInterface( _rType );
+        OPropertySetAggregationHelper::disposing();
+        Reference<com::sun::star::lang::XComponent> xComp;
+        if (query_aggregation(m_xAggregate, xComp))
+            xComp->dispose();
+        setParent(Reference<XFormComponent>());
+        m_aPropertyBagHelper.dispose();
     }
 
-    return aReturn;
-}
-
-//------------------------------------------------------------------
-OBoundControlModel::OBoundControlModel(
-        const Reference< XComponentContext>& _rxFactory,
-        const OUString& _rUnoControlModelTypeName, const OUString& _rDefault,
-        const sal_Bool _bCommitable, const sal_Bool _bSupportExternalBinding, const sal_Bool _bSupportsValidation )
-    :OControlModel( _rxFactory, _rUnoControlModelTypeName, _rDefault, sal_False )
-    ,OPropertyChangeListener( m_aMutex )
-    ,m_xField()
-    ,m_xAmbientForm()
-    ,m_nValuePropertyAggregateHandle( -1 )
-    ,m_nFieldType( DataType::OTHER )
-    ,m_bValuePropertyMayBeVoid( false )
-    ,m_aResetHelper( *this, m_aMutex )
-    ,m_aUpdateListeners(m_aMutex)
-    ,m_aFormComponentListeners( m_aMutex )
-    ,m_bInputRequired( sal_True )
-    ,m_pAggPropMultiplexer( NULL )
-    ,m_bFormListening( false )
-    ,m_bLoaded(sal_False)
-    ,m_bRequired(sal_False)
-    ,m_bCommitable(_bCommitable)
-    ,m_bSupportsExternalBinding( _bSupportExternalBinding )
-    ,m_bSupportsValidation( _bSupportsValidation )
-    ,m_bForwardValueChanges(sal_True)
-    ,m_bTransferingValue( sal_False )
-    ,m_bIsCurrentValueValid( sal_True )
-    ,m_bBindingControlsRO( sal_False )
-    ,m_bBindingControlsEnable( sal_False )
-    ,m_eControlValueChangeInstigator( eOther )
-    ,m_aLabelServiceName(FRM_SUN_COMPONENT_FIXEDTEXT)
-{
-
-    // start property listening at the aggregate
-    implInitAggMultiplexer( );
-}
-
-//------------------------------------------------------------------
-OBoundControlModel::OBoundControlModel(
-        const OBoundControlModel* _pOriginal, const Reference< XComponentContext>& _rxFactory )
-    :OControlModel( _pOriginal, _rxFactory, sal_True, sal_False )
-    ,OPropertyChangeListener( m_aMutex )
-    ,m_xField()
-    ,m_xAmbientForm()
-    ,m_nValuePropertyAggregateHandle( _pOriginal->m_nValuePropertyAggregateHandle )
-    ,m_nFieldType( DataType::OTHER )
-    ,m_bValuePropertyMayBeVoid( _pOriginal->m_bValuePropertyMayBeVoid )
-    ,m_aResetHelper( *this, m_aMutex )
-    ,m_aUpdateListeners( m_aMutex )
-    ,m_aFormComponentListeners( m_aMutex )
-    ,m_xValidator( _pOriginal->m_xValidator )
-    ,m_bInputRequired( sal_True )
-    ,m_pAggPropMultiplexer( NULL )
-    ,m_bFormListening( false )
-    ,m_bLoaded( sal_False )
-    ,m_bRequired( sal_False )
-    ,m_bCommitable( _pOriginal->m_bCommitable )
-    ,m_bSupportsExternalBinding( _pOriginal->m_bSupportsExternalBinding )
-    ,m_bSupportsValidation( _pOriginal->m_bSupportsValidation )
-    ,m_bForwardValueChanges( sal_True )
-    ,m_bTransferingValue( sal_False )
-    ,m_bIsCurrentValueValid( _pOriginal->m_bIsCurrentValueValid )
-    ,m_bBindingControlsRO( sal_False )
-    ,m_bBindingControlsEnable( sal_False )
-    ,m_eControlValueChangeInstigator( eOther )
-{
-
-    // start property listening at the aggregate
-    implInitAggMultiplexer( );
-
-    m_aLabelServiceName = _pOriginal->m_aLabelServiceName;
-    m_sValuePropertyName = _pOriginal->m_sValuePropertyName;
-    m_nValuePropertyAggregateHandle = _pOriginal->m_nValuePropertyAggregateHandle;
-    m_bValuePropertyMayBeVoid = _pOriginal->m_bValuePropertyMayBeVoid;
-    m_aValuePropertyType = _pOriginal->m_aValuePropertyType;
-    m_aControlSource = _pOriginal->m_aControlSource;
-    m_bInputRequired = _pOriginal->m_bInputRequired;
-    // m_xLabelControl, though being a property, is not to be cloned, not even the reference will be transferred.
-    // (the former should be clear - a clone of the object we're only referencing does not make sense)
-    // (the second would violate the restriction for label controls that they're part of the
-    // same form component hierarchy - we ourself are no part, yet, so we can't have a label control)
-
-    // start listening for changes at the value property
-    implInitValuePropertyListening( );
-}
-
-//------------------------------------------------------------------
-OBoundControlModel::~OBoundControlModel()
-{
-    if ( !OComponentHelper::rBHelper.bDisposed )
+    void OControlModel::writeAggregate( const Reference< XObjectOutputStream >& _rxOutStream ) const
     {
-        acquire();
-        dispose();
+        Reference< XPersistObject > xPersist;
+        if ( query_aggregation( m_xAggregate, xPersist ) )
+            xPersist->write( _rxOutStream );
     }
 
-    doResetDelegator( );
-
-    OSL_ENSURE( m_pAggPropMultiplexer, "OBoundControlModel::~OBoundControlModel: what about my property multiplexer?" );
-    if ( m_pAggPropMultiplexer )
+    void OControlModel::readAggregate( const Reference< XObjectInputStream >& _rxInStream )
     {
-        m_pAggPropMultiplexer->dispose();
-        m_pAggPropMultiplexer->release();
-        m_pAggPropMultiplexer = NULL;
+        Reference< XPersistObject > xPersist;
+        if ( query_aggregation( m_xAggregate, xPersist ) )
+            xPersist->read( _rxInStream );
     }
 
-}
-
-//------------------------------------------------------------------
-void OBoundControlModel::clonedFrom( const OControlModel* _pOriginal )
-{
-    const OBoundControlModel* pBoundOriginal = static_cast< const OBoundControlModel* >( _pOriginal );
-    // the value binding can be handled as if somebody called setValueBinding here
-    // By definition, bindings can be share between bindables
-    if ( pBoundOriginal && pBoundOriginal->m_xExternalBinding.is() )
+    void SAL_CALL OControlModel::write(const Reference<stario::XObjectOutputStream>& _rxOutStream)
+                            throw(stario::IOException, RuntimeException)
     {
-        try
+        osl::MutexGuard aGuard(m_aMutex);
+        // 1. Schreiben des UnoControls
+        Reference<stario::XMarkableStream> xMark(_rxOutStream, UNO_QUERY);
+        if ( !xMark.is() )
         {
-            setValueBinding( pBoundOriginal->m_xExternalBinding );
+            throw IOException(
+                FRM_RES_STRING( RID_STR_INVALIDSTREAM ),
+                static_cast< ::cppu::OWeakObject* >( this )
+            );
         }
-        catch( const Exception& )
+        sal_Int32 nMark = xMark->createMark();
+        sal_Int32 nLen = 0;
+        _rxOutStream->writeLong(nLen);
+        writeAggregate( _rxOutStream );
+        // feststellen der Laenge
+        nLen = xMark->offsetToMark(nMark) - 4;
+        xMark->jumpToMark(nMark);
+        _rxOutStream->writeLong(nLen);
+        xMark->jumpToFurthest();
+        xMark->deleteMark(nMark);
+        // 2. Schreiben einer VersionsNummer
+        _rxOutStream->writeShort(0x0003);
+        // 3. Schreiben der allgemeinen Properties
+        ::comphelper::operator<<( _rxOutStream, m_aName);
+        _rxOutStream->writeShort(m_nTabIndex);
+        ::comphelper::operator<<( _rxOutStream, m_aTag); // 3. version
+        // !!! IMPORTANT NOTE !!!
+        // don't write any new members here : this wouldn't be compatible with older versions, as OControlModel
+        // is a base class which is called in derived classes "read" method. So if you increment the version
+        // and write new stuff, older office versions will read this in the _derived_ classes, which may result
+        // in anything from data loss to crash.
+        // EOIN!
+    }
+
+    void OControlModel::read(const Reference<stario::XObjectInputStream>& InStream) throw (::com::sun::star::io::IOException, RuntimeException)
+    {
+        osl::MutexGuard aGuard(m_aMutex);
+        Reference<stario::XMarkableStream> xMark(InStream, UNO_QUERY);
+        if ( !xMark.is() )
         {
-            DBG_UNHANDLED_EXCEPTION();
+            throw IOException(
+                FRM_RES_STRING( RID_STR_INVALIDSTREAM ),
+                static_cast< ::cppu::OWeakObject* >( this )
+            );
+        }
+        // 1. reading the UnoControls
+        sal_Int32 nLen = InStream->readLong();
+        if (nLen)
+        {
+            sal_Int32 nMark = xMark->createMark();
+            try
+            {
+                readAggregate( InStream );
+            }
+            catch( const Exception& )
+            {
+                DBG_UNHANDLED_EXCEPTION();
+            }
+            xMark->jumpToMark(nMark);
+            InStream->skipBytes(nLen);
+            xMark->deleteMark(nMark);
+        }
+        // 2. reading the version number
+        sal_uInt16 nVersion = InStream->readShort();
+        // 3. reading the general properties
+        ::comphelper::operator>>( InStream, m_aName);
+        m_nTabIndex  = InStream->readShort();
+        if (nVersion > 0x0002)
+            ::comphelper::operator>>( InStream, m_aTag);
+        // we had a version where we wrote the help text
+        if (nVersion == 0x0004)
+            readHelpTextCompatibly(InStream);
+        DBG_ASSERT(nVersion < 5, "OControlModel::read : suspicious version number !");
+        // 4. was the version where we wrote the help text
+        // later versions shouldn't exist (see write for a detailed comment)
+    }
+
+    PropertyState OControlModel::getPropertyStateByHandle( sal_Int32 _nHandle )
+    {
+        // simply compare the current and the default value
+        Any aCurrentValue = getPropertyDefaultByHandle( _nHandle );
+        Any aDefaultValue;  getFastPropertyValue( aDefaultValue, _nHandle );
+        sal_Bool bEqual = uno_type_equalData(
+                const_cast< void* >( aCurrentValue.getValue() ), aCurrentValue.getValueType().getTypeLibType(),
+                const_cast< void* >( aDefaultValue.getValue() ), aDefaultValue.getValueType().getTypeLibType(),
+                reinterpret_cast< uno_QueryInterfaceFunc >(cpp_queryInterface),
+                reinterpret_cast< uno_ReleaseFunc >(cpp_release)
+            );
+        return bEqual ? PropertyState_DEFAULT_VALUE : PropertyState_DIRECT_VALUE;
+    }
+
+    void OControlModel::setPropertyToDefaultByHandle( sal_Int32 _nHandle)
+    {
+        Any aDefault = getPropertyDefaultByHandle( _nHandle );
+        Any aConvertedValue, aOldValue;
+        if ( convertFastPropertyValue( aConvertedValue, aOldValue, _nHandle, aDefault ) )
+        {
+            setFastPropertyValue_NoBroadcast( _nHandle, aConvertedValue );
+            // TODO: fire the property change
         }
     }
-}
 
-//-----------------------------------------------------------------------------
-void OBoundControlModel::implInitAggMultiplexer( )
-{
-    increment( m_refCount );
-    if ( m_xAggregateSet.is() )
+    Any OControlModel::getPropertyDefaultByHandle( sal_Int32 _nHandle ) const
     {
-        m_pAggPropMultiplexer = new OPropertyChangeMultiplexer( this, m_xAggregateSet, false );
-        m_pAggPropMultiplexer->acquire();
-    }
-    decrement( m_refCount );
-
-       doSetDelegator();
-}
-
-//-----------------------------------------------------------------------------
-void OBoundControlModel::implInitValuePropertyListening( ) const
-{
-    // start listening for changes at the value property
-    // There are three pre-requisites for this to be done:
-    // 1. We support external value bindings. In this case, the changes in the control value need to
-    //    be propagated to the external binding immediately when they happen
-    // 2. We support external validation. In this case, we need to listen for changes in the value
-    //    property, since we need to revalidate then.
-    // 3. We are not committable. In this case, changes in the control value need to be propagated
-    //    to the database column immediately when they happen.
-    if ( m_bSupportsExternalBinding || m_bSupportsValidation || !m_bCommitable )
-    {
-        OSL_ENSURE( m_pAggPropMultiplexer, "OBoundControlModel::implInitValuePropertyListening: no multiplexer!" );
-        if ( m_pAggPropMultiplexer && !m_sValuePropertyName.isEmpty() )
-            m_pAggPropMultiplexer->addProperty( m_sValuePropertyName );
+        Any aReturn;
+        switch ( _nHandle )
+        {
+            case PROPERTY_ID_NAME:
+            case PROPERTY_ID_TAG:
+                aReturn <<= OUString();
+                break;
+            case PROPERTY_ID_CLASSID:
+                aReturn <<= (sal_Int16)FormComponentType::CONTROL;
+                break;
+            case PROPERTY_ID_TABINDEX:
+                aReturn <<= (sal_Int16)FRM_DEFAULT_TABINDEX;
+                break;
+            case PROPERTY_ID_NATIVE_LOOK:
+                aReturn <<= (sal_Bool)sal_True;
+                break;
+            case PROPERTY_ID_GENERATEVBAEVENTS:
+                aReturn <<= (sal_Bool)sal_False;
+                break;
+            // added for exporting OCX control
+            case PROPERTY_ID_CONTROL_TYPE_IN_MSO:
+                aReturn <<= (sal_Int16)0;
+                break;
+            case PROPERTY_ID_OBJ_ID_IN_MSO:
+                aReturn <<= (sal_uInt16)INVALID_OBJ_ID_IN_MSO;
+                break;
+            default:
+                if ( m_aPropertyBagHelper.hasDynamicPropertyByHandle( _nHandle ) )
+                    m_aPropertyBagHelper.getDynamicPropertyDefaultByHandle( _nHandle, aReturn );
+                else
+                    SAL_WARN("forms.component",  "OControlModel::convertFastPropertyValue: unknown handle " << _nHandle);
+        }
+        return aReturn;
     }
-}
-
-//-----------------------------------------------------------------------------
-void OBoundControlModel::initOwnValueProperty( const OUString& i_rValuePropertyName )
-{
-    OSL_PRECOND( m_sValuePropertyName.isEmpty() && -1 == m_nValuePropertyAggregateHandle,
-        "OBoundControlModel::initOwnValueProperty: value property is already initialized!" );
-    OSL_ENSURE( !i_rValuePropertyName.isEmpty(), "OBoundControlModel::initOwnValueProperty: invalid property name!" );
-    m_sValuePropertyName = i_rValuePropertyName;
-}
-
-//-----------------------------------------------------------------------------
-void OBoundControlModel::initValueProperty( const OUString& _rValuePropertyName, sal_Int32 _nValuePropertyExternalHandle )
-{
-    OSL_PRECOND( m_sValuePropertyName.isEmpty() && -1 == m_nValuePropertyAggregateHandle,
-        "OBoundControlModel::initValueProperty: value property is already initialized!" );
-    OSL_ENSURE( !_rValuePropertyName.isEmpty(), "OBoundControlModel::initValueProperty: invalid property name!" );
-    OSL_ENSURE( _nValuePropertyExternalHandle != -1, "OBoundControlModel::initValueProperty: invalid property handle!" );
-
-    m_sValuePropertyName = _rValuePropertyName;
-    m_nValuePropertyAggregateHandle = getOriginalHandle( _nValuePropertyExternalHandle );
-    OSL_ENSURE( m_nValuePropertyAggregateHandle != -1, "OBoundControlModel::initValueProperty: unable to find the original handle!" );
 
-    if ( m_nValuePropertyAggregateHandle != -1 )
+    void OControlModel::getFastPropertyValue( Any& _rValue, sal_Int32 _nHandle ) const
     {
-        Reference< XPropertySetInfo > xPropInfo( m_xAggregateSet->getPropertySetInfo(), UNO_SET_THROW );
-        Property aValuePropDesc = xPropInfo->getPropertyByName( m_sValuePropertyName );
-        m_aValuePropertyType = aValuePropDesc.Type;
-        m_bValuePropertyMayBeVoid = ( aValuePropDesc.Attributes & PropertyAttribute::MAYBEVOID ) != 0;
+        switch ( _nHandle )
+        {
+            case PROPERTY_ID_NAME:
+                _rValue <<= m_aName;
+                break;
+            case PROPERTY_ID_TAG:
+                _rValue <<= m_aTag;
+                break;
+            case PROPERTY_ID_CLASSID:
+                _rValue <<= m_nClassId;
+                break;
+            case PROPERTY_ID_TABINDEX:
+                _rValue <<= m_nTabIndex;
+                break;
+            case PROPERTY_ID_NATIVE_LOOK:
+                _rValue <<= (sal_Bool)m_bNativeLook;
+                break;
+            case PROPERTY_ID_GENERATEVBAEVENTS:
+                _rValue <<= (sal_Bool)m_bGenerateVbEvents;
+            // added for exporting OCX control
+            case PROPERTY_ID_CONTROL_TYPE_IN_MSO:
+                _rValue <<= (sal_Int16)m_nControlTypeinMSO;
+                break;
+            case PROPERTY_ID_OBJ_ID_IN_MSO:
+                _rValue <<= (sal_uInt16)m_nObjIDinMSO;
+                break;
+            default:
+                if ( m_aPropertyBagHelper.hasDynamicPropertyByHandle( _nHandle ) )
+                    m_aPropertyBagHelper.getDynamicFastPropertyValue( _nHandle, _rValue );
+                else
+                    OPropertySetAggregationHelper::getFastPropertyValue( _rValue, _nHandle );
+                break;
+        }
     }
 
-    // start listening for changes at the value property
-    implInitValuePropertyListening( );
-}
-
-//-----------------------------------------------------------------------------
-void OBoundControlModel::suspendValueListening( )
-{
-    OSL_PRECOND( !m_sValuePropertyName.isEmpty(), "OBoundControlModel::suspendValueListening: don't have a value property!" );
-    OSL_PRECOND( m_pAggPropMultiplexer, "OBoundControlModel::suspendValueListening: I *am* not listening!" );
-
-    if ( m_pAggPropMultiplexer )
-        m_pAggPropMultiplexer->lock();
-}
-
-//-----------------------------------------------------------------------------
-void OBoundControlModel::resumeValueListening( )
-{
-    OSL_PRECOND( !m_sValuePropertyName.isEmpty(), "OBoundControlModel::resumeValueListening: don't have a value property!" );
-    OSL_PRECOND( m_pAggPropMultiplexer, "OBoundControlModel::resumeValueListening: I *am* not listening at all!" );
-    OSL_PRECOND( !m_pAggPropMultiplexer || m_pAggPropMultiplexer->locked(), "OBoundControlModel::resumeValueListening: listening not suspended currently!" );
-
-    if ( m_pAggPropMultiplexer )
-        m_pAggPropMultiplexer->unlock();
-}
-
-//-----------------------------------------------------------------------------
-Sequence< Type > OBoundControlModel::_getTypes()
-{
-    TypeBag aTypes(
-        OControlModel::_getTypes(),
-        OBoundControlModel_BASE1::getTypes()
-    );
-
-    if ( m_bCommitable )
-        aTypes.addTypes( OBoundControlModel_COMMITTING::getTypes() );
-
-    if ( m_bSupportsExternalBinding )
-        aTypes.addTypes( OBoundControlModel_BINDING::getTypes() );
-
-    if ( m_bSupportsValidation )
-        aTypes.addTypes( OBoundControlModel_VALIDATION::getTypes() );
-
-    return aTypes.getTypes();
-}
-
-// OComponentHelper
-//-----------------------------------------------------------------------------
-void OBoundControlModel::disposing()
-{
-    OControlModel::disposing();
-
-    ::osl::ClearableMutexGuard aGuard(m_aMutex);
-
-    if ( m_pAggPropMultiplexer )
-        m_pAggPropMultiplexer->dispose();
-
-    // notify all our listeners
-    com::sun::star::lang::EventObject aEvt( static_cast< XWeak* >( this ) );
-    m_aUpdateListeners.disposeAndClear( aEvt );
-    m_aResetHelper.disposing();
+    sal_Bool OControlModel::convertFastPropertyValue(
+                            Any& _rConvertedValue, Any& _rOldValue, sal_Int32 _nHandle, const Any& _rValue)
+                            throw (com::sun::star::lang::IllegalArgumentException)
+    {
+        sal_Bool bModified(sal_False);
+        switch (_nHandle)
+        {
+            case PROPERTY_ID_NAME:
+                bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_aName);
+                break;
+            case PROPERTY_ID_TAG:
+                bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_aTag);
+                break;
+            case PROPERTY_ID_TABINDEX:
+                bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_nTabIndex);
+                break;
+            case PROPERTY_ID_NATIVE_LOOK:
+                bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_bNativeLook);
+                break;
+            case PROPERTY_ID_GENERATEVBAEVENTS:
+                bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_bGenerateVbEvents);
+                break;
+            // added for exporting OCX control
+            case PROPERTY_ID_CONTROL_TYPE_IN_MSO:
+                bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_nControlTypeinMSO);
+                break;
+            case PROPERTY_ID_OBJ_ID_IN_MSO:
+                bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_nObjIDinMSO);
+                break;
+            default:
+                if ( m_aPropertyBagHelper.hasDynamicPropertyByHandle( _nHandle ) )
+                    bModified = m_aPropertyBagHelper.convertDynamicFastPropertyValue( _nHandle, _rValue, _rConvertedValue, _rOldValue );
+                else
+                    SAL_WARN("forms.component",  "OControlModel::convertFastPropertyValue: unknown handle " << _nHandle);
+                break;
+        }
+        return bModified;
+    }
 
-    // disconnect from our database column
-    // TODO: could we replace the following 5 lines with a call to impl_disconnectDatabaseColumn_noNotify?
-    // The only more thing which it does is calling onDisconnectedDbColumn - could this
-    // cause trouble? At least when we continue to call OControlModel::disposing before, it *may*.
-    if ( hasField() )
+    void OControlModel::setFastPropertyValue_NoBroadcast(sal_Int32 _nHandle, const Any& _rValue)
+                            throw (Exception)
     {
-        getField()->removePropertyChangeListener( PROPERTY_VALUE, this );
-        resetField();
+        switch (_nHandle)
+        {
+            case PROPERTY_ID_NAME:
+                DBG_ASSERT(_rValue.getValueType() == getCppuType((const OUString*)NULL),
+                    "OControlModel::setFastPropertyValue_NoBroadcast : invalid type" );
+                _rValue >>= m_aName;
+                break;
+            case PROPERTY_ID_TAG:
+                DBG_ASSERT(_rValue.getValueType() == getCppuType((const OUString*)NULL),
+                    "OControlModel::setFastPropertyValue_NoBroadcast : invalid type" );
+                _rValue >>= m_aTag;
+                break;
+            case PROPERTY_ID_TABINDEX:
+                DBG_ASSERT(_rValue.getValueType() == getCppuType((const sal_Int16*)NULL),
+                    "OControlModel::setFastPropertyValue_NoBroadcast : invalid type" );
+                _rValue >>= m_nTabIndex;
+                break;
+            case PROPERTY_ID_NATIVE_LOOK:
+                OSL_VERIFY( _rValue >>= m_bNativeLook );
+                break;
+            case PROPERTY_ID_GENERATEVBAEVENTS:
+                OSL_VERIFY( _rValue >>= m_bGenerateVbEvents );
+                break;
+            // added for exporting OCX control
+            case PROPERTY_ID_CONTROL_TYPE_IN_MSO:
+                OSL_VERIFY( _rValue >>= m_nControlTypeinMSO );
+                break;
+            case PROPERTY_ID_OBJ_ID_IN_MSO:
+                OSL_VERIFY( _rValue >>= m_nObjIDinMSO );
+                break;
+            default:
+                if ( m_aPropertyBagHelper.hasDynamicPropertyByHandle( _nHandle ) )
+                    m_aPropertyBagHelper.setDynamicFastPropertyValue( _nHandle, _rValue );
+                else
+                    SAL_WARN("forms.component",  "OControlModel::setFastPropertyValue_NoBroadcast: unknown handle " << _nHandle );
+                break;
+        }
     }
-    m_xCursor = NULL;
-
-    Reference< XComponent > xComp( m_xLabelControl, UNO_QUERY );
-    if ( xComp.is() )
-        xComp->removeEventListener(static_cast< XEventListener* >( static_cast< XPropertyChangeListener* >( this ) ) );
-
-    // disconnect from our external value binding
-    if ( hasExternalValueBinding() )
-        disconnectExternalValueBinding();
 
-    // dito for the validator
-    if ( hasValidator() )
-        disconnectValidator( );
-}
-
-//------------------------------------------------------------------------------
-void OBoundControlModel::onValuePropertyChange( ControlModelLock& i_rControLock )
-{
-    if ( hasExternalValueBinding() )
-    {   // the control value changed, while we have an external value binding
-        // -> forward the value to it
-        if ( m_eControlValueChangeInstigator != eExternalBinding )
-            transferControlValueToExternal( i_rControLock );
-    }
-    else if ( !m_bCommitable && m_xColumnUpdate.is() )
-    {   // the control value changed, while we are  bound to a database column,
-        // but not committable (which means changes in the control have to be reflected to
-        // the underlying database column immediately)
-        // -> forward the value to the database column
-        if ( m_eControlValueChangeInstigator != eDbColumnBinding )
-            commitControlValueToDbColumn( false );
-    }
-
-    // validate the new value
-    if ( m_bSupportsValidation )
-        recheckValidity( true );
-}
-
-//------------------------------------------------------------------------------
-void OBoundControlModel::_propertyChanged( const PropertyChangeEvent& _rEvt ) throw ( RuntimeException )
-{
-    ControlModelLock aLock( *this );
-
-    OSL_ENSURE( _rEvt.PropertyName == m_sValuePropertyName,
-        "OBoundControlModel::_propertyChanged: where did this come from (1)?" );
-    OSL_ENSURE( m_pAggPropMultiplexer && !m_pAggPropMultiplexer->locked(),
-        "OBoundControlModel::_propertyChanged: where did this come from (2)?" );
-
-    if ( _rEvt.PropertyName == m_sValuePropertyName )
+    void OControlModel::describeFixedProperties( Sequence< Property >& _rProps ) const
     {
-        onValuePropertyChange( aLock );
+        BEGIN_DESCRIBE_BASE_PROPERTIES( 7 )
+            DECL_PROP2      (CLASSID,     sal_Int16,        READONLY, TRANSIENT);
+            DECL_PROP1      (NAME,        OUString,  BOUND);
+            DECL_BOOL_PROP2 (NATIVE_LOOK,                   BOUND, TRANSIENT);
+            DECL_PROP1      (TAG,         OUString,  BOUND);
+            DECL_PROP1      (GENERATEVBAEVENTS,         sal_Bool,  TRANSIENT);
+            DECL_PROP1      (CONTROL_TYPE_IN_MSO,sal_Int16,     BOUND);
+            DECL_PROP1      (OBJ_ID_IN_MSO,sal_uInt16,      BOUND);
+        END_DESCRIBE_PROPERTIES()
     }
-}
-
-//------------------------------------------------------------------------------
-void OBoundControlModel::startAggregatePropertyListening( const OUString& _rPropertyName )
-{
-    OSL_PRECOND( m_pAggPropMultiplexer, "OBoundControlModel::startAggregatePropertyListening: no multiplexer!" );
-    OSL_ENSURE( !_rPropertyName.isEmpty(), "OBoundControlModel::startAggregatePropertyListening: invalid property name!" );
 
-    if ( m_pAggPropMultiplexer && !_rPropertyName.isEmpty() )
+    void OControlModel::describeAggregateProperties( Sequence< Property >& /* [out] */ _rAggregateProps ) const
     {
-        m_pAggPropMultiplexer->addProperty( _rPropertyName );
+        if ( m_xAggregateSet.is() )
+        {
+            Reference< XPropertySetInfo > xPSI( m_xAggregateSet->getPropertySetInfo() );
+            if ( xPSI.is() )
+                _rAggregateProps = xPSI->getProperties();
+        }
     }
-}
-
-//------------------------------------------------------------------------------
-void OBoundControlModel::doFormListening( const bool _bStart )
-{
-    OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::doFormListening: external value binding should overrule the database binding!" );
-
-    if ( isFormListening() == _bStart )
-        return;
 
-    if ( m_xAmbientForm.is() )
-        _bStart ? m_xAmbientForm->addLoadListener( this ) : m_xAmbientForm->removeLoadListener( this );
-
-    Reference< XLoadable > xParentLoadable( getParent(), UNO_QUERY );
-    if ( getParent().is() && !xParentLoadable.is() )
+    ::osl::Mutex& OControlModel::getMutex()
     {
-        // if our parent does not directly support the XLoadable interface, then it might support the
-        // XRowSetSupplier/XRowSetChangeBroadcaster interfaces. In this case we have to listen for changes
-        // broadcasted by the latter.
-        Reference< XRowSetChangeBroadcaster > xRowSetBroadcaster( getParent(), UNO_QUERY );
-        if ( xRowSetBroadcaster.is() )
-            _bStart ? xRowSetBroadcaster->addRowSetChangeListener( this ) : xRowSetBroadcaster->removeRowSetChangeListener( this );
+        return m_aMutex;
     }
 
-    m_bFormListening = _bStart && m_xAmbientForm.is();
-}
-
-// XChild
-//------------------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::setParent(const Reference<XInterface>& _rxParent) throw(com::sun::star::lang::NoSupportException, RuntimeException)
-{
-    ControlModelLock aLock( *this );
-    FieldChangeNotifier aBoundFieldNotifier( aLock );
-
-    if ( getParent() == _rxParent )
-        return;
-
-    // disconnect from database column (which is controlled by parent, directly or indirectly)
-    if ( hasField() )
-        impl_disconnectDatabaseColumn_noNotify();
-
-    // log off old listeners
-    if ( isFormListening() )
-        doFormListening( false );
-
-    // actually set the new parent
-    OControlModel::setParent( _rxParent );
-
-    // a new parent means a new ambient form
-    impl_determineAmbientForm_nothrow();
-
-    if ( !hasExternalValueBinding() )
+    void OControlModel::describeFixedAndAggregateProperties( Sequence< Property >& _out_rFixedProperties, Sequence< Property >& _out_rAggregateProperties ) const
     {
-        // log on new listeners
-        doFormListening( true );
-
-        // re-connect to database column of the new parent
-        if ( m_xAmbientForm.is() && m_xAmbientForm->isLoaded() )
-            impl_connectDatabaseColumn_noNotify( false );
+        describeFixedProperties( _out_rFixedProperties );
+        describeAggregateProperties( _out_rAggregateProperties );
     }
-}
 
-// XEventListener
-//------------------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::disposing(const com::sun::star::lang::EventObject& _rEvent) throw (RuntimeException)
-{
-    ControlModelLock aLock( *this );
-
-    if ( _rEvent.Source == getField() )
+    Reference< XMultiPropertySet > OControlModel::getPropertiesInterface()
     {
-        resetField();
+        return Reference< XMultiPropertySet >( *this, UNO_QUERY );
     }
-    else if ( _rEvent.Source == m_xLabelControl )
-    {
-        Reference<XPropertySet> xOldValue = m_xLabelControl;
-        m_xLabelControl = NULL;
 
-        // fire a propertyChanged (when we leave aLock's scope)
-        aLock.addPropertyNotification( PROPERTY_ID_CONTROLLABEL, makeAny( xOldValue ), makeAny( m_xLabelControl ) );
-    }
-    else if ( _rEvent.Source == m_xExternalBinding )
-    {   // *first* check for the external binding
-        disconnectExternalValueBinding( );
-    }
-    else if ( _rEvent.Source == m_xValidator )
-    {   // *then* check for the validator. Reason is that bindings may also act as validator at the same
-        // time, in this case, the validator is automatically revoked when the binding is revoked
-        disconnectValidator( );
+    Reference< XPropertySetInfo> SAL_CALL OControlModel::getPropertySetInfo() throw( RuntimeException)
+    {
+        return createPropertySetInfo( getInfoHelper() );
     }
-    else
-        OControlModel::disposing(_rEvent);
-}
-
-// XServiceInfo
-//------------------------------------------------------------------------------
-StringSequence SAL_CALL OBoundControlModel::getSupportedServiceNames() throw(RuntimeException)
-{
-    return ::comphelper::concatSequences(
-        getAggregateServiceNames(),
-        getSupportedServiceNames_Static()
-    );
-}
-
-//------------------------------------------------------------------------------
-Sequence< OUString > SAL_CALL OBoundControlModel::getSupportedServiceNames_Static() throw( RuntimeException )
-{
-    Sequence< OUString > aOwnServiceNames( 1 );
-    aOwnServiceNames[ 0 ] = "com.sun.star.form.DataAwareControlModel";
-
-    return ::comphelper::concatSequences(
-        OControlModel::getSupportedServiceNames_Static(),
-        aOwnServiceNames
-    );
-}
-
-// XPersist
-//------------------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::write( const Reference<stario::XObjectOutputStream>& _rxOutStream ) throw(stario::IOException, RuntimeException)
-{
-    OControlModel::write(_rxOutStream);
 
-    osl::MutexGuard aGuard(m_aMutex);
+    ::cppu::IPropertyArrayHelper& OControlModel::getInfoHelper()
+    {
+        return m_aPropertyBagHelper.getInfoHelper();
+    }
 
-    // Version
-    _rxOutStream->writeShort(0x0002);
+    void SAL_CALL OControlModel::addProperty( const OUString& _rName, ::sal_Int16 _nAttributes, const Any& _rInitialValue ) throw (PropertyExistException, IllegalTypeException, IllegalArgumentException, RuntimeException)
+    {
+        m_aPropertyBagHelper.addProperty( _rName, _nAttributes, _rInitialValue );
+    }
 
-    // Controlsource
-    ::comphelper::operator<<( _rxOutStream, m_aControlSource);
+    void SAL_CALL OControlModel::removeProperty( const OUString& _rName ) throw (UnknownPropertyException, NotRemoveableException, RuntimeException)
+    {
+        m_aPropertyBagHelper.removeProperty( _rName );
+    }
 
-    // !!! IMPORTANT NOTE !!!
-    // don't write any new members here : this wouldn't be compatible with older versions, as OBoundControlModel
-    // is a base class which is called in derived classes "read" method. So if you increment the version
-    // and write new stuff, older office versions will read this in the _derived_ classes, which may result
-    // in anything from data loss to crash.
-    // (use writeCommonProperties instead, this is called in derived classes write-method)
-    // !!! EOIN !!!
-}
+    Sequence< PropertyValue > SAL_CALL OControlModel::getPropertyValues() throw (RuntimeException)
+    {
+        return m_aPropertyBagHelper.getPropertyValues();
+    }
 
-//------------------------------------------------------------------------------
-void OBoundControlModel::defaultCommonProperties()
-{
-    Reference<com::sun::star::lang::XComponent> xComp(m_xLabelControl, UNO_QUERY);
-    if (xComp.is())
-        xComp->removeEventListener(static_cast<com::sun::star::lang::XEventListener*>(static_cast<XPropertyChangeListener*>(this)));
-    m_xLabelControl = NULL;
-}
+    void SAL_CALL OControlModel::setPropertyValues( const Sequence< PropertyValue >& _rProps ) throw (UnknownPropertyException, PropertyVetoException, IllegalArgumentException, WrappedTargetException, RuntimeException)
+    {
+        m_aPropertyBagHelper.setPropertyValues( _rProps );
+    }
 
-//------------------------------------------------------------------------------
-void OBoundControlModel::readCommonProperties(const Reference<stario::XObjectInputStream>& _rxInStream)
-{
-    sal_Int32 nLen = _rxInStream->readLong();
-
-    Reference<stario::XMarkableStream> xMark(_rxInStream, UNO_QUERY);
-    DBG_ASSERT(xMark.is(), "OBoundControlModel::readCommonProperties : can only work with markable streams !");
-    sal_Int32 nMark = xMark->createMark();
-
-    // read the reference to the label control
-    Reference<stario::XPersistObject> xPersist;
-    sal_Int32 nUsedFlag;
-    nUsedFlag = _rxInStream->readLong();
-    if (nUsedFlag)
-        xPersist = _rxInStream->readObject();
-    m_xLabelControl = m_xLabelControl.query( xPersist );
-    Reference< XComponent > xComp( m_xLabelControl, UNO_QUERY );
-    if (xComp.is())
-        xComp->addEventListener(static_cast<com::sun::star::lang::XEventListener*>(static_cast<XPropertyChangeListener*>(this)));
-
-    // read any other new common properties here
-
-    // skip the remaining bytes
-    xMark->jumpToMark(nMark);
-    _rxInStream->skipBytes(nLen);
-    xMark->deleteMark(nMark);
-}
+    void OControlModel::lockInstance( LockAccess )
+    {
+        m_aMutex.acquire();
+        osl_atomic_increment( &m_lockCount );
+    }
 
-//------------------------------------------------------------------------------
-void OBoundControlModel::writeCommonProperties(const Reference<stario::XObjectOutputStream>& _rxOutStream)
-{
-    Reference<stario::XMarkableStream> xMark(_rxOutStream, UNO_QUERY);
-    DBG_ASSERT(xMark.is(), "OBoundControlModel::writeCommonProperties : can only work with markable streams !");
-    sal_Int32 nMark = xMark->createMark();
-
-    // a placeholder where we will write the overall length (later in this method)
-    sal_Int32 nLen = 0;
-    _rxOutStream->writeLong(nLen);
-
-    // write the reference to the label control
-    Reference<stario::XPersistObject> xPersist(m_xLabelControl, UNO_QUERY);
-    sal_Int32 nUsedFlag = 0;
-    if (xPersist.is())
-        nUsedFlag = 1;
-    _rxOutStream->writeLong(nUsedFlag);
-    if (xPersist.is())
-        _rxOutStream->writeObject(xPersist);
-
-    // write any other new common properties here
-
-    // write the correct length at the beginning of the block
-    nLen = xMark->offsetToMark(nMark) - sizeof(nLen);
-    xMark->jumpToMark(nMark);
-    _rxOutStream->writeLong(nLen);
-    xMark->jumpToFurthest();
-    xMark->deleteMark(nMark);
-}
+    oslInterlockedCount OControlModel::unlockInstance( LockAccess )
+    {
+        OSL_ENSURE( m_lockCount > 0, "OControlModel::unlockInstance: not locked!" );
+        oslInterlockedCount lockCount = osl_atomic_decrement( &m_lockCount );
+        m_aMutex.release();
+        return lockCount;
+    }
 
-//------------------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::read( const Reference< stario::XObjectInputStream >& _rxInStream ) throw(stario::IOException, RuntimeException)
-{
-    OControlModel::read(_rxInStream);
+    void OControlModel::firePropertyChanges( const Sequence< sal_Int32 >& _rHandles, const Sequence< Any >& _rOldValues,
+                                            const Sequence< Any >& _rNewValues, LockAccess )
+    {
+        OPropertySetHelper::fire(
+            const_cast< Sequence< sal_Int32 >& >( _rHandles ).getArray(),
+            _rNewValues.getConstArray(),
+            _rOldValues.getConstArray(),
+            _rHandles.getLength(),
+            sal_False
+        );
+    }
 
-    osl::MutexGuard aGuard(m_aMutex);
-    sal_uInt16 nVersion = _rxInStream->readShort(); (void)nVersion;
-    ::comphelper::operator>>( _rxInStream, m_aControlSource);
-}
+    // OBoundControlModel
 
-//------------------------------------------------------------------------------
-void OBoundControlModel::getFastPropertyValue(Any& rValue, sal_Int32 nHandle) const
-{
-    switch (nHandle)
+    Any SAL_CALL OBoundControlModel::queryAggregation( const Type& _rType ) throw (RuntimeException)
     {
-        case PROPERTY_ID_INPUT_REQUIRED:
-            rValue <<= m_bInputRequired;
-            break;
-        case PROPERTY_ID_CONTROLSOURCEPROPERTY:
-            rValue <<= m_sValuePropertyName;
-            break;
-        case PROPERTY_ID_CONTROLSOURCE:
-            rValue <<= m_aControlSource;
-            break;
-        case PROPERTY_ID_BOUNDFIELD:
-            rValue <<= getField();
-            break;
-        case PROPERTY_ID_CONTROLLABEL:
-            if (!m_xLabelControl.is())
-                rValue.clear();
-            else
-                rValue <<= m_xLabelControl;
-            break;
-        default:
-            OControlModel::getFastPropertyValue(rValue, nHandle);
+        Any aReturn( OControlModel::queryAggregation(_rType) );
+        if (!aReturn.hasValue())
+        {
+            aReturn = OBoundControlModel_BASE1::queryInterface(_rType);
+            if ( !aReturn.hasValue() && m_bCommitable )
+                aReturn = OBoundControlModel_COMMITTING::queryInterface( _rType );
+            if ( !aReturn.hasValue() && m_bSupportsExternalBinding )
+                aReturn = OBoundControlModel_BINDING::queryInterface( _rType );
+            if ( !aReturn.hasValue() && m_bSupportsValidation )
+                aReturn = OBoundControlModel_VALIDATION::queryInterface( _rType );
+        }
+        return aReturn;
+    }
+
+    OBoundControlModel::OBoundControlModel(
+            const Reference< XComponentContext>& _rxFactory,
+            const OUString& _rUnoControlModelTypeName, const OUString& _rDefault,
+            const sal_Bool _bCommitable, const sal_Bool _bSupportExternalBinding, const sal_Bool _bSupportsValidation )
+        :OControlModel( _rxFactory, _rUnoControlModelTypeName, _rDefault, sal_False )
+        ,OPropertyChangeListener( m_aMutex )
+        ,m_xField()
+        ,m_xAmbientForm()
+        ,m_nValuePropertyAggregateHandle( -1 )
+        ,m_nFieldType( DataType::OTHER )
+        ,m_bValuePropertyMayBeVoid( false )
+        ,m_aResetHelper( *this, m_aMutex )
+        ,m_aUpdateListeners(m_aMutex)
+        ,m_aFormComponentListeners( m_aMutex )
+        ,m_bInputRequired( sal_True )
+        ,m_pAggPropMultiplexer( NULL )
+        ,m_bFormListening( false )
+        ,m_bLoaded(sal_False)
+        ,m_bRequired(sal_False)
+        ,m_bCommitable(_bCommitable)
+        ,m_bSupportsExternalBinding( _bSupportExternalBinding )
+        ,m_bSupportsValidation( _bSupportsValidation )
+        ,m_bForwardValueChanges(sal_True)
+        ,m_bTransferingValue( sal_False )
+        ,m_bIsCurrentValueValid( sal_True )
+        ,m_bBindingControlsRO( sal_False )
+        ,m_bBindingControlsEnable( sal_False )
+        ,m_eControlValueChangeInstigator( eOther )
+        ,m_aLabelServiceName(FRM_SUN_COMPONENT_FIXEDTEXT)
+    {
+        // start property listening at the aggregate
+        implInitAggMultiplexer( );
+    }
+
+    OBoundControlModel::OBoundControlModel(
+            const OBoundControlModel* _pOriginal, const Reference< XComponentContext>& _rxFactory )
+        :OControlModel( _pOriginal, _rxFactory, sal_True, sal_False )
+        ,OPropertyChangeListener( m_aMutex )
+        ,m_xField()
+        ,m_xAmbientForm()
+        ,m_nValuePropertyAggregateHandle( _pOriginal->m_nValuePropertyAggregateHandle )
+        ,m_nFieldType( DataType::OTHER )
+        ,m_bValuePropertyMayBeVoid( _pOriginal->m_bValuePropertyMayBeVoid )
+        ,m_aResetHelper( *this, m_aMutex )
+        ,m_aUpdateListeners( m_aMutex )
+        ,m_aFormComponentListeners( m_aMutex )
+        ,m_xValidator( _pOriginal->m_xValidator )
+        ,m_bInputRequired( sal_True )
+        ,m_pAggPropMultiplexer( NULL )
+        ,m_bFormListening( false )
+        ,m_bLoaded( sal_False )
+        ,m_bRequired( sal_False )
+        ,m_bCommitable( _pOriginal->m_bCommitable )
+        ,m_bSupportsExternalBinding( _pOriginal->m_bSupportsExternalBinding )
+        ,m_bSupportsValidation( _pOriginal->m_bSupportsValidation )
+        ,m_bForwardValueChanges( sal_True )
+        ,m_bTransferingValue( sal_False )
+        ,m_bIsCurrentValueValid( _pOriginal->m_bIsCurrentValueValid )
+        ,m_bBindingControlsRO( sal_False )
+        ,m_bBindingControlsEnable( sal_False )
+        ,m_eControlValueChangeInstigator( eOther )
+    {
+        // start property listening at the aggregate
+        implInitAggMultiplexer( );
+        m_aLabelServiceName = _pOriginal->m_aLabelServiceName;
+        m_sValuePropertyName = _pOriginal->m_sValuePropertyName;
+        m_nValuePropertyAggregateHandle = _pOriginal->m_nValuePropertyAggregateHandle;
+        m_bValuePropertyMayBeVoid = _pOriginal->m_bValuePropertyMayBeVoid;
+        m_aValuePropertyType = _pOriginal->m_aValuePropertyType;
+        m_aControlSource = _pOriginal->m_aControlSource;
+        m_bInputRequired = _pOriginal->m_bInputRequired;
+        // m_xLabelControl, though being a property, is not to be cloned, not even the reference will be transferred.
+        // (the former should be clear - a clone of the object we're only referencing does not make sense)
+        // (the second would violate the restriction for label controls that they're part of the
+        // same form component hierarchy - we ourself are no part, yet, so we can't have a label control)
+        // start listening for changes at the value property
+        implInitValuePropertyListening( );
+    }
+
+    OBoundControlModel::~OBoundControlModel()
+    {
+        if ( !OComponentHelper::rBHelper.bDisposed )
+        {
+            acquire();
+            dispose();
+        }
+        doResetDelegator( );
+        OSL_ENSURE( m_pAggPropMultiplexer, "OBoundControlModel::~OBoundControlModel: what about my property multiplexer?" );
+        if ( m_pAggPropMultiplexer )
+        {
+            m_pAggPropMultiplexer->dispose();
+            m_pAggPropMultiplexer->release();
+            m_pAggPropMultiplexer = NULL;
+        }
     }
-}
 
-//------------------------------------------------------------------------------
-sal_Bool OBoundControlModel::convertFastPropertyValue(
-                                Any& _rConvertedValue, Any& _rOldValue,
-                sal_Int32 _nHandle,
-                                const Any& _rValue)
-                throw (com::sun::star::lang::IllegalArgumentException)
-{
-    sal_Bool bModified(sal_False);
-    switch (_nHandle)
+    void OBoundControlModel::clonedFrom( const OControlModel* _pOriginal )
     {
-        case PROPERTY_ID_INPUT_REQUIRED:
-            bModified = tryPropertyValue( _rConvertedValue, _rOldValue, _rValue, m_bInputRequired );
-            break;
-        case PROPERTY_ID_CONTROLSOURCE:
-            bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_aControlSource);
-            break;
-        case PROPERTY_ID_BOUNDFIELD:
-            SAL_WARN("forms.component",  "OBoundControlModel::convertFastPropertyValue: BoundField should be a read-only property !" );
-            throw com::sun::star::lang::IllegalArgumentException();
-        case PROPERTY_ID_CONTROLLABEL:
-            if (!_rValue.hasValue())
-            {   // property set to void
-                _rConvertedValue = Any();
-                getFastPropertyValue(_rOldValue, _nHandle);
-                bModified = m_xLabelControl.is();
+        const OBoundControlModel* pBoundOriginal = static_cast< const OBoundControlModel* >( _pOriginal );
+        // the value binding can be handled as if somebody called setValueBinding here
+        // By definition, bindings can be share between bindables
+        if ( pBoundOriginal && pBoundOriginal->m_xExternalBinding.is() )
+        {
+            try
+            {
+                setValueBinding( pBoundOriginal->m_xExternalBinding );
             }
-            else
+            catch( const Exception& )
             {
-                bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_xLabelControl);
-                if (!m_xLabelControl.is())
-                    // an empty interface is interpreted as VOID
-                    _rOldValue.clear();
+                DBG_UNHANDLED_EXCEPTION();
             }
-            break;
-        default:
-            bModified = OControlModel::convertFastPropertyValue(_rConvertedValue, _rOldValue, _nHandle, _rValue);
+        }
     }
-    return bModified;
-}
 
-//------------------------------------------------------------------------------
-Any OBoundControlModel::getPropertyDefaultByHandle( sal_Int32 _nHandle ) const
-{
-    Any aDefault;
-    switch ( _nHandle )
+    void OBoundControlModel::implInitAggMultiplexer( )
     {
-        case PROPERTY_ID_INPUT_REQUIRED:
-            aDefault <<= sal_Bool( sal_True );
-            break;
-
-        case PROPERTY_ID_CONTROLSOURCE:
-            aDefault <<= OUString();
-            break;
-
-        case PROPERTY_ID_CONTROLLABEL:
-            aDefault <<= Reference< XPropertySet >();
-            break;
+        increment( m_refCount );
+        if ( m_xAggregateSet.is() )
+        {
+            m_pAggPropMultiplexer = new OPropertyChangeMultiplexer( this, m_xAggregateSet, false );
+            m_pAggPropMultiplexer->acquire();
+        }
+        decrement( m_refCount );
+           doSetDelegator();
     }
-    return aDefault;
-}
 
-//------------------------------------------------------------------------------
-void OBoundControlModel::setFastPropertyValue_NoBroadcast( sal_Int32 nHandle, const Any& rValue ) throw (Exception)
-{
-    switch (nHandle)
+    void OBoundControlModel::implInitValuePropertyListening( ) const
     {
-        case PROPERTY_ID_INPUT_REQUIRED:
-            OSL_VERIFY( rValue >>= m_bInputRequired );
-            break;
-        case PROPERTY_ID_CONTROLSOURCE:
-            OSL_VERIFY( rValue >>= m_aControlSource );
-            break;
-        case PROPERTY_ID_BOUNDFIELD:
-            SAL_WARN("forms.component", "OBoundControlModel::setFastPropertyValue_NoBroadcast : BoundField should be a read-only property !");
-            throw com::sun::star::lang::IllegalArgumentException();
-        case PROPERTY_ID_CONTROLLABEL:
+        // start listening for changes at the value property
+        // There are three pre-requisites for this to be done:
+        // 1. We support external value bindings. In this case, the changes in the control value need to
+        //    be propagated to the external binding immediately when they happen
+        // 2. We support external validation. In this case, we need to listen for changes in the value
+        //    property, since we need to revalidate then.
+        // 3. We are not committable. In this case, changes in the control value need to be propagated
+        //    to the database column immediately when they happen.
+        if ( m_bSupportsExternalBinding || m_bSupportsValidation || !m_bCommitable )
         {
-            if ( rValue.hasValue() && ( rValue.getValueTypeClass() != TypeClass_INTERFACE ) )
-                throw com::sun::star::lang::IllegalArgumentException();
-
-            Reference< XInterface > xNewValue( rValue, UNO_QUERY );
-            if ( !xNewValue.is() )
-            {   // set property to "void"
-                Reference< XComponent > xComp( m_xLabelControl, UNO_QUERY );
-                if ( xComp.is() )
-                    xComp->removeEventListener( static_cast< XPropertyChangeListener* >( this ) );
-                m_xLabelControl = NULL;
-                break;
-            }
+            OSL_ENSURE( m_pAggPropMultiplexer, "OBoundControlModel::implInitValuePropertyListening: no multiplexer!" );
+            if ( m_pAggPropMultiplexer && !m_sValuePropertyName.isEmpty() )
+                m_pAggPropMultiplexer->addProperty( m_sValuePropertyName );
+        }
+    }
 
-            Reference< XControlModel >  xAsModel        ( xNewValue,        UNO_QUERY );
-            Reference< XServiceInfo >   xAsServiceInfo  ( xAsModel,         UNO_QUERY );
-            Reference< XPropertySet >   xAsPropSet      ( xAsServiceInfo,   UNO_QUERY );
-            Reference< XChild >         xAsChild        ( xAsPropSet,       UNO_QUERY );
-            if ( !xAsChild.is() || !xAsServiceInfo->supportsService( m_aLabelServiceName ) )
-            {
-                throw com::sun::star::lang::IllegalArgumentException();
-            }
+    void OBoundControlModel::initOwnValueProperty( const OUString& i_rValuePropertyName )
+    {
+        OSL_PRECOND( m_sValuePropertyName.isEmpty() && -1 == m_nValuePropertyAggregateHandle,
+            "OBoundControlModel::initOwnValueProperty: value property is already initialized!" );
+        OSL_ENSURE( !i_rValuePropertyName.isEmpty(), "OBoundControlModel::initOwnValueProperty: invalid property name!" );
+        m_sValuePropertyName = i_rValuePropertyName;
+    }
 
-            // check if weself and the given model have a common anchestor (up to the forms collection)
-            Reference<XChild> xCont;
-            query_interface(static_cast<XWeak*>(this), xCont);
-            Reference< XInterface > xMyTopLevel = xCont->getParent();
-            while (xMyTopLevel.is())
-            {
-                Reference<XForm> xAsForm(xMyTopLevel, UNO_QUERY);
-                if (!xAsForm.is())
-                    // found my root
-                    break;
+    void OBoundControlModel::initValueProperty( const OUString& _rValuePropertyName, sal_Int32 _nValuePropertyExternalHandle )
+    {
+        OSL_PRECOND( m_sValuePropertyName.isEmpty() && -1 == m_nValuePropertyAggregateHandle,
+            "OBoundControlModel::initValueProperty: value property is already initialized!" );
+        OSL_ENSURE( !_rValuePropertyName.isEmpty(), "OBoundControlModel::initValueProperty: invalid property name!" );
+        OSL_ENSURE( _nValuePropertyExternalHandle != -1, "OBoundControlModel::initValueProperty: invalid property handle!" );
+        m_sValuePropertyName = _rValuePropertyName;
+        m_nValuePropertyAggregateHandle = getOriginalHandle( _nValuePropertyExternalHandle );
+        OSL_ENSURE( m_nValuePropertyAggregateHandle != -1, "OBoundControlModel::initValueProperty: unable to find the original handle!" );
+        if ( m_nValuePropertyAggregateHandle != -1 )
+        {
+            Reference< XPropertySetInfo > xPropInfo( m_xAggregateSet->getPropertySetInfo(), UNO_SET_THROW );
+            Property aValuePropDesc = xPropInfo->getPropertyByName( m_sValuePropertyName );
+            m_aValuePropertyType = aValuePropDesc.Type;
+            m_bValuePropertyMayBeVoid = ( aValuePropDesc.Attributes & PropertyAttribute::MAYBEVOID ) != 0;
+        }
+        // start listening for changes at the value property
+        implInitValuePropertyListening( );
+    }
 
-                Reference<XChild> xLoopAsChild(xMyTopLevel, UNO_QUERY);
-                xMyTopLevel = xLoopAsChild.is() ? xLoopAsChild->getParent() : Reference< XInterface >();
-            }
-            Reference< XInterface > xNewTopLevel = xAsChild->getParent();
-            while (xNewTopLevel.is())
-            {
-                Reference<XForm> xAsForm(xNewTopLevel, UNO_QUERY);
-                if (!xAsForm.is())
-                    break;
+    void OBoundControlModel::suspendValueListening( )
+    {
+        OSL_PRECOND( !m_sValuePropertyName.isEmpty(), "OBoundControlModel::suspendValueListening: don't have a value property!" );
+        OSL_PRECOND( m_pAggPropMultiplexer, "OBoundControlModel::suspendValueListening: I *am* not listening!" );
+        if ( m_pAggPropMultiplexer )
+            m_pAggPropMultiplexer->lock();
+    }
 
-                Reference<XChild> xLoopAsChild(xNewTopLevel, UNO_QUERY);
-                xNewTopLevel = xLoopAsChild.is() ? xLoopAsChild->getParent() : Reference< XInterface >();
-            }
-            if (xNewTopLevel != xMyTopLevel)
-            {
-                // the both objects don't belong to the same forms collection -> not acceptable
-                throw com::sun::star::lang::IllegalArgumentException();
-            }
+    void OBoundControlModel::resumeValueListening( )
+    {
+        OSL_PRECOND( !m_sValuePropertyName.isEmpty(), "OBoundControlModel::resumeValueListening: don't have a value property!" );
+        OSL_PRECOND( m_pAggPropMultiplexer, "OBoundControlModel::resumeValueListening: I *am* not listening at all!" );
+        OSL_PRECOND( !m_pAggPropMultiplexer || m_pAggPropMultiplexer->locked(), "OBoundControlModel::resumeValueListening: listening not suspended currently!" );
+        if ( m_pAggPropMultiplexer )
+            m_pAggPropMultiplexer->unlock();
+    }
 
-            m_xLabelControl = xAsPropSet;
-            Reference<com::sun::star::lang::XComponent> xComp(m_xLabelControl, UNO_QUERY);
-            if (xComp.is())
-                xComp->addEventListener(static_cast<com::sun::star::lang::XEventListener*>(static_cast<XPropertyChangeListener*>(this)));
+    Sequence< Type > OBoundControlModel::_getTypes()
+    {
+        TypeBag aTypes(
+            OControlModel::_getTypes(),
+            OBoundControlModel_BASE1::getTypes()
+        );
+        if ( m_bCommitable )
+            aTypes.addTypes( OBoundControlModel_COMMITTING::getTypes() );
+        if ( m_bSupportsExternalBinding )
+            aTypes.addTypes( OBoundControlModel_BINDING::getTypes() );
+        if ( m_bSupportsValidation )
+            aTypes.addTypes( OBoundControlModel_VALIDATION::getTypes() );
+        return aTypes.getTypes();
+    }
+
+    // OComponentHelper
+    void OBoundControlModel::disposing()
+    {
+        OControlModel::disposing();
+        ::osl::ClearableMutexGuard aGuard(m_aMutex);
+        if ( m_pAggPropMultiplexer )
+            m_pAggPropMultiplexer->dispose();
+        // notify all our listeners
+        com::sun::star::lang::EventObject aEvt( static_cast< XWeak* >( this ) );
+        m_aUpdateListeners.disposeAndClear( aEvt );
+        m_aResetHelper.disposing();
+        // disconnect from our database column
+        // TODO: could we replace the following 5 lines with a call to impl_disconnectDatabaseColumn_noNotify?
+        // The only more thing which it does is calling onDisconnectedDbColumn - could this
+        // cause trouble? At least when we continue to call OControlModel::disposing before, it *may*.
+        if ( hasField() )
+        {
+            getField()->removePropertyChangeListener( PROPERTY_VALUE, this );
+            resetField();
         }
-        break;
-        default:
-            OControlModel::setFastPropertyValue_NoBroadcast(nHandle, rValue );
+        m_xCursor = NULL;
+        Reference< XComponent > xComp( m_xLabelControl, UNO_QUERY );
+        if ( xComp.is() )
+            xComp->removeEventListener(static_cast< XEventListener* >( static_cast< XPropertyChangeListener* >( this ) ) );
+        // disconnect from our external value binding
+        if ( hasExternalValueBinding() )
+            disconnectExternalValueBinding();
+        // dito for the validator
+        if ( hasValidator() )
+            disconnectValidator( );
     }
-}
 
-// XPropertyChangeListener
-//------------------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::propertyChange( const PropertyChangeEvent& evt ) throw(RuntimeException)
-{
-    // if the DBColumn value changed, transfer it to the control
-    if ( evt.PropertyName.equals( PROPERTY_VALUE ) )
+    void OBoundControlModel::onValuePropertyChange( ControlModelLock& i_rControLock )
     {
-        OSL_ENSURE( evt.Source == getField(), "OBoundControlModel::propertyChange: value changes from components other than our database column?" );
-        osl::MutexGuard aGuard(m_aMutex);
-        if ( m_bForwardValueChanges && m_xColumn.is() )
-            transferDbValueToControl();
+        if ( hasExternalValueBinding() )
+        {   // the control value changed, while we have an external value binding
+            // -> forward the value to it
+            if ( m_eControlValueChangeInstigator != eExternalBinding )
+                transferControlValueToExternal( i_rControLock );
+        }
+        else if ( !m_bCommitable && m_xColumnUpdate.is() )
+        {   // the control value changed, while we are  bound to a database column,
+            // but not committable (which means changes in the control have to be reflected to
+            // the underlying database column immediately)
+            // -> forward the value to the database column
+            if ( m_eControlValueChangeInstigator != eDbColumnBinding )
+                commitControlValueToDbColumn( false );
+        }
+        // validate the new value
+        if ( m_bSupportsValidation )
+            recheckValidity( true );
     }
-    else
+
+    void OBoundControlModel::_propertyChanged( const PropertyChangeEvent& _rEvt ) throw ( RuntimeException )
     {
-        OSL_ENSURE( evt.Source == m_xExternalBinding, "OBoundControlModel::propertyChange: where did this come from?" );
+        ControlModelLock aLock( *this );
+        OSL_ENSURE( _rEvt.PropertyName == m_sValuePropertyName,
+            "OBoundControlModel::_propertyChanged: where did this come from (1)?" );
+        OSL_ENSURE( m_pAggPropMultiplexer && !m_pAggPropMultiplexer->locked(),
+            "OBoundControlModel::_propertyChanged: where did this come from (2)?" );
+        if ( _rEvt.PropertyName == m_sValuePropertyName )
+        {
+            onValuePropertyChange( aLock );
+        }
+    }
 
-        // our binding has properties which can control properties of ourself
-        OUString sBindingControlledProperty;
-        bool bForwardToLabelControl = false;
-        if ( evt.PropertyName.equals( PROPERTY_READONLY ) )
+    void OBoundControlModel::startAggregatePropertyListening( const OUString& _rPropertyName )
+    {
+        OSL_PRECOND( m_pAggPropMultiplexer, "OBoundControlModel::startAggregatePropertyListening: no multiplexer!" );
+        OSL_ENSURE( !_rPropertyName.isEmpty(), "OBoundControlModel::startAggregatePropertyListening: invalid property name!" );
+        if ( m_pAggPropMultiplexer && !_rPropertyName.isEmpty() )
         {
-            sBindingControlledProperty = PROPERTY_READONLY;
+            m_pAggPropMultiplexer->addProperty( _rPropertyName );
         }
-        else if ( evt.PropertyName.equals( PROPERTY_RELEVANT ) )
+    }
+
+    void OBoundControlModel::doFormListening( const bool _bStart )
+    {
+        OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::doFormListening: external value binding should overrule the database binding!" );
+        if ( isFormListening() == _bStart )
+            return;
+        if ( m_xAmbientForm.is() )
+            _bStart ? m_xAmbientForm->addLoadListener( this ) : m_xAmbientForm->removeLoadListener( this );
+        Reference< XLoadable > xParentLoadable( getParent(), UNO_QUERY );
+        if ( getParent().is() && !xParentLoadable.is() )
         {
-            sBindingControlledProperty = PROPERTY_ENABLED;
-            bForwardToLabelControl = true;
+            // if our parent does not directly support the XLoadable interface, then it might support the
+            // XRowSetSupplier/XRowSetChangeBroadcaster interfaces. In this case we have to listen for changes
+            // broadcasted by the latter.
+            Reference< XRowSetChangeBroadcaster > xRowSetBroadcaster( getParent(), UNO_QUERY );
+            if ( xRowSetBroadcaster.is() )
+                _bStart ? xRowSetBroadcaster->addRowSetChangeListener( this ) : xRowSetBroadcaster->removeRowSetChangeListener( this );
         }
-        else
+        m_bFormListening = _bStart && m_xAmbientForm.is();
+    }
+
+    // XChild
+    void SAL_CALL OBoundControlModel::setParent(const Reference<XInterface>& _rxParent) throw(com::sun::star::lang::NoSupportException, RuntimeException)
+    {
+        ControlModelLock aLock( *this );
+        FieldChangeNotifier aBoundFieldNotifier( aLock );
+        if ( getParent() == _rxParent )
             return;
+        // disconnect from database column (which is controlled by parent, directly or indirectly)
+        if ( hasField() )
+            impl_disconnectDatabaseColumn_noNotify();
+        // log off old listeners
+        if ( isFormListening() )
+            doFormListening( false );
+        // actually set the new parent
+        OControlModel::setParent( _rxParent );
+        // a new parent means a new ambient form
+        impl_determineAmbientForm_nothrow();
+        if ( !hasExternalValueBinding() )
+        {
+            // log on new listeners
+            doFormListening( true );
+            // re-connect to database column of the new parent
+            if ( m_xAmbientForm.is() && m_xAmbientForm->isLoaded() )
+                impl_connectDatabaseColumn_noNotify( false );
+        }
+    }
 
-        try
+    // XEventListener
+    void SAL_CALL OBoundControlModel::disposing(const com::sun::star::lang::EventObject& _rEvent) throw (RuntimeException)
+    {
+        ControlModelLock aLock( *this );
+        if ( _rEvent.Source == getField() )
         {
-            setPropertyValue( sBindingControlledProperty, evt.NewValue );
-            if ( bForwardToLabelControl && m_xLabelControl.is() )
-                m_xLabelControl->setPropertyValue( sBindingControlledProperty, evt.NewValue );
+            resetField();
         }
-        catch( const Exception& )
+        else if ( _rEvent.Source == m_xLabelControl )
         {
-            SAL_WARN("forms.component",  "OBoundControlModel::propertyChange: could not adjust my binding-controlled property!");
-            DBG_UNHANDLED_EXCEPTION();
+            Reference<XPropertySet> xOldValue = m_xLabelControl;
+            m_xLabelControl = NULL;
+            // fire a propertyChanged (when we leave aLock's scope)
+            aLock.addPropertyNotification( PROPERTY_ID_CONTROLLABEL, makeAny( xOldValue ), makeAny( m_xLabelControl ) );
+        }
+        else if ( _rEvent.Source == m_xExternalBinding )
+        {   // *first* check for the external binding
+            disconnectExternalValueBinding( );
         }
+        else if ( _rEvent.Source == m_xValidator )
+        {   // *then* check for the validator. Reason is that bindings may also act as validator at the same
+            // time, in this case, the validator is automatically revoked when the binding is revoked
+            disconnectValidator( );
+        }
+        else
+            OControlModel::disposing(_rEvent);
     }
-}
-
-//------------------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::onRowSetChanged( const EventObject& /*i_Event*/ ) throw (RuntimeException)
-{
-    ControlModelLock aLock( *this );
-    FieldChangeNotifier aBoundFieldNotifier( aLock );
-
-    // disconnect from database column (which is controlled by parent, directly or indirectly)
-    if ( hasField() )
-        impl_disconnectDatabaseColumn_noNotify();
-
-    // log off old listeners
-    if ( isFormListening() )
-        doFormListening( false );
-
-    // determine the new ambient form
-    impl_determineAmbientForm_nothrow();
-
-    // log on new listeners
-    doFormListening( true );
 
-    // re-connect to database column if needed and possible
-    if ( m_xAmbientForm.is() && m_xAmbientForm->isLoaded() )
-        impl_connectDatabaseColumn_noNotify( false );
-}
-
-// XBoundComponent
-//------------------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::addUpdateListener(const Reference<XUpdateListener>& _rxListener) throw(RuntimeException)
-{
-    m_aUpdateListeners.addInterface(_rxListener);
-}
-
-//------------------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::removeUpdateListener(const Reference< XUpdateListener>& _rxListener) throw(RuntimeException)
-{
-    m_aUpdateListeners.removeInterface(_rxListener);
-}
+    // XServiceInfo
+    StringSequence SAL_CALL OBoundControlModel::getSupportedServiceNames() throw(RuntimeException)
+    {
+        return ::comphelper::concatSequences(
+            getAggregateServiceNames(),
+            getSupportedServiceNames_Static()
+        );
+    }
 
-//------------------------------------------------------------------------------
-sal_Bool SAL_CALL OBoundControlModel::commit() throw(RuntimeException)
-{
-    ControlModelLock aLock( *this );
-
-    OSL_PRECOND( m_bCommitable, "OBoundControlModel::commit: invalid call (I'm not commitable !) " );
-    if ( hasExternalValueBinding() )
-    {
-        // in most cases, no action is required: For most derivees, we know the value property of
-        // our control (see initValueProperty), and when an external binding is active, we
-        // instantly forward all changes in this property to the external binding.
-        if ( m_sValuePropertyName.isEmpty() )
-            // but for those derivees which did not use this feature, we need an
-            // explicit transfer
-            transferControlValueToExternal( aLock );
-        return sal_True;
+    Sequence< OUString > SAL_CALL OBoundControlModel::getSupportedServiceNames_Static() throw( RuntimeException )
+    {
+        Sequence< OUString > aOwnServiceNames( 1 );
+        aOwnServiceNames[ 0 ] = "com.sun.star.form.DataAwareControlModel";
+        return ::comphelper::concatSequences(
+            OControlModel::getSupportedServiceNames_Static(),
+            aOwnServiceNames
+        );
     }
 
-    OSL_ENSURE( !hasExternalValueBinding(), "OBoundControlModel::commit: control flow broken!" );
-        // we reach this only if we're not working with an external binding
+    // XPersist
+    void SAL_CALL OBoundControlModel::write( const Reference<stario::XObjectOutputStream>& _rxOutStream ) throw(stario::IOException, RuntimeException)
+    {
+        OControlModel::write(_rxOutStream);
+        osl::MutexGuard aGuard(m_aMutex);
+        // Version
+        _rxOutStream->writeShort(0x0002);
+        // Controlsource
+        ::comphelper::operator<<( _rxOutStream, m_aControlSource);
+        // !!! IMPORTANT NOTE !!!
+        // don't write any new members here : this wouldn't be compatible with older versions, as OBoundControlModel
+        // is a base class which is called in derived classes "read" method. So if you increment the version
+        // and write new stuff, older office versions will read this in the _derived_ classes, which may result
+        // in anything from data loss to crash.
+        // (use writeCommonProperties instead, this is called in derived classes write-method)
+        // !!! EOIN !!!
+    }
+
+    void OBoundControlModel::defaultCommonProperties()
+    {
+        Reference<com::sun::star::lang::XComponent> xComp(m_xLabelControl, UNO_QUERY);
+        if (xComp.is())
+            xComp->removeEventListener(static_cast<com::sun::star::lang::XEventListener*>(static_cast<XPropertyChangeListener*>(this)));
+        m_xLabelControl = NULL;
+    }
 
-    if ( !hasField() )
-        return sal_True;
+    void OBoundControlModel::readCommonProperties(const Reference<stario::XObjectInputStream>& _rxInStream)
+    {
+        sal_Int32 nLen = _rxInStream->readLong();
+        Reference<stario::XMarkableStream> xMark(_rxInStream, UNO_QUERY);
+        DBG_ASSERT(xMark.is(), "OBoundControlModel::readCommonProperties : can only work with markable streams !");
+        sal_Int32 nMark = xMark->createMark();
+        // read the reference to the label control
+        Reference<stario::XPersistObject> xPersist;
+        sal_Int32 nUsedFlag;
+        nUsedFlag = _rxInStream->readLong();
+        if (nUsedFlag)
+            xPersist = _rxInStream->readObject();
+        m_xLabelControl = m_xLabelControl.query( xPersist );
+        Reference< XComponent > xComp( m_xLabelControl, UNO_QUERY );
+        if (xComp.is())
+            xComp->addEventListener(static_cast<com::sun::star::lang::XEventListener*>(static_cast<XPropertyChangeListener*>(this)));
+        // read any other new common properties here
+        // skip the remaining bytes
+        xMark->jumpToMark(nMark);
+        _rxInStream->skipBytes(nLen);
+        xMark->deleteMark(nMark);
+    }
 
-    ::cppu::OInterfaceIteratorHelper aIter( m_aUpdateListeners );
-    EventObject aEvent;
-    aEvent.Source = static_cast< XWeak* >( this );
-    sal_Bool bSuccess = sal_True;
+    void OBoundControlModel::writeCommonProperties(const Reference<stario::XObjectOutputStream>& _rxOutStream)
+    {
+        Reference<stario::XMarkableStream> xMark(_rxOutStream, UNO_QUERY);
+        DBG_ASSERT(xMark.is(), "OBoundControlModel::writeCommonProperties : can only work with markable streams !");
+        sal_Int32 nMark = xMark->createMark();
+        // a placeholder where we will write the overall length (later in this method)
+        sal_Int32 nLen = 0;
+        _rxOutStream->writeLong(nLen);
+        // write the reference to the label control
+        Reference<stario::XPersistObject> xPersist(m_xLabelControl, UNO_QUERY);
+        sal_Int32 nUsedFlag = 0;
+        if (xPersist.is())
+            nUsedFlag = 1;
+        _rxOutStream->writeLong(nUsedFlag);
+        if (xPersist.is())
+            _rxOutStream->writeObject(xPersist);
+        // write any other new common properties here
+        // write the correct length at the beginning of the block
+        nLen = xMark->offsetToMark(nMark) - sizeof(nLen);
+        xMark->jumpToMark(nMark);
+        _rxOutStream->writeLong(nLen);
+        xMark->jumpToFurthest();
+        xMark->deleteMark(nMark);
+    }
 
-    aLock.release();
-    // >>>>>>>> ----- UNSAFE ----- >>>>>>>>
-    while (aIter.hasMoreElements() && bSuccess)
-        bSuccess = static_cast< XUpdateListener* >( aIter.next() )->approveUpdate( aEvent );
-    // <<<<<<<< ----- UNSAFE ----- <<<<<<<<
-    aLock.acquire();
+    void SAL_CALL OBoundControlModel::read( const Reference< stario::XObjectInputStream >& _rxInStream ) throw(stario::IOException, RuntimeException)
+    {
+        OControlModel::read(_rxInStream);
+        osl::MutexGuard aGuard(m_aMutex);
+        sal_uInt16 nVersion = _rxInStream->readShort(); (void)nVersion;
+        ::comphelper::operator>>( _rxInStream, m_aControlSource);
+    }
 
-    if ( bSuccess )
+    void OBoundControlModel::getFastPropertyValue(Any& rValue, sal_Int32 nHandle) const
     {
-        try
+        switch (nHandle)
         {
-            if ( m_xColumnUpdate.is() )
-                bSuccess = commitControlValueToDbColumn( false );
+            case PROPERTY_ID_INPUT_REQUIRED:
+                rValue <<= m_bInputRequired;
+                break;
+            case PROPERTY_ID_CONTROLSOURCEPROPERTY:
+                rValue <<= m_sValuePropertyName;
+                break;
+            case PROPERTY_ID_CONTROLSOURCE:
+                rValue <<= m_aControlSource;
+                break;
+            case PROPERTY_ID_BOUNDFIELD:
+                rValue <<= getField();
+                break;
+            case PROPERTY_ID_CONTROLLABEL:
+                if (!m_xLabelControl.is())
+                    rValue.clear();
+                else
+                    rValue <<= m_xLabelControl;
+                break;
+            default:
+                OControlModel::getFastPropertyValue(rValue, nHandle);
         }
-        catch(const Exception&)
+    }
+
+    sal_Bool OBoundControlModel::convertFastPropertyValue(
+                                    Any& _rConvertedValue, Any& _rOldValue,
+                    sal_Int32 _nHandle,
+                                    const Any& _rValue)
+                    throw (com::sun::star::lang::IllegalArgumentException)
+    {
+        sal_Bool bModified(sal_False);
+        switch (_nHandle)
         {
-            bSuccess = sal_False;
+            case PROPERTY_ID_INPUT_REQUIRED:
+                bModified = tryPropertyValue( _rConvertedValue, _rOldValue, _rValue, m_bInputRequired );
+                break;
+            case PROPERTY_ID_CONTROLSOURCE:
+                bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_aControlSource);
+                break;
+            case PROPERTY_ID_BOUNDFIELD:
+                SAL_WARN("forms.component",  "OBoundControlModel::convertFastPropertyValue: BoundField should be a read-only property !" );
+                throw com::sun::star::lang::IllegalArgumentException();
+            case PROPERTY_ID_CONTROLLABEL:
+                if (!_rValue.hasValue())
+                {   // property set to void
+                    _rConvertedValue = Any();
+                    getFastPropertyValue(_rOldValue, _nHandle);
+                    bModified = m_xLabelControl.is();
+                }
+                else
+                {
+                    bModified = tryPropertyValue(_rConvertedValue, _rOldValue, _rValue, m_xLabelControl);
+                    if (!m_xLabelControl.is())
+                        // an empty interface is interpreted as VOID
+                        _rOldValue.clear();
+                }
+                break;
+            default:
+                bModified = OControlModel::convertFastPropertyValue(_rConvertedValue, _rOldValue, _nHandle, _rValue);
         }
+        return bModified;
     }
 
-    if ( bSuccess )
+    Any OBoundControlModel::getPropertyDefaultByHandle( sal_Int32 _nHandle ) const
     {
-        aLock.release();
-        m_aUpdateListeners.notifyEach( &XUpdateListener::updated, aEvent );
+        Any aDefault;
+        switch ( _nHandle )
+        {
+            case PROPERTY_ID_INPUT_REQUIRED:
+                aDefault <<= sal_Bool( sal_True );
+                break;
+            case PROPERTY_ID_CONTROLSOURCE:
+                aDefault <<= OUString();
+                break;
+            case PROPERTY_ID_CONTROLLABEL:
+                aDefault <<= Reference< XPropertySet >();
+                break;
+        }
+        return aDefault;
     }
 
-    return bSuccess;
-}
-
-//------------------------------------------------------------------------------
-void OBoundControlModel::resetField()
-{
-    m_xColumnUpdate.clear();
-    m_xColumn.clear();
-    m_xField.clear();
-    m_nFieldType = DataType::OTHER;
-}
-
-//------------------------------------------------------------------------------
-sal_Bool OBoundControlModel::connectToField(const Reference<XRowSet>& rForm)
-{
-    OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::connectToField: invalid call (have an external binding)!" );
-
-    // wenn eine Verbindung zur Datenbank existiert
-    if (rForm.is() && getConnection(rForm).is())
+    void OBoundControlModel::setFastPropertyValue_NoBroadcast( sal_Int32 nHandle, const Any& rValue ) throw (Exception)
     {
-        // Feld bestimmen und PropertyChangeListener
-        m_xCursor = rForm;
-        Reference<XPropertySet> xFieldCandidate;
-
-        if (m_xCursor.is())
+        switch (nHandle)
         {
-            Reference<XColumnsSupplier> xColumnsSupplier(m_xCursor, UNO_QUERY);
-            DBG_ASSERT(xColumnsSupplier.is(), "OBoundControlModel::connectToField : the row set should support the com::sun::star::sdb::ResultSet service !");
-            if (xColumnsSupplier.is())
+            case PROPERTY_ID_INPUT_REQUIRED:
+                OSL_VERIFY( rValue >>= m_bInputRequired );
+                break;
+            case PROPERTY_ID_CONTROLSOURCE:
+                OSL_VERIFY( rValue >>= m_aControlSource );
+                break;
+            case PROPERTY_ID_BOUNDFIELD:
+                SAL_WARN("forms.component", "OBoundControlModel::setFastPropertyValue_NoBroadcast : BoundField should be a read-only property !");
+                throw com::sun::star::lang::IllegalArgumentException();
+            case PROPERTY_ID_CONTROLLABEL:
             {
-                Reference<XNameAccess> xColumns(xColumnsSupplier->getColumns(), UNO_QUERY);
-                if (xColumns.is() && xColumns->hasByName(m_aControlSource))
+                if ( rValue.hasValue() && ( rValue.getValueTypeClass() != TypeClass_INTERFACE ) )
+                    throw com::sun::star::lang::IllegalArgumentException();
+                Reference< XInterface > xNewValue( rValue, UNO_QUERY );
+                if ( !xNewValue.is() )
+                {   // set property to "void"
+                    Reference< XComponent > xComp( m_xLabelControl, UNO_QUERY );
+                    if ( xComp.is() )
+                        xComp->removeEventListener( static_cast< XPropertyChangeListener* >( this ) );
+                    m_xLabelControl = NULL;
+                    break;
+                }
+                Reference< XControlModel >  xAsModel        ( xNewValue,        UNO_QUERY );
+                Reference< XServiceInfo >   xAsServiceInfo  ( xAsModel,         UNO_QUERY );
+                Reference< XPropertySet >   xAsPropSet      ( xAsServiceInfo,   UNO_QUERY );
+                Reference< XChild >         xAsChild        ( xAsPropSet,       UNO_QUERY );
+                if ( !xAsChild.is() || !xAsServiceInfo->supportsService( m_aLabelServiceName ) )
                 {
-                    OSL_VERIFY( xColumns->getByName(m_aControlSource) >>= xFieldCandidate );
+                    throw com::sun::star::lang::IllegalArgumentException();
                 }
-            }
-        }
-
-        try
-        {
-            sal_Int32 nFieldType = DataType::OTHER;
-            if ( xFieldCandidate.is() )
-            {
-                xFieldCandidate->getPropertyValue( PROPERTY_FIELDTYPE ) >>= nFieldType;
-                if ( approveDbColumnType( nFieldType ) )
-                    impl_setField_noNotify( xFieldCandidate );
-            }
-            else
-                impl_setField_noNotify( NULL );
-
-            if ( m_xField.is() )
-            {
-                if( m_xField->getPropertySetInfo()->hasPropertyByName( PROPERTY_VALUE ) )
+                // check if weself and the given model have a common anchestor (up to the forms collection)
+                Reference<XChild> xCont;
+                query_interface(static_cast<XWeak*>(this), xCont);
+                Reference< XInterface > xMyTopLevel = xCont->getParent();
+                while (xMyTopLevel.is())
                 {
-                    m_nFieldType = nFieldType;
-
-                    // an wertaenderungen horchen
-                    m_xField->addPropertyChangeListener( PROPERTY_VALUE, this );
-                    m_xColumnUpdate = Reference< XColumnUpdate >( m_xField, UNO_QUERY );
-                    m_xColumn = Reference< XColumn >( m_xField, UNO_QUERY );
-
-                    sal_Int32 nNullableFlag = ColumnValue::NO_NULLS;
-                    m_xField->getPropertyValue(PROPERTY_ISNULLABLE) >>= nNullableFlag;
-                    m_bRequired = (ColumnValue::NO_NULLS == nNullableFlag);
-                        // we're optimistic : in case of ColumnValue_NULLABLE_UNKNOWN we assume nullability ....
+                    Reference<XForm> xAsForm(xMyTopLevel, UNO_QUERY);
+                    if (!xAsForm.is())
+                        // found my root
+                        break;
+                    Reference<XChild> xLoopAsChild(xMyTopLevel, UNO_QUERY);
+                    xMyTopLevel = xLoopAsChild.is() ? xLoopAsChild->getParent() : Reference< XInterface >();
                 }
-                else
+                Reference< XInterface > xNewTopLevel = xAsChild->getParent();
+                while (xNewTopLevel.is())
                 {
-                    SAL_WARN("forms.component", "OBoundControlModel::connectToField: property " << PROPERTY_VALUE << " not supported!");
-                    impl_setField_noNotify( NULL );
+                    Reference<XForm> xAsForm(xNewTopLevel, UNO_QUERY);
+                    if (!xAsForm.is())
+                        break;
+                    Reference<XChild> xLoopAsChild(xNewTopLevel, UNO_QUERY);
+                    xNewTopLevel = xLoopAsChild.is() ? xLoopAsChild->getParent() : Reference< XInterface >();
+                }
+                if (xNewTopLevel != xMyTopLevel)
+                {
+                    // the both objects don't belong to the same forms collection -> not acceptable
+                    throw com::sun::star::lang::IllegalArgumentException();
                 }
+                m_xLabelControl = xAsPropSet;
+                Reference<com::sun::star::lang::XComponent> xComp(m_xLabelControl, UNO_QUERY);
+                if (xComp.is())
+                    xComp->addEventListener(static_cast<com::sun::star::lang::XEventListener*>(static_cast<XPropertyChangeListener*>(this)));
             }
-        }
-        catch( const Exception& )
-        {
-            DBG_UNHANDLED_EXCEPTION();
-            resetField();
+            break;
+            default:
+                OControlModel::setFastPropertyValue_NoBroadcast(nHandle, rValue );
         }
     }
-    return hasField();
-}
 
-//------------------------------------------------------------------------------
-void OBoundControlModel::initFromField( const Reference< XRowSet >& _rxRowSet )
-{
-    // but only if the rowset if posisitioned on a valid record
-    if ( hasField() && _rxRowSet.is() )
+    // XPropertyChangeListener
+    void SAL_CALL OBoundControlModel::propertyChange( const PropertyChangeEvent& evt ) throw(RuntimeException)
     {
-        if ( !_rxRowSet->isBeforeFirst() && !_rxRowSet->isAfterLast() )
-            transferDbValueToControl();
+        // if the DBColumn value changed, transfer it to the control
+        if ( evt.PropertyName.equals( PROPERTY_VALUE ) )
+        {
+            OSL_ENSURE( evt.Source == getField(), "OBoundControlModel::propertyChange: value changes from components other than our database column?" );
+            osl::MutexGuard aGuard(m_aMutex);
+            if ( m_bForwardValueChanges && m_xColumn.is() )
+                transferDbValueToControl();
+        }
         else
-            // reset the field if the row set is empty
-            // #i30661#
-            resetNoBroadcast();
+        {
+            OSL_ENSURE( evt.Source == m_xExternalBinding, "OBoundControlModel::propertyChange: where did this come from?" );
+            // our binding has properties which can control properties of ourself
+            OUString sBindingControlledProperty;
+            bool bForwardToLabelControl = false;
+            if ( evt.PropertyName.equals( PROPERTY_READONLY ) )
+            {
+                sBindingControlledProperty = PROPERTY_READONLY;
+            }
+            else if ( evt.PropertyName.equals( PROPERTY_RELEVANT ) )
+            {
+                sBindingControlledProperty = PROPERTY_ENABLED;
+                bForwardToLabelControl = true;
+            }
+            else
+                return;
+            try
+            {
+                setPropertyValue( sBindingControlledProperty, evt.NewValue );
+                if ( bForwardToLabelControl && m_xLabelControl.is() )
+                    m_xLabelControl->setPropertyValue( sBindingControlledProperty, evt.NewValue );
+            }
+            catch( const Exception& )
+            {
+                SAL_WARN("forms.component",  "OBoundControlModel::propertyChange: could not adjust my binding-controlled property!");
+                DBG_UNHANDLED_EXCEPTION();
+            }
+        }
     }
-}
 
-//------------------------------------------------------------------------------
-sal_Bool OBoundControlModel::approveDbColumnType(sal_Int32 _nColumnType)
-{
-    OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::approveDbColumnType: invalid call (have an external binding)!" );
-
-    if ((_nColumnType == DataType::BINARY) || (_nColumnType == DataType::VARBINARY)
-        || (_nColumnType == DataType::LONGVARBINARY) || (_nColumnType == DataType::OTHER)
-        || (_nColumnType == DataType::OBJECT) || (_nColumnType == DataType::DISTINCT)
-        || (_nColumnType == DataType::STRUCT) || (_nColumnType == DataType::ARRAY)
-        || (_nColumnType == DataType::BLOB) /*|| (_nColumnType == DataType::CLOB)*/
-        || (_nColumnType == DataType::REF) || (_nColumnType == DataType::SQLNULL))
-        return sal_False;
-
-    return sal_True;
-}
-
-//------------------------------------------------------------------------------
-void OBoundControlModel::impl_determineAmbientForm_nothrow()
-{
-    Reference< XInterface > xParent( const_cast< OBoundControlModel* >( this )->getParent() );
-
-    m_xAmbientForm.set( xParent, UNO_QUERY );
-    if ( !m_xAmbientForm.is() )
+    void SAL_CALL OBoundControlModel::onRowSetChanged( const EventObject& /*i_Event*/ ) throw (RuntimeException)
     {
-        Reference< XRowSetSupplier > xSupRowSet( xParent, UNO_QUERY );
-        if ( xSupRowSet.is() )
-            m_xAmbientForm.set( xSupRowSet->getRowSet(), UNO_QUERY );
+        ControlModelLock aLock( *this );
+        FieldChangeNotifier aBoundFieldNotifier( aLock );
+        // disconnect from database column (which is controlled by parent, directly or indirectly)
+        if ( hasField() )
+            impl_disconnectDatabaseColumn_noNotify();
+        // log off old listeners
+        if ( isFormListening() )
+            doFormListening( false );
+        // determine the new ambient form
+        impl_determineAmbientForm_nothrow();
+        // log on new listeners
+        doFormListening( true );
+        // re-connect to database column if needed and possible
+        if ( m_xAmbientForm.is() && m_xAmbientForm->isLoaded() )
+            impl_connectDatabaseColumn_noNotify( false );
     }
-}
-
-//------------------------------------------------------------------------------
-void OBoundControlModel::impl_connectDatabaseColumn_noNotify( bool _bFromReload )
-{
-    OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::impl_connectDatabaseColumn_noNotify: not to be called with an external value binding!" );
-
-    // consistency checks
-    DBG_ASSERT( !( hasField() && !_bFromReload ),
-        "OBoundControlModel::impl_connectDatabaseColumn_noNotify: the form is just *loaded*, but we already have a field!" );
-    (void)_bFromReload;
-
-    Reference< XRowSet > xRowSet( m_xAmbientForm, UNO_QUERY );
-    OSL_ENSURE( xRowSet.is(), "OBoundControlModel::impl_connectDatabaseColumn_noNotify: no row set!" );
-    if ( !xRowSet.is() )
-        return;
 
-    if ( !hasField() )
+    // XBoundComponent
+    void SAL_CALL OBoundControlModel::addUpdateListener(const Reference<XUpdateListener>& _rxListener) throw(RuntimeException)
     {
-        // connect to the column
-        connectToField( xRowSet );
+        m_aUpdateListeners.addInterface(_rxListener);
     }
 
-    // now that we're connected (more or less, even if we did not find a column),
-    // we definitely want to forward any potentially occuring value changes
-    m_bForwardValueChanges = sal_True;
-
-    // let derived classes react on this new connection
-    m_bLoaded = sal_True;
-    onConnectedDbColumn( xRowSet );
-
-    // initially transfer the db column value to the control, if we successfully connected to a database column
-    if ( hasField() )
-        initFromField( xRowSet );
-}
-
-//------------------------------------------------------------------------------
-void OBoundControlModel::impl_disconnectDatabaseColumn_noNotify()
-{
-    OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::impl_disconnectDatabaseColumn_noNotify: not to be called with an external value binding!" );
-
-    // let derived classes react on this
-    onDisconnectedDbColumn();
-
-    if ( hasField() )
+    void SAL_CALL OBoundControlModel::removeUpdateListener(const Reference< XUpdateListener>& _rxListener) throw(RuntimeException)
     {
-        getField()->removePropertyChangeListener( PROPERTY_VALUE, this );
-        resetField();
+        m_aUpdateListeners.removeInterface(_rxListener);
     }
 
-    m_xCursor = NULL;
-    m_bLoaded = sal_False;
-}
-
-//==============================================================================
-// XLoadListener
-//------------------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::loaded( const EventObject& _rEvent ) throw(RuntimeException)
-{
-    ControlModelLock aLock( *this );
-    FieldChangeNotifier aBoundFieldNotifier( aLock );
-
-    OSL_ENSURE( _rEvent.Source == m_xAmbientForm, "OBoundControlModel::loaded: where does this come from?" );
-    (void)_rEvent;
-
-    OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::loaded: we should never reach this with an external value binding!" );
-    if ( hasExternalValueBinding() )
-        return;
-
-    impl_connectDatabaseColumn_noNotify( false );
-}
-
-
-//------------------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::unloaded( const com::sun::star::lang::EventObject& /*aEvent*/ ) throw(RuntimeException)
-{
-    OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::unloaded: we should never reach this with an external value binding!" );
-}
-
-//------------------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::reloading( const com::sun::star::lang::EventObject& /*aEvent*/ ) throw(RuntimeException)
-{
-    OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::reloading: we should never reach this with an external value binding!" );
-    if ( hasExternalValueBinding() )
-        return;
-
-    osl::MutexGuard aGuard(m_aMutex);
-    m_bForwardValueChanges = sal_False;
-}
-
-//------------------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::unloading(const com::sun::star::lang::EventObject& /*aEvent*/) throw(RuntimeException)
-{
-    ControlModelLock aLock( *this );
-    FieldChangeNotifier aBoundFieldNotifier( aLock );
-
-    OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::unloading: we should never reach this with an external value binding!" );
-    if ( hasExternalValueBinding() )
-        return;
-
-    impl_disconnectDatabaseColumn_noNotify();
-}
-
-//------------------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::reloaded( const EventObject& _rEvent ) throw(RuntimeException)
-{
-    ControlModelLock aLock( *this );
-    FieldChangeNotifier aBoundFieldNotifier( aLock );
-
-    OSL_ENSURE( _rEvent.Source == m_xAmbientForm, "OBoundControlModel::reloaded: where does this come from?" );
-    (void)_rEvent;
-
-    OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::reloaded: we should never reach this with an external value binding!" );
-    if ( hasExternalValueBinding() )
-        return;
-
-    impl_connectDatabaseColumn_noNotify( true );
-}
-
-//------------------------------------------------------------------------------
-void OBoundControlModel::setControlValue( const Any& _rValue, ValueChangeInstigator _eInstigator )
-{
-    m_eControlValueChangeInstigator = _eInstigator;
-    doSetControlValue( _rValue );
-    m_eControlValueChangeInstigator = eOther;
-}
-
-//------------------------------------------------------------------------------
-void OBoundControlModel::doSetControlValue( const Any& _rValue )
-{
-    OSL_PRECOND( m_xAggregateFastSet.is() && m_xAggregateSet.is(),
-        "OBoundControlModel::doSetControlValue: invalid aggregate !" );
-    OSL_PRECOND( !m_sValuePropertyName.isEmpty() || ( m_nValuePropertyAggregateHandle != -1 ),
-        "OBoundControlModel::doSetControlValue: please override if you have own value property handling!" );
-
-    try
+    sal_Bool SAL_CALL OBoundControlModel::commit() throw(RuntimeException)
     {
-        // release our mutex once (it's acquired in one of the calling methods), as setting aggregate properties
-        // may cause any uno controls belonging to us to lock the solar mutex, which is potentially dangerous with
-        // our own mutex locked
-        MutexRelease aRelease( m_aMutex );
-        if ( ( m_nValuePropertyAggregateHandle != -1 ) && m_xAggregateFastSet.is() )
+        ControlModelLock aLock( *this );
+        OSL_PRECOND( m_bCommitable, "OBoundControlModel::commit: invalid call (I'm not commitable !) " );
+        if ( hasExternalValueBinding() )
         {
-            m_xAggregateFastSet->setFastPropertyValue( m_nValuePropertyAggregateHandle, _rValue );
+            // in most cases, no action is required: For most derivees, we know the value property of
+            // our control (see initValueProperty), and when an external binding is active, we
+            // instantly forward all changes in this property to the external binding.
+            if ( m_sValuePropertyName.isEmpty() )
+                // but for those derivees which did not use this feature, we need an
+                // explicit transfer
+                transferControlValueToExternal( aLock );
+            return sal_True;
         }
-        else if ( !m_sValuePropertyName.isEmpty() && m_xAggregateSet.is() )
+        OSL_ENSURE( !hasExternalValueBinding(), "OBoundControlModel::commit: control flow broken!" );
+            // we reach this only if we're not working with an external binding
+        if ( !hasField() )
+            return sal_True;
+        ::cppu::OInterfaceIteratorHelper aIter( m_aUpdateListeners );
+        EventObject aEvent;
+        aEvent.Source = static_cast< XWeak* >( this );
+        sal_Bool bSuccess = sal_True;
+        aLock.release();
+        // UNSAFE >
+        while (aIter.hasMoreElements() && bSuccess)
+            bSuccess = static_cast< XUpdateListener* >( aIter.next() )->approveUpdate( aEvent );
+        // < UNSAFE
+        aLock.acquire();
+        if ( bSuccess )
+        {
+            try
+            {
+                if ( m_xColumnUpdate.is() )
+                    bSuccess = commitControlValueToDbColumn( false );
+            }
+            catch(const Exception&)
+            {
+                bSuccess = sal_False;
+            }
+        }
+        if ( bSuccess )
         {
-            m_xAggregateSet->setPropertyValue( m_sValuePropertyName, _rValue );
+            aLock.release();
+            m_aUpdateListeners.notifyEach( &XUpdateListener::updated, aEvent );
         }
+        return bSuccess;
     }
-    catch( const Exception& )
-    {
-        SAL_WARN("forms.component",  "OBoundControlModel::doSetControlValue: caught an exception!");
-        DBG_UNHANDLED_EXCEPTION();
-    }
-}
 
-//------------------------------------------------------------------------------
-void OBoundControlModel::onConnectedValidator( )
-{
-    try
-    {
-        // if we have an external validator, we do not want the control to force invalid
-        // inputs to the default value. Instead, invalid inputs should be translated
-        // to NaN (not a number)
-        Reference< XPropertySetInfo > xAggregatePropertyInfo;
-        if ( m_xAggregateSet.is() )
-            xAggregatePropertyInfo = m_xAggregateSet->getPropertySetInfo();
-        if ( xAggregatePropertyInfo.is() && xAggregatePropertyInfo->hasPropertyByName( PROPERTY_ENFORCE_FORMAT ) )
-            m_xAggregateSet->setPropertyValue( PROPERTY_ENFORCE_FORMAT, makeAny( (sal_Bool)sal_False ) );
-    }
-    catch( const Exception& )
+    void OBoundControlModel::resetField()
     {
-        SAL_WARN("forms.component",  "OBoundControlModel::onConnectedValidator: caught an exception!");
-        DBG_UNHANDLED_EXCEPTION();
+        m_xColumnUpdate.clear();
+        m_xColumn.clear();
+        m_xField.clear();
+        m_nFieldType = DataType::OTHER;
     }
-    recheckValidity( false );
-}
 
-//------------------------------------------------------------------------------
-void OBoundControlModel::onDisconnectedValidator( )
-{
-    try
+    sal_Bool OBoundControlModel::connectToField(const Reference<XRowSet>& rForm)
     {
-        Reference< XPropertySetInfo > xAggregatePropertyInfo;
-        if ( m_xAggregateSet.is() )
-            xAggregatePropertyInfo = m_xAggregateSet->getPropertySetInfo();
-        if ( xAggregatePropertyInfo.is() && xAggregatePropertyInfo->hasPropertyByName( PROPERTY_ENFORCE_FORMAT ) )
-            m_xAggregateSet->setPropertyValue( PROPERTY_ENFORCE_FORMAT, makeAny( (sal_Bool)sal_True ) );
-    }
-    catch( const Exception& )
-    {
-        SAL_WARN("forms.component",  "OBoundControlModel::onDisconnectedValidator: caught an exception!");
-        DBG_UNHANDLED_EXCEPTION();
+        OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::connectToField: invalid call (have an external binding)!" );
+        // if there's a connection to the database
+        if (rForm.is() && getConnection(rForm).is())
+        {
+            // determine field and PropertyChangeListener
+            m_xCursor = rForm;
+            Reference<XPropertySet> xFieldCandidate;
+            if (m_xCursor.is())
+            {
+                Reference<XColumnsSupplier> xColumnsSupplier(m_xCursor, UNO_QUERY);
+                DBG_ASSERT(xColumnsSupplier.is(), "OBoundControlModel::connectToField : the row set should support the com::sun::star::sdb::ResultSet service !");
+                if (xColumnsSupplier.is())
+                {
+                    Reference<XNameAccess> xColumns(xColumnsSupplier->getColumns(), UNO_QUERY);
+                    if (xColumns.is() && xColumns->hasByName(m_aControlSource))
+                    {
+                        OSL_VERIFY( xColumns->getByName(m_aControlSource) >>= xFieldCandidate );
+                    }
+                }
+            }
+            try
+            {
+                sal_Int32 nFieldType = DataType::OTHER;
+                if ( xFieldCandidate.is() )
+                {
+                    xFieldCandidate->getPropertyValue( PROPERTY_FIELDTYPE ) >>= nFieldType;
+                    if ( approveDbColumnType( nFieldType ) )
+                        impl_setField_noNotify( xFieldCandidate );
+                }
+                else
+                    impl_setField_noNotify( NULL );
+                if ( m_xField.is() )
+                {
+                    if( m_xField->getPropertySetInfo()->hasPropertyByName( PROPERTY_VALUE ) )
+                    {
+                        m_nFieldType = nFieldType;
+                        // listen to changing values
+                        m_xField->addPropertyChangeListener( PROPERTY_VALUE, this );
+                        m_xColumnUpdate = Reference< XColumnUpdate >( m_xField, UNO_QUERY );
+                        m_xColumn = Reference< XColumn >( m_xField, UNO_QUERY );
+                        sal_Int32 nNullableFlag = ColumnValue::NO_NULLS;
+                        m_xField->getPropertyValue(PROPERTY_ISNULLABLE) >>= nNullableFlag;
+                        m_bRequired = (ColumnValue::NO_NULLS == nNullableFlag);
+                            // we're optimistic: in case of ColumnValue_NULLABLE_UNKNOWN we assume nullability...
+                    }
+                    else
+                    {
+                        SAL_WARN("forms.component", "OBoundControlModel::connectToField: property " << PROPERTY_VALUE << " not supported!");
+                        impl_setField_noNotify( NULL );
+                    }
+                }
+            }
+            catch( const Exception& )
+            {
+                DBG_UNHANDLED_EXCEPTION();
+                resetField();
+            }
+        }
+        return hasField();
     }
-    recheckValidity( false );
-}
 
-//------------------------------------------------------------------------------
-void OBoundControlModel::onConnectedExternalValue( )
-{
-    calculateExternalValueType();
-}
-
-//------------------------------------------------------------------------------
-void OBoundControlModel::onDisconnectedExternalValue( )
-{
-}
-
-//------------------------------------------------------------------------------
-void OBoundControlModel::onConnectedDbColumn( const Reference< XInterface >& /*_rxForm*/ )
-{
-    OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::onConnectedDbColumn: how this? There's an external value binding!" );
-}
-
-//------------------------------------------------------------------------------
-void OBoundControlModel::onDisconnectedDbColumn()
-{
-    OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::onDisconnectedDbColumn: how this? There's an external value binding!" );
-}
-
-// XReset
-//-----------------------------------------------------------------------------
-Any OBoundControlModel::getDefaultForReset() const
-{
-    return Any();
-}
-
-//-----------------------------------------------------------------------------
-void OBoundControlModel::resetNoBroadcast()
-{
-    setControlValue( getDefaultForReset(), eOther );
-}
-
-//-----------------------------------------------------------------------------
-void OBoundControlModel::addResetListener(const Reference<XResetListener>& l) throw (RuntimeException)
-{
-    m_aResetHelper.addResetListener( l );
-}
-
-//-----------------------------------------------------------------------------
-void OBoundControlModel::removeResetListener(const Reference<XResetListener>& l) throw (RuntimeException)
-{
-    m_aResetHelper.removeResetListener( l );
-}
-
-//-----------------------------------------------------------------------------
-void OBoundControlModel::reset() throw (RuntimeException)
-{
-    if ( !m_aResetHelper.approveReset() )
-       return;
-
-    ControlModelLock aLock( *this );
-
-    // on a new record?
-    sal_Bool bIsNewRecord = sal_False;
-    Reference<XPropertySet> xSet( m_xCursor, UNO_QUERY );
-    if ( xSet.is() )
+    void OBoundControlModel::initFromField( const Reference< XRowSet >& _rxRowSet )
     {
-        try
+        // but only if the rowset if posisitioned on a valid record
+        if ( hasField() && _rxRowSet.is() )
         {
-            xSet->getPropertyValue( PROPERTY_ISNEW ) >>= bIsNewRecord;
-        }
-        catch( const Exception& )
-        {
-            DBG_UNHANDLED_EXCEPTION();
+            if ( !_rxRowSet->isBeforeFirst() && !_rxRowSet->isAfterLast() )
+                transferDbValueToControl();
+            else
+                // reset the field if the row set is empty
+                // #i30661#
+                resetNoBroadcast();
         }
     }
 
-    // cursor on an invalid row?
-    sal_Bool bInvalidCursorPosition = sal_True;
-    try
-    {
-        bInvalidCursorPosition =    m_xCursor.is()
-                                &&  (  m_xCursor->isAfterLast()
-                                    || m_xCursor->isBeforeFirst()
-                                    )
-                                &&  !bIsNewRecord;
-    }
-    catch( const SQLException& )
+    sal_Bool OBoundControlModel::approveDbColumnType(sal_Int32 _nColumnType)
     {
-        SAL_WARN("forms.component",  "OBoundControlModel::reset: caught an SQL exception!" );
-        DBG_UNHANDLED_EXCEPTION();
+        OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::approveDbColumnType: invalid call (have an external binding)!" );
+        if ((_nColumnType == DataType::BINARY) || (_nColumnType == DataType::VARBINARY)
+            || (_nColumnType == DataType::LONGVARBINARY) || (_nColumnType == DataType::OTHER)
+            || (_nColumnType == DataType::OBJECT) || (_nColumnType == DataType::DISTINCT)
+            || (_nColumnType == DataType::STRUCT) || (_nColumnType == DataType::ARRAY)
+            || (_nColumnType == DataType::BLOB) /*|| (_nColumnType == DataType::CLOB)*/
+            || (_nColumnType == DataType::REF) || (_nColumnType == DataType::SQLNULL))
+            return sal_False;
+        return sal_True;
     }
-    // #i24495# - don't count the insert row as "invalid"
-
-    sal_Bool bSimpleReset =
-                        (   !m_xColumn.is()                     // no connection to a database column
-                        ||  (   m_xCursor.is()                  // OR   we have an improperly positioned cursor
-                            &&  bInvalidCursorPosition
-                            )
-                        ||  hasExternalValueBinding()           // OR we have an external value binding
-                        );
 
-    if ( !bSimpleReset )
+    void OBoundControlModel::impl_determineAmbientForm_nothrow()
     {
-        // The default values will be set if and only if the current value of the field which we're bound
-        // to is NULL.
-        // Else, the current field value should be refreshed
-        // This behaviour is not completely ... "matured": What should happen if the field as well as the
-        // control have a default value?
-
-        sal_Bool bIsNull = sal_True;
-        // we have to access the field content at least once to get a reliable result by XColumn::wasNull
-        try
+        Reference< XInterface > xParent( const_cast< OBoundControlModel* >( this )->getParent() );
+        m_xAmbientForm.set( xParent, UNO_QUERY );
+        if ( !m_xAmbientForm.is() )
         {
-            // normally, we'd do a getString here. However, this is extremely expensive in the case
-            // of binary fields. Unfortunately, getString is the only method which is guaranteed
-            // to *always* succeed, all other getXXX methods may fail if the column is asked for a
-            // non-convertible type
-            sal_Int32 nFieldType = DataType::OBJECT;
-            getField()->getPropertyValue( PROPERTY_FIELDTYPE ) >>= nFieldType;
-            if  (  ( nFieldType == DataType::BINARY        )
-                || ( nFieldType == DataType::VARBINARY     )
-                || ( nFieldType == DataType::LONGVARBINARY )
-                || ( nFieldType == DataType::OBJECT        )
-                /*|| ( nFieldType == DataType::CLOB          )*/
-                )
-                m_xColumn->getBinaryStream();
-            else if ( nFieldType == DataType::BLOB          )
-                m_xColumn->getBlob();
-            else
-                m_xColumn->getString();
-
-            bIsNull = m_xColumn->wasNull();
+            Reference< XRowSetSupplier > xSupRowSet( xParent, UNO_QUERY );
+            if ( xSupRowSet.is() )
+                m_xAmbientForm.set( xSupRowSet->getRowSet(), UNO_QUERY );
         }
-        catch(const Exception&)
+    }
+
+    void OBoundControlModel::impl_connectDatabaseColumn_noNotify( bool _bFromReload )
+    {
+        OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::impl_connectDatabaseColumn_noNotify: not to be called with an external value binding!" );
+        // consistency checks
+        DBG_ASSERT( !( hasField() && !_bFromReload ),
+            "OBoundControlModel::impl_connectDatabaseColumn_noNotify: the form is just *loaded*, but we already have a field!" );
+        (void)_bFromReload;
+        Reference< XRowSet > xRowSet( m_xAmbientForm, UNO_QUERY );
+        OSL_ENSURE( xRowSet.is(), "OBoundControlModel::impl_connectDatabaseColumn_noNotify: no row set!" );
+        if ( !xRowSet.is() )
+            return;
+        if ( !hasField() )
         {
-            SAL_WARN("forms.component", "OBoundControlModel::reset: this should have succeeded in all cases!");
-            DBG_UNHANDLED_EXCEPTION();
+            // connect to the column
+            connectToField( xRowSet );
         }
-
-        sal_Bool bNeedValueTransfer = sal_True;
-
-        if ( bIsNull )
+        // now that we're connected (more or less, even if we did not find a column),
+        // we definitely want to forward any potentially occuring value changes
+        m_bForwardValueChanges = sal_True;
+        // let derived classes react on this new connection
+        m_bLoaded = sal_True;
+        onConnectedDbColumn( xRowSet );
+        // initially transfer the db column value to the control, if we successfully connected to a database column
+        if ( hasField() )
+            initFromField( xRowSet );
+    }
+
+    void OBoundControlModel::impl_disconnectDatabaseColumn_noNotify()
+    {
+        OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::impl_disconnectDatabaseColumn_noNotify: not to be called with an external value binding!" );
+        // let derived classes react on this
+        onDisconnectedDbColumn();
+        if ( hasField() )
         {
-            if ( bIsNewRecord )
-            {
-                // reset the control to it's default
-                resetNoBroadcast();
-                // and immediately commit the changes to the DB column, to keep consistency
-                commitControlValueToDbColumn( true );
-
-                bNeedValueTransfer = sal_False;
-            }
+            getField()->removePropertyChangeListener( PROPERTY_VALUE, this );
+            resetField();
         }
-
-        if ( bNeedValueTransfer )
-            transferDbValueToControl();
+        m_xCursor = NULL;
+        m_bLoaded = sal_False;
     }
-    else
-    {
-        resetNoBroadcast();
 
-        // transfer to the external binding, if necessary
+    // XLoadListener
+    void SAL_CALL OBoundControlModel::loaded( const EventObject& _rEvent ) throw(RuntimeException)
+    {
+        ControlModelLock aLock( *this );
+        FieldChangeNotifier aBoundFieldNotifier( aLock );
+        OSL_ENSURE( _rEvent.Source == m_xAmbientForm, "OBoundControlModel::loaded: where does this come from?" );
+        (void)_rEvent;
+        OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::loaded: we should never reach this with an external value binding!" );
         if ( hasExternalValueBinding() )
-            transferControlValueToExternal( aLock );
+            return;
+        impl_connectDatabaseColumn_noNotify( false );
     }
 
-    // revalidate, if necessary
-    if ( hasValidator() )
-        recheckValidity( true );
-
-    aLock.release();
-
-    m_aResetHelper.notifyResetted();
-}
-
-// -----------------------------------------------------------------------------
-void OBoundControlModel::impl_setField_noNotify( const Reference< XPropertySet>& _rxField )
-{
-    DBG_ASSERT( !hasExternalValueBinding(), "OBoundControlModel::impl_setField_noNotify: We have an external value binding!" );
-    m_xField = _rxField;
-}
-
-//--------------------------------------------------------------------
-sal_Bool OBoundControlModel::impl_approveValueBinding_nolock( const Reference< XValueBinding >& _rxBinding )
-{
-    if ( !_rxBinding.is() )
-        return sal_False;
-
-    Sequence< Type > aTypeCandidates;
+    void SAL_CALL OBoundControlModel::unloaded( const com::sun::star::lang::EventObject& /*aEvent*/ ) throw(RuntimeException)
     {
-        // SYNCHRONIZED -->
-        ::osl::MutexGuard aGuard( m_aMutex );
-        aTypeCandidates = getSupportedBindingTypes();
-        // <-- SYNCHRONIZED
+        OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::unloaded: we should never reach this with an external value binding!" );
     }
 
-    for (   const Type* pType = aTypeCandidates.getConstArray();
-            pType != aTypeCandidates.getConstArray() + aTypeCandidates.getLength();
-            ++pType
-        )
+    void SAL_CALL OBoundControlModel::reloading( const com::sun::star::lang::EventObject& /*aEvent*/ ) throw(RuntimeException)
     {
-        if ( _rxBinding->supportsType( *pType ) )
-            return sal_True;
+        OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::reloading: we should never reach this with an external value binding!" );
+        if ( hasExternalValueBinding() )
+            return;
+        osl::MutexGuard aGuard(m_aMutex);
+        m_bForwardValueChanges = sal_False;
     }
 
-    return sal_False;
-}
-
-//--------------------------------------------------------------------
-void OBoundControlModel::connectExternalValueBinding(
-        const Reference< XValueBinding >& _rxBinding, ControlModelLock& _rInstanceLock )
-{
-    OSL_PRECOND( _rxBinding.is(), "OBoundControlModel::connectExternalValueBinding: invalid binding instance!" );
-    OSL_PRECOND( !hasExternalValueBinding( ), "OBoundControlModel::connectExternalValueBinding: precond not met (currently have a binding)!" );
-
-    // if we're connected to a database column, suspend this
-    if ( hasField() )
+    void SAL_CALL OBoundControlModel::unloading(const com::sun::star::lang::EventObject& /*aEvent*/) throw(RuntimeException)
+    {
+        ControlModelLock aLock( *this );
+        FieldChangeNotifier aBoundFieldNotifier( aLock );
+        OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::unloading: we should never reach this with an external value binding!" );
+        if ( hasExternalValueBinding() )
+            return;
         impl_disconnectDatabaseColumn_noNotify();
+    }
 
-    // suspend listening for load-related events at out ambient form.
-    // This is because an external value binding overrules a possible database binding.
-    if ( isFormListening() )
-        doFormListening( false );
-
-    // remember this new binding
-    m_xExternalBinding = _rxBinding;
-
-    // tell the derivee
-    onConnectedExternalValue();
+    void SAL_CALL OBoundControlModel::reloaded( const EventObject& _rEvent ) throw(RuntimeException)
+    {
+        ControlModelLock aLock( *this );
+        FieldChangeNotifier aBoundFieldNotifier( aLock );
+        OSL_ENSURE( _rEvent.Source == m_xAmbientForm, "OBoundControlModel::reloaded: where does this come from?" );
+        (void)_rEvent;
+        OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::reloaded: we should never reach this with an external value binding!" );
+        if ( hasExternalValueBinding() )
+            return;
+        impl_connectDatabaseColumn_noNotify( true );
+    }
 
-    try
+    void OBoundControlModel::setControlValue( const Any& _rValue, ValueChangeInstigator _eInstigator )
     {
-        // add as value listener so we get notified when the value changes
-        Reference< XModifyBroadcaster > xModifiable( m_xExternalBinding, UNO_QUERY );
-        if ( xModifiable.is() )
-            xModifiable->addModifyListener( this );
+        m_eControlValueChangeInstigator = _eInstigator;
+        doSetControlValue( _rValue );
+        m_eControlValueChangeInstigator = eOther;
+    }
 
-        // add as property change listener for some (possibly present) properties we're
-        // interested in
-        Reference< XPropertySet > xBindingProps( m_xExternalBinding, UNO_QUERY );
-        Reference< XPropertySetInfo > xBindingPropsInfo( xBindingProps.is() ? xBindingProps->getPropertySetInfo() : Reference< XPropertySetInfo >() );
-        if ( xBindingPropsInfo.is() )
+    void OBoundControlModel::doSetControlValue( const Any& _rValue )
+    {
+        OSL_PRECOND( m_xAggregateFastSet.is() && m_xAggregateSet.is(),
+            "OBoundControlModel::doSetControlValue: invalid aggregate !" );
+        OSL_PRECOND( !m_sValuePropertyName.isEmpty() || ( m_nValuePropertyAggregateHandle != -1 ),
+            "OBoundControlModel::doSetControlValue: please override if you have own value property handling!" );
+        try
         {
-            if ( xBindingPropsInfo->hasPropertyByName( PROPERTY_READONLY ) )
+            // release our mutex once (it's acquired in one of the calling methods), as setting aggregate properties
+            // may cause any uno controls belonging to us to lock the solar mutex, which is potentially dangerous with
+            // our own mutex locked
+            MutexRelease aRelease( m_aMutex );
+            if ( ( m_nValuePropertyAggregateHandle != -1 ) && m_xAggregateFastSet.is() )
             {
-                xBindingProps->addPropertyChangeListener( PROPERTY_READONLY, this );
-                m_bBindingControlsRO = sal_True;
+                m_xAggregateFastSet->setFastPropertyValue( m_nValuePropertyAggregateHandle, _rValue );
             }
-            if ( xBindingPropsInfo->hasPropertyByName( PROPERTY_RELEVANT ) )
+            else if ( !m_sValuePropertyName.isEmpty() && m_xAggregateSet.is() )
             {
-                xBindingProps->addPropertyChangeListener( PROPERTY_RELEVANT, this );
-                m_bBindingControlsEnable = sal_True;
+                m_xAggregateSet->setPropertyValue( m_sValuePropertyName, _rValue );
             }
         }
+        catch( const Exception& )
+        {
+            SAL_WARN("forms.component",  "OBoundControlModel::doSetControlValue: caught an exception!");
+            DBG_UNHANDLED_EXCEPTION();
+        }
     }
-    catch( const Exception& )
+
+    void OBoundControlModel::onConnectedValidator( )
     {
-        DBG_UNHANDLED_EXCEPTION();
+        try
+        {
+            // if we have an external validator, we do not want the control to force invalid
+            // inputs to the default value. Instead, invalid inputs should be translated
+            // to NaN (not a number)
+            Reference< XPropertySetInfo > xAggregatePropertyInfo;
+            if ( m_xAggregateSet.is() )
+                xAggregatePropertyInfo = m_xAggregateSet->getPropertySetInfo();
+            if ( xAggregatePropertyInfo.is() && xAggregatePropertyInfo->hasPropertyByName( PROPERTY_ENFORCE_FORMAT ) )
+                m_xAggregateSet->setPropertyValue( PROPERTY_ENFORCE_FORMAT, makeAny( (sal_Bool)sal_False ) );
+        }
+        catch( const Exception& )
+        {
+            SAL_WARN("forms.component",  "OBoundControlModel::onConnectedValidator: caught an exception!");
+            DBG_UNHANDLED_EXCEPTION();
+        }
+        recheckValidity( false );
     }
 
-    // propagate our new value
-    transferExternalValueToControl( _rInstanceLock );
-
-    // if the binding is also a validator, use it, too. This is a constraint of the
-    // com.sun.star.form.binding.ValidatableBindableFormComponent service
-    if ( m_bSupportsValidation )
+    void OBoundControlModel::onDisconnectedValidator( )
     {
         try
         {
-            Reference< XValidator > xAsValidator( _rxBinding, UNO_QUERY );
-            if ( xAsValidator.is() )
-                setValidator( xAsValidator );
+            Reference< XPropertySetInfo > xAggregatePropertyInfo;
+            if ( m_xAggregateSet.is() )
+                xAggregatePropertyInfo = m_xAggregateSet->getPropertySetInfo();
+            if ( xAggregatePropertyInfo.is() && xAggregatePropertyInfo->hasPropertyByName( PROPERTY_ENFORCE_FORMAT ) )
+                m_xAggregateSet->setPropertyValue( PROPERTY_ENFORCE_FORMAT, makeAny( (sal_Bool)sal_True ) );
         }
         catch( const Exception& )
         {
+            SAL_WARN("forms.component",  "OBoundControlModel::onDisconnectedValidator: caught an exception!");
             DBG_UNHANDLED_EXCEPTION();
         }
+        recheckValidity( false );
     }
-}
 
-//--------------------------------------------------------------------
-void OBoundControlModel::disconnectExternalValueBinding( )
-{
-    try
+    void OBoundControlModel::onConnectedExternalValue( )
     {
-        // not listening at the binding anymore
-        Reference< XModifyBroadcaster > xModifiable( m_xExternalBinding, UNO_QUERY );
-        if ( xModifiable.is() )
-            xModifiable->removeModifyListener( this );
-
-        // remove as property change listener
-        Reference< XPropertySet > xBindingProps( m_xExternalBinding, UNO_QUERY );
-        if ( m_bBindingControlsRO )
-            xBindingProps->removePropertyChangeListener( PROPERTY_READONLY, this );
-        if ( m_bBindingControlsEnable )
-            xBindingProps->removePropertyChangeListener( PROPERTY_RELEVANT, this );
+        calculateExternalValueType();
     }
-    catch( const Exception& )
+
+    void OBoundControlModel::onDisconnectedExternalValue( )
     {
-        SAL_WARN("forms.component",  "OBoundControlModel::disconnectExternalValueBinding: caught an exception!");
-        DBG_UNHANDLED_EXCEPTION();
     }
 
-    // if the binding also acts as our validator, disconnect the validator, too
-    if ( ( m_xExternalBinding == m_xValidator ) && m_xValidator.is() )
-        disconnectValidator( );
-
-    // no binding anymore
-    m_xExternalBinding.clear();
-
-    // be a load listener at our form, again. This was suspended while we had
-    // an external value binding in place.
-    doFormListening( true );
-
-    // re-connect to database column of the new parent
-    if ( m_xAmbientForm.is() && m_xAmbientForm->isLoaded() )
-        impl_connectDatabaseColumn_noNotify( false );
-
-    // tell the derivee
-    onDisconnectedExternalValue();
-}
-
-//--------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::setValueBinding( const Reference< XValueBinding >& _rxBinding ) throw (IncompatibleTypesException, RuntimeException)
-{
-    OSL_PRECOND( m_bSupportsExternalBinding, "OBoundControlModel::setValueBinding: How did you reach this method?" );
-        // the interface for this method should not have been exposed if we do not
-        // support binding to external data
-    // allow reset
-    if ( _rxBinding.is() && !impl_approveValueBinding_nolock( _rxBinding ) )
-    {
-        throw IncompatibleTypesException(
-            FRM_RES_STRING( RID_STR_INCOMPATIBLE_TYPES ),
-            *this
-        );
+    void OBoundControlModel::onConnectedDbColumn( const Reference< XInterface >& /*_rxForm*/ )
+    {
+        OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::onConnectedDbColumn: how this? There's an external value binding!" );
     }
 
-    ControlModelLock aLock( *this );
-
-    // since a ValueBinding overrules any potentially active database binding, the change in a ValueBinding
-    // might trigger a change in our BoundField.
-    FieldChangeNotifier aBoundFieldNotifier( aLock );
-
-    // disconnect from the old binding
-    if ( hasExternalValueBinding() )
-        disconnectExternalValueBinding( );
-
-    // connect to the new binding
-    if ( _rxBinding.is() )
-        connectExternalValueBinding( _rxBinding, aLock );
-}
+    void OBoundControlModel::onDisconnectedDbColumn()
+    {
+        OSL_PRECOND( !hasExternalValueBinding(), "OBoundControlModel::onDisconnectedDbColumn: how this? There's an external value binding!" );
+    }
 
-//--------------------------------------------------------------------
-Reference< XValueBinding > SAL_CALL OBoundControlModel::getValueBinding(  ) throw (RuntimeException)
-{
-    ::osl::MutexGuard aGuard( m_aMutex );
-    OSL_PRECOND( m_bSupportsExternalBinding, "OBoundControlModel::getValueBinding: How did you reach this method?" );
-        // the interface for this method should not have been exposed if we do not
-        // support binding to external data
+    // XReset
+    Any OBoundControlModel::getDefaultForReset() const
+    {
+        return Any();
+    }
 
-    return m_xExternalBinding;
-}
+    void OBoundControlModel::resetNoBroadcast()
+    {
+        setControlValue( getDefaultForReset(), eOther );
+    }
 
-//--------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::modified( const EventObject& _rEvent ) throw ( RuntimeException )
-{
-    ControlModelLock aLock( *this );
+    void OBoundControlModel::addResetListener(const Reference<XResetListener>& l) throw (RuntimeException)
+    {
+        m_aResetHelper.addResetListener( l );
+    }
 
-    OSL_PRECOND( hasExternalValueBinding(), "OBoundControlModel::modified: Where did this come from?" );
-    if ( !m_bTransferingValue && ( m_xExternalBinding == _rEvent.Source ) && m_xExternalBinding.is() )
+    void OBoundControlModel::removeResetListener(const Reference<XResetListener>& l) throw (RuntimeException)
     {
-        transferExternalValueToControl( aLock );
+        m_aResetHelper.removeResetListener( l );
     }
-}
 
-//--------------------------------------------------------------------
-void OBoundControlModel::transferDbValueToControl( )
-{
-    try
+    void OBoundControlModel::reset() throw (RuntimeException)
     {
-        setControlValue( translateDbColumnToControlValue(), eDbColumnBinding );
+        if ( !m_aResetHelper.approveReset() )
+           return;
+        ControlModelLock aLock( *this );
+        // on a new record?
+        sal_Bool bIsNewRecord = sal_False;
+        Reference<XPropertySet> xSet( m_xCursor, UNO_QUERY );
+        if ( xSet.is() )
+        {
+            try
+            {
+                xSet->getPropertyValue( PROPERTY_ISNEW ) >>= bIsNewRecord;
+            }
+            catch( const Exception& )
+            {
+                DBG_UNHANDLED_EXCEPTION();
+            }
+        }
+        // cursor on an invalid row?
+        sal_Bool bInvalidCursorPosition = sal_True;
+        try
+        {
+            bInvalidCursorPosition =    m_xCursor.is()
+                                    &&  (  m_xCursor->isAfterLast()
+                                        || m_xCursor->isBeforeFirst()
+                                        )
+                                    &&  !bIsNewRecord;
+        }
+        catch( const SQLException& )
+        {
+            SAL_WARN("forms.component",  "OBoundControlModel::reset: caught an SQL exception!" );
+            DBG_UNHANDLED_EXCEPTION();
+        }
+        // #i24495# - don't count the insert row as "invalid"
+        sal_Bool bSimpleReset =
+                            (   !m_xColumn.is()                     // no connection to a database column
+                            ||  (   m_xCursor.is()                  // OR   we have an improperly positioned cursor
+                                &&  bInvalidCursorPosition
+                                )
+                            ||  hasExternalValueBinding()           // OR we have an external value binding
+                            );
+        if ( !bSimpleReset )
+        {
+            // The default values will be set if and only if the current value of the field which we're bound
+            // to is NULL.
+            // Else, the current field value should be refreshed
+            // This behaviour is not completely ... "matured": What should happen if the field as well as the
+            // control have a default value?
+            sal_Bool bIsNull = sal_True;
+            // we have to access the field content at least once to get a reliable result by XColumn::wasNull
+            try
+            {
+                // normally, we'd do a getString here. However, this is extremely expensive in the case
+                // of binary fields. Unfortunately, getString is the only method which is guaranteed
+                // to *always* succeed, all other getXXX methods may fail if the column is asked for a
+                // non-convertible type
+                sal_Int32 nFieldType = DataType::OBJECT;
+                getField()->getPropertyValue( PROPERTY_FIELDTYPE ) >>= nFieldType;
+                if  (  ( nFieldType == DataType::BINARY        )
+                    || ( nFieldType == DataType::VARBINARY     )
+                    || ( nFieldType == DataType::LONGVARBINARY )
+                    || ( nFieldType == DataType::OBJECT        )
+                    /*|| ( nFieldType == DataType::CLOB          )*/
+                    )
+                    m_xColumn->getBinaryStream();
+                else if ( nFieldType == DataType::BLOB          )
+                    m_xColumn->getBlob();
+                else
+                    m_xColumn->getString();
+                bIsNull = m_xColumn->wasNull();
+            }
+            catch(const Exception&)
+            {
+                SAL_WARN("forms.component", "OBoundControlModel::reset: this should have succeeded in all cases!");
+                DBG_UNHANDLED_EXCEPTION();
+            }
+            sal_Bool bNeedValueTransfer = sal_True;
+            if ( bIsNull )
+            {
+                if ( bIsNewRecord )
+                {
+                    // reset the control to it's default
+                    resetNoBroadcast();
+                    // and immediately commit the changes to the DB column, to keep consistency
+                    commitControlValueToDbColumn( true );
+                    bNeedValueTransfer = sal_False;
+                }
+            }
+            if ( bNeedValueTransfer )
+                transferDbValueToControl();
+        }
+        else
+        {
+            resetNoBroadcast();
+            // transfer to the external binding, if necessary
+            if ( hasExternalValueBinding() )
+                transferControlValueToExternal( aLock );
+        }
+        // revalidate, if necessary
+        if ( hasValidator() )
+            recheckValidity( true );
+        aLock.release();
+        m_aResetHelper.notifyResetted();
     }
-    catch( const Exception& )
+
+    void OBoundControlModel::impl_setField_noNotify( const Reference< XPropertySet>& _rxField )
     {
-        DBG_UNHANDLED_EXCEPTION();
+        DBG_ASSERT( !hasExternalValueBinding(), "OBoundControlModel::impl_setField_noNotify: We have an external value binding!" );
+        m_xField = _rxField;
     }
-}
 
-//------------------------------------------------------------------------------
-void OBoundControlModel::transferExternalValueToControl( ControlModelLock& _rInstanceLock )
-{
-        Reference< XValueBinding > xExternalBinding( m_xExternalBinding );
-        Type aValueExchangeType( getExternalValueType() );
+    sal_Bool OBoundControlModel::impl_approveValueBinding_nolock( const Reference< XValueBinding >& _rxBinding )
+    {
+        if ( !_rxBinding.is() )
+            return sal_False;
+        Sequence< Type > aTypeCandidates;
+        {
+            // SYNCHRONIZED >
+            ::osl::MutexGuard aGuard( m_aMutex );
+            aTypeCandidates = getSupportedBindingTypes();
+            // < SYNCHRONIZED
+        }
+        for (   const Type* pType = aTypeCandidates.getConstArray();
+                pType != aTypeCandidates.getConstArray() + aTypeCandidates.getLength();
+                ++pType
+            )
+        {
+            if ( _rxBinding->supportsType( *pType ) )
+                return sal_True;
+        }
+        return sal_False;
+    }
 
-        _rInstanceLock.release();
-        // >>>>>>>> ----- UNSAFE ----- >>>>>>>>
-        Any aExternalValue;
+    void OBoundControlModel::connectExternalValueBinding(
+            const Reference< XValueBinding >& _rxBinding, ControlModelLock& _rInstanceLock )
+    {
+        OSL_PRECOND( _rxBinding.is(), "OBoundControlModel::connectExternalValueBinding: invalid binding instance!" );
+        OSL_PRECOND( !hasExternalValueBinding( ), "OBoundControlModel::connectExternalValueBinding: precond not met (currently have a binding)!" );
+        // if we're connected to a database column, suspend this
+        if ( hasField() )
+            impl_disconnectDatabaseColumn_noNotify();
+        // suspend listening for load-related events at out ambient form.
+        // This is because an external value binding overrules a possible database binding.
+        if ( isFormListening() )
+            doFormListening( false );
+        // remember this new binding
+        m_xExternalBinding = _rxBinding;
+        // tell the derivee
+        onConnectedExternalValue();
         try
         {
-            aExternalValue = xExternalBinding->getValue( aValueExchangeType );
+            // add as value listener so we get notified when the value changes
+            Reference< XModifyBroadcaster > xModifiable( m_xExternalBinding, UNO_QUERY );
+            if ( xModifiable.is() )
+                xModifiable->addModifyListener( this );
+            // add as property change listener for some (possibly present) properties we're
+            // interested in
+            Reference< XPropertySet > xBindingProps( m_xExternalBinding, UNO_QUERY );
+            Reference< XPropertySetInfo > xBindingPropsInfo( xBindingProps.is() ? xBindingProps->getPropertySetInfo() : Reference< XPropertySetInfo >() );
+            if ( xBindingPropsInfo.is() )
+            {
+                if ( xBindingPropsInfo->hasPropertyByName( PROPERTY_READONLY ) )
+                {
+                    xBindingProps->addPropertyChangeListener( PROPERTY_READONLY, this );
+                    m_bBindingControlsRO = sal_True;
+                }
+                if ( xBindingPropsInfo->hasPropertyByName( PROPERTY_RELEVANT ) )
+                {
+                    xBindingProps->addPropertyChangeListener( PROPERTY_RELEVANT, this );
+                    m_bBindingControlsEnable = sal_True;
+                }
+            }
         }
         catch( const Exception& )
         {
             DBG_UNHANDLED_EXCEPTION();
         }
-        // <<<<<<<< ----- UNSAFE ----- <<<<<<<<
-        _rInstanceLock.acquire();
-
-        setControlValue( translateExternalValueToControlValue( aExternalValue ), eExternalBinding );
-}
-
-//------------------------------------------------------------------------------
-void OBoundControlModel::transferControlValueToExternal( ControlModelLock& _rInstanceLock )
-{
-    OSL_PRECOND( m_bSupportsExternalBinding && hasExternalValueBinding(),
-        "OBoundControlModel::transferControlValueToExternal: precondition not met!" );
+        // propagate our new value
+        transferExternalValueToControl( _rInstanceLock );
+        // if the binding is also a validator, use it, too. This is a constraint of the
+        // com.sun.star.form.binding.ValidatableBindableFormComponent service
+        if ( m_bSupportsValidation )
+        {
+            try
+            {
+                Reference< XValidator > xAsValidator( _rxBinding, UNO_QUERY );
+                if ( xAsValidator.is() )
+                    setValidator( xAsValidator );
+            }
+            catch( const Exception& )
+            {
+                DBG_UNHANDLED_EXCEPTION();
+            }
+        }
+    }
 
-    if ( m_xExternalBinding.is() )
+    void OBoundControlModel::disconnectExternalValueBinding( )
     {
-        Any aExternalValue( translateControlValueToExternalValue() );
-        m_bTransferingValue = sal_True;
-
-        _rInstanceLock.release();
-         // >>>>>>>> ----- UNSAFE ----- >>>>>>>>
         try
         {
-            m_xExternalBinding->setValue( aExternalValue );
+            // not listening at the binding anymore
+            Reference< XModifyBroadcaster > xModifiable( m_xExternalBinding, UNO_QUERY );
+            if ( xModifiable.is() )
+                xModifiable->removeModifyListener( this );
+            // remove as property change listener
+            Reference< XPropertySet > xBindingProps( m_xExternalBinding, UNO_QUERY );
+            if ( m_bBindingControlsRO )
+                xBindingProps->removePropertyChangeListener( PROPERTY_READONLY, this );
+            if ( m_bBindingControlsEnable )
+                xBindingProps->removePropertyChangeListener( PROPERTY_RELEVANT, this );
         }
         catch( const Exception& )
         {
+            SAL_WARN("forms.component",  "OBoundControlModel::disconnectExternalValueBinding: caught an exception!");
             DBG_UNHANDLED_EXCEPTION();
         }
-        // <<<<<<<< ----- UNSAFE ----- <<<<<<<<
-        _rInstanceLock.acquire();
-
-        m_bTransferingValue = sal_False;
+        // if the binding also acts as our validator, disconnect the validator, too
+        if ( ( m_xExternalBinding == m_xValidator ) && m_xValidator.is() )
+            disconnectValidator( );
+        // no binding anymore
+        m_xExternalBinding.clear();
+        // be a load listener at our form, again. This was suspended while we had
+        // an external value binding in place.
+        doFormListening( true );
+        // re-connect to database column of the new parent
+        if ( m_xAmbientForm.is() && m_xAmbientForm->isLoaded() )
+            impl_connectDatabaseColumn_noNotify( false );
+        // tell the derivee
+        onDisconnectedExternalValue();
     }
-}
-
-// -----------------------------------------------------------------------------
-Sequence< Type > OBoundControlModel::getSupportedBindingTypes()
-{
-    return Sequence< Type >( &m_aValuePropertyType, 1 );
-}
-
-//-----------------------------------------------------------------------------
-void OBoundControlModel::calculateExternalValueType()
-{
-    m_aExternalValueType = Type();
-    if ( !m_xExternalBinding.is() )
-        return;
 
-    Sequence< Type > aTypeCandidates( getSupportedBindingTypes() );
-    for (   const Type* pTypeCandidate = aTypeCandidates.getConstArray();
-            pTypeCandidate != aTypeCandidates.getConstArray() + aTypeCandidates.getLength();
-            ++pTypeCandidate
-        )
+    void SAL_CALL OBoundControlModel::setValueBinding( const Reference< XValueBinding >& _rxBinding ) throw (IncompatibleTypesException, RuntimeException)
     {
-        if ( m_xExternalBinding->supportsType( *pTypeCandidate ) )
+        OSL_PRECOND( m_bSupportsExternalBinding, "OBoundControlModel::setValueBinding: How did you reach this method?" );
+            // the interface for this method should not have been exposed if we do not
+            // support binding to external data
+        // allow reset
+        if ( _rxBinding.is() && !impl_approveValueBinding_nolock( _rxBinding ) )
         {
-            m_aExternalValueType = *pTypeCandidate;
-            break;
+            throw IncompatibleTypesException(
+                FRM_RES_STRING( RID_STR_INCOMPATIBLE_TYPES ),
+                *this
+            );
         }
+        ControlModelLock aLock( *this );
+        // since a ValueBinding overrules any potentially active database binding, the change in a ValueBinding
+        // might trigger a change in our BoundField.
+        FieldChangeNotifier aBoundFieldNotifier( aLock );
+        // disconnect from the old binding
+        if ( hasExternalValueBinding() )
+            disconnectExternalValueBinding( );
+        // connect to the new binding
+        if ( _rxBinding.is() )
+            connectExternalValueBinding( _rxBinding, aLock );
     }
-}
-
-//-----------------------------------------------------------------------------
-Any OBoundControlModel::translateExternalValueToControlValue( const Any& _rExternalValue ) const
-{
-    OSL_PRECOND( m_bSupportsExternalBinding && hasExternalValueBinding(),
-        "OBoundControlModel::translateExternalValueToControlValue: precondition not met!" );
-
-    Any aControlValue( _rExternalValue );
-
-    // if the external value is VOID, and our value property is not allowed to be VOID,
-    // then default-construct a value
-    if ( !aControlValue.hasValue() && !m_bValuePropertyMayBeVoid )
-        aControlValue.setValue( NULL, m_aValuePropertyType );
-
-    // outta here
-    return aControlValue;
-}
-
-//------------------------------------------------------------------------------
-Any OBoundControlModel::translateControlValueToExternalValue( ) const
-{
-    return getControlValue( );
-}
-
-//------------------------------------------------------------------------------
-Any OBoundControlModel::translateControlValueToValidatableValue( ) const
-{
-    OSL_PRECOND( m_xValidator.is(), "OBoundControlModel::translateControlValueToValidatableValue: no validator, so why should I?" );
-    if ( ( m_xValidator == m_xExternalBinding ) && m_xValidator.is() )
-        return translateControlValueToExternalValue();
-    return getControlValue();
-}
 
-//------------------------------------------------------------------------------
-Any OBoundControlModel::getControlValue( ) const
-{
-    OSL_PRECOND( m_xAggregateFastSet.is() && m_xAggregateSet.is(),
-        "OBoundControlModel::getControlValue: invalid aggregate !" );
-    OSL_PRECOND( !m_sValuePropertyName.isEmpty() || ( m_nValuePropertyAggregateHandle != -1 ),
-        "OBoundControlModel::getControlValue: please override if you have own value property handling!" );
-
-    // determine the current control value
-    Any aControlValue;
-    if ( ( m_nValuePropertyAggregateHandle != -1 ) && m_xAggregateFastSet.is() )
+    Reference< XValueBinding > SAL_CALL OBoundControlModel::getValueBinding(  ) throw (RuntimeException)
     {
-        aControlValue = m_xAggregateFastSet->getFastPropertyValue( m_nValuePropertyAggregateHandle );
+        ::osl::MutexGuard aGuard( m_aMutex );
+        OSL_PRECOND( m_bSupportsExternalBinding, "OBoundControlModel::getValueBinding: How did you reach this method?" );
+            // the interface for this method should not have been exposed if we do not
+            // support binding to external data
+        return m_xExternalBinding;
     }
-    else if ( !m_sValuePropertyName.isEmpty() && m_xAggregateSet.is() )
+
+    void SAL_CALL OBoundControlModel::modified( const EventObject& _rEvent ) throw ( RuntimeException )
     {
-        aControlValue = m_xAggregateSet->getPropertyValue( m_sValuePropertyName );
+        ControlModelLock aLock( *this );
+        OSL_PRECOND( hasExternalValueBinding(), "OBoundControlModel::modified: Where did this come from?" );
+        if ( !m_bTransferingValue && ( m_xExternalBinding == _rEvent.Source ) && m_xExternalBinding.is() )
+        {
+            transferExternalValueToControl( aLock );
+        }
     }
 
-    return aControlValue;
-}
-
-//--------------------------------------------------------------------
-void OBoundControlModel::connectValidator( const Reference< XValidator >& _rxValidator )
-{
-    OSL_PRECOND( _rxValidator.is(), "OBoundControlModel::connectValidator: invalid validator instance!" );
-    OSL_PRECOND( !hasValidator( ), "OBoundControlModel::connectValidator: precond not met (have a validator currently)!" );
-
-    m_xValidator = _rxValidator;
-
-    // add as value listener so we get notified when the value changes
-    if ( m_xValidator.is() )
+    void OBoundControlModel::transferDbValueToControl( )
     {
         try
         {
-            m_xValidator->addValidityConstraintListener( this );
+            setControlValue( translateDbColumnToControlValue(), eDbColumnBinding );
         }
-        catch( const RuntimeException& )
+        catch( const Exception& )
         {
+            DBG_UNHANDLED_EXCEPTION();
         }
     }
 
-    onConnectedValidator( );
-}
-
-//--------------------------------------------------------------------
-void OBoundControlModel::disconnectValidator( )
-{
-    OSL_PRECOND( hasValidator( ), "OBoundControlModel::connectValidator: precond not met (don't have a validator currently)!" );
+    void OBoundControlModel::transferExternalValueToControl( ControlModelLock& _rInstanceLock )
+    {
+            Reference< XValueBinding > xExternalBinding( m_xExternalBinding );
+            Type aValueExchangeType( getExternalValueType() );
+            _rInstanceLock.release();
+            // UNSAFE >
+            Any aExternalValue;
+            try
+            {
+                aExternalValue = xExternalBinding->getValue( aValueExchangeType );
+            }
+            catch( const Exception& )
+            {
+                DBG_UNHANDLED_EXCEPTION();
+            }
+            // < UNSAFE
+            _rInstanceLock.acquire();
+            setControlValue( translateExternalValueToControlValue( aExternalValue ), eExternalBinding );
+    }
 
-    // add as value listener so we get notified when the value changes
-    if ( m_xValidator.is() )
+    void OBoundControlModel::transferControlValueToExternal( ControlModelLock& _rInstanceLock )
     {
-        try
+        OSL_PRECOND( m_bSupportsExternalBinding && hasExternalValueBinding(),
+            "OBoundControlModel::transferControlValueToExternal: precondition not met!" );
+        if ( m_xExternalBinding.is() )
         {
-            m_xValidator->removeValidityConstraintListener( this );
+            Any aExternalValue( translateControlValueToExternalValue() );
+            m_bTransferingValue = sal_True;
+            _rInstanceLock.release();
+             // UNSAFE >
+            try
+            {
+                m_xExternalBinding->setValue( aExternalValue );
+            }
+            catch( const Exception& )
+            {
+                DBG_UNHANDLED_EXCEPTION();
+            }
+            // < UNSAFE
+            _rInstanceLock.acquire();
+            m_bTransferingValue = sal_False;
         }
-        catch( const RuntimeException& )
+    }
+
+    Sequence< Type > OBoundControlModel::getSupportedBindingTypes()
+    {
+        return Sequence< Type >( &m_aValuePropertyType, 1 );
+    }
+
+    void OBoundControlModel::calculateExternalValueType()
+    {
+        m_aExternalValueType = Type();
+        if ( !m_xExternalBinding.is() )
+            return;
+        Sequence< Type > aTypeCandidates( getSupportedBindingTypes() );
+        for (   const Type* pTypeCandidate = aTypeCandidates.getConstArray();
+                pTypeCandidate != aTypeCandidates.getConstArray() + aTypeCandidates.getLength();
+                ++pTypeCandidate
+            )
         {
+            if ( m_xExternalBinding->supportsType( *pTypeCandidate ) )
+            {
+                m_aExternalValueType = *pTypeCandidate;
+                break;
+            }
         }
     }
 
-    m_xValidator.clear();
-
-    onDisconnectedValidator( );
-}
+    Any OBoundControlModel::translateExternalValueToControlValue( const Any& _rExternalValue ) const
+    {
+        OSL_PRECOND( m_bSupportsExternalBinding && hasExternalValueBinding(),
+            "OBoundControlModel::translateExternalValueToControlValue: precondition not met!" );
+        Any aControlValue( _rExternalValue );
+        // if the external value is VOID, and our value property is not allowed to be VOID,
+        // then default-construct a value
+        if ( !aControlValue.hasValue() && !m_bValuePropertyMayBeVoid )
+            aControlValue.setValue( NULL, m_aValuePropertyType );
+        // out of here
+        return aControlValue;
+    }
 
-//--------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::setValidator( const Reference< XValidator >& _rxValidator ) throw (VetoException,RuntimeException)
-{
-    ::osl::ClearableMutexGuard aGuard( m_aMutex );
-    OSL_PRECOND( m_bSupportsValidation, "OBoundControlModel::setValidator: How did you reach this method?" );
-        // the interface for this method should not have been exposed if we do not
-        // support validation
-
-    // early out if the validator does not change
-    if( _rxValidator == m_xValidator )
-        return;
-
-    if ( m_xValidator.is() && ( m_xValidator == m_xExternalBinding ) )
-        throw VetoException(
-            FRM_RES_STRING( RID_STR_INVALID_VALIDATOR ),
-            *this
-        );
+    Any OBoundControlModel::translateControlValueToExternalValue( ) const
+    {
+        return getControlValue( );
+    }
 
-    // disconnect from the old validator
-    if ( hasValidator() )
-        disconnectValidator( );
+    Any OBoundControlModel::translateControlValueToValidatableValue( ) const
+    {
+        OSL_PRECOND( m_xValidator.is(), "OBoundControlModel::translateControlValueToValidatableValue: no validator, so why should I?" );
+        if ( ( m_xValidator == m_xExternalBinding ) && m_xValidator.is() )
+            return translateControlValueToExternalValue();
+        return getControlValue();
+    }
 
-    // connect to the new validator
-    if ( _rxValidator.is() )
-        connectValidator( _rxValidator );
-}
+    Any OBoundControlModel::getControlValue( ) const
+    {
+        OSL_PRECOND( m_xAggregateFastSet.is() && m_xAggregateSet.is(),
+            "OBoundControlModel::getControlValue: invalid aggregate !" );
+        OSL_PRECOND( !m_sValuePropertyName.isEmpty() || ( m_nValuePropertyAggregateHandle != -1 ),
+            "OBoundControlModel::getControlValue: please override if you have own value property handling!" );
+        // determine the current control value
+        Any aControlValue;
+        if ( ( m_nValuePropertyAggregateHandle != -1 ) && m_xAggregateFastSet.is() )
+        {
+            aControlValue = m_xAggregateFastSet->getFastPropertyValue( m_nValuePropertyAggregateHandle );
+        }
+        else if ( !m_sValuePropertyName.isEmpty() && m_xAggregateSet.is() )
+        {
+            aControlValue = m_xAggregateSet->getPropertyValue( m_sValuePropertyName );
+        }
+        return aControlValue;
+    }
 
-//--------------------------------------------------------------------
-Reference< XValidator > SAL_CALL OBoundControlModel::getValidator(  ) throw (RuntimeException)
-{
-    ::osl::MutexGuard aGuard( m_aMutex );
-    OSL_PRECOND( m_bSupportsValidation, "OBoundControlModel::getValidator: How did you reach this method?" );
-        // the interface for this method should not have been exposed if we do not
-        // support validation
+    void OBoundControlModel::connectValidator( const Reference< XValidator >& _rxValidator )
+    {
+        OSL_PRECOND( _rxValidator.is(), "OBoundControlModel::connectValidator: invalid validator instance!" );
+        OSL_PRECOND( !hasValidator( ), "OBoundControlModel::connectValidator: precond not met (have a validator currently)!" );
+        m_xValidator = _rxValidator;
+        // add as value listener so we get notified when the value changes
+        if ( m_xValidator.is() )
+        {
+            try
+            {
+                m_xValidator->addValidityConstraintListener( this );
+            }
+            catch( const RuntimeException& )
+            {
+            }
+        }
+        onConnectedValidator( );
+    }
 
-    return m_xValidator;
-}
+    void OBoundControlModel::disconnectValidator( )
+    {
+        OSL_PRECOND( hasValidator( ), "OBoundControlModel::connectValidator: precond not met (don't have a validator currently)!" );
+        // add as value listener so we get notified when the value changes
+        if ( m_xValidator.is() )
+        {
+            try
+            {
+                m_xValidator->removeValidityConstraintListener( this );
+            }
+            catch( const RuntimeException& )
+            {
+            }
+        }
+        m_xValidator.clear();
+        onDisconnectedValidator( );
+    }
 
-//--------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::validityConstraintChanged( const EventObject& /*Source*/ ) throw (RuntimeException)
-{
-    ::osl::ClearableMutexGuard aGuard( m_aMutex );
-    OSL_PRECOND( m_bSupportsValidation, "OBoundControlModel::validityConstraintChanged: How did you reach this method?" );
-        // the interface for this method should not have been exposed if we do not
-        // support validation
+    void SAL_CALL OBoundControlModel::setValidator( const Reference< XValidator >& _rxValidator ) throw (VetoException,RuntimeException)
+    {
+        ::osl::ClearableMutexGuard aGuard( m_aMutex );
+        OSL_PRECOND( m_bSupportsValidation, "OBoundControlModel::setValidator: How did you reach this method?" );
+            // the interface for this method should not have been exposed if we do not
+            // support validation
+        // early out if the validator does not change
+        if( _rxValidator == m_xValidator )
+            return;
+        if ( m_xValidator.is() && ( m_xValidator == m_xExternalBinding ) )
+            throw VetoException(
+                FRM_RES_STRING( RID_STR_INVALID_VALIDATOR ),
+                *this
+            );
+        // disconnect from the old validator
+        if ( hasValidator() )
+            disconnectValidator( );
+        // connect to the new validator
+        if ( _rxValidator.is() )
+            connectValidator( _rxValidator );
+    }
 
-    recheckValidity( false );
-}
+    Reference< XValidator > SAL_CALL OBoundControlModel::getValidator(  ) throw (RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+        OSL_PRECOND( m_bSupportsValidation, "OBoundControlModel::getValidator: How did you reach this method?" );
+            // the interface for this method should not have been exposed if we do not
+            // support validation
+        return m_xValidator;
+    }
 
-//--------------------------------------------------------------------
-sal_Bool SAL_CALL OBoundControlModel::isValid(  ) throw (RuntimeException)
-{
-    return m_bIsCurrentValueValid;
-}
+    void SAL_CALL OBoundControlModel::validityConstraintChanged( const EventObject& /*Source*/ ) throw (RuntimeException)
+    {
+        ::osl::ClearableMutexGuard aGuard( m_aMutex );
+        OSL_PRECOND( m_bSupportsValidation, "OBoundControlModel::validityConstraintChanged: How did you reach this method?" );
+            // the interface for this method should not have been exposed if we do not
+            // support validation
+        recheckValidity( false );
+    }
 
-//--------------------------------------------------------------------
-::com::sun::star::uno::Any OBoundControlModel::getCurrentFormComponentValue() const
-{
-    if ( hasValidator() )
-        return translateControlValueToValidatableValue();
-    return getControlValue();
-}
+    sal_Bool SAL_CALL OBoundControlModel::isValid(  ) throw (RuntimeException)
+    {
+        return m_bIsCurrentValueValid;
+    }
 
-//--------------------------------------------------------------------
-Any SAL_CALL OBoundControlModel::getCurrentValue(  ) throw (RuntimeException)
-{
-    ::osl::MutexGuard aGuard( m_aMutex );
-    return getCurrentFormComponentValue();
-}
+    ::com::sun::star::uno::Any OBoundControlModel::getCurrentFormComponentValue() const
+    {
+        if ( hasValidator() )
+            return translateControlValueToValidatableValue();
+        return getControlValue();
+    }
 
-//--------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::addFormComponentValidityListener( const Reference< validation::XFormComponentValidityListener >& Listener ) throw (NullPointerException, RuntimeException)
-{
-    if ( Listener.is() )
-        m_aFormComponentListeners.addInterface( Listener );
-}
+    Any SAL_CALL OBoundControlModel::getCurrentValue(  ) throw (RuntimeException)
+    {
+        ::osl::MutexGuard aGuard( m_aMutex );
+        return getCurrentFormComponentValue();
+    }
 
-//--------------------------------------------------------------------
-void SAL_CALL OBoundControlModel::removeFormComponentValidityListener( const Reference< validation::XFormComponentValidityListener >& Listener ) throw (NullPointerException, RuntimeException)
-{
-    if ( Listener.is() )
-        m_aFormComponentListeners.removeInterface( Listener );
-}
+    void SAL_CALL OBoundControlModel::addFormComponentValidityListener( const Reference< validation::XFormComponentValidityListener >& Listener ) throw (NullPointerException, RuntimeException)
+    {
+        if ( Listener.is() )
+            m_aFormComponentListeners.addInterface( Listener );
+    }
 
-//--------------------------------------------------------------------
-void OBoundControlModel::recheckValidity( bool _bForceNotification )
-{
-    try
+    void SAL_CALL OBoundControlModel::removeFormComponentValidityListener( const Reference< validation::XFormComponentValidityListener >& Listener ) throw (NullPointerException, RuntimeException)
     {
-        sal_Bool bIsCurrentlyValid = sal_True;
-        if ( hasValidator() )
-            bIsCurrentlyValid = m_xValidator->isValid( translateControlValueToValidatableValue() );
+        if ( Listener.is() )
+            m_aFormComponentListeners.removeInterface( Listener );
+    }
 
-        if ( ( bIsCurrentlyValid != m_bIsCurrentValueValid ) || _bForceNotification )
+    void OBoundControlModel::recheckValidity( bool _bForceNotification )
+    {
+        try
         {
-            m_bIsCurrentValueValid = bIsCurrentlyValid;
-
-            // release our mutex for the notifications
-            MutexRelease aRelease( m_aMutex );
-            m_aFormComponentListeners.notifyEach( &validation::XFormComponentValidityListener::componentValidityChanged, EventObject( *this ) );
+            sal_Bool bIsCurrentlyValid = sal_True;
+            if ( hasValidator() )
+                bIsCurrentlyValid = m_xValidator->isValid( translateControlValueToValidatableValue() );
+            if ( ( bIsCurrentlyValid != m_bIsCurrentValueValid ) || _bForceNotification )
+            {
+                m_bIsCurrentValueValid = bIsCurrentlyValid;
+                // release our mutex for the notifications
+                MutexRelease aRelease( m_aMutex );
+                m_aFormComponentListeners.notifyEach( &validation::XFormComponentValidityListener::componentValidityChanged, EventObject( *this ) );
+            }
+        }
+        catch( const Exception& )
+        {
+            SAL_WARN("forms.component",  "OBoundControlModel::recheckValidity: caught an exception!");
+            DBG_UNHANDLED_EXCEPTION();
         }
     }
-    catch( const Exception& )
+
+    void OBoundControlModel::describeFixedProperties( Sequence< Property >& _rProps ) const
     {
-        SAL_WARN("forms.component",  "OBoundControlModel::recheckValidity: caught an exception!");
-        DBG_UNHANDLED_EXCEPTION();
+        BEGIN_DESCRIBE_PROPERTIES( 5, OControlModel )
+            DECL_PROP1      ( CONTROLSOURCE,           OUString,     BOUND );
+            DECL_IFACE_PROP3( BOUNDFIELD,               XPropertySet,       BOUND, READONLY, TRANSIENT );
+            DECL_IFACE_PROP2( CONTROLLABEL,             XPropertySet,       BOUND, MAYBEVOID );
+            DECL_PROP2      ( CONTROLSOURCEPROPERTY,    OUString,    READONLY, TRANSIENT );
+            DECL_BOOL_PROP1 ( INPUT_REQUIRED,                               BOUND );
+        END_DESCRIBE_PROPERTIES()
     }
 }
 
-//------------------------------------------------------------------------------
-void OBoundControlModel::describeFixedProperties( Sequence< Property >& _rProps ) const
-{
-    BEGIN_DESCRIBE_PROPERTIES( 5, OControlModel )
-        DECL_PROP1      ( CONTROLSOURCE,           OUString,     BOUND );
-        DECL_IFACE_PROP3( BOUNDFIELD,               XPropertySet,       BOUND, READONLY, TRANSIENT );
-        DECL_IFACE_PROP2( CONTROLLABEL,             XPropertySet,       BOUND, MAYBEVOID );
-        DECL_PROP2      ( CONTROLSOURCEPROPERTY,    OUString,    READONLY, TRANSIENT );
-        DECL_BOOL_PROP1 ( INPUT_REQUIRED,                               BOUND );
-    END_DESCRIBE_PROPERTIES()
-}
-
-// -----------------------------------------------------------------------------
-
-//.........................................................................
-}
-//... namespace frm .......................................................
-
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/forms/source/component/FormattedField.cxx b/forms/source/component/FormattedField.cxx
index afb857d..eb85026 100644
--- a/forms/source/component/FormattedField.cxx
+++ b/forms/source/component/FormattedField.cxx
@@ -16,8 +16,6 @@
  *   except in compliance with the License. You may obtain a copy of
  *   the License at http://www.apache.org/licenses/LICENSE-2.0 .
  */
-
-
 #include "FormattedField.hxx"
 #include "services.hxx"
 #include "property.hrc"
@@ -51,14 +49,12 @@
 #include <com/sun/star/form/XForm.hpp>
 #include <com/sun/star/container/XIndexAccess.hpp>
 #include <osl/mutex.hxx>
-    // needed as long as we use the SolarMutex
+// needed as long as we use the SolarMutex
 #include <comphelper/streamsection.hxx>
 #include <cppuhelper/weakref.hxx>
 #include <unotools/desktopterminationobserver.hxx>
-
 #include <list>
 #include <algorithm>
-
 using namespace dbtools;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::sdb;
@@ -72,64 +68,44 @@ using namespace ::com::sun::star::io;
 using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::util;
 using namespace ::com::sun::star::form::binding;
-
 namespace
 {
     typedef com::sun::star::util::Date UNODate;
     typedef com::sun::star::util::Time UNOTime;
     typedef com::sun::star::util::DateTime UNODateTime;
 }
-
-//.........................................................................
 namespace frm
 {
-
-/*************************************************************************/
-
 class StandardFormatsSupplier : protected SvNumberFormatsSupplierObj, public ::utl::ITerminationListener
 {
 protected:
             SvNumberFormatter*                       m_pMyPrivateFormatter;
     static  WeakReference< XNumberFormatsSupplier >  s_xDefaultFormatsSupplier;
-
 public:
     static Reference< XNumberFormatsSupplier > get( const Reference< XComponentContext >& _rxORB );
-
     using SvNumberFormatsSupplierObj::operator new;
     using SvNumberFormatsSupplierObj::operator delete;
-
 protected:
     StandardFormatsSupplier(const Reference< XComponentContext >& _rxFactory,LanguageType _eSysLanguage);
     ~StandardFormatsSupplier();
-
 protected:
     virtual bool    queryTermination() const;
     virtual void    notifyTermination();
 };
-
-//------------------------------------------------------------------
 WeakReference< XNumberFormatsSupplier > StandardFormatsSupplier::s_xDefaultFormatsSupplier;
-
-//------------------------------------------------------------------
 StandardFormatsSupplier::StandardFormatsSupplier(const Reference< XComponentContext > & _rxContext,LanguageType _eSysLanguage)
     :SvNumberFormatsSupplierObj()
     ,m_pMyPrivateFormatter(new SvNumberFormatter(_rxContext, _eSysLanguage))
 {
     SetNumberFormatter(m_pMyPrivateFormatter);
-
     // #i29147#
     ::utl::DesktopTerminationObserver::registerTerminationListener( this );
 }
-
-//------------------------------------------------------------------
 StandardFormatsSupplier::~StandardFormatsSupplier()
 {
     ::utl::DesktopTerminationObserver::revokeTerminationListener( this );
-
     DELETEZ( m_pMyPrivateFormatter );
 }
-
-//------------------------------------------------------------------
 Reference< XNumberFormatsSupplier > StandardFormatsSupplier::get( const Reference< XComponentContext >& _rxORB )
 {
     LanguageType eSysLanguage = LANGUAGE_SYSTEM;
@@ -138,14 +114,11 @@ Reference< XNumberFormatsSupplier > StandardFormatsSupplier::get( const Referenc
         Reference< XNumberFormatsSupplier > xSupplier = s_xDefaultFormatsSupplier;
         if ( xSupplier.is() )
             return xSupplier;
-
         // get the Office's locale
         eSysLanguage = SvtSysLocale().GetLanguageTag().getLanguageType( false);
     }
-
     StandardFormatsSupplier* pSupplier = new StandardFormatsSupplier( _rxORB, eSysLanguage );
     Reference< XNumberFormatsSupplier > xNewlyCreatedSupplier( pSupplier );
-
     {
         ::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
         Reference< XNumberFormatsSupplier > xSupplier = s_xDefaultFormatsSupplier;
@@ -153,20 +126,14 @@ Reference< XNumberFormatsSupplier > StandardFormatsSupplier::get( const Referenc
             // somebody used the small time frame where the mutex was not locked to create and set
             // the supplier
             return xSupplier;
-
         s_xDefaultFormatsSupplier = xNewlyCreatedSupplier;
     }
-
     return xNewlyCreatedSupplier;
 }
-
-//------------------------------------------------------------------
 bool StandardFormatsSupplier::queryTermination() const
 {
     return true;
 }
-
-//------------------------------------------------------------------
 void StandardFormatsSupplier::notifyTermination()
 {
     Reference< XNumberFormatsSupplier > xKeepAlive = this;
@@ -174,19 +141,13 @@ void StandardFormatsSupplier::notifyTermination()
     // earlier than upon unloading the library
     // #i29147#
     s_xDefaultFormatsSupplier = WeakReference< XNumberFormatsSupplier >( );
-
     SetNumberFormatter( NULL );
     DELETEZ( m_pMyPrivateFormatter );
 }
-
-/*************************************************************************/
-//------------------------------------------------------------------
 InterfaceRef SAL_CALL OFormattedControl_CreateInstance(const Reference<XMultiServiceFactory>& _rxFactory)
 {
     return *(new OFormattedControl( comphelper::getComponentContext(_rxFactory) ));
 }
-
-//------------------------------------------------------------------
 Sequence<Type> OFormattedControl::_getTypes()
 {
     return ::comphelper::concatSequences(
@@ -194,8 +155,6 @@ Sequence<Type> OFormattedControl::_getTypes()
         OBoundControl::_getTypes()
     );
 }
-
-//------------------------------------------------------------------
 Any SAL_CALL OFormattedControl::queryAggregation(const Type& _rType) throw (RuntimeException)
 {
     Any aReturn = OBoundControl::queryAggregation(_rType);
@@ -203,14 +162,10 @@ Any SAL_CALL OFormattedControl::queryAggregation(const Type& _rType) throw (Runt
         aReturn = OFormattedControl_BASE::queryInterface(_rType);
     return aReturn;
 }
-
-
-//------------------------------------------------------------------------------
 OFormattedControl::OFormattedControl(const Reference<XComponentContext>& _rxFactory)
                :OBoundControl(_rxFactory, VCL_CONTROL_FORMATTEDFIELD)
                ,m_nKeyEvent(0)
 {
-
     increment(m_refCount);
     {
         Reference<XWindow>  xComp;
@@ -221,64 +176,50 @@ OFormattedControl::OFormattedControl(const Reference<XComponentContext>& _rxFact
     }
     decrement(m_refCount);
 }
-
-//------------------------------------------------------------------------------
 OFormattedControl::~OFormattedControl()
 {
     if( m_nKeyEvent )
         Application::RemoveUserEvent( m_nKeyEvent );
-
     if (!OComponentHelper::rBHelper.bDisposed)
     {
         acquire();
         dispose();
     }
-
 }
 
 // XKeyListener
-//------------------------------------------------------------------------------
 void OFormattedControl::disposing(const EventObject& _rSource) throw(RuntimeException)
 {
     OBoundControl::disposing(_rSource);
 }
-
-//------------------------------------------------------------------------------
 void OFormattedControl::keyPressed(const ::com::sun::star::awt::KeyEvent& e) throw ( ::com::sun::star::uno::RuntimeException)
 {
     if( e.KeyCode != KEY_RETURN || e.Modifiers != 0 )
         return;
-
     // Steht das Control in einem Formular mit einer Submit-URL?
     Reference<com::sun::star::beans::XPropertySet>  xSet(getModel(), UNO_QUERY);
     if( !xSet.is() )
         return;
-
     Reference<XFormComponent>  xFComp(xSet, UNO_QUERY);
     InterfaceRef  xParent = xFComp->getParent();
     if( !xParent.is() )
         return;
-
     Reference<com::sun::star::beans::XPropertySet>  xFormSet(xParent, UNO_QUERY);
     if( !xFormSet.is() )
         return;
-
     Any aTmp(xFormSet->getPropertyValue( PROPERTY_TARGET_URL ));
     if (!isA(aTmp, static_cast< OUString* >(NULL)) ||
         getString(aTmp).isEmpty() )
         return;
-
     Reference<XIndexAccess>  xElements(xParent, UNO_QUERY);
     sal_Int32 nCount = xElements->getCount();
     if( nCount > 1 )
     {
-
         Reference<com::sun::star::beans::XPropertySet>  xFCSet;
         for( sal_Int32 nIndex=0; nIndex < nCount; nIndex++ )
         {
             //  Any aElement(xElements->getByIndex(nIndex));
             xElements->getByIndex(nIndex) >>= xFCSet;
-
             if (hasProperty(PROPERTY_CLASSID, xFCSet) &&
                 getINT16(xFCSet->getPropertyValue(PROPERTY_CLASSID)) == FormComponentType::TEXTFIELD)
             {
@@ -288,7 +229,6 @@ void OFormattedControl::keyPressed(const ::com::sun::star::awt::KeyEvent& e) thr
             }
         }
     }
-
     // Da wir noch im Haender stehen, submit asynchron ausloesen
     if( m_nKeyEvent )
         Application::RemoveUserEvent( m_nKeyEvent );
@@ -296,16 +236,13 @@ void OFormattedControl::keyPressed(const ::com::sun::star::awt::KeyEvent& e) thr
                                             OnKeyPressed) );
 }
 
-//------------------------------------------------------------------------------
 void OFormattedControl::keyReleased(const ::com::sun::star::awt::KeyEvent& /*e*/) throw ( ::com::sun::star::uno::RuntimeException)
 {
 }
 
-//------------------------------------------------------------------------------
 IMPL_LINK(OFormattedControl, OnKeyPressed, void*, /*EMPTYARG*/)
 {
     m_nKeyEvent = 0;
-
     Reference<XFormComponent>  xFComp(getModel(), UNO_QUERY);
     InterfaceRef  xParent = xFComp->getParent();
     Reference<XSubmit>  xSubmit(xParent, UNO_QUERY);
@@ -314,25 +251,20 @@ IMPL_LINK(OFormattedControl, OnKeyPressed, void*, /*EMPTYARG*/)
     return 0L;
 }
 
-//------------------------------------------------------------------------------
 StringSequence  OFormattedControl::getSupportedServiceNames() throw()
 {
     StringSequence aSupported = OBoundControl::getSupportedServiceNames();
     aSupported.realloc(aSupported.getLength() + 1);
-
     OUString*pArray = aSupported.getArray();
     pArray[aSupported.getLength()-1] = FRM_SUN_CONTROL_FORMATTEDFIELD;
     return aSupported;
 }
 
-//------------------------------------------------------------------------------
 void OFormattedControl::setDesignMode(sal_Bool bOn) throw ( ::com::sun::star::uno::RuntimeException)
 {
     OBoundControl::setDesignMode(bOn);
 }
 
-/*************************************************************************/
-//------------------------------------------------------------------
 void OFormattedModel::implConstruct()
 {
     // members
@@ -342,48 +274,36 @@ void OFormattedModel::implConstruct()
     m_nKeyType = NumberFormat::UNDEFINED;
     m_aNullDate = DBTypeConversion::getStandardDate();
     m_nFieldType =  DataType::OTHER;
-
     // default our formats supplier
     increment(m_refCount);
     setPropertyToDefaultByHandle(PROPERTY_ID_FORMATSSUPPLIER);
     decrement(m_refCount);
-
     startAggregatePropertyListening( PROPERTY_FORMATKEY );
     startAggregatePropertyListening( PROPERTY_FORMATSSUPPLIER );
 }
-
-//------------------------------------------------------------------
 OFormattedModel::OFormattedModel(const Reference<XComponentContext>& _rxFactory)
     :OEditBaseModel(_rxFactory, VCL_CONTROLMODEL_FORMATTEDFIELD, FRM_SUN_CONTROL_FORMATTEDFIELD, sal_True, sal_True )
                             // use the old control name for compytibility reasons
     ,OErrorBroadcaster( OComponentHelper::rBHelper )
 {
-
     implConstruct();
-
     m_nClassId = FormComponentType::TEXTFIELD;
     initValueProperty( PROPERTY_EFFECTIVE_VALUE, PROPERTY_ID_EFFECTIVE_VALUE );
 }
-
-//------------------------------------------------------------------
 OFormattedModel::OFormattedModel( const OFormattedModel* _pOriginal, const Reference< XComponentContext >& _rxFactory )
     :OEditBaseModel( _pOriginal, _rxFactory )
     ,OErrorBroadcaster( OComponentHelper::rBHelper )
 {
-
     implConstruct();
 }
 
-//------------------------------------------------------------------------------
 OFormattedModel::~OFormattedModel()
 {
 }
 
 // XCloneable
-//------------------------------------------------------------------------------
 IMPLEMENT_DEFAULT_CLONING( OFormattedModel )
 
-//------------------------------------------------------------------------------
 void SAL_CALL OFormattedModel::disposing()
 {
     OErrorBroadcaster::disposing();
@@ -391,31 +311,24 @@ void SAL_CALL OFormattedModel::disposing()
 }
 
 // XServiceInfo
-//------------------------------------------------------------------------------
 StringSequence OFormattedModel::getSupportedServiceNames() throw()
 {
     StringSequence aSupported = OEditBaseModel::getSupportedServiceNames();
-
     sal_Int32 nOldLen = aSupported.getLength();
     aSupported.realloc( nOldLen + 8 );
     OUString* pStoreTo = aSupported.getArray() + nOldLen;
-
     *pStoreTo++ = BINDABLE_CONTROL_MODEL;
     *pStoreTo++ = DATA_AWARE_CONTROL_MODEL;
     *pStoreTo++ = VALIDATABLE_CONTROL_MODEL;
-
     *pStoreTo++ = BINDABLE_DATA_AWARE_CONTROL_MODEL;
     *pStoreTo++ = VALIDATABLE_BINDABLE_CONTROL_MODEL;
-
     *pStoreTo++ = FRM_SUN_COMPONENT_FORMATTEDFIELD;
     *pStoreTo++ = FRM_SUN_COMPONENT_DATABASE_FORMATTEDFIELD;
     *pStoreTo++ = BINDABLE_DATABASE_FORMATTED_FIELD;
-
     return aSupported;
 }
 
 // XAggregation
-//------------------------------------------------------------------------------
 Any SAL_CALL OFormattedModel::queryAggregation(const Type& _rType) throw(RuntimeException)
 {
     Any aReturn = OEditBaseModel::queryAggregation( _rType );
@@ -423,7 +336,6 @@ Any SAL_CALL OFormattedModel::queryAggregation(const Type& _rType) throw(Runtime
 }
 
 // XTypeProvider
-//------------------------------------------------------------------------------
 Sequence< Type > OFormattedModel::_getTypes()
 {
     return ::comphelper::concatSequences(
@@ -433,14 +345,12 @@ Sequence< Type > OFormattedModel::_getTypes()
 }
 
 // XPersistObject
-//------------------------------------------------------------------------------
 OUString SAL_CALL OFormattedModel::getServiceName() throw ( ::com::sun::star::uno::RuntimeException)
 {
     return OUString(FRM_COMPONENT_EDIT);
 }
 
 // XPropertySet
-//------------------------------------------------------------------------------
 void OFormattedModel::describeFixedProperties( Sequence< Property >& _rProps ) const
 {
     BEGIN_DESCRIBE_PROPERTIES( 3, OEditBaseModel )
@@ -450,11 +360,9 @@ void OFormattedModel::describeFixedProperties( Sequence< Property >& _rProps ) c
     END_DESCRIBE_PROPERTIES();
 }
 
-//------------------------------------------------------------------------------
 void OFormattedModel::describeAggregateProperties( Sequence< Property >& _rAggregateProps ) const
 {
     OEditBaseModel::describeAggregateProperties( _rAggregateProps );
-
     // TreatAsNumeric nicht transient : wir wollen es an der UI anbinden (ist noetig, um dem EffectiveDefault
     // - der kann Text oder Zahl sein - einen Sinn zu geben)
     ModifyPropertyAttributes(_rAggregateProps, PROPERTY_TREATASNUMERIC, 0, PropertyAttribute::TRANSIENT);
@@ -462,33 +370,28 @@ void OFormattedModel::describeAggregateProperties( Sequence< Property >& _rAggre
     // (though the paragraph above for the TreatAsNumeric does not hold anymore - we do not have an UI for this.
     // But we have for the format key ...)
     ModifyPropertyAttributes(_rAggregateProps, PROPERTY_FORMATKEY, 0, PropertyAttribute::TRANSIENT);
-
     RemoveProperty(_rAggregateProps, PROPERTY_STRICTFORMAT);
         // no strict format property for formatted fields: it does not make sense, 'cause
         // there is no general way to decide which characters/sub strings are allowed during the input of an
         // arbitraryly formatted control
 }
 
-//------------------------------------------------------------------------------
 void OFormattedModel::getFastPropertyValue(Any& rValue, sal_Int32 nHandle) const
 {
     OEditBaseModel::getFastPropertyValue(rValue, nHandle);
 }
 
-//------------------------------------------------------------------------------
 void OFormattedModel::setFastPropertyValue_NoBroadcast(sal_Int32 nHandle, const Any& rValue) throw ( ::com::sun::star::uno::Exception)
 {
     OEditBaseModel::setFastPropertyValue_NoBroadcast(nHandle, rValue);
 }
 
-//------------------------------------------------------------------------------
 sal_Bool OFormattedModel::convertFastPropertyValue(Any& rConvertedValue, Any& rOldValue, sal_Int32 nHandle, const Any& rValue)
                                                         throw( IllegalArgumentException )
 {
     return OEditBaseModel::convertFastPropertyValue(rConvertedValue, rOldValue, nHandle, rValue);
 }
 
-//------------------------------------------------------------------------------
 void OFormattedModel::setPropertyToDefaultByHandle(sal_Int32 nHandle)
 {
     if (nHandle == PROPERTY_ID_FORMATSSUPPLIER)
@@ -502,19 +405,16 @@ void OFormattedModel::setPropertyToDefaultByHandle(sal_Int32 nHandle)
         OEditBaseModel::setPropertyToDefaultByHandle(nHandle);
 }
 
-//------------------------------------------------------------------------------
 void OFormattedModel::setPropertyToDefault(const OUString& aPropertyName) throw( com::sun::star::beans::UnknownPropertyException, RuntimeException )
 {
     OPropertyArrayAggregationHelper& rPH = m_aPropertyBagHelper.getInfoHelper();
     sal_Int32 nHandle = rPH.getHandleByName( aPropertyName );
-
     if (nHandle == PROPERTY_ID_FORMATSSUPPLIER)
         setPropertyToDefaultByHandle(PROPERTY_ID_FORMATSSUPPLIER);
     else
         OEditBaseModel::setPropertyToDefault(aPropertyName);
 }
 
-//------------------------------------------------------------------------------
 Any OFormattedModel::getPropertyDefaultByHandle( sal_Int32 nHandle ) const
 {
     if (nHandle == PROPERTY_ID_FORMATSSUPPLIER)
@@ -526,23 +426,19 @@ Any OFormattedModel::getPropertyDefaultByHandle( sal_Int32 nHandle ) const
         return OEditBaseModel::getPropertyDefaultByHandle(nHandle);
 }
 
-//------------------------------------------------------------------------------
 Any SAL_CALL OFormattedModel::getPropertyDefault( const OUString& aPropertyName ) throw( com::sun::star::beans::UnknownPropertyException, RuntimeException )
 {
     OPropertyArrayAggregationHelper& rPH = m_aPropertyBagHelper.getInfoHelper();
     sal_Int32 nHandle = rPH.getHandleByName( aPropertyName );
-
     if (nHandle == PROPERTY_ID_FORMATSSUPPLIER)
         return getPropertyDefaultByHandle(PROPERTY_ID_FORMATSSUPPLIER);
     else
         return OEditBaseModel::getPropertyDefault(aPropertyName);
 }
 
-//------------------------------------------------------------------------------
 void OFormattedModel::_propertyChanged( const com::sun::star::beans::PropertyChangeEvent& evt ) throw(RuntimeException)
 {
     // TODO: check how this works with external bindings
-
     OSL_ENSURE( evt.Source == m_xAggregateSet, "OFormattedModel::_propertyChanged: where did this come from?" );
     if ( evt.Source == m_xAggregateSet )
     {
@@ -554,17 +450,14 @@ void OFormattedModel::_propertyChanged( const com::sun::star::beans::PropertyCha
                 try
                 {
                     ::osl::MutexGuard aGuard( m_aMutex );
-
                     Reference<XNumberFormatsSupplier> xSupplier( calcFormatsSupplier() );
                     m_nKeyType  = getNumberFormatType(xSupplier->getNumberFormats(), getINT32( evt.NewValue ) );
-
                     // as m_aSaveValue (which is used by commitControlValueToDbColumn) is format dependent we have
                     // to recalc it, which is done by translateDbColumnToControlValue
                     if ( m_xColumn.is() && m_xAggregateFastSet.is()  && !m_xCursor->isBeforeFirst() && !m_xCursor->isAfterLast())
                     {
                         setControlValue( translateDbColumnToControlValue(), eOther );
                     }
-
                     // if we're connected to an external value binding, then re-calculate the type
                     // used to exchange the value - it depends on the format, too
                     if ( hasExternalValueBinding() )
@@ -578,18 +471,15 @@ void OFormattedModel::_propertyChanged( const com::sun::star::beans::PropertyCha
             }
             return;
         }
-
         if ( evt.PropertyName.equals( PROPERTY_FORMATSSUPPLIER ) )
         {
             updateFormatterNullDate();
             return;
         }
-
         OBoundControlModel::_propertyChanged( evt );
     }
 }
 
-//------------------------------------------------------------------------------
 void OFormattedModel::updateFormatterNullDate()
 {
     // calc the current NULL date
@@ -598,29 +488,23 @@ void OFormattedModel::updateFormatterNullDate()
         xSupplier->getNumberFormatSettings()->getPropertyValue("NullDate") >>= m_aNullDate;
 }
 
-//------------------------------------------------------------------------------
 Reference< XNumberFormatsSupplier > OFormattedModel::calcFormatsSupplier() const
 {
     Reference<XNumberFormatsSupplier>  xSupplier;
-
     DBG_ASSERT(m_xAggregateSet.is(), "OFormattedModel::calcFormatsSupplier : have no aggregate !");
     // hat mein aggregiertes Model einen FormatSupplier ?
     if( m_xAggregateSet.is() )
         m_xAggregateSet->getPropertyValue(PROPERTY_FORMATSSUPPLIER) >>= xSupplier;
-
     if (!xSupplier.is())
         // check if my parent form has a supplier
         xSupplier = calcFormFormatsSupplier();
-
     if (!xSupplier.is())
         xSupplier = calcDefaultFormatsSupplier();
-
     DBG_ASSERT(xSupplier.is(), "OFormattedModel::calcFormatsSupplier : no supplier !");
         // jetzt sollte aber einer da sein
     return xSupplier;
 }
 
-//------------------------------------------------------------------------------
 Reference<XNumberFormatsSupplier>  OFormattedModel::calcFormFormatsSupplier() const
 {
     Reference<XChild>  xMe;
@@ -628,7 +512,6 @@ Reference<XNumberFormatsSupplier>  OFormattedModel::calcFormFormatsSupplier() co
     // damit stellen wir sicher, dass wir auch fuer den Fall der Aggregation das richtige
     // Objekt bekommen
     DBG_ASSERT(xMe.is(), "OFormattedModel::calcFormFormatsSupplier : I should have a content interface !");
-
     // jetzt durchhangeln nach oben, bis wir auf eine starform treffen (angefangen mit meinem eigenen Parent)
     Reference<XChild>  xParent(xMe->getParent(), UNO_QUERY);
     Reference<XForm>  xNextParentForm(xParent, UNO_QUERY);
@@ -637,13 +520,11 @@ Reference<XNumberFormatsSupplier>  OFormattedModel::calcFormFormatsSupplier() co
         xParent         = xParent.query( xParent->getParent() );
         xNextParentForm = xNextParentForm.query( xParent );
     }
-
     if (!xNextParentForm.is())
     {
         OSL_FAIL("OFormattedModel::calcFormFormatsSupplier : have no ancestor which is a form !");
         return NULL;
     }
-
     // den FormatSupplier von meinem Vorfahren (falls der einen hat)
     Reference< XRowSet > xRowSet( xNextParentForm, UNO_QUERY );
     Reference< XNumberFormatsSupplier > xSupplier;
@@ -652,14 +533,12 @@ Reference<XNumberFormatsSupplier>  OFormattedModel::calcFormFormatsSupplier() co
     return xSupplier;
 }
 
-//------------------------------------------------------------------------------
 Reference< XNumberFormatsSupplier > OFormattedModel::calcDefaultFormatsSupplier() const
 {
     return StandardFormatsSupplier::get( getContext() );
 }
 
 // XBoundComponent
-//------------------------------------------------------------------------------
 void OFormattedModel::loaded(const EventObject& rEvent) throw ( ::com::sun::star::uno::RuntimeException)
 {
     // HACK : our onConnectedDbColumn accesses our NumberFormatter which locks the solar mutex (as it doesn't have
@@ -670,31 +549,25 @@ void OFormattedModel::loaded(const EventObject& rEvent) throw ( ::com::sun::star
     // property requests and one for our own code. This would need a lot of code rewriting
     // alternative b): The NumberFormatter has to be really threadsafe (with an own mutex), which is
     // the only "clean" solution for me.
-
     SolarMutexGuard aGuard;
     OEditBaseModel::loaded(rEvent);
 }
 
-//------------------------------------------------------------------------------
 void OFormattedModel::onConnectedDbColumn( const Reference< XInterface >& _rxForm )
 {
     m_xOriginalFormatter = NULL;
-
     // get some properties of the field
     m_nFieldType = DataType::OTHER;
     Reference<XPropertySet> xField = getField();
     if ( xField.is() )
         xField->getPropertyValue( PROPERTY_FIELDTYPE ) >>= m_nFieldType;
-
     sal_Int32 nFormatKey = 0;
-
     DBG_ASSERT(m_xAggregateSet.is(), "OFormattedModel::onConnectedDbColumn : have no aggregate !");
     if (m_xAggregateSet.is())
     {   // all the following doesn't make any sense if we have no aggregate ...
         Any aSupplier = m_xAggregateSet->getPropertyValue(PROPERTY_FORMATSSUPPLIER);
         DBG_ASSERT( aSupplier.hasValue(), "OFormattedModel::onConnectedDbColumn : invalid property value !" );
         // das sollte im Constructor oder im read auf was richtiges gesetzt worden sein
-
         Any aFmtKey = m_xAggregateSet->getPropertyValue(PROPERTY_FORMATKEY);
         if ( !(aFmtKey >>= nFormatKey ) )
         {   // nobody gave us a format to use. So we examine the field we're bound to for a
@@ -705,13 +578,11 @@ void OFormattedModel::onConnectedDbColumn( const Reference< XInterface >& _rxFor
                 aFmtKey = xField->getPropertyValue(PROPERTY_FORMATKEY);
                 xField->getPropertyValue(PROPERTY_FIELDTYPE) >>= nType ;
             }
-
             Reference<XNumberFormatsSupplier>  xSupplier = calcFormFormatsSupplier();
             DBG_ASSERT(xSupplier.is(), "OFormattedModel::onConnectedDbColumn : bound to a field but no parent with a formatter ? how this ?");
             if (xSupplier.is())
             {
                 m_bOriginalNumeric = getBOOL(getPropertyValue(PROPERTY_TREATASNUMERIC));
-
                 if (!aFmtKey.hasValue())
                 {   // we aren't bound to a field (or this field's format is invalid)
                     // -> determine the standard text (or numeric) format of the supplier
@@ -719,18 +590,15 @@ void OFormattedModel::onConnectedDbColumn( const Reference< XInterface >& _rxFor
                     if (xTypes.is())
                     {
                         Locale aApplicationLocale = Application::GetSettings().GetUILanguageTag().getLocale();
-
                         if (m_bOriginalNumeric)
                             aFmtKey <<= (sal_Int32)xTypes->getStandardFormat(NumberFormat::NUMBER, aApplicationLocale);
                         else
                             aFmtKey <<= (sal_Int32)xTypes->getStandardFormat(NumberFormat::TEXT, aApplicationLocale);
                     }
                 }
-
                 aSupplier >>= m_xOriginalFormatter;
                 m_xAggregateSet->setPropertyValue(PROPERTY_FORMATSSUPPLIER, makeAny(xSupplier));
                 m_xAggregateSet->setPropertyValue(PROPERTY_FORMATKEY, aFmtKey);
-
                 // das Numeric-Flag an mein gebundenes Feld anpassen
                 if (xField.is())
                 {
@@ -757,23 +625,18 @@ void OFormattedModel::onConnectedDbColumn( const Reference< XInterface >& _rxFor
                 }
                 else
                     m_bNumeric = m_bOriginalNumeric;
-
                 setPropertyValue(PROPERTY_TREATASNUMERIC, makeAny((sal_Bool)m_bNumeric));
-
                 OSL_VERIFY( aFmtKey >>= nFormatKey );
             }
         }
     }
-
     Reference<XNumberFormatsSupplier>  xSupplier = calcFormatsSupplier();
     m_bNumeric = getBOOL( getPropertyValue( PROPERTY_TREATASNUMERIC ) );
     m_nKeyType  = getNumberFormatType( xSupplier->getNumberFormats(), nFormatKey );
     xSupplier->getNumberFormatSettings()->getPropertyValue("NullDate") >>= m_aNullDate;
-
     OEditBaseModel::onConnectedDbColumn( _rxForm );
 }
 
-//------------------------------------------------------------------------------
 void OFormattedModel::onDisconnectedDbColumn()
 {
     OEditBaseModel::onDisconnectedDbColumn();
@@ -784,23 +647,18 @@ void OFormattedModel::onDisconnectedDbColumn()
         setPropertyValue(PROPERTY_TREATASNUMERIC, makeAny((sal_Bool)m_bOriginalNumeric));
         m_xOriginalFormatter = NULL;
     }
-
     m_nFieldType = DataType::OTHER;
     m_nKeyType   = NumberFormat::UNDEFINED;
     m_aNullDate  = DBTypeConversion::getStandardDate();
 }
 
-//------------------------------------------------------------------------------
 void OFormattedModel::write(const Reference<XObjectOutputStream>& _rxOutStream) throw ( ::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException)
 {
     OEditBaseModel::write(_rxOutStream);
     _rxOutStream->writeShort(0x0003);
-
     DBG_ASSERT(m_xAggregateSet.is(), "OFormattedModel::write : have no aggregate !");
-
     // mein Format (evtl. void) in ein persistentes Format bringen (der Supplier zusammen mit dem Key ist es zwar auch,
     // aber deswegen muessen wir ja nicht gleich den ganzen Supplier speichern, das waere ein klein wenig Overhead ;)
-
         Reference<XNumberFormatsSupplier>  xSupplier;
         Any aFmtKey;
     sal_Bool bVoidKey = sal_True;
@@ -811,25 +669,19 @@ void OFormattedModel::write(const Reference<XObjectOutputStream>& _rxOutStream)
         {
             OSL_VERIFY( aSupplier >>= xSupplier );
         }
-
         aFmtKey = m_xAggregateSet->getPropertyValue(PROPERTY_FORMATKEY);
         bVoidKey = (!xSupplier.is() || !aFmtKey.hasValue()) || (isLoaded() && m_xOriginalFormatter.is());
             // (kein Fomatter und/oder Key) oder (loaded und faked Formatter)
     }
-
     _rxOutStream->writeBoolean(!bVoidKey);
     if (!bVoidKey)
     {
         // aus dem FormatKey und dem Formatter persistente Angaben basteln
-
         Any aKey = m_xAggregateSet->getPropertyValue(PROPERTY_FORMATKEY);
         sal_Int32 nKey = aKey.hasValue() ? getINT32(aKey) : 0;
-
         Reference<XNumberFormats>  xFormats = xSupplier->getNumberFormats();
-
         OUString         sFormatDescription;
         LanguageType    eFormatLanguage = LANGUAGE_DONTKNOW;
-
         static const OUString s_aLocaleProp ("Locale");
         Reference<com::sun::star::beans::XPropertySet>  xFormat = xFormats->getByKey(nKey);
         if (hasProperty(s_aLocaleProp, xFormat))
@@ -842,37 +694,29 @@ void OFormattedModel::write(const Reference<XObjectOutputStream>& _rxOutStream)
                 eFormatLanguage = LanguageTag::convertToLanguageType( *pLocale, false);
             }
         }
-
         static const OUString s_aFormatStringProp ("FormatString");
         if (hasProperty(s_aFormatStringProp, xFormat))
             xFormat->getPropertyValue(s_aFormatStringProp) >>= sFormatDescription;
-
         _rxOutStream->writeUTF(sFormatDescription);
         _rxOutStream->writeLong((sal_Int32)eFormatLanguage);
     }
-
     // version 2 : write the properties common to all OEditBaseModels
     writeCommonEditProperties(_rxOutStream);
-
     // version 3 : write the effective value property of the aggregate
     // Due to a bug within the UnoControlFormattedFieldModel implementation (our default aggregate) this props value isn't correctly read
     // and this can't be corrected without being incompatible.
     // so we have our own handling.
-
     // and to be a little bit more compatible we make the following section skippable
     {
         OStreamSection aDownCompat(_rxOutStream);
-
         // a sub version within the skippable block
         _rxOutStream->writeShort(0x0000);
-
         // version 0: the effective value of the aggregate
                 Any aEffectiveValue;
         if (m_xAggregateSet.is())
         {
             try { aEffectiveValue = m_xAggregateSet->getPropertyValue(PROPERTY_EFFECTIVE_VALUE); } catch(const Exception&) { }
         }
-
         {
             OStreamSection aDownCompat2(_rxOutStream);
             switch (aEffectiveValue.getValueType().getTypeClass())
@@ -894,12 +738,10 @@ void OFormattedModel::write(const Reference<XObjectOutputStream>& _rxOutStream)
     }
 }
 
-//------------------------------------------------------------------------------
 void OFormattedModel::read(const Reference<XObjectInputStream>& _rxInStream) throw ( ::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException)
 {
     OEditBaseModel::read(_rxInStream);
     sal_uInt16 nVersion = _rxInStream->readShort();
-
     Reference<XNumberFormatsSupplier>  xSupplier;
     sal_Int32 nKey = -1;
     switch (nVersion)
@@ -911,36 +753,30 @@ void OFormattedModel::read(const Reference<XObjectInputStream>& _rxInStream) thr
             sal_Bool bNonVoidKey = _rxInStream->readBoolean();
             if (bNonVoidKey)
             {
-                // den String und die Language lesen ....
+                // read string and language...
                 OUString sFormatDescription = _rxInStream->readUTF();
                 LanguageType eDescriptionLanguage = (LanguageType)_rxInStream->readLong();
-
-                // und daraus von einem Formatter zu einem Key zusammenwuerfeln lassen ...
+                // and let a formatter roll dice based on that to create a key...
                 xSupplier = calcFormatsSupplier();
-                    // calcFormatsSupplier nimmt erst den vom Model, dann einen von der starform, dann einen ganz neuen ....
+                    // calcFormatsSupplier first takes the one from the model, then one from the starform, then a new one...
                 Reference<XNumberFormats>  xFormats = xSupplier->getNumberFormats();
-
                 if (xFormats.is())
                 {
                     Locale aDescriptionLanguage( LanguageTag::convertToLocale(eDescriptionLanguage));
-
                     nKey = xFormats->queryKey(sFormatDescription, aDescriptionLanguage, sal_False);
                     if (nKey == (sal_Int32)-1)
-                    {   // noch nicht vorhanden in meinem Formatter ...
+                    {   // does not yet exist in my formatter...
                         nKey = xFormats->addNew(sFormatDescription, aDescriptionLanguage);
                     }
                 }
             }
             if ((nVersion == 0x0002) || (nVersion == 0x0003))
                 readCommonEditProperties(_rxInStream);
-
             if (nVersion == 0x0003)
             {   // since version 3 there is a "skippable" block at this position
                 OStreamSection aDownCompat(_rxInStream);
-
                 sal_Int16 nSubVersion = _rxInStream->readShort();
                 (void)nSubVersion;
-
                 // version 0 and higher : the "effective value" property
                 Any aEffectiveValue;
                 {
@@ -959,7 +795,6 @@ void OFormattedModel::read(const Reference<XObjectInputStream>& _rxInStream) thr
                             OSL_FAIL("FmXFormattedModel::read : unknown effective value type !");
                     }
                 }
-
                 // this property is only to be set if we have no control source : in all other cases the base class did a
                 // reset after it's read and this set the effective value to a default value
                 if ( m_xAggregateSet.is() && getControlSource().isEmpty() )
@@ -977,11 +812,10 @@ void OFormattedModel::read(const Reference<XObjectInputStream>& _rxInStream) thr
         break;
         default :
             OSL_FAIL("OFormattedModel::read : unknown version !");
-            // dann bleibt das Format des aggregierten Sets, wie es bei der Erzeugung ist : void
+            // then the format of the aggregated set stay like it was during creation: void
             defaultCommonEditProperties();
             break;
     }
-
     if ((nKey != -1) && m_xAggregateSet.is())
     {
                 m_xAggregateSet->setPropertyValue(PROPERTY_FORMATSSUPPLIER, makeAny(xSupplier));
@@ -994,20 +828,18 @@ void OFormattedModel::read(const Reference<XObjectInputStream>& _rxInStream) thr
     }
 }
 
-//------------------------------------------------------------------------------
 sal_uInt16 OFormattedModel::getPersistenceFlags() const
 {
     return (OEditBaseModel::getPersistenceFlags() & ~PF_HANDLE_COMMON_PROPS);
     // a) we do our own call to writeCommonEditProperties
 }
 
-//------------------------------------------------------------------------------
 sal_Bool OFormattedModel::commitControlValueToDbColumn( bool /*_bPostReset*/ )
 {
     Any aControlValue( m_xAggregateFastSet->getFastPropertyValue( getValuePropertyAggHandle() ) );
     if ( aControlValue != m_aSaveValue )
     {
-        // Leerstring + EmptyIsNull = void
+        // empty string + EmptyIsNull = void
         if  (   !aControlValue.hasValue()
             ||  (   ( aControlValue.getValueType().getTypeClass() == TypeClass_STRING )
                 &&  getString( aControlValue ).isEmpty()
@@ -1040,14 +872,12 @@ sal_Bool OFormattedModel::commitControlValueToDbColumn( bool /*_bPostReset*/ )
     return sal_True;
 }
 
-//------------------------------------------------------------------------------
 void OFormattedModel::onConnectedExternalValue( )
 {
     OEditBaseModel::onConnectedExternalValue();
     updateFormatterNullDate();
 }
 
-//------------------------------------------------------------------------------
 Any OFormattedModel::translateExternalValueToControlValue( const Any& _rExternalValue ) const
 {
     Any aControlValue;
@@ -1055,11 +885,9 @@ Any OFormattedModel::translateExternalValueToControlValue( const Any& _rExternal
     {
     case TypeClass_VOID:
         break;
-
     case TypeClass_STRING:
         aControlValue = _rExternalValue;
         break;
-
     case TypeClass_BOOLEAN:
     {
         sal_Bool bExternalValue = sal_False;
@@ -1067,7 +895,6 @@ Any OFormattedModel::translateExternalValueToControlValue( const Any& _rExternal
         aControlValue <<= (double)( bExternalValue ? 1 : 0 );
     }
     break;
-
     default:
     {
         if ( _rExternalValue.getValueType().equals( ::getCppuType( static_cast< UNODate* >( NULL ) ) ) )
@@ -1098,22 +925,17 @@ Any OFormattedModel::translateExternalValueToControlValue( const Any& _rExternal
         }
     }
     }
-
     return aControlValue;
 }
 
-//------------------------------------------------------------------------------
 Any OFormattedModel::translateControlValueToExternalValue( ) const
 {
     OSL_PRECOND( hasExternalValueBinding(),
         "OFormattedModel::translateControlValueToExternalValue: precondition not met!" );
-
     Any aControlValue( getControlValue() );
     if ( !aControlValue.hasValue() )
         return aControlValue;
-
     Any aExternalValue;
-
     // translate into the external value type
     Type aExternalValueType( getExternalValueType() );
     switch ( aExternalValueType.getTypeClass() )
@@ -1128,7 +950,6 @@ Any OFormattedModel::translateControlValueToExternalValue( ) const
         }
     }
     // NO break here!
-
     case TypeClass_BOOLEAN:
     {
         double fValue = 0;
@@ -1139,7 +960,6 @@ Any OFormattedModel::translateControlValueToExternalValue( ) const
         aExternalValue <<= (sal_Bool)( fValue ? sal_True : sal_False );
     }
     break;
-
     default:
     {
         double fValue = 0;
@@ -1147,7 +967,6 @@ Any OFormattedModel::translateControlValueToExternalValue( ) const
             // if this asserts ... well, the somebody set the TreatAsNumeric property to false,
             // and the control value is a string. This implies some weird misconfiguration
             // of the FormattedModel, so we won't care for it for the moment.
-
         if ( aExternalValueType.equals( ::getCppuType( static_cast< UNODate* >( NULL ) ) ) )
         {
             aExternalValue <<= DBTypeConversion::toDate( fValue, m_aNullDate );
@@ -1172,26 +991,21 @@ Any OFormattedModel::translateControlValueToExternalValue( ) const
     return aExternalValue;
 }
 
-//------------------------------------------------------------------------------
 Any OFormattedModel::translateDbColumnToControlValue()
 {
     if ( m_bNumeric )
         m_aSaveValue <<= DBTypeConversion::getValue( m_xColumn, m_aNullDate ); // #100056# OJ
     else
         m_aSaveValue <<= m_xColumn->getString();
-
     if ( m_xColumn->wasNull() )
         m_aSaveValue.clear();
-
     return m_aSaveValue;
 }
 
-// -----------------------------------------------------------------------------
 Sequence< Type > OFormattedModel::getSupportedBindingTypes()
 {
     ::std::list< Type > aTypes;
     aTypes.push_back( ::getCppuType( static_cast< double* >( NULL ) ) );
-
     switch ( m_nKeyType & ~NumberFormat::DEFINED )
     {
     case NumberFormat::DATE:
@@ -1210,27 +1024,21 @@ Sequence< Type > OFormattedModel::getSupportedBindingTypes()
         aTypes.push_front(::getCppuType( static_cast< sal_Bool* >( NULL ) ) );
         break;
     }
-
     Sequence< Type > aTypesRet( aTypes.size() );
     ::std::copy( aTypes.begin(), aTypes.end(), aTypesRet.getArray() );
     return aTypesRet;
 }
 
-//------------------------------------------------------------------------------
 Any OFormattedModel::getDefaultForReset() const
 {
     return m_xAggregateSet->getPropertyValue( PROPERTY_EFFECTIVE_DEFAULT );
 }
 
-//------------------------------------------------------------------------------
 void OFormattedModel::resetNoBroadcast()
 {
     OEditBaseModel::resetNoBroadcast();
     m_aSaveValue.clear();
 }
-
-//.........................................................................
 }
-//.........................................................................
 
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/forms/source/component/FormattedField.hxx b/forms/source/component/FormattedField.hxx
index 1ea82f6..eb27424 100644
--- a/forms/source/component/FormattedField.hxx
+++ b/forms/source/component/FormattedField.hxx
@@ -26,20 +26,16 @@
 #include <cppuhelper/implbase1.hxx>
 #include "errorbroadcaster.hxx"
 
-//.........................................................................
 namespace frm
 {
-
-    //==================================================================
-    //= OFormattedModel
-    //==================================================================
-
-    class OFormattedModel
+class OFormattedModel
                     :public OEditBaseModel
                     ,public OErrorBroadcaster
     {
-        // das Original, falls ich die Format-Properties meines aggregierten Models gefaket, d.h. von dem Feld, an das
-        // ich gebunden bin, weitergereicht habe (nur gueltig wenn loaded)
+        // the original, in case I faked the format properties of my aggregated model,
+        // i.e. I just passed on the attributes of the field to which I am bound
+        // (only valid if loaded)
+
         ::com::sun::star::uno::Reference< ::com::sun::star::util::XNumberFormatsSupplier>   m_xOriginalFormatter;
         ::com::sun::star::util::Date        m_aNullDate;
         ::com::sun::star::uno::Any          m_aSaveValue;
@@ -47,7 +43,7 @@ namespace frm
         sal_Int32                           m_nFieldType;
         sal_Int16                           m_nKeyType;
         sal_Bool                            m_bOriginalNumeric      : 1,
-                                            m_bNumeric              : 1;    // analog fuer TreatAsNumeric-Property
+                                            m_bNumeric              : 1;    // analogous for the TreatAsNumeric-property
 
     protected:
         ::com::sun::star::uno::Reference< ::com::sun::star::util::XNumberFormatsSupplier>  calcDefaultFormatsSupplier() const;
@@ -59,38 +55,38 @@ namespace frm
         friend class OFormattedFieldWrapper;
 
     protected:
-    // XInterface
+        // XInterface
         DECLARE_UNO3_AGG_DEFAULTS( OFormattedModel, OEditBaseModel );
 
-    // XTypeProvider
+        // XTypeProvider
         virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Type> _getTypes();
 
-    // XAggregation
+        // XAggregation
         virtual ::com::sun::star::uno::Any SAL_CALL queryAggregation(const ::com::sun::star::uno::Type& _rType) throw(::com::sun::star::uno::RuntimeException);
 
-    // OComponentHelper
+        // OComponentHelper
         virtual void SAL_CALL disposing();
 
-    // XServiceInfo
+        // XServiceInfo
         IMPLEMENTATION_NAME(OFormattedModel);
         virtual StringSequence SAL_CALL getSupportedServiceNames() throw();
 
-    // XPersistObject
+        // XPersistObject
         virtual void SAL_CALL write(const ::com::sun::star::uno::Reference< ::com::sun::star::io::XObjectOutputStream>& _rxOutStream) throw ( ::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException);
         virtual void SAL_CALL read(const ::com::sun::star::uno::Reference< ::com::sun::star::io::XObjectInputStream>& _rxInStream) throw ( ::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException);
         virtual OUString SAL_CALL getServiceName() throw ( ::com::sun::star::uno::RuntimeException);
 
-    // XPropertySet
+        // XPropertySet
         virtual void SAL_CALL getFastPropertyValue(::com::sun::star::uno::Any& rValue, sal_Int32 nHandle ) const;
         virtual sal_Bool SAL_CALL convertFastPropertyValue(::com::sun::star::uno::Any& rConvertedValue, ::com::sun::star::uno::Any& rOldValue,
                                               sal_Int32 nHandle, const ::com::sun::star::uno::Any& rValue )
                                             throw(::com::sun::star::lang::IllegalArgumentException);
         virtual void SAL_CALL setFastPropertyValue_NoBroadcast(sal_Int32 nHandle, const ::com::sun::star::uno::Any& rValue) throw ( ::com::sun::star::uno::Exception);
 
-    // XLoadListener
+        // XLoadListener
         virtual void SAL_CALL loaded(const ::com::sun::star::lang::EventObject& rEvent) throw ( ::com::sun::star::uno::RuntimeException);
 
-    // XPropertyState
+        // XPropertyState
         void setPropertyToDefaultByHandle(sal_Int32 nHandle);
         ::com::sun::star::uno::Any getPropertyDefaultByHandle(sal_Int32 nHandle) const;
 
@@ -105,16 +101,16 @@ namespace frm
             ::com::sun::star::uno::Sequence< ::com::sun::star::beans::Property >& /* [out] */ _rAggregateProps
         ) const;
 
-    // XPropertyChangeListener
+        // XPropertyChangeListener
         virtual void _propertyChanged(const ::com::sun::star::beans::PropertyChangeEvent& evt) throw(::com::sun::star::uno::RuntimeException);
 
-    // prevent method hiding
+        // prevent method hiding
         using OEditBaseModel::disposing;
         using OEditBaseModel::getFastPropertyValue;
 
     protected:
         virtual sal_uInt16 getPersistenceFlags() const;
-            // as we have an own version handling for persistence
+        // as we have an own version handling for persistence
 
         // OBoundControlModel overridables
         virtual ::com::sun::star::uno::Any
@@ -144,9 +140,7 @@ namespace frm
         void    updateFormatterNullDate();
     };
 
-    //==================================================================
-    //= OFormattedControl
-    //==================================================================
+    // OFormattedControl
     typedef ::cppu::ImplHelper1< ::com::sun::star::awt::XKeyListener> OFormattedControl_BASE;
     class OFormattedControl :    public OBoundControl
                                 ,public OFormattedControl_BASE
@@ -162,31 +156,27 @@ namespace frm
 
         virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Type> _getTypes();
 
-    // ::com::sun::star::lang::XServiceInfo
+        // ::com::sun::star::lang::XServiceInfo
         IMPLEMENTATION_NAME(OFormattedControl);
         virtual StringSequence SAL_CALL getSupportedServiceNames() throw();
 
-    // ::com::sun::star::lang::XEventListener
+        // ::com::sun::star::lang::XEventListener
         virtual void SAL_CALL disposing(const ::com::sun::star::lang::EventObject& _rSource) throw(::com::sun::star::uno::RuntimeException);
 
-    // ::com::sun::star::awt::XKeyListener
+        // ::com::sun::star::awt::XKeyListener
         virtual void SAL_CALL keyPressed(const ::com::sun::star::awt::KeyEvent& e) throw ( ::com::sun::star::uno::RuntimeException);
         virtual void SAL_CALL keyReleased(const ::com::sun::star::awt::KeyEvent& e) throw ( ::com::sun::star::uno::RuntimeException);
 
-    // ::com::sun::star::awt::XControl
+        // ::com::sun::star::awt::XControl
         virtual void SAL_CALL setDesignMode(sal_Bool bOn) throw ( ::com::sun::star::uno::RuntimeException);
 
-    // disambiguation
+        // disambiguation
         using OBoundControl::disposing;
 
     private:
         DECL_LINK( OnKeyPressed, void* );
     };
-
-//.........................................................................
 }
-//.........................................................................
-
 #endif // INCLUDED_FORMS_SOURCE_COMPONENT_FORMATTEDFIELD_HXX
 
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/forms/source/component/Grid.cxx b/forms/source/component/Grid.cxx
index c524b01..746583b 100644
--- a/forms/source/component/Grid.cxx
+++ b/forms/source/component/Grid.cxx
@@ -16,20 +16,16 @@
  *   except in compliance with the License. You may obtain a copy of
  *   the License at http://www.apache.org/licenses/LICENSE-2.0 .
  */
-
-
 #include "Columns.hxx"
 #include "findpos.hxx"
 #include "Grid.hxx"
 #include "property.hrc"
 #include "property.hxx"
 #include "services.hxx"
-
 #include <com/sun/star/form/FormComponentType.hpp>
 #include <com/sun/star/form/XForm.hpp>
 #include <com/sun/star/form/XLoadable.hpp>
 #include <com/sun/star/text/WritingMode2.hpp>
-
 #include <comphelper/basicio.hxx>
 #include <comphelper/container.hxx>
 #include <comphelper/extract.hxx>
@@ -37,13 +33,9 @@
 #include <cppuhelper/queryinterface.hxx>
 #include <toolkit/helper/vclunohelper.hxx>
 #include <vcl/svapp.hxx>
-
 using namespace ::com::sun::star::uno;
-
-//.........................................................................
 namespace frm
 {
-//.........................................................................
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::sdb;
@@ -57,9 +49,7 @@ using namespace ::com::sun::star::io;
 using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::util;
 using namespace ::com::sun::star::view;
-
 namespace WritingMode2 = ::com::sun::star::text::WritingMode2;
-
 const sal_uInt16 ROWHEIGHT          =   0x0001;
 const sal_uInt16 FONTTYPE           =   0x0002;
 const sal_uInt16 FONTSIZE           =   0x0004;
@@ -69,14 +59,10 @@ const sal_uInt16 TEXTCOLOR          =   0x0020;
 const sal_uInt16 FONTDESCRIPTOR     =   0x0040;
 const sal_uInt16 RECORDMARKER       =   0x0080;
 const sal_uInt16 BACKGROUNDCOLOR    =   0x0100;
-
-//------------------------------------------------------------------
 InterfaceRef SAL_CALL OGridControlModel_CreateInstance(const Reference<XMultiServiceFactory>& _rxFactory)
 {
     return *(new OGridControlModel( comphelper::getComponentContext(_rxFactory) ));
 }
-
-//------------------------------------------------------------------
 OGridControlModel::OGridControlModel(const Reference<XComponentContext>& _rxFactory)
     :OControlModel(_rxFactory, OUString())
     ,OInterfaceContainer(_rxFactory, m_aMutex, ::getCppuType(static_cast<Reference<XPropertySet>*>(NULL)))
@@ -97,11 +83,9 @@ OGridControlModel::OGridControlModel(const Reference<XComponentContext>& _rxFact
     ,m_bAlwaysShowCursor(sal_False)
     ,m_bDisplaySynchron(sal_True)
 {
-
     m_nClassId = FormComponentType::GRIDCONTROL;
 }
 
-//------------------------------------------------------------------
 OGridControlModel::OGridControlModel( const OGridControlModel* _pOriginal, const Reference< XComponentContext >& _rxFactory )
     :OControlModel( _pOriginal, _rxFactory )
     ,OInterfaceContainer( _rxFactory, m_aMutex, ::getCppuType( static_cast<Reference<XPropertySet>*>( NULL ) ) )
@@ -111,7 +95,6 @@ OGridControlModel::OGridControlModel( const OGridControlModel* _pOriginal, const
     ,m_aResetListeners( m_aMutex )
     ,m_aRowSetChangeListeners( m_aMutex )
 {
-
     m_aDefaultControl = _pOriginal->m_aDefaultControl;
     m_bEnable = _pOriginal->m_bEnable;
     m_bEnableVisible = _pOriginal->m_bEnableVisible;
@@ -123,14 +106,11 @@ OGridControlModel::OGridControlModel( const OGridControlModel* _pOriginal, const
     m_bPrintable = _pOriginal->m_bPrintable;
     m_bAlwaysShowCursor = _pOriginal->m_bAlwaysShowCursor;
     m_bDisplaySynchron = _pOriginal->m_bDisplaySynchron;
-
     // clone the columns
     cloneColumns( _pOriginal );
-
     // TODO: clone the events?
 }
 
-//------------------------------------------------------------------
 OGridControlModel::~OGridControlModel()
 {
     if (!OComponentHelper::rBHelper.bDisposed)
@@ -138,11 +118,9 @@ OGridControlModel::~OGridControlModel()
         acquire();
         dispose();
     }
-
 }
 
 // XCloneable
-//------------------------------------------------------------------------------
 Reference< XCloneable > SAL_CALL OGridControlModel::createClone( ) throw (RuntimeException)
 {
     OGridControlModel* pClone = new OGridControlModel( this, getContext() );
@@ -155,13 +133,11 @@ Reference< XCloneable > SAL_CALL OGridControlModel::createClone( ) throw (Runtim
     return static_cast< XCloneable* >( static_cast< OControlModel* >( pClone ) );
 }
 
-//------------------------------------------------------------------------------
 void OGridControlModel::cloneColumns( const OGridControlModel* _pOriginalContainer )
 {
     try
     {
         Reference< XCloneable > xColCloneable;
-
         const OInterfaceArray::const_iterator pColumnStart = _pOriginalContainer->m_aItems.begin();
         const OInterfaceArray::const_iterator pColumnEnd = _pOriginalContainer->m_aItems.end();
         for ( OInterfaceArray::const_iterator pColumn = pColumnStart; pColumn != pColumnEnd; ++pColumn )
@@ -169,19 +145,16 @@ void OGridControlModel::cloneColumns( const OGridControlModel* _pOriginalContain
             // ask the col for a factory for the clone
             xColCloneable = xColCloneable.query( *pColumn );
             DBG_ASSERT( xColCloneable.is(), "OGridControlModel::cloneColumns: column is not cloneable!" );
-
             if ( xColCloneable.is() )
             {
                 // create a clone of the column
                 Reference< XCloneable > xColClone( xColCloneable->createClone() );
                 DBG_ASSERT( xColClone.is(), "OGridControlModel::cloneColumns: invalid column clone!" );
-
                 if ( xColClone.is() )
                 {
                     // insert this clone into our own container
                     insertByIndex( pColumn - pColumnStart, xColClone->queryInterface( m_aElementType ) );
                 }
-
             }
         }
     }
@@ -192,22 +165,17 @@ void OGridControlModel::cloneColumns( const OGridControlModel* _pOriginalContain
 }
 
 // XServiceInfo
-//------------------------------------------------------------------------------
 StringSequence OGridControlModel::getSupportedServiceNames() throw(RuntimeException)
 {
     StringSequence aSupported = OControlModel::getSupportedServiceNames();
     aSupported.realloc(aSupported.getLength() + 2);
-
     aSupported[aSupported.getLength()-2] = "com.sun.star.awt.UnoControlModel";
     aSupported[aSupported.getLength()-1] = FRM_SUN_COMPONENT_GRIDCONTROL;
     return aSupported;
 }
-
-//------------------------------------------------------------------------------
 Any SAL_CALL OGridControlModel::queryAggregation( const Type& _rType ) throw (RuntimeException)
 {
     Any aReturn = OGridControlModel_BASE::queryInterface(_rType);
-
     if ( !aReturn.hasValue() )
     {
         aReturn = OControlModel::queryAggregation( _rType );
@@ -222,7 +190,6 @@ Any SAL_CALL OGridControlModel::queryAggregation( const Type& _rType ) throw (Ru
 }
 
 // XSQLErrorListener
-//------------------------------------------------------------------------------
 void SAL_CALL OGridControlModel::errorOccured( const SQLErrorEvent& _rEvent ) throw (RuntimeException)
 {
     // forward the errors which happened to my columns to my own listeners
@@ -230,47 +197,38 @@ void SAL_CALL OGridControlModel::errorOccured( const SQLErrorEvent& _rEvent ) th
 }
 
 // XRowSetSupplier
-//------------------------------------------------------------------------------
 Reference< XRowSet > SAL_CALL OGridControlModel::getRowSet(  ) throw (RuntimeException)
 {
     return Reference< XRowSet >( getParent(), UNO_QUERY );
 }
 
-//------------------------------------------------------------------------------
 void SAL_CALL OGridControlModel::setRowSet( const Reference< XRowSet >& /*_rxDataSource*/ ) throw (RuntimeException)
 {
     OSL_FAIL( "OGridControlModel::setRowSet: not supported!" );
 }
 
-//--------------------------------------------------------------------
 void SAL_CALL OGridControlModel::addRowSetChangeListener( const Reference< XRowSetChangeListener >& i_Listener ) throw (RuntimeException)
 {
     if ( i_Listener.is() )
         m_aRowSetChangeListeners.addInterface( i_Listener );
 }
 
-//--------------------------------------------------------------------
 void SAL_CALL OGridControlModel::removeRowSetChangeListener( const Reference< XRowSetChangeListener >& i_Listener ) throw (RuntimeException)
 {
     m_aRowSetChangeListeners.removeInterface( i_Listener );
 }
 
 // XChild
-//------------------------------------------------------------------------------
 void SAL_CALL OGridControlModel::setParent( const InterfaceRef& i_Parent ) throw(NoSupportException, RuntimeException)
 {
     ::osl::ClearableMutexGuard aGuard( m_aMutex );
     if ( i_Parent == getParent() )
         return;
-
     OControlModel::setParent( i_Parent );
-
     EventObject aEvent( *this );
     aGuard.clear();
     m_aRowSetChangeListeners.notifyEach( &XRowSetChangeListener::onRowSetChanged, aEvent );
 }
-
-//------------------------------------------------------------------------------
 Sequence< Type > SAL_CALL OGridControlModel::getTypes(  ) throw(RuntimeException)
 {
     return concatSequences(
@@ -284,15 +242,12 @@ Sequence< Type > SAL_CALL OGridControlModel::getTypes(  ) throw(RuntimeException
 }
 
 // OComponentHelper
-//------------------------------------------------------------------------------
 void OGridControlModel::disposing()
 {
     OControlModel::disposing();
     OErrorBroadcaster::disposing();
     OInterfaceContainer::disposing();
-
     setParent(NULL);
-
     EventObject aEvt(static_cast<XWeak*>(this));
     m_aSelectListeners.disposeAndClear(aEvt);
     m_aResetListeners.disposeAndClear(aEvt);
@@ -300,7 +255,6 @@ void OGridControlModel::disposing()
 }
 
 // XEventListener
-//------------------------------------------------------------------------------
 void OGridControlModel::disposing(const EventObject& _rEvent) throw( RuntimeException )
 {
     OControlModel::disposing( _rEvent );
@@ -308,18 +262,15 @@ void OGridControlModel::disposing(const EventObject& _rEvent) throw( RuntimeExce
 }
 
 // XSelectionSupplier
-//-----------------------------------------------------------------------------
 sal_Bool SAL_CALL OGridControlModel::select(const Any& rElement) throw(IllegalArgumentException, RuntimeException)
 {
     ::osl::ClearableMutexGuard aGuard( m_aMutex );
-
     Reference<XPropertySet> xSel;
     if (rElement.hasValue() && !::cppu::extractInterface(xSel, rElement))
     {
         throw IllegalArgumentException();
     }
     InterfaceRef xMe = static_cast<XWeak*>(this);
-
     if (xSel.is())
     {
         Reference<XChild> xAsChild(xSel, UNO_QUERY);
@@ -328,7 +279,6 @@ sal_Bool SAL_CALL OGridControlModel::select(const Any& rElement) throw(IllegalAr
             throw IllegalArgumentException();
         }
     }
-
     if ( xSel != m_xSelection )
     {
         m_xSelection = xSel;
@@ -338,35 +288,28 @@ sal_Bool SAL_CALL OGridControlModel::select(const Any& rElement) throw(IllegalAr
     }
     return sal_False;
 }
-
-//-----------------------------------------------------------------------------
 Any SAL_CALL OGridControlModel::getSelection() throw(RuntimeException)
 {
     return makeAny(m_xSelection);
 }
 
-//-----------------------------------------------------------------------------
 void OGridControlModel::addSelectionChangeListener(const Reference< XSelectionChangeListener >& _rxListener) throw( RuntimeException )
 {
     m_aSelectListeners.addInterface(_rxListener);
 }
 
-//-----------------------------------------------------------------------------
 void OGridControlModel::removeSelectionChangeListener(const Reference< XSelectionChangeListener >& _rxListener) throw( RuntimeException )
 {
     m_aSelectListeners.removeInterface(_rxListener);
 }
 
 // XGridColumnFactory
-//------------------------------------------------------------------------------
 Reference<XPropertySet> SAL_CALL OGridControlModel::createColumn(const OUString& ColumnType) throw ( :: com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
 {
     SolarMutexGuard g;
     const Sequence< OUString >& rColumnTypes = frm::getColumnTypes();
     return createColumn( ::detail::findPos( ColumnType, rColumnTypes ) );
 }
-
-//------------------------------------------------------------------------------
 Reference<XPropertySet>  OGridControlModel::createColumn(sal_Int32 nTypeId) const
 {
     Reference<XPropertySet>  xReturn;
@@ -388,15 +331,12 @@ Reference<XPropertySet>  OGridControlModel::createColumn(sal_Int32 nTypeId) cons
     }
     return xReturn;
 }
-
-//------------------------------------------------------------------------------
 StringSequence SAL_CALL OGridControlModel::getColumnTypes() throw ( ::com::sun::star::uno::RuntimeException)
 {
     return frm::getColumnTypes();
 }
 
 // XReset
-//-----------------------------------------------------------------------------
 void SAL_CALL OGridControlModel::reset() throw ( ::com::sun::star::uno::RuntimeException)
 {
     ::cppu::OInterfaceIteratorHelper aIter(m_aResetListeners);
@@ -404,27 +344,20 @@ void SAL_CALL OGridControlModel::reset() throw ( ::com::sun::star::uno::RuntimeE
     sal_Bool bContinue = sal_True;
     while (aIter.hasMoreElements() && bContinue)
         bContinue =((XResetListener*)aIter.next())->approveReset(aEvt);
-
     if (bContinue)
     {
         _reset();
         m_aResetListeners.notifyEach( &XResetListener::resetted, aEvt );
     }
 }
-
-//-----------------------------------------------------------------------------
 void SAL_CALL OGridControlModel::addResetListener(const Reference<XResetListener>& _rxListener) throw ( ::com::sun::star::uno::RuntimeException)
 {
     m_aResetListeners.addInterface(_rxListener);
 }
-
-//-----------------------------------------------------------------------------
 void SAL_CALL OGridControlModel::removeResetListener(const Reference<XResetListener>& _rxListener) throw ( ::com::sun::star::uno::RuntimeException)
 {
     m_aResetListeners.removeInterface(_rxListener);
 }
-
-//-----------------------------------------------------------------------------
 void OGridControlModel::_reset()
 {
     Reference<XReset> xReset;
@@ -438,7 +371,6 @@ void OGridControlModel::_reset()
 }
 
 // XPropertySet
-//------------------------------------------------------------------------------
 void OGridControlModel::describeFixedProperties( Sequence< Property >& _rProps ) const
 {
     BEGIN_DESCRIBE_BASE_PROPERTIES( 37 )
@@ -481,8 +413,6 @@ void OGridControlModel::describeFixedProperties( Sequence< Property >& _rProps )
         DECL_PROP3(CONTEXT_WRITING_MODE,sal_Int16,          BOUND, MAYBEDEFAULT, TRANSIENT);
     END_DESCRIBE_PROPERTIES();
 }
-
-//------------------------------------------------------------------------------
 void OGridControlModel::getFastPropertyValue(Any& rValue, sal_Int32 nHandle ) const
 {
     switch (nHandle)
@@ -541,7 +471,6 @@ void OGridControlModel::getFastPropertyValue(Any& rValue, sal_Int32 nHandle ) co
         case PROPERTY_ID_ROWHEIGHT:
             rValue = m_aRowHeight;
             break;
-
         default:
             if ( isFontRelatedProperty( nHandle ) )
                 FontControlModel::getFastPropertyValue( rValue, nHandle );
@@ -549,8 +478,6 @@ void OGridControlModel::getFastPropertyValue(Any& rValue, sal_Int32 nHandle ) co
                 OControlModel::getFastPropertyValue( rValue, nHandle );
     }
 }
-
-//------------------------------------------------------------------------------
 sal_Bool OGridControlModel::convertFastPropertyValue( Any& rConvertedValue, Any& rOldValue,
                                                     sal_Int32 nHandle, const Any& rValue )throw( IllegalArgumentException )
 {
@@ -622,7 +549,6 @@ sal_Bool OGridControlModel::convertFastPropertyValue( Any& rConvertedValue, Any&
         case PROPERTY_ID_ROWHEIGHT:
             {
                 bModified = tryPropertyValue(rConvertedValue, rOldValue, rValue, m_aRowHeight, ::getCppuType((const sal_Int32*)NULL));
-
                 sal_Int32 nNewVal( 0 );
                 if ( ( rConvertedValue >>= nNewVal ) && ( nNewVal <= 0 ) )
                 {
@@ -639,8 +565,6 @@ sal_Bool OGridControlModel::convertFastPropertyValue( Any& rConvertedValue, Any&
     }
     return bModified;
 }
-
-//------------------------------------------------------------------------------
 void OGridControlModel::setFastPropertyValue_NoBroadcast( sal_Int32 nHandle, const Any& rValue ) throw ( ::com::sun::star::uno::Exception)
 {
     switch (nHandle)
@@ -699,7 +623,6 @@ void OGridControlModel::setFastPropertyValue_NoBroadcast( sal_Int32 nHandle, con
         case PROPERTY_ID_ROWHEIGHT:
             m_aRowHeight = rValue;
             break;
-
         default:
             if ( isFontRelatedProperty( nHandle ) )
             {
@@ -710,12 +633,9 @@ void OGridControlModel::setFastPropertyValue_NoBroadcast( sal_Int32 nHandle, con
             else
                 OControlModel::setFastPropertyValue_NoBroadcast( nHandle, rValue );
     }
-
 }
 
 //XPropertyState
-
-//------------------------------------------------------------------------------
 Any OGridControlModel::getPropertyDefaultByHandle( sal_Int32 nHandle ) const
 {
     Any aReturn;
@@ -725,11 +645,9 @@ Any OGridControlModel::getPropertyDefaultByHandle( sal_Int32 nHandle ) const
         case PROPERTY_ID_WRITING_MODE:
             aReturn <<= WritingMode2::CONTEXT;
             break;
-
         case PROPERTY_ID_DEFAULTCONTROL:
             aReturn <<= OUString( STARDIV_ONE_FORM_CONTROL_GRID  );
             break;
-
         case PROPERTY_ID_PRINTABLE:
         case PROPERTY_ID_HASNAVIGATION:
         case PROPERTY_ID_RECORDMARKER:
@@ -738,20 +656,16 @@ Any OGridControlModel::getPropertyDefaultByHandle( sal_Int32 nHandle ) const
         case PROPERTY_ID_ENABLEVISIBLE:
             aReturn = makeBoolAny(true);
             break;
-
         case PROPERTY_ID_ALWAYSSHOWCURSOR:
             aReturn = makeBoolAny(false);
             break;
-
         case PROPERTY_ID_HELPURL:
         case PROPERTY_ID_HELPTEXT:
             aReturn <<= OUString();
             break;
-
         case PROPERTY_ID_BORDER:
             aReturn <<= (sal_Int16)1;
             break;
-
         case PROPERTY_ID_BORDERCOLOR:
         case PROPERTY_ID_TABSTOP:
         case PROPERTY_ID_BACKGROUNDCOLOR:
@@ -759,7 +673,6 @@ Any OGridControlModel::getPropertyDefaultByHandle( sal_Int32 nHandle ) const
         case PROPERTY_ID_CURSORCOLOR:
             // void
             break;
-
         default:
             if ( isFontRelatedProperty( nHandle ) )
                 aReturn = FontControlModel::getPropertyDefaultByHandle( nHandle );
@@ -769,18 +682,15 @@ Any OGridControlModel::getPropertyDefaultByHandle( sal_Int32 nHandle ) const
     return aReturn;
 }
 
-//------------------------------------------------------------------------------
 OGridColumn* OGridControlModel::getColumnImplementation(const InterfaceRef& _rxIFace) const
 {
     OGridColumn* pImplementation = NULL;
     Reference< XUnoTunnel > xUnoTunnel( _rxIFace, UNO_QUERY );
     if ( xUnoTunnel.is() )
         pImplementation = reinterpret_cast<OGridColumn*>(xUnoTunnel->getSomething(OGridColumn::getUnoTunnelImplementationId()));
-
     return pImplementation;
 }
 
-//------------------------------------------------------------------------------
 void OGridControlModel::gotColumn( const Reference< XInterface >& _rxColumn )
 {
     Reference< XSQLErrorBroadcaster > xBroadcaster( _rxColumn, UNO_QUERY );
@@ -788,7 +698,6 @@ void OGridControlModel::gotColumn( const Reference< XInterface >& _rxColumn )
         xBroadcaster->addSQLErrorListener( this );
 }
 
-//------------------------------------------------------------------------------
 void OGridControlModel::lostColumn(const Reference< XInterface >& _rxColumn)
 {
     if ( m_xSelection == _rxColumn )
@@ -797,119 +706,95 @@ void OGridControlModel::lostColumn(const Reference< XInterface >& _rxColumn)
         EventObject aEvt( static_cast< XWeak* >( this ) );
         m_aSelectListeners.notifyEach( &XSelectionChangeListener::selectionChanged, aEvt );
     }
-
     Reference< XSQLErrorBroadcaster > xBroadcaster( _rxColumn, UNO_QUERY );
     if ( xBroadcaster.is() )
         xBroadcaster->removeSQLErrorListener( this );
 }
 
-//------------------------------------------------------------------------------
 void OGridControlModel::implRemoved(const InterfaceRef& _rxObject)
 {
     OInterfaceContainer::implRemoved(_rxObject);
     lostColumn(_rxObject);
 }
 
-//------------------------------------------------------------------------------
 void OGridControlModel::implInserted( const ElementDescription* _pElement )
 {
     OInterfaceContainer::implInserted( _pElement );
     gotColumn( _pElement->xInterface );
 }
 
-//------------------------------------------------------------------------------
 void OGridControlModel::impl_replacedElement( const ContainerEvent& _rEvent, ::osl::ClearableMutexGuard& _rInstanceLock )
 {
     Reference< XInterface > xOldColumn( _rEvent.ReplacedElement, UNO_QUERY );
     Reference< XInterface > xNewColumn( _rEvent.Element, UNO_QUERY );
-
     bool bNewSelection = ( xOldColumn == m_xSelection );
-
     lostColumn( xOldColumn );
     gotColumn( xNewColumn );
-
     if ( bNewSelection )
         m_xSelection.set( xNewColumn, UNO_QUERY );
-
     OInterfaceContainer::impl_replacedElement( _rEvent, _rInstanceLock );
-    // <<---- SYNCHRONIZED
-
+    // < SYNCHRONIZED
     if ( bNewSelection )
     {
         m_aSelectListeners.notifyEach( &XSelectionChangeListener::selectionChanged, EventObject( *this ) );
     }
 }
 
-//------------------------------------------------------------------------------
 ElementDescription* OGridControlModel::createElementMetaData( )
 {
     return new ColumnDescription;
 }
 
-//------------------------------------------------------------------------------
 void OGridControlModel::approveNewElement( const Reference< XPropertySet >& _rxObject, ElementDescription* _pElement )
 {
     OGridColumn* pCol = getColumnImplementation( _rxObject );
     if ( !pCol )
         throw IllegalArgumentException();
-
     OInterfaceContainer::approveNewElement( _rxObject, _pElement );
-
     // if we're here, the object passed all tests
     if ( _pElement )
         static_cast< ColumnDescription* >( _pElement )->pColumn = pCol;
 }
 
 // XPersistObject
-//------------------------------------------------------------------------------
 OUString SAL_CALL OGridControlModel::getServiceName() throw ( ::com::sun::star::uno::RuntimeException)
 {
-    return OUString(FRM_COMPONENT_GRID);  // old (non-sun) name for compatibility !
+    return OUString(FRM_COMPONENT_GRID);  // old (non-sun) name for compatibility!
 }
 
-//------------------------------------------------------------------------------
 void OGridControlModel::write(const Reference<XObjectOutputStream>& _rxOutStream) throw ( ::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException)
 {
     OControlModel::write(_rxOutStream);
-
     Reference<XMarkableStream>  xMark(_rxOutStream, UNO_QUERY);
-
     // 1. Version
     _rxOutStream->writeShort(0x0008);
-
     // 2. Columns
     sal_Int32 nLen = getCount();
     _rxOutStream->writeLong(nLen);
     OGridColumn* pCol;
     for (sal_Int32 i = 0; i < nLen; i++)
     {
-        // zuerst den Servicenamen fuer das darunterliegende Model
+        // first the service name for the unerlying model
         pCol = getColumnImplementation(m_aItems[i]);
         DBG_ASSERT(pCol != NULL, "OGridControlModel::write : such items should never reach it into my container !");
-
         _rxOutStream << pCol->getModelName();
-
-        // dann das Object selbst
+        // then the object itself
         sal_Int32 nMark = xMark->createMark();
         sal_Int32 nObjLen = 0;
         _rxOutStream->writeLong(nObjLen);
-
-        // schreiben der Col
+        // writing the column
         pCol->write(_rxOutStream);
-
-        // feststellen der Laenge
+        // determining the length
         nObjLen = xMark->offsetToMark(nMark) - 4;
         xMark->jumpToMark(nMark);
         _rxOutStream->writeLong(nObjLen);
         xMark->jumpToFurthest();
         xMark->deleteMark(nMark);
     }
-
     // 3. Events
     writeEvents(_rxOutStream);
-
-    // 4. Attribute
-    // Maskierung fuer alle any Typen
+    // 4. Attributes
+    // Masking for all 'any' types
     sal_uInt16 nAnyMask = 0;
     if (m_aRowHeight.getValueType().getTypeClass() == TypeClass_LONG)
         nAnyMask |= ROWHEIGHT;
@@ -923,12 +808,9 @@ void OGridControlModel::write(const Reference<XObjectOutputStream>& _rxOutStream
         nAnyMask |= BACKGROUNDCOLOR;
     if (!m_bRecordMarker)
         nAnyMask |= RECORDMARKER;
-
     _rxOutStream->writeShort(nAnyMask);
-
     if (nAnyMask & ROWHEIGHT)
         _rxOutStream->writeLong(getINT32(m_aRowHeight));
-
     // old structures
     const FontDescriptor& aFont = getFont();
     if ( nAnyMask & FONTDESCRIPTOR )
@@ -941,12 +823,10 @@ void OGridControlModel::write(const Reference<XObjectOutputStream>& _rxOutStream
         _rxOutStream->writeShort( sal_Int16(aFont.Orientation * 10) );
         _rxOutStream->writeBoolean( aFont.Kerning );
         _rxOutStream->writeBoolean( aFont.WordLineMode );
-
         // Size
         _rxOutStream->writeLong( aFont.Width );
         _rxOutStream->writeLong( aFont.Height );
         _rxOutStream->writeShort( sal::static_int_cast< sal_Int16 >( VCLUnoHelper::ConvertFontWidth( aFont.CharacterWidth ) ) );
-
         // Type
         _rxOutStream->writeUTF( aFont.Name );
         _rxOutStream->writeUTF( aFont.StyleName );
@@ -954,59 +834,43 @@ void OGridControlModel::write(const Reference<XObjectOutputStream>& _rxOutStream
         _rxOutStream->writeShort( aFont.CharSet );
         _rxOutStream->writeShort( aFont.Pitch );
     }
-
     _rxOutStream << m_aDefaultControl;
-
     _rxOutStream->writeShort(m_nBorder);
     _rxOutStream->writeBoolean(m_bEnable);
-
     if (nAnyMask & TABSTOP)
         _rxOutStream->writeBoolean(getBOOL(m_aTabStop));
-
     _rxOutStream->writeBoolean(m_bNavigation);
-
     if (nAnyMask & TEXTCOLOR)
         _rxOutStream->writeLong( getTextColor() );
-
-    // neu ab Version 6
+    // new since version 6
     _rxOutStream << m_sHelpText;
-
     if (nAnyMask & FONTDESCRIPTOR)
         _rxOutStream << getFont();
-
     if (nAnyMask & RECORDMARKER)
         _rxOutStream->writeBoolean(m_bRecordMarker);
-
-    // neu ab Version 7
+    // new since version 7
     _rxOutStream->writeBoolean(m_bPrintable);
-
-    // new since 8
+    // new since version 8
     if (nAnyMask & BACKGROUNDCOLOR)
         _rxOutStream->writeLong(getINT32(m_aBackgroundColor));
 }
 
-//------------------------------------------------------------------------------
 void OGridControlModel::read(const Reference<XObjectInputStream>& _rxInStream) throw ( ::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException)
 {
     SolarMutexGuard g;
     OControlModel::read(_rxInStream);
-
     Reference<XMarkableStream>  xMark(_rxInStream, UNO_QUERY);
-
-    // 1. Version
+    // 1. version
     sal_Int16 nVersion = _rxInStream->readShort();
-
-    // 2. Einlesen der Spalten
+    // 2. reading the columns
     sal_Int32 nLen = _rxInStream->readLong();
     if (nLen)
     {
         for (sal_Int32 i = 0; i < nLen; i++)
         {
-            // Lesen des Modelnamen
-
+            // reading the model names
             OUString sModelName;
             _rxInStream >> sModelName;
-
             Reference<XPropertySet>  xCol(createColumn(getColumnTypeByModelName(sModelName)));
             DBG_ASSERT(xCol.is(), "OGridControlModel::read : unknown column type !");
             sal_Int32 nObjLen = _rxInStream->readLong();
@@ -1022,15 +886,13 @@ void OGridControlModel::read(const Reference<XObjectInputStream>& _rxInStream) t
                 _rxInStream->skipBytes(nObjLen);
                 xMark->deleteMark(nMark);
             }
-
             if ( xCol.is() )
                 implInsert( i, xCol, sal_False, NULL, sal_False );
         }
     }
-
-    // In der Basisimplementierung werden die Events nur gelesen, Elemente im Container existieren
-    // da aber vor TF_ONE fuer das GridControl immer Events geschrieben wurden, muessen sie auch immer
-    // mit gelesen werden
+    // In the base implementation events are only read, elements in the container exist
+    // but since before TF_ONE for the GridControl events were always written, so they
+    // need to be read, too
     sal_Int32 nObjLen = _rxInStream->readLong();
     if (nObjLen)
     {
@@ -1042,8 +904,7 @@ void OGridControlModel::read(const Reference<XObjectInputStream>& _rxInStream) t
         _rxInStream->skipBytes(nObjLen);
         xMark->deleteMark(nMark);
     }
-
-    // Attachement lesen
+    // reading the attachement
     for (sal_Int32 i = 0; i < nLen; i++)
     {
         InterfaceRef  xIfc(m_aItems[i], UNO_QUERY);
@@ -1052,25 +913,20 @@ void OGridControlModel::read(const Reference<XObjectInputStream>& _rxInStream) t
         aHelper <<= xSet;
         m_xEventAttacher->attach( i, xIfc, aHelper );
     }
-
-    // 4. Einlesen der Attribute
+    // 4. reading the attributes
     if (nVersion == 1)
         return;
-
-    // Maskierung fuer any
+    // Masking for any
     sal_uInt16 nAnyMask = _rxInStream->readShort();
-
     if (nAnyMask & ROWHEIGHT)
     {
         sal_Int32 nValue = _rxInStream->readLong();
         m_aRowHeight <<= (sal_Int32)nValue;
     }
-
     FontDescriptor aFont( getFont() );
     if ( nAnyMask & FONTATTRIBS )
     {
         aFont.Weight = (float)VCLUnoHelper::ConvertFontWeight( _rxInStream->readShort() );
-
         aFont.Slant = (FontSlant)_rxInStream->readShort();
         aFont.Underline = _rxInStream->readShort();
         aFont.Strikeout = _rxInStream->readShort();
@@ -1092,56 +948,42 @@ void OGridControlModel::read(const Reference<XObjectInputStream>& _rxInStream) t
         aFont.CharSet = _rxInStream->readShort();
         aFont.Pitch = _rxInStream->readShort();
     }
-
     if ( nAnyMask & ( FONTATTRIBS | FONTSIZE | FONTTYPE ) )
         setFont( aFont );
-
     // Name
     _rxInStream >> m_aDefaultControl;
     m_nBorder = _rxInStream->readShort();
     m_bEnable = _rxInStream->readBoolean();
-
     if (nAnyMask & TABSTOP)
     {
         m_aTabStop = makeBoolAny(_rxInStream->readBoolean());
     }
-
     if (nVersion > 3)
         m_bNavigation = _rxInStream->readBoolean();
-
     if (nAnyMask & TEXTCOLOR)
     {
         sal_Int32 nValue = _rxInStream->readLong();
         setTextColor( (sal_Int32)nValue );
     }
-
-    // neu ab Version 6
+    // new since version 6
     if (nVersion > 5)
         _rxInStream >> m_sHelpText;
-
     if (nAnyMask & FONTDESCRIPTOR)
     {
         FontDescriptor aUNOFont;
         _rxInStream >> aUNOFont;
         setFont( aFont );
     }
-
     if (nAnyMask & RECORDMARKER)
         m_bRecordMarker = _rxInStream->readBoolean();
-
-    // neu ab Version 7
+    // new since version 7
     if (nVersion > 6)
         m_bPrintable = _rxInStream->readBoolean();
-
     if (nAnyMask & BACKGROUNDCOLOR)
     {
         sal_Int32 nValue = _rxInStream->readLong();
         m_aBackgroundColor <<= (sal_Int32)nValue;
     }
 }
-
-//.........................................................................
-}   // namespace frm
-//.........................................................................
-
+}
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/forms/source/component/GroupManager.cxx b/forms/source/component/GroupManager.cxx
index af6b3c8..7a90ed5 100644
--- a/forms/source/component/GroupManager.cxx
+++ b/forms/source/component/GroupManager.cxx
@@ -29,11 +29,8 @@
 
 #include <algorithm>
 
-//.........................................................................
 namespace frm
 {
-//.........................................................................
-
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::sdbc;
 using namespace ::com::sun::star::beans;
@@ -58,23 +55,18 @@ namespace
     }
 }
 
-//========================================================================
 // class OGroupCompAcc
-//========================================================================
-//------------------------------------------------------------------
 OGroupCompAcc::OGroupCompAcc(const Reference<XPropertySet>& rxElement, const OGroupComp& _rGroupComp )
                :m_xComponent( rxElement )
                ,m_aGroupComp( _rGroupComp )
 {
 }
 
-//------------------------------------------------------------------
 sal_Bool OGroupCompAcc::operator==( const OGroupCompAcc& rCompAcc ) const
 {
     return (m_xComponent == rCompAcc.GetComponent());
 }
 
-//------------------------------------------------------------------
 class OGroupCompAccLess : public ::std::binary_function<OGroupCompAcc, OGroupCompAcc, sal_Bool>
 {
 public:
@@ -86,18 +78,13 @@ public:
     }
 };
 
-//========================================================================
 // class OGroupComp
-//========================================================================
-
-//------------------------------------------------------------------
 OGroupComp::OGroupComp()
     :m_nPos( -1 )
     ,m_nTabIndex( 0 )
 {
 }
 
-//------------------------------------------------------------------
 OGroupComp::OGroupComp(const OGroupComp& _rSource)
     :m_aName( _rSource.m_aName )
     ,m_xComponent( _rSource.m_xComponent )
@@ -107,7 +94,6 @@ OGroupComp::OGroupComp(const OGroupComp& _rSource)
 {
 }
 
-//------------------------------------------------------------------
 OGroupComp::OGroupComp(const Reference<XPropertySet>& rxSet, sal_Int32 nInsertPos )
     : m_aName( OGroupManager::GetGroupName( rxSet ) )
     , m_xComponent( rxSet )
@@ -118,18 +104,16 @@ OGroupComp::OGroupComp(const Reference<XPropertySet>& rxSet, sal_Int32 nInsertPo
     if (m_xComponent.is())
     {
         if (hasProperty( PROPERTY_TABINDEX, m_xComponent ) )
-            // Indices kleiner 0 werden wie 0 behandelt
+            // Indices smaller than 0 are treated like 0
             m_nTabIndex = std::max(getINT16(m_xComponent->getPropertyValue( PROPERTY_TABINDEX )) , sal_Int16(0));
     }
 }
 
-//------------------------------------------------------------------
 sal_Bool OGroupComp::operator==( const OGroupComp& rComp ) const
 {
     return m_nTabIndex == rComp.GetTabIndex() && m_nPos == rComp.GetPos();
 }
 
-//------------------------------------------------------------------
 class OGroupCompLess : public ::std::binary_function<OGroupComp, OGroupComp, sal_Bool>
 {
 public:
@@ -147,23 +131,17 @@ public:
     }
 };
 
-//========================================================================
 // class OGroup
-//========================================================================
-
-//------------------------------------------------------------------
 OGroup::OGroup( const OUString& rGroupName )
         :m_aGroupName( rGroupName )
         ,m_nInsertPos(0)
 {
 }
 
-//------------------------------------------------------------------
 OGroup::~OGroup()
 {
 }
 
-//------------------------------------------------------------------
 void OGroup::InsertComponent( const Reference<XPropertySet>& xSet )
 {
     OGroupComp aNewGroupComp( xSet, m_nInsertPos );
@@ -174,7 +152,6 @@ void OGroup::InsertComponent( const Reference<XPropertySet>& xSet )
     m_nInsertPos++;
 }
 
-//------------------------------------------------------------------
 void OGroup::RemoveComponent( const Reference<XPropertySet>& rxElement )
 {
     sal_Int32 nGroupCompAccPos;
@@ -190,12 +167,12 @@ void OGroup::RemoveComponent( const Reference<XPropertySet>& rxElement )
             m_aCompAccArray.erase( m_aCompAccArray.begin() + nGroupCompAccPos );
             m_aCompArray.erase( m_aCompArray.begin() + nGroupCompPos );
 
-            /*============================================================
+            /*
             Durch das Entfernen der GroupComp ist die Einfuegeposition
             ungueltig geworden. Sie braucht hier aber nicht angepasst werden,
             da sie fortlaufend vergeben wird und damit immer
             aufsteigend eindeutig ist.
-            ============================================================*/
+            */
         }
         else
         {
@@ -208,13 +185,11 @@ void OGroup::RemoveComponent( const Reference<XPropertySet>& rxElement )
     }
 }
 
-//------------------------------------------------------------------
 sal_Bool OGroup::operator==( const OGroup& rGroup ) const
 {
     return m_aGroupName.equals(rGroup.GetGroupName());
 }
 
-//------------------------------------------------------------------
 class OGroupLess : public ::std::binary_function<OGroup, OGroup, sal_Bool>
 {
 public:
@@ -224,7 +199,6 @@ public:
     }
 };
 
-//------------------------------------------------------------------
 Sequence< Reference<XControlModel>  > OGroup::GetControlModels() const
 {
     sal_Int32 nLen = m_aCompArray.size();
@@ -240,7 +214,7 @@ Sequence< Reference<XControlModel>  > OGroup::GetControlModels() const
 }
 
 DBG_NAME(OGroupManager);
-//------------------------------------------------------------------
+
 OGroupManager::OGroupManager(const Reference< XContainer >& _rxContainer)
     :m_pCompGroup( new OGroup( OUString("AllComponentGroup") ) )
     ,m_xContainer(_rxContainer)
@@ -254,16 +228,14 @@ OGroupManager::OGroupManager(const Reference< XContainer >& _rxContainer)
     decrement(m_refCount);
 }
 
-//------------------------------------------------------------------
 OGroupManager::~OGroupManager()
 {
     DBG_DTOR(OGroupManager,NULL);
-    // Alle Components und CompGroup loeschen
+    // delete all Components and CompGroup
     delete m_pCompGroup;
 }
 
 // XPropertyChangeListener
-//------------------------------------------------------------------
 void OGroupManager::disposing(const EventObject& evt) throw( RuntimeException )
 {
     Reference<XContainer>  xContainer(evt.Source, UNO_QUERY);
@@ -271,23 +243,22 @@ void OGroupManager::disposing(const EventObject& evt) throw( RuntimeException )
     {
         DELETEZ(m_pCompGroup);
 
-        ////////////////////////////////////////////////////////////////
-        // Gruppen loeschen
+        // delete group
         m_aGroupArr.clear();
         m_xContainer.clear();
     }
 }
-// -----------------------------------------------------------------------------
+
 void OGroupManager::removeFromGroupMap(const OUString& _sGroupName,const Reference<XPropertySet>& _xSet)
 {
-    // Component aus CompGroup entfernen
+    // remove Component from CompGroup
     m_pCompGroup->RemoveComponent( _xSet );
 
     OGroupArr::iterator aFind = m_aGroupArr.find(_sGroupName);
 
     if ( aFind != m_aGroupArr.end() )
     {
-        // Gruppe vorhanden
+        // group exists
         aFind->second.RemoveComponent( _xSet );
 
         // Wenn Anzahl der Gruppenelemente == 1 ist, Gruppe deaktivieren
@@ -317,12 +288,12 @@ void OGroupManager::removeFromGroupMap(const OUString& _sGroupName,const Referen
     if (hasProperty(PROPERTY_TABINDEX, _xSet))
         _xSet->removePropertyChangeListener( PROPERTY_TABINDEX, this );
 }
-//------------------------------------------------------------------
+
 void SAL_CALL OGroupManager::propertyChange(const PropertyChangeEvent& evt) throw ( ::com::sun::star::uno::RuntimeException)
 {
     Reference<XPropertySet>  xSet(evt.Source, UNO_QUERY);
 
-    // Component aus Gruppe entfernen
+    // remove Component from group
     OUString     sGroupName;
     if (hasProperty( PROPERTY_GROUP_NAME, xSet ))
         xSet->getPropertyValue( PROPERTY_GROUP_NAME ) >>= sGroupName;
@@ -349,7 +320,6 @@ void SAL_CALL OGroupManager::propertyChange(const PropertyChangeEvent& evt) thro
 }
 
 // XContainerListener
-//------------------------------------------------------------------
 void SAL_CALL OGroupManager::elementInserted(const ContainerEvent& Event) throw ( ::com::sun::star::uno::RuntimeException)
 {
     Reference< XPropertySet > xProps;
@@ -358,7 +328,6 @@ void SAL_CALL OGroupManager::elementInserted(const ContainerEvent& Event) throw
         InsertElement( xProps );
 }
 
-//------------------------------------------------------------------
 void SAL_CALL OGroupManager::elementRemoved(const ContainerEvent& Event) throw ( ::com::sun::star::uno::RuntimeException)
 {
     Reference<XPropertySet> xProps;
@@ -367,7 +336,6 @@ void SAL_CALL OGroupManager::elementRemoved(const ContainerEvent& Event) throw (
         RemoveElement( xProps );
 }
 
-//------------------------------------------------------------------
 void SAL_CALL OGroupManager::elementReplaced(const ContainerEvent& Event) throw ( ::com::sun::star::uno::RuntimeException)
 {
     Reference<XPropertySet> xProps;
@@ -382,19 +350,16 @@ void SAL_CALL OGroupManager::elementReplaced(const ContainerEvent& Event) throw
 }
 
 // Other functions
-//------------------------------------------------------------------
 Sequence<Reference<XControlModel> > OGroupManager::getControlModels()
 {
     return m_pCompGroup->GetControlModels();
 }
 
-//------------------------------------------------------------------
 sal_Int32 OGroupManager::getGroupCount()
 {
     return m_aActiveGroupMap.size();
 }
 
-//------------------------------------------------------------------
 void OGroupManager::getGroup(sal_Int32 nGroup, Sequence< Reference<XControlModel> >& _rGroup, OUString& _rName)
 {
     OSL_ENSURE(nGroup >= 0 && (size_t)nGroup < m_aActiveGroupMap.size(),"OGroupManager::getGroup: Invalid group index!");
@@ -403,7 +368,6 @@ void OGroupManager::getGroup(sal_Int32 nGroup, Sequence< Reference<XControlModel
     _rGroup                         = aGroupPos->second.GetControlModels();
 }
 
-//------------------------------------------------------------------
 void OGroupManager::getGroupByName(const OUString& _rName, Sequence< Reference<XControlModel>  >& _rGroup)
 {
     OGroupArr::iterator aFind = m_aGroupArr.find(_rName);
@@ -411,7 +375,6 @@ void OGroupManager::getGroupByName(const OUString& _rName, Sequence< Reference<X
         _rGroup = aFind->second.GetControlModels();
 }
 
-//------------------------------------------------------------------
 void OGroupManager::InsertElement( const Reference<XPropertySet>& xSet )
 {
     // Nur ControlModels
@@ -458,7 +421,6 @@ void OGroupManager::InsertElement( const Reference<XPropertySet>& xSet )
             m_aActiveGroupMap.push_back(  aFind );
     }
 
-
     // Bei Component als PropertyChangeListener anmelden
     xSet->addPropertyChangeListener( PROPERTY_NAME, this );
     if (hasProperty(PROPERTY_GROUP_NAME, xSet))
@@ -467,10 +429,8 @@ void OGroupManager::InsertElement( const Reference<XPropertySet>& xSet )
     // Tabindex muss nicht jeder unterstuetzen
     if (hasProperty(PROPERTY_TABINDEX, xSet))
         xSet->addPropertyChangeListener( PROPERTY_TABINDEX, this );
-
 }
 
-//------------------------------------------------------------------
 void OGroupManager::RemoveElement( const Reference<XPropertySet>& xSet )
 {
     // Nur ControlModels
@@ -498,9 +458,6 @@ OUString OGroupManager::GetGroupName( ::com::sun::star::uno::Reference< ::com::s
         xComponent->getPropertyValue( PROPERTY_NAME ) >>= sGroupName;
     return sGroupName;
 }
-
-//.........................................................................
 }   // namespace frm
-//.........................................................................
 
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/forms/source/component/ImageButton.cxx b/forms/source/component/ImageButton.cxx
index 944df88..3c60460 100644
--- a/forms/source/component/ImageButton.cxx
+++ b/forms/source/component/ImageButton.cxx
@@ -26,10 +26,8 @@
 #include <comphelper/processfactory.hxx>
 #include <com/sun/star/awt/MouseButton.hpp>
 
-//.........................................................................
 namespace frm
 {
-//.........................................................................
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::sdb;
@@ -42,16 +40,12 @@ using namespace ::com::sun::star::io;
 using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::util;
 
-//==================================================================
-//= OImageButtonModel
-//==================================================================
-//------------------------------------------------------------------
+// OImageButtonModel
 InterfaceRef SAL_CALL OImageButtonModel_CreateInstance(const Reference<XMultiServiceFactory>& _rxFactory)
 {
      return *(new OImageButtonModel( comphelper::getComponentContext(_rxFactory) ));
 }
 
-//------------------------------------------------------------------
 OImageButtonModel::OImageButtonModel(const Reference<XComponentContext>& _rxFactory)
                     :OClickableImageBaseModel( _rxFactory, VCL_CONTROLMODEL_IMAGEBUTTON, FRM_SUN_CONTROL_IMAGEBUTTON )
                                     // use the old control name for compytibility reasons
@@ -59,23 +53,19 @@ OImageButtonModel::OImageButtonModel(const Reference<XComponentContext>& _rxFact
     m_nClassId = FormComponentType::IMAGEBUTTON;
 }
 
-//------------------------------------------------------------------
 OImageButtonModel::OImageButtonModel( const OImageButtonModel* _pOriginal, const Reference<XComponentContext>& _rxFactory)
     :OClickableImageBaseModel( _pOriginal, _rxFactory )
 {
     implInitializeImageURL();
 }
 
-//------------------------------------------------------------------------------
 IMPLEMENT_DEFAULT_CLONING( OImageButtonModel )
 
-//------------------------------------------------------------------------------
 OImageButtonModel::~OImageButtonModel()
 {
 }
 
 // XServiceInfo
-//------------------------------------------------------------------------------
 StringSequence  OImageButtonModel::getSupportedServiceNames() throw()
 {
     StringSequence aSupported = OClickableImageBaseModel::getSupportedServiceNames();
@@ -86,7 +76,6 @@ StringSequence  OImageButtonModel::getSupportedServiceNames() throw()
     return aSupported;
 }
 
-//------------------------------------------------------------------------------
 void OImageButtonModel::describeFixedProperties( Sequence< Property >& _rProps ) const
 {
     BEGIN_DESCRIBE_PROPERTIES( 5, OClickableImageBaseModel )
@@ -98,13 +87,11 @@ void OImageButtonModel::describeFixedProperties( Sequence< Property >& _rProps )
     END_DESCRIBE_PROPERTIES();
 }
 
-//------------------------------------------------------------------------------
 OUString OImageButtonModel::getServiceName() throw ( ::com::sun::star::uno::RuntimeException)
 {
     return OUString(FRM_COMPONENT_IMAGEBUTTON);   // old (non-sun) name for compatibility !
 }
 
-//------------------------------------------------------------------------------
 void OImageButtonModel::write(const Reference<XObjectOutputStream>& _rxOutStream) throw ( ::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException)
 {
     OControlModel::write(_rxOutStream);
@@ -119,7 +106,6 @@ void OImageButtonModel::write(const Reference<XObjectOutputStream>& _rxOutStream
     writeHelpTextCompatibly(_rxOutStream);
 }
 
-//------------------------------------------------------------------------------
 void OImageButtonModel::read(const Reference<XObjectInputStream>& _rxInStream) throw ( ::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException)
 {
     OControlModel::read(_rxInStream);
@@ -159,16 +145,12 @@ void OImageButtonModel::read(const Reference<XObjectInputStream>& _rxInStream) t
     }
 }
 
-//==================================================================
 // OImageButtonControl
-//==================================================================
-//------------------------------------------------------------------
 InterfaceRef SAL_CALL OImageButtonControl_CreateInstance(const Reference<XMultiServiceFactory>& _rxFactory)
 {
     return *(new OImageButtonControl( comphelper::getComponentContext(_rxFactory) ));
 }
 
-//------------------------------------------------------------------------------
 Sequence<Type> OImageButtonControl::_getTypes()
 {
     static Sequence<Type> aTypes;
@@ -177,7 +159,6 @@ Sequence<Type> OImageButtonControl::_getTypes()
     return aTypes;
 }
 
-//------------------------------------------------------------------------------
 StringSequence  OImageButtonControl::getSupportedServiceNames() throw()
 {
     StringSequence aSupported = OClickableImageBaseControl::getSupportedServiceNames();
@@ -188,7 +169,6 @@ StringSequence  OImageButtonControl::getSupportedServiceNames() throw()
     return aSupported;
 }
 
-//------------------------------------------------------------------------------
 OImageButtonControl::OImageButtonControl(const Reference<XComponentContext>& _rxFactory)
             :OClickableImageBaseControl(_rxFactory, VCL_CONTROL_IMAGEBUTTON)
 {
@@ -204,7 +184,6 @@ OImageButtonControl::OImageButtonControl(const Reference<XComponentContext>& _rx
 }
 
 // UNO Anbindung
-//------------------------------------------------------------------------------
 Any SAL_CALL OImageButtonControl::queryAggregation(const Type& _rType) throw (RuntimeException)
 {
     Any aReturn = OClickableImageBaseControl::queryAggregation(_rType);
@@ -214,7 +193,6 @@ Any SAL_CALL OImageButtonControl::queryAggregation(const Type& _rType) throw (Ru
     return aReturn;
 }
 
-//------------------------------------------------------------------------------
 void OImageButtonControl::mousePressed(const awt::MouseEvent& e) throw ( ::com::sun::star::uno::RuntimeException)
 {
     SolarMutexGuard aSolarGuard;
@@ -238,24 +216,18 @@ void OImageButtonControl::mousePressed(const awt::MouseEvent& e) throw ( ::com::
     }
 }
 
-//------------------------------------------------------------------------------
 void SAL_CALL OImageButtonControl::mouseReleased(const awt::MouseEvent& /*e*/) throw ( RuntimeException)
 {
 }
 
-//------------------------------------------------------------------------------
 void SAL_CALL OImageButtonControl::mouseEntered(const awt::MouseEvent& /*e*/) throw ( RuntimeException)
 {
 }
 
-//------------------------------------------------------------------------------
 void SAL_CALL OImageButtonControl::mouseExited(const awt::MouseEvent& /*e*/) throw ( RuntimeException)
 {
 }
 
-
-//.........................................................................
 }   // namespace frm
-//.........................................................................
 
 /* vim:set shiftwidth=4 softtabstop=4 expandtab: */
diff --git a/i18npool/source/search/levdis.cxx b/i18npool/source/search/levdis.cxx
index 90399d3..12ba7a1 100644
--- a/i18npool/source/search/levdis.cxx
+++ b/i18npool/source/search/levdis.cxx
@@ -17,7 +17,7 @@
  *   the License at http://www.apache.org/licenses/LICENSE-2.0 .
  */
 
-/*************************************************************************
+/*
 
     Weighted Levenshtein Distance
     including wildcards
@@ -53,9 +53,7 @@
 
     See also: German computer magazine
     c't 07/89 pages 192-208 and c't 03/94 pages 230-239
-
-*************************************************************************/
-
+*/
 
 #include <string.h>
 
@@ -69,7 +67,7 @@
 #undef min
 #endif
 
-#define LEVDISBIG   (nLimit + 1)    // Returnwert wenn Distanz > nLimit
+#define LEVDISBIG   (nLimit + 1)    // Return value if distance > nLimit
 #define LEVDISDOUBLEBUF 2048        // dadrueber wird nicht mehr gedoppelt
 
 // Balance, aus Geschwindigkeitsgruenden ist dieses keine Funktion
@@ -109,11 +107,11 @@ static sal_Int32 Impl_WLD_StringLen( const sal_Unicode* pStr )
     return (sal_Int32)(pTempStr-pStr);
 }
 
-// Distanz von String zu Pattern
+// Distance from string to pattern
 int WLevDistance::WLD( const sal_Unicode* cString, sal_Int32 nStringLen )
 {
-    int nSPMin = 0;     // StrafPunkteMinimum
-    int nRepS = 0;      // fuer SplitCount
+    int nSPMin = 0;     // penalty point Minimum
+    int nRepS = 0;      // for SplitCount
 
     // Laengendifferenz von Pattern und String
     int nLenDiff = nPatternLen - nStars - nStringLen;
@@ -163,7 +161,7 @@ int WLevDistance::WLD( const sal_Unicode* cString, sal_Int32 nStringLen )
         npDistance[0] = nInsQ0;     // mit einfachem Einfuegen geht's los
         npDistance[1] = nInsQ0;
         npDistance[2] = nInsQ0;
-        int nReplacePos = -1;       // tristate Flag
+        int nReplacePos = -1;       // tristate flag
         int nDelCnt = 0;
         for ( sal_Int32 i=1; i <= nStringLen; i++, nDelCnt += nDelR0 )
         {
@@ -232,7 +230,7 @@ int WLevDistance::WLD( const sal_Unicode* cString, sal_Int32 nStringLen )
                 nPij = 0;           // p(i,j)
                 if ( nReplacePos < 0 )
                 {
-                    int nBalance = 0;   // gleiche Anzahl c
+                    int nBalance = 0;   // same quantity c
                     LEVDISBALANCE( j, i-1 );
                     if ( !nBalance )
                         nReplacePos = 0;    // keine Ersetzung mehr
@@ -249,7 +247,7 @@ int WLevDistance::WLD( const sal_Unicode* cString, sal_Int32 nStringLen )
             if ( bSplitCount )
             {
                 if ( nReplacePos < 0 && nPij && npDistance[i] == d1 + nPij )
-                {   // diese Stelle wird ersetzt
+                {   // this poition will be replaced
                     nRepS++;
                     nReplacePos = i;
                 }
@@ -261,7 +259,7 @@ int WLevDistance::WLD( const sal_Unicode* cString, sal_Int32 nStringLen )
                     // Replace keins. Buchstabendreher werden hier erfasst
                     // und der ReplaceS zurueckgenommen, wodurch das doppelte
                     // Limit zum Tragen kommt.
-                    int nBalance = 0;   // gleiche Anzahl c
+                    int nBalance = 0;   // same quantity c
                     LEVDISBALANCE( j, i-1 );
                     if ( !nBalance )
                     {   // einer wurde ersetzt, der ein Insert war
@@ -279,7 +277,7 @@ int WLevDistance::WLD( const sal_Unicode* cString, sal_Int32 nStringLen )
         if ( bSplitCount )
         {
             if ( nRepS && nLenDiff > 0 )
-                nRepS -= nLenDiff;      // Inserts wurden mitgezaehlt
+                nRepS -= nLenDiff;      // Inserts were counted
             if ( (nSPMin <= 2 * nLimit)
                     && (npDistance[nStringLen] <= 2 * nLimit)
                     && (nRepS * nRepP0 <= nLimit) )
@@ -290,25 +288,23 @@ int WLevDistance::WLD( const sal_Unicode* cString, sal_Int32 nStringLen )
     }
 }
 
-
-
-// Berechnung von nLimit,   nReplP0,    nInsQ0,     nDelR0,     bSplitCount
-// aus Userwerten           nOtherX,    nShorterY,  nLongerZ,   bRelaxed
+// Calculating nLimit,   nReplP0,    nInsQ0,     nDelR0,     bSplitCount
+// from user values           nOtherX,    nShorterY,  nLongerZ,   bRelaxed
 int WLevDistance::CalcLPQR( int nX, int nY, int nZ, bool bRelaxed )
 {
-    if ( nX < 0 ) nX = 0;       // nur positive Werte
+    if ( nX < 0 ) nX = 0;       // only positive values
     if ( nY < 0 ) nY = 0;
     if ( nZ < 0 ) nZ = 0;
-    if (0 == Min3( nX, nY, nZ ))     // mindestens einer 0
+    if (0 == Min3( nX, nY, nZ ))     // at least one 0
     {
         int nMid, nMax;
-        nMax = Max3( nX, nY, nZ );      // entweder 0 bei drei 0 oder Max
-        if ( 0 == (nMid = Mid3( nX, nY, nZ )) )     // sogar zwei 0
-            nLimit = nMax;  // entweder 0 oder einziger >0
-        else        // einer 0
+        nMax = Max3( nX, nY, nZ );      // either 0 for three 0s or Max
+        if ( 0 == (nMid = Mid3( nX, nY, nZ )) )     // even two 0
+            nLimit = nMax;  // either 0 or the only one >0
+        else        // one is 0
             nLimit = KGV( nMid, nMax );
     }
-    else        // alle drei nicht 0
+    else        // all three of them are not 0
         nLimit = KGV( KGV( nX, nY ), nZ );
     nRepP0 = ( nX ? nLimit / nX : nLimit + 1 );
     nInsQ0 = ( nY ? nLimit / nY : nLimit + 1 );
@@ -317,8 +313,6 @@ int WLevDistance::CalcLPQR( int nX, int nY, int nZ, bool bRelaxed )
     return( nLimit );
 }
 
-
-
 // Groesster Gemeinsamer Teiler nach Euklid (Kettendivision)
 // Sonderfall: 0 und irgendwas geben 1
 int WLevDistance::GGT( int a, int b )
@@ -337,8 +331,6 @@ int WLevDistance::GGT( int a, int b )
     return( a ? a : b);
 }
 
-
-
 // Kleinstes Gemeinsames Vielfaches: a * b / GGT(a,b)
 int WLevDistance::KGV( int a, int b )
 {
@@ -348,8 +340,7 @@ int WLevDistance::KGV( int a, int b )
         return( (b / GGT(a,b)) * a );
 }
 
-
-// Minimum von drei Werten
+// Minimum of three values
 inline int WLevDistance::Min3( int x, int y, int z )
 {
     if ( x < y )
@@ -358,9 +349,7 @@ inline int WLevDistance::Min3( int x, int y, int z )
         return( y < z ? y : z );
 }
 
-
-
-// mittlerer von drei Werten
+// The value in the middle
 int WLevDistance::Mid3( int x, int y, int z )
 {
     int min = Min3(x,y,z);
@@ -372,9 +361,7 @@ int WLevDistance::Mid3( int x, int y, int z )
         return( x < y ? x : y);
 }
 
-
-
-// Maximum von drei Werten
+// Maximum of three values
 int WLevDistance::Max3( int x, int y, int z )
 {
     if ( x > y )
@@ -383,8 +370,6 @@ int WLevDistance::Max3( int x, int y, int z )
         return( y > z ? y : z );
 }
 
-
-
 // Daten aus CTor initialisieren
 void WLevDistance::InitData( const sal_Unicode* cPattern )
 {
@@ -395,12 +380,12 @@ void WLevDistance::InitData( const sal_Unicode* cPattern )
     const sal_Unicode* cp1 = cPattern;
     sal_Unicode* cp2 = cpPattern;
     bool* bp = bpPatIsWild;
-    // Pattern kopieren, Sternchen zaehlen, escaped Jokers
+    // copy pattern, count asterisks, escaped Jokers
     while ( *cp1 )
     {
         if ( *cp1 == '\\' )     // maybe escaped
         {
-            if ( *(cp1+1) == '*' || *(cp1+1) == '?' )   // naechstes Joker?
+            if ( *(cp1+1) == '*' || *(cp1+1) == '?' )   // next Joker?
             {
                 cp1++;          // skip '\\'
                 nPatternLen--;
@@ -420,7 +405,6 @@ void WLevDistance::InitData( const sal_Unicode* cPattern )
     *cp2 = '\0';
 }
 
-
 WLevDistance::WLevDistance( const sal_Unicode* cPattern,
                             int nOtherX, int nShorterY, int nLongerZ,
                             bool bRelaxed ) :
@@ -433,7 +417,6 @@ WLevDistance::WLevDistance( const sal_Unicode* cPattern,
     CalcLPQR( nOtherX, nShorterY, nLongerZ, bRelaxed );
 }
 
-
 // CopyCTor
 WLevDistance::WLevDistance( const WLevDistance& rWLD ) :
     nPatternLen( rWLD.nPatternLen ),
@@ -459,7 +442,6 @@ WLevDistance::WLevDistance( const WLevDistance& rWLD ) :
     cpPattern[i] = '\0';
 }
 
-
 // DTor
 WLevDistance::~WLevDistance()
 {
diff --git a/sc/source/filter/lotus/lotform.cxx b/sc/source/filter/lotus/lotform.cxx
index 4892489..dc0dcba 100644
--- a/sc/source/filter/lotus/lotform.cxx
+++ b/sc/source/filter/lotus/lotform.cxx
@@ -84,7 +84,7 @@ void LotusToSc::DoFunc( DefTokenId eOc, sal_uInt8 nAnz, const sal_Char* pExtStri
     for( nLauf = 0 ; nLauf < nAnz ; nLauf++ )
         aStack >> eParam[ nLauf ];
 
-    // Spezialfaelle...
+    // special cases...
     switch( eOc )
     {
         case ocIndex:
@@ -118,7 +118,7 @@ void LotusToSc::DoFunc( DefTokenId eOc, sal_uInt8 nAnz, const sal_Char* pExtStri
         case ocFind:
         case ocHLookup:
         case ocVLookup:
-        {// letzten Parameter ++
+        {// last parameter ++
             IncToken( eParam[ 0 ] );
         }
             break;
@@ -131,20 +131,18 @@ void LotusToSc::DoFunc( DefTokenId eOc, sal_uInt8 nAnz, const sal_Char* pExtStri
             break;
         case ocZins:
         {
-            // neue Anzahl = 4!
+            // new quantity = 4!
             OSL_ENSURE( nAnz == 3,
                 "*LotusToSc::DoFunc(): ZINS() hat 3 Parameter!" );
             nAnz = 4;
             eParam[ 3 ] = eParam[ 0 ];  // 3. -> 1.
             eParam[ 0 ] = eParam[ 2 ];  // 1. -> 4.
             NegToken( eParam[ 1 ] );    // 2. -> -2. (+ 2. -> 3.)
-            eParam[ 2 ] = n0Token;      //    -> 2. als Default
+            eParam[ 2 ] = n0Token;      //    -> 2. as Default
         }
             break;
         default:;
     }
-    // ................
-
 
     if( !bAddIn )
         aPool << eOc;
@@ -153,7 +151,7 @@ void LotusToSc::DoFunc( DefTokenId eOc, sal_uInt8 nAnz, const sal_Char* pExtStri
 
     if( nAnz > 0 )
     {
-            // ACHTUNG: 0 ist der letzte Parameter, nAnz-1 der erste
+            // ATTENTION: 0 is the last parameter, nAnz-1 the first one
 
         sal_Int16 nLast = nAnz - 1;
 
@@ -198,8 +196,6 @@ void LotusToSc::DoFunc( DefTokenId eOc, sal_uInt8 nAnz, const sal_Char* pExtStri
 
     aPool << ocClose;
 
-    // ................
-
     aPool >> aStack;
 
     if( bNeg )
@@ -522,7 +518,7 @@ ConvErr LotusToSc::Convert( const ScTokenArray*& rpErg, sal_Int32& rRest,
                 break;
             case FT_NOP:
                 break;
-            // ------------------------------------------ fuer > WK3 -
+            // for > WK3
             case FT_Cref:
                 Read( nRelBits );
                 ReadSRD( rR, nRelBits );
@@ -688,7 +684,7 @@ FUNC_TYPE LotusToSc::IndexToType( sal_uInt8 nIndex )
         FT_FuncFix1,        //   39 Sinus
         FT_FuncFix1,        //   40 Cosinus
         FT_FuncFix1,        //   41 Tangens
-        FT_FuncFix2,        //   42 Arcus-Tangens 2 (4.Quadrant)   <----- richtig? -
+        FT_FuncFix2,        //   42 Arcus-Tangens 2 (4.Quadrant) <- correct?
         FT_FuncFix1,        //   43 Arcus-Tangens (2.Quadrant)
         FT_FuncFix1,        //   44 Arcus-Sinus
         FT_FuncFix1,        //   45 Arcus-Cosinus
@@ -744,7 +740,7 @@ FUNC_TYPE LotusToSc::IndexToType( sal_uInt8 nIndex )
         FT_FuncFix3,        //   95 ?
         FT_FuncFix3,        //   96 ?
         FT_FuncFix3,        //   97 ?
-        FT_FuncFix3,        //   98 Index()                         <- richtig? -
+        FT_FuncFix3,        //   98 Index() <- correct?
         FT_FuncFix1,        //   99 Cols()
         FT_FuncFix1,        //  100 Rows()
         FT_FuncFix2,        //  101 Repeat()
@@ -758,7 +754,7 @@ FUNC_TYPE LotusToSc::IndexToType( sal_uInt8 nIndex )
         FT_FuncFix1,        //  109 Trim()
         FT_FuncFix1,        //  110 Clean()
         FT_FuncFix1,        //  111 F()
-        FT_FuncFix1,        //  112 Wert() (oder W()?)
+        FT_FuncFix1,        //  112 Wert() (or W()?)
         FT_FuncFix2,        //  113 Exact()
         FT_NotImpl,         //  114 Call()
         FT_FuncFix1,        //  115 @@()
@@ -1203,16 +1199,16 @@ FUNC_TYPE LotusToSc::IndexToTypeWK123( sal_uInt8 nIndex )
         FT_Op,              //   23 Groesser-gleich
         FT_Op,              //   24 Kleiner
         FT_Op,              //   25 Groesser
-        FT_Op,              //   26 And (logisch)
-        FT_Op,              //   27 Or (logisch)
-        FT_FuncFix1,        //   28 Not (logisch)
-        FT_NOP,             //   29 unaeres Plus
+        FT_Op,              //   26 And (logical)
+        FT_Op,              //   27 Or (logical)
+        FT_FuncFix1,        //   28 Not (logical)
+        FT_NOP,             //   29 unary plus
         FT_Op,              //   30 Concatenation
         FT_FuncFix0,        //   31 Not applicable
         FT_FuncFix0,        //   32 Error
-        FT_FuncFix1,        //   33 Betrag ABS()
-        FT_FuncFix1,        //   34 Ganzzahl INT()
-        FT_FuncFix1,        //   35 Quadratwurzel
+        FT_FuncFix1,        //   33 Absolute value ABS()
+        FT_FuncFix1,        //   34 Integer INT()
+        FT_FuncFix1,        //   35 Square root
         FT_FuncFix1,        //   36 Zehnerlogarithmus
         FT_FuncFix1,        //   37 Natuerlicher Logarithmus
         FT_FuncFix0,        //   38 PI
@@ -1225,7 +1221,7 @@ FUNC_TYPE LotusToSc::IndexToTypeWK123( sal_uInt8 nIndex )
         FT_FuncFix1,        //   45 Arcus-Cosinus
         FT_FuncFix1,        //   46 Exponentialfunktion
         FT_FuncFix2,        //   47 Modulo
-        FT_FuncVar,         //   48 Auswahl
+        FT_FuncVar,         //   48 Selection
         FT_FuncFix1,        //   49 Is not applicable?
         FT_FuncFix1,        //   50 Is Error?
         FT_FuncFix0,        //   51 FALSE
@@ -1268,81 +1264,81 @@ FUNC_TYPE LotusToSc::IndexToTypeWK123( sal_uInt8 nIndex )
         FT_FuncVar,         //   88 Std()
         FT_FuncFix2,        //   89 Irr()
         FT_FuncFix3,        //   90 Hlookup()
-        FT_FuncVar,         //   91 Dsum                 <-------- neu! -
-        FT_FuncVar,         //   92 Davg                 <-------- neu! -
-        FT_FuncVar,         //   93 Dcnt                 <-------- neu! -
-        FT_FuncVar,         //   94 Dmin                 <-------- neu! -
-        FT_FuncVar,         //   95 Dmax                 <-------- neu! -
-        FT_FuncVar,         //   96 Dvar                 <-------- neu! -
-        FT_FuncVar,         //   97 Dstd                 <-------- neu! -
-        FT_FuncVar,         //   98 Index()              <-------- change! -
-        FT_FuncFix1,        //   99 Cols()               <-------- neu! -
-        FT_FuncFix1,        //  100 Rows()               <-------- neu! -
-        FT_FuncFix2,        //  101 Repeat()             <-------- neu! -
-        FT_FuncFix1,        //  102 Upper()              <-------- neu! -
-        FT_FuncFix1,        //  103 Lower()              <-------- neu! -
-        FT_FuncFix2,        //  104 Left()               <-------- neu! -
-        FT_FuncFix2,        //  105 Right()              <-------- neu! -
-        FT_FuncFix4,        //  106 Replace()            <-------- neu! -
-        FT_FuncFix1,        //  107 Proper()             <-------- neu! -
-        FT_FuncFix2,        //  108 Cell()               <-------- neu! -
-        FT_FuncFix1,        //  109 Trim()               <-------- neu! -
-        FT_FuncFix1,        //  110 Clean()              <-------- neu! -
-        FT_FuncFix1,        //  111 S()                  <--------- change in Bez. -
-        FT_FuncFix1,        //  112 N()                  <--------- change in Bez. -
-        FT_FuncFix2,        //  113 Exact()              <-------- neu! -
-        FT_NotImpl,         //  114 App                  <--------- change in Bez. -
-        FT_FuncFix1,        //  115 @@()                 <-------- neu! -
-        FT_FuncFix3,        //  116 Rate()               <-------- neu! -
-        FT_FuncFix3,        //  117 Term()               <--------- change in Anz.
-        FT_FuncFix3,        //  118 Cterm()              <--------- change in Anz.
-        FT_FuncFix3,        //  119 Sln()                <-------- neu! -
-        FT_FuncFix4,        //  120 Syd()                <-------- neu! -
-        FT_FuncFix4,        //  121 Ddb()                <-------- neu! -
-        FT_Splfunc,         //  122 Splfunc              <-------- neu! -
-        FT_FuncFix1,        //  123 Sheets               <-------- neu! -
-        FT_FuncFix1,        //  124 Info                 <-------- neu! -
-        FT_FuncVar,         //  125 Sumproduct           <-------- neu! -
-        FT_FuncFix1,        //  126 Isrange              <-------- neu! -
-        FT_FuncVar,         //  127 Dget                 <-------- neu! -
-        FT_FuncVar,         //  128 Dquery               <-------- neu! -
-        FT_FuncFix4,        //  129 Coord                <-------- neu! -
-        FT_NOP,             //  130 Reserved (internal)  <-------- neu! -
-        FT_FuncFix0,        //  131 Today                <-------- neu! -
-        FT_FuncVar,         //  132 Vdb                  <-------- neu! -
-        FT_FuncVar,         //  133 Dvars                <-------- neu! -
-        FT_FuncVar,         //  134 Dstds                <-------- neu! -
-        FT_FuncVar,         //  135 Vars                 <-------- neu! -
-        FT_FuncVar,         //  136 Stds                 <-------- neu! -
-        FT_FuncFix2,        //  137 D360                 <-------- neu! -
-        FT_NOP,             //  138 Reserved (internal)  <-------- neu! -
-        FT_FuncFix0,        //  139 Isapp                <-------- neu! - Anzahl ? -
-        FT_FuncVar,         //  140 Isaaf                <-------- neu! - Anzahl ? -
-        FT_FuncFix1,        //  141 Weekday              <-------- neu! -
-        FT_FuncFix3,        //  142 Datedif              <-------- neu! -
-        FT_FuncVar,         //  143 Rank                 <-------- neu! -
-        FT_FuncFix2,        //  144 Numberstring         <-------- neu! -
-        FT_FuncFix1,        //  145 Datestring           <-------- neu! -
-        FT_FuncFix1,        //  146 Decimal              <-------- neu! -
-        FT_FuncFix1,        //  147 Hex                  <-------- neu! -
-        FT_FuncFix4,        //  148 Db                   <-------- neu! -
-        FT_FuncFix4,        //  149 Pmti                 <-------- neu! -
-        FT_FuncFix4,        //  150 Spi                  <-------- neu! -
-        FT_FuncFix1,        //  151 Fullp                <-------- neu! -
-        FT_FuncFix1,        //  152 Halfp                <-------- neu! -
-        FT_FuncVar,         //  153 Pureavg              <-------- neu! -
-        FT_FuncVar,         //  154 Purecount            <-------- neu! -
-        FT_FuncVar,         //  155 Puremax              <-------- neu! -
-        FT_FuncVar,         //  156 Puremin              <-------- neu! -
-        FT_FuncVar,         //  157 Purestd              <-------- neu! -
-        FT_FuncVar,         //  158 Purevar              <-------- neu! -
-        FT_FuncVar,         //  159 Purestds             <-------- neu! -
-        FT_FuncVar,         //  160 Purevars             <-------- neu! -
-        FT_FuncFix3,        //  161 Pmt2                 <-------- neu! -
-        FT_FuncFix3,        //  162 Pv2                  <-------- neu! -
-        FT_FuncFix3,        //  163 Fv2                  <-------- neu! -
-        FT_FuncFix3,        //  164 Term2                <-------- neu! -
-        FT_NotImpl,         //  165 ---                  <-------- neu! - Anzahl ? -
+        FT_FuncVar,         //   91 Dsum                 <- new
+        FT_FuncVar,         //   92 Davg                 <- new
+        FT_FuncVar,         //   93 Dcnt                 <- new
+        FT_FuncVar,         //   94 Dmin                 <- new
+        FT_FuncVar,         //   95 Dmax                 <- new
+        FT_FuncVar,         //   96 Dvar                 <- new
+        FT_FuncVar,         //   97 Dstd                 <- new
+        FT_FuncVar,         //   98 Index()              <- change!
+        FT_FuncFix1,        //   99 Cols()               <- new
+        FT_FuncFix1,        //  100 Rows()               <- new
+        FT_FuncFix2,        //  101 Repeat()             <- new
+        FT_FuncFix1,        //  102 Upper()              <- new
+        FT_FuncFix1,        //  103 Lower()              <- new
+        FT_FuncFix2,        //  104 Left()               <- new
+        FT_FuncFix2,        //  105 Right()              <- new
+        FT_FuncFix4,        //  106 Replace()            <- new
+        FT_FuncFix1,        //  107 Proper()             <- new
+        FT_FuncFix2,        //  108 Cell()               <- new
+        FT_FuncFix1,        //  109 Trim()               <- new
+        FT_FuncFix1,        //  110 Clean()              <- new
+        FT_FuncFix1,        //  111 S()                  <- change in Bez.
+        FT_FuncFix1,        //  112 N()                  <- change in Bez.
+        FT_FuncFix2,        //  113 Exact()              <- new
+        FT_NotImpl,         //  114 App                  <- change in Bez.
+        FT_FuncFix1,        //  115 @@()                 <- new
+        FT_FuncFix3,        //  116 Rate()               <- new
+        FT_FuncFix3,        //  117 Term()               <- change in Anz.
+        FT_FuncFix3,        //  118 Cterm()              <- change in Anz.
+        FT_FuncFix3,        //  119 Sln()                <- new
+        FT_FuncFix4,        //  120 Syd()                <- new
+        FT_FuncFix4,        //  121 Ddb()                <- new
+        FT_Splfunc,         //  122 Splfunc              <- new
+        FT_FuncFix1,        //  123 Sheets               <- new
+        FT_FuncFix1,        //  124 Info                 <- new
+        FT_FuncVar,         //  125 Sumproduct           <- new
+        FT_FuncFix1,        //  126 Isrange              <- new
+        FT_FuncVar,         //  127 Dget                 <- new
+        FT_FuncVar,         //  128 Dquery               <- new
+        FT_FuncFix4,        //  129 Coord                <- new
+        FT_NOP,             //  130 Reserved (internal)  <- new
+        FT_FuncFix0,        //  131 Today                <- new
+        FT_FuncVar,         //  132 Vdb                  <- new
+        FT_FuncVar,         //  133 Dvars                <- new
+        FT_FuncVar,         //  134 Dstds                <- new
+        FT_FuncVar,         //  135 Vars                 <- new
+        FT_FuncVar,         //  136 Stds                 <- new
+        FT_FuncFix2,        //  137 D360                 <- new
+        FT_NOP,             //  138 Reserved (internal)  <- new
+        FT_FuncFix0,        //  139 Isapp                <- new quantity ?
+        FT_FuncVar,         //  140 Isaaf                <- new quantity ?
+        FT_FuncFix1,        //  141 Weekday              <- new
+        FT_FuncFix3,        //  142 Datedif              <- new
+        FT_FuncVar,         //  143 Rank                 <- new
+        FT_FuncFix2,        //  144 Numberstring         <- new
+        FT_FuncFix1,        //  145 Datestring           <- new
+        FT_FuncFix1,        //  146 Decimal              <- new
+        FT_FuncFix1,        //  147 Hex                  <- new
+        FT_FuncFix4,        //  148 Db                   <- new
+        FT_FuncFix4,        //  149 Pmti                 <- new
+        FT_FuncFix4,        //  150 Spi                  <- new
+        FT_FuncFix1,        //  151 Fullp                <- new
+        FT_FuncFix1,        //  152 Halfp                <- new
+        FT_FuncVar,         //  153 Pureavg              <- new
+        FT_FuncVar,         //  154 Purecount            <- new
+        FT_FuncVar,         //  155 Puremax              <- new
+        FT_FuncVar,         //  156 Puremin              <- new
+        FT_FuncVar,         //  157 Purestd              <- new
+        FT_FuncVar,         //  158 Purevar              <- new
+        FT_FuncVar,         //  159 Purestds             <- new
+        FT_FuncVar,         //  160 Purevars             <- new
+        FT_FuncFix3,        //  161 Pmt2                 <- new
+        FT_FuncFix3,        //  162 Pv2                  <- new
+        FT_FuncFix3,        //  163 Fv2                  <- new
+        FT_FuncFix3,        //  164 Term2                <- new
+        FT_NotImpl,         //  165--                    <- new quantity ?
         FT_FuncFix2,        //  166 D360 (US-Version)
         FT_NotImpl,         //  167
         FT_NotImpl,         //  168
@@ -1363,7 +1359,7 @@ FUNC_TYPE LotusToSc::IndexToTypeWK123( sal_uInt8 nIndex )
         FT_NotImpl,         //  183
         FT_NotImpl,         //  184
         FT_NotImpl,         //  185
-        FT_FuncVar,         //  186 Solver               <-------- neu! -
+        FT_FuncVar,         //  186 Solver               <- new
         FT_NotImpl,         //  187
         FT_NotImpl,         //  188
         FT_NotImpl,         //  189
@@ -1441,7 +1437,7 @@ FUNC_TYPE LotusToSc::IndexToTypeWK123( sal_uInt8 nIndex )
 DefTokenId LotusToSc::IndexToTokenWK123( sal_uInt8 nIndex )
 {
     static const DefTokenId pToken[ 256 ] =
-    {                       // Code Bezeichnung
+    {                       // Code Description
         ocPush,             //    0 8-Byte-IEEE-Long-Numbers
         ocPush,             //    1 Variable
         ocPush,             //    2 Bereich
@@ -1462,8 +1458,8 @@ DefTokenId LotusToSc::IndexToTokenWK123( sal_uInt8 nIndex )
         ocMul,              //   17 Multiplikation
         ocDiv,              //   18 Division
         ocPow,              //   19 Potenzierung
-        ocEqual,            //   20 Gleichheit
-        ocNotEqual,         //   21 Ungleich
+        ocEqual,            //   20 Equality
+        ocNotEqual,         //   21 Inequality
         ocLessEqual,        //   22 Kleiner-gleich
         ocGreaterEqual,     //   23 Groesser-gleich
         ocLess,             //   24 Kleiner
@@ -1480,7 +1476,7 @@ DefTokenId LotusToSc::IndexToTokenWK123( sal_uInt8 nIndex )
         ocSqrt,             //   35 Quadratwurzel
         ocLog10,            //   36 Zehnerlogarithmus
         ocLn,               //   37 Natuerlicher Logarithmus
-        ocPi,               //   38 PI
+        ocPi,               //   38 Pi
         ocSin,              //   39 Sinus
         ocCos,              //   40 Cosinus
         ocTan,              //   41 Tangens
@@ -1490,7 +1486,7 @@ DefTokenId LotusToSc::IndexToTokenWK123( sal_uInt8 nIndex )
         ocArcCos,           //   45 Arcus-Cosinus
         ocExp,              //   46 Exponentialfunktion
         ocMod,              //   47 Modulo
-        ocChose,            //   48 Auswahl
+        ocChose,            //   48 Selection
         ocIsNA,             //   49 Is not available?
         ocIsError,          //   50 Is Error?
         ocFalse,            //   51 FALSE
@@ -1501,17 +1497,17 @@ DefTokenId LotusToSc::IndexToTokenWK123( sal_uInt8 nIndex )
         ocRMZ,              //   56 Payment
         ocBW,               //   57 Present Value
         ocZW,               //   58 Future Value
-        ocIf,               //   59 If ... then ... else ...
+        ocIf,               //   59 If... then... else...
         ocGetDay,           //   60 Tag des Monats
-        ocGetMonth,         //   61 Monat
-        ocGetYear,          //   62 Jahr
-        ocRound,            //   63 Runden
-        ocGetTime,          //   64 Zeit
-        ocGetHour,          //   65 Stunde
+        ocGetMonth,         //   61 Month
+        ocGetYear,          //   62 Year
+        ocRound,            //   63 Round
+        ocGetTime,          //   64 Time
+        ocGetHour,          //   65 Hour
         ocGetMin,           //   66 Minute
-        ocGetSec,           //   67 Sekunde
-        ocIsValue,          //   68 Ist Zahl?
-        ocIsString,         //   69 Ist Text?
+        ocGetSec,           //   67 Second
+        ocIsValue,          //   68 Is number?
+        ocIsString,         //   69 Is text?
         ocLen,              //   70 Len()
         ocValue,            //   71 Val()
         ocFixed,            //   72 String()    ocFixed ersatzweise + Spezialfall
@@ -1607,7 +1603,7 @@ DefTokenId LotusToSc::IndexToTokenWK123( sal_uInt8 nIndex )
         ocNoName,           //  162 Pv2
         ocNoName,           //  163 Fv2
         ocNoName,           //  164 Term2
-        ocNoName,           //  165 ---                  <-------- neu! - Anzahl ? -
+        ocNoName,           //  165--                  <- new quantity ?
         ocGetDiffDate360,   //  166 D360 (US-Version, ersatzweise wie ander D360-Funktion)
         ocNoName,           //  167
         ocNoName,           //  168
@@ -1714,7 +1710,7 @@ const sal_Char* GetAddInName( const sal_uInt8 n )
         NULL,                       //    1 Variable
         NULL,                       //    2 Bereich
         NULL,                       //    3 return
-        NULL,                       //    4 Klammer
+        NULL,                       //    4 Bracket
         NULL,                       //    5 2-Byte-Integer
         NULL,                       //    6 ASCII-String
         NULL,                       //    7 Named range reference
@@ -1864,7 +1860,7 @@ const sal_Char* GetAddInName( const sal_uInt8 n )
         NULL,                       //  151 Fullp
         NULL,                       //  152 Halfp
         "PURMITTELWERT",            //  153 Pureavg
-        "PURANZAHL",                //  154 Purecount
+        "PURquantity",                //  154 Purecount
         "PURMAX",                   //  155 Puremax
         "PURMIN",                   //  156 Puremin
         "PURSTDABW",                //  157 Purestd
@@ -1875,7 +1871,7 @@ const sal_Char* GetAddInName( const sal_uInt8 n )
         NULL,                       //  162 Pv2
         NULL,                       //  163 Fv2
         NULL,                       //  164 Term2
-        NULL,                       //  165 ---                  <-------- neu! - Anzahl ? -
+        NULL,                       //  165--                  <- new quantity ?
         NULL,                       //  166 D360 (US-Version, ersatzweise wie ander D360-Funktion)
         NULL,                       //  167
         NULL,                       //  168
diff --git a/sw/source/filter/ww8/ww8graf.cxx b/sw/source/filter/ww8/ww8graf.cxx
index fecf9f7..9709780 100644
--- a/sw/source/filter/ww8/ww8graf.cxx
+++ b/sw/source/filter/ww8/ww8graf.cxx
@@ -98,11 +98,10 @@ using namespace ::com::sun::star;
 using namespace sw::types;
 using namespace sw::util;
 
-// Hilfsroutinen
-
+// helper methods
 Color WW8TransCol(SVBT32 nWC)
 {
-#if 1               // 1 = Vordefinierte Farben benutzen, 0 = ignorieren
+#if 1               // 1 = use predefined color, 0 = ignore
 
     // Farbtabelle zum Umrechnen RGB-Werte in vordefinierte Farben
     // ( Damit bei der Writer-UI die Farbnamen stimmen )
@@ -130,7 +129,7 @@ Color WW8TransCol(SVBT32 nWC)
         (    ( nWC[0] == 0 ||  nWC[0]== 0x80 || nWC[0] == 0xff )    // R-Anteil
           && ( nWC[1] == 0 ||  nWC[1]== 0x80 || nWC[1] == 0xff )    // G-Anteil
           && ( nWC[2] == 0 ||  nWC[2]== 0x80 || nWC[2] == 0xff ) ) ){// B-Anteil
-        int nIdx = 0;       // und nun: Idx-Berechnung im 3er-System
+        int nIdx = 0;       // and now: Idx-calculation im 3er-System
         for (int i = 2; i >= 0; i--)
         {
             nIdx *= 3;
@@ -138,13 +137,13 @@ Color WW8TransCol(SVBT32 nWC)
                 nIdx += ((nWC[i] == 0xff) ? 2 : 1);
         }
         if (eColA[nIdx] != COL_BLACK)
-            return Color(eColA[nIdx]);  // Standard-Color
+            return Color(eColA[nIdx]);  // default color
     }
 #endif
 
     if (nWC[3] & 0x1)
     {
-        //Special colour gray
+        // Special color gray
         sal_uInt8 u = (sal_uInt8)( (sal_uLong)( 200 - nWC[0] ) * 256 / 200 );
         return Color(u, u, u);
     }
@@ -185,11 +184,11 @@ bool SwWW8ImplReader::ReadGrafStart(void* pData, short nDataSiz,
 
     if (eAnchor == FLY_AT_PARA)
     {
-        if( pDo->bx == 1 )       // Pos: echt links
+        if( pDo->bx == 1 )       // Position: actually left
             nDrawXOfs2 = static_cast< short >(nDrawXOfs2 - maSectionManager.GetPageLeft());
-        if( nInTable )                          // Obj in Table
-            nDrawXOfs2 = nDrawXOfs2 - GetTableLeft();       // -> siehe Kommentar
-                                                // bei GetTableLeft()
+        if( nInTable )                          // Object in table
+            nDrawXOfs2 = nDrawXOfs2 - GetTableLeft();       // -> see comment
+                                                // at GetTableLeft()
     }
     else
     {
@@ -201,19 +200,18 @@ bool SwWW8ImplReader::ReadGrafStart(void* pData, short nDataSiz,
 }
 
 // SetStdAttr() setzt die Attribute, die jedes Objekt hat
-
 static void SetStdAttr( SfxItemSet& rSet, WW8_DP_LINETYPE& rL,
                         WW8_DP_SHADOW& rSh )
 {
-    if( SVBT16ToShort( rL.lnps ) == 5 ){            // unsichtbar
+    if( SVBT16ToShort( rL.lnps ) == 5 ){            // invisible
         rSet.Put( XLineStyleItem( XLINE_NONE ) );
     }else{                                          // sichtbar
         Color aCol( WW8TransCol( rL.lnpc ) );           // LinienFarbe
         rSet.Put( XLineColorItem( OUString(), aCol ) );
         rSet.Put( XLineWidthItem( SVBT16ToShort( rL.lnpw ) ) );
-                                                    // LinienDicke
+                                                    // line thickness
         if( SVBT16ToShort( rL.lnps ) >= 1
-            && SVBT16ToShort(rL.lnps ) <= 4 ){      // LinienStil
+            && SVBT16ToShort(rL.lnps ) <= 4 ){      // line style
             rSet.Put( XLineStyleItem( XLINE_DASH ) );
             sal_Int16 nLen = SVBT16ToShort( rL.lnpw );
             XDash aD( XDASH_RECT, 1, 2 * nLen, 1, 5 * nLen, 5 * nLen );
@@ -228,10 +226,10 @@ static void SetStdAttr( SfxItemSet& rSet, WW8_DP_LINETYPE& rL,
             }
             rSet.Put( XLineDashItem( OUString(), aD ) );
         }else{
-            rSet.Put( XLineStyleItem( XLINE_SOLID ) );  // noetig fuer TextBox
+            rSet.Put( XLineStyleItem( XLINE_SOLID ) );  // needed for TextBox
         }
     }
-    if( SVBT16ToShort( rSh.shdwpi ) ){                  // Schatten
+    if( SVBT16ToShort( rSh.shdwpi ) ){                  // shadow
         rSet.Put(SdrShadowItem(true));
         rSet.Put( SdrShadowXDistItem( SVBT16ToShort( rSh.xaOffset ) ) );
         rSet.Put( SdrShadowYDistItem( SVBT16ToShort( rSh.yaOffset ) ) );
@@ -261,11 +259,11 @@ static void SetFill( SfxItemSet& rSet, WW8_DP_FILL& rFill )
         rSet.Put(XFillStyleItem(XFILL_SOLID));  // necessary for textbox
         if (nPat <= 1 || ((sizeof(nPatA)/sizeof(nPatA[0])) <= nPat))
         {
-            // Solid Background or unknown
+            // Solid background or unknown
             rSet.Put(XFillColorItem(OUString(), WW8TransCol(rFill.dlpcBg)));
         }
         else
-        {                                      // Brush -> Farbmischung
+        {                                      // Brush -> color mix
             Color aB( WW8TransCol( rFill.dlpcBg ) );
             Color aF( WW8TransCol( rFill.dlpcFg ) );
             aB.SetRed( (sal_uInt8)( ( (sal_uLong)aF.GetRed() * nPatA[nPat]
@@ -501,8 +499,8 @@ void SwWW8ImplReader::InsertTxbxStyAttrs( SfxItemSet& rS, sal_uInt16 nColl )
         const SfxPoolItem* pItem;
         for( sal_uInt16 i = POOLATTR_BEGIN; i < POOLATTR_END; i++ )
         {
-            //If we are set in the source and not set in the destination
-            //then add it in.
+            // If we are set in the source and not set in the destination
+            // then add it in.
             if ( SFX_ITEM_SET == pStyInf->pFmt->GetItemState(
                 i, true, &pItem ) )
             {
@@ -564,8 +562,8 @@ class Chunk
 {
 private:
     OUString msURL;
-    long mnStartPos; //0x13
-    long mnEndPos;   //0x15
+    long mnStartPos; // 0x13
+    long mnEndPos;   // 0x15
 public:
     explicit Chunk(long nStart, const OUString &rURL)
         : msURL(rURL), mnStartPos(nStart), mnEndPos(0)  {}
@@ -617,12 +615,12 @@ void SwWW8ImplReader::InsertAttrsAsDrawingAttrs(long nStartCp, long nEndCp,
 
     std::deque<Chunk> aChunks;
 
-    //Here store stack location
+    // Here store stack location
     size_t nCurrentCount = pCtrlStck->size();
     while (nStart < nEndCp)
     {
-        //nStart is the beginning of the attributes for this range, and
-        //may be before the text itself. So watch out for that
+        // nStart is the beginning of the attributes for this range, and
+        // may be before the text itself. So watch out for that
         WW8_CP nTxtStart = nStart;
         if (nTxtStart < nStartCp)
             nTxtStart = nStartCp;
@@ -645,8 +643,8 @@ void SwWW8ImplReader::InsertAttrsAsDrawingAttrs(long nStartCp, long nEndCp,
             else if ( aRes.nSprmId && (
                 (eFTN >  aRes.nSprmId) || (0x0800 <= aRes.nSprmId) ) )
             {
-                //Here place them onto our usual stack and we will pop them
-                //off and convert them later
+                // Here place them onto our usual stack and we will pop them
+                // off and convert them later
                 if (bStartAttr)
                 {
                     ImportSprm(aRes.pMemPos, aRes.nSprmId);
@@ -711,9 +709,9 @@ void SwWW8ImplReader::InsertAttrsAsDrawingAttrs(long nStartCp, long nEndCp,
             nEnd = ( nNext < nEndCp ) ? nNext : nEndCp;
             SfxItemPool *pEditPool = pS->GetPool();
 
-            //Here read current properties and convert them into pS
-            //and put those attrs into the draw box if they can be converted
-            //to draw attributes
+            // Here read current properties and convert them into pS
+            // and put those attrs into the draw box if they can be converted
+            // to draw attributes
             if (pCtrlStck->size() - nCurrentCount)
             {
                 for (size_t i = nCurrentCount; i < pCtrlStck->size(); ++i)
@@ -738,7 +736,7 @@ void SwWW8ImplReader::InsertAttrsAsDrawingAttrs(long nStartCp, long nEndCp,
                     }
                 }
             }
-            //Fill in the remainder from the style
+            // Fill in the remainder from the style
             InsertTxbxStyAttrs(*pS, nAktColl);
 
             if( pS->Count() )
@@ -753,8 +751,8 @@ void SwWW8ImplReader::InsertAttrsAsDrawingAttrs(long nStartCp, long nEndCp,
     }
     delete pS;
 
-    //pop off as far as recorded location just in case there were some left
-    //unclosed
+    // pop off as far as recorded location just in case there were some left
+    // unclosed
     for (size_t nI = pCtrlStck->size(); nI > nCurrentCount; --nI)
         pCtrlStck->DeleteAndDestroy(nI-1);
 
@@ -796,7 +794,7 @@ void SwWW8ImplReader::InsertAttrsAsDrawingAttrs(long nStartCp, long nEndCp,
 bool SwWW8ImplReader::GetTxbxTextSttEndCp(WW8_CP& rStartCp, WW8_CP& rEndCp,
     sal_uInt16 nTxBxS, sal_uInt16 nSequence)
 {
-    // rasch den TextBox-PLCF greifen
+    // grab the TextBox-PLCF quickly
     WW8PLCFspecial* pT = pPlcxMan ? pPlcxMan->GetTxbx() : 0;
     if( !pT )
     {
@@ -809,7 +807,7 @@ bool SwWW8ImplReader::GetTxbxTextSttEndCp(WW8_CP& rStartCp, WW8_CP& rEndCp,
     if(  bCheckTextBoxStory )
         pT->SetIdx( nTxBxS-1 );
 
-    // dann Start und Ende ermitteln
+    // then determine start and end
     void* pT0;
     if( !pT->Get( rStartCp, pT0 ) )
     {
@@ -849,7 +847,7 @@ bool SwWW8ImplReader::GetTxbxTextSttEndCp(WW8_CP& rStartCp, WW8_CP& rEndCp,
             long nMaxEndCp   = rEndCp;
             // rasch den TextBox-Break-Deskriptor-PLCF greifen
             pT = pPlcxMan->GetTxbxBkd();
-            if (!pT) //It can occur on occasion, Caolan
+            if (!pT) // It can occur on occasion, Caolan
                 return false;
 
             // den ersten Eintrag fuer diese TextBox-Story finden
@@ -928,7 +926,7 @@ OutlinerParaObject* SwWW8ImplReader::ImportAsOutliner(OUString &rString, WW8_CP
         mpDrawEditEngine->SetText(rString);
         InsertAttrsAsDrawingAttrs(nStartCp, nEndCp, eType);
 
-        //Annotations typically begin with a (useless) 0x5
+        // Annotations typically begin with a (useless) 0x5
         if ((eType == MAN_AND) && mpDrawEditEngine->GetTextLen())
         {
             ESelection aFirstChar(0, 0, 0, 1);
@@ -944,10 +942,10 @@ OutlinerParaObject* SwWW8ImplReader::ImportAsOutliner(OUString &rString, WW8_CP
         mpDrawEditEngine->SetText( OUString() );
         mpDrawEditEngine->SetParaAttribs(0, mpDrawEditEngine->GetEmptyItemSet());
 
-        //Strip out fields, leaving the result
+        // Strip out fields, leaving the result
         long nDummy(0);
         lcl_StripFields(rString, nDummy);
-        //Strip out word's special characters for the simple string
+        // Strip out word's special characters for the simple string
         rString = rString.replaceAll(OUString(0x1), "");
         rString = rString.replaceAll(OUString(0x5), "");
         rString = rString.replaceAll(OUString(0x8), "");
@@ -1004,8 +1002,8 @@ SwFrmFmt* SwWW8ImplReader::InsertTxbxText(SdrTextObj* pTextObj,
                     {
                         WW8ReaderSave aSave(this, nNewStartCp -1);
                         bool bOldEmbeddObj = bEmbeddObj;
-                        //bEmbedd Ordinarily would have been set by field
-                        //parse, but this is impossible here so...
+                        // bEmbedd Ordinarily would have been set by field
+                        // parse, but this is impossible here so...
                         bEmbeddObj = true;
 
                         // 1st look for OLE- or Graph-Indicator Sprms
@@ -1320,8 +1318,8 @@ SdrObject *SwWW8ImplReader::ReadGroup( WW8_DPHEAD* pHd, const WW8_DO* pDo,
 SdrObject* SwWW8ImplReader::ReadGrafPrimitive( short& rLeft, const WW8_DO* pDo,
     SfxAllItemSet &rSet)
 {
-    //cmc: This whole archaic word 6 graphic import can probably be refactored
-    //into an object hierarachy with a little effort.
+    // cmc: This whole archaic word 6 graphic import can probably be refactored
+    // into an object hierarachy with a little effort.
     SdrObject *pRet=0;
     WW8_DPHEAD aHd;                         // Lese Draw-Primitive-Header
     bool bCouldRead = checkRead(*pStrm, &aHd, sizeof(WW8_DPHEAD));
@@ -1473,9 +1471,9 @@ sal_Int32 SwMSDffManager::GetEscherLineMatch(MSO_LineStyle eStyle,
     return nOutsideThick;
 }
 
-//Returns the thickness of the line outside the frame, the logic of
-//words positioning of borders around floating objects is that of a
-//disturbed mind.
+// Returns the thickness of the line outside the frame, the logic of
+// words positioning of borders around floating objects is that of a
+// disturbed mind.
 sal_Int32 SwWW8ImplReader::MatchSdrBoxIntoFlyBoxItem(const Color& rLineColor,
     MSO_LineStyle eLineStyle, MSO_LineDashing eDashing, MSO_SPT eShapeType, sal_Int32 &rLineThick,
     SvxBoxItem& rBox )
@@ -1552,7 +1550,7 @@ sal_Int32 SwWW8ImplReader::MatchSdrBoxIntoFlyBoxItem(const Color& rLineColor,
 
         for(sal_uInt16 nLine = 0; nLine < 4; ++nLine)
         {
-            //aLine is cloned by SetLine
+            // aLine is cloned by SetLine
             rBox.SetLine(&aLine, nLine);
         }
     }
@@ -1678,7 +1676,7 @@ void SwWW8ImplReader::MatchSdrItemsIntoFlySet( SdrObject* pSdrObj,
             rSnapRect.GetWidth()  + 2*nOutside,
             rSnapRect.GetHeight() + 2*nOutside) );
     }
-    else //If a size is set, adjust it to consider border thickness
+    else // If a size is set, adjust it to consider border thickness
     {
         SwFmtFrmSize aSize = (const SwFmtFrmSize &)(rFlySet.Get(RES_FRM_SIZE));
 
@@ -1689,8 +1687,8 @@ void SwWW8ImplReader::MatchSdrItemsIntoFlySet( SdrObject* pSdrObj,
         rFlySet.Put( aNewSize );
     }
 
-    //Sadly word puts escher borders outside the graphic, but orients the
-    //graphic in relation to the top left inside the border. We don't
+    // Sadly word puts escher borders outside the graphic, but orients the
+    // graphic in relation to the top left inside the border. We don't
     if (nOutside)
     {
         SwFmtHoriOrient aHori = (const SwFmtHoriOrient &)(rFlySet.Get(
@@ -1748,7 +1746,7 @@ void SwWW8ImplReader::MatchSdrItemsIntoFlySet( SdrObject* pSdrObj,
     bool bBrushItemOk = false;
     sal_uInt8 nTrans = 0;
 
-    //Separate transparency
+    // Separate transparency
     eState = rOldSet.GetItemState(XATTR_FILLTRANSPARENCE, true, &pItem);
     if (eState == SFX_ITEM_SET)
     {
@@ -1768,7 +1766,7 @@ void SwWW8ImplReader::MatchSdrItemsIntoFlySet( SdrObject* pSdrObj,
         switch (eFill)
         {
             case XFILL_NONE:
-                //Writer graphics don't have it yet
+                // Writer graphics don't have it yet
                 if (eShapeType != mso_sptPictureFrame)
                 {
                     aBrushItem.GetColor().SetTransparency(0xFE);
@@ -1782,14 +1780,14 @@ void SwWW8ImplReader::MatchSdrItemsIntoFlySet( SdrObject* pSdrObj,
                         rOldSet.Get(XATTR_FILLCOLOR)).GetColorValue();
                     aBrushItem.SetColor(aColor);
 
-                    if (bBrushItemOk) //has trans
+                    if (bBrushItemOk) // has trans
                         aBrushItem.GetColor().SetTransparency(nTrans);
 
                     bBrushItemOk = true;
                 }
             break;
-            //case XFILL_GRADIENT:
-            //break;
+            // case XFILL_GRADIENT:
+            // break;
             case XFILL_HATCH:
             break;
             case XFILL_BITMAP:
@@ -1797,7 +1795,7 @@ void SwWW8ImplReader::MatchSdrItemsIntoFlySet( SdrObject* pSdrObj,
                     GraphicObject aGrfObj(static_cast< XFillBitmapItem const & >(rOldSet.Get(XATTR_FILLBITMAP)).GetGraphicObject());
                     const bool bTile(WW8ITEMVALUE(rOldSet, XATTR_FILLBMP_TILE, SfxBoolItem) ? true: false);
 
-                    if(bBrushItemOk) //has trans
+                    if(bBrushItemOk) // has trans
                     {
                         GraphicAttr aAttr(aGrfObj.GetAttr());
 
@@ -1842,13 +1840,13 @@ void SwWW8ImplReader::AdjustLRWrapForWordMargins(
             rLR.SetRight((sal_uInt16)0);
     }
 
-    //Inside margin, remove left wrapping
+    // Inside margin, remove left wrapping
     if ((rRecord.nXAlign == 4) && (nXRelTo == 0))
     {
         rLR.SetLeft((sal_uInt16)0);
     }
 
-    //Outside margin, remove left wrapping
+    // Outside margin, remove left wrapping
     if ((rRecord.nXAlign == 5) && (nXRelTo == 0))
     {
         rLR.SetRight((sal_uInt16)0);
@@ -1881,7 +1879,7 @@ void SwWW8ImplReader::AdjustULWrapForWordMargins(
             rUL.SetLower((sal_uInt16)0);
     }
 
-    //Remove top margin if aligned vertically inside margin
+    // Remove top margin if aligned vertically inside margin
     if ((rRecord.nYAlign == 4) && (nYRelTo == 0))
         rUL.SetUpper((sal_uInt16)0);
 }
@@ -1907,7 +1905,7 @@ void SwWW8ImplReader::MapWrapIntoFlyFmt(SvxMSDffImportRec* pRecord,
         pFlyFmt->SetFmtAttr(aUL);
     }
 
-    //If we are contoured and have a custom polygon...
+    // If we are contoured and have a custom polygon...
     if (pRecord->pWrapPolygon && pFlyFmt->GetSurround().IsContour())
     {
         if (SwNoTxtNode *pNd = GetNoTxtNodeFromSwFrmFmt(*pFlyFmt))
@@ -1976,7 +1974,7 @@ void SwWW8ImplReader::MapWrapIntoFlyFmt(SvxMSDffImportRec* pRecord,
             Fraction aHackY(ww::nWrap100Percent, ww::nWrap100Percent - nMove);
             aPoly.Scale(aHackX, aHackY);
 
-            //Turn polygon back into units that match the graphic's
+            // Turn polygon back into units that match the graphic's
             const Size &rOrigSize = pNd->GetGraphic().GetPrefSize();
             Fraction aMapPolyX(rOrigSize.Width(), ww::nWrap100Percent);
             Fraction aMapPolyY(rOrigSize.Height(), ww::nWrap100Percent);
@@ -2035,7 +2033,7 @@ SwWW8ImplReader::SetAttributesAtGrfNode(SvxMSDffImportRec const*const pRecord,
         if (pRecord->pObj)
         {
             const SfxItemSet& rOldSet = pRecord->pObj->GetMergedItemSet();
-            //contrast
+            // contrast
             if (WW8ITEMVALUE(rOldSet, SDRATTR_GRAFCONTRAST,
                 SdrGrafContrastItem))
             {
@@ -2045,7 +2043,7 @@ SwWW8ImplReader::SetAttributesAtGrfNode(SvxMSDffImportRec const*const pRecord,
                 pGrfNd->SetAttr( aContrast );
             }
 
-            //luminance
+            // luminance
             if (WW8ITEMVALUE(rOldSet, SDRATTR_GRAFLUMINANCE,
                 SdrGrafLuminanceItem))
             {
@@ -2053,7 +2051,7 @@ SwWW8ImplReader::SetAttributesAtGrfNode(SvxMSDffImportRec const*const pRecord,
                     SDRATTR_GRAFLUMINANCE, SdrGrafLuminanceItem));
                 pGrfNd->SetAttr( aLuminance );
             }
-            //gamma
+            // gamma
             if (WW8ITEMVALUE(rOldSet, SDRATTR_GRAFGAMMA, SdrGrafGamma100Item))
             {
                 double fVal = WW8ITEMVALUE(rOldSet, SDRATTR_GRAFGAMMA,
@@ -2061,7 +2059,7 @@ SwWW8ImplReader::SetAttributesAtGrfNode(SvxMSDffImportRec const*const pRecord,
                 pGrfNd->SetAttr(SwGammaGrf(fVal/100.));
             }
 
-            //drawmode
+            // drawmode
             if (WW8ITEMVALUE(rOldSet, SDRATTR_GRAFMODE, SdrGrafModeItem))
             {
                 SwDrawModeGrf aDrawMode( static_cast< sal_uInt16 >(WW8ITEMVALUE(rOldSet,
@@ -2174,8 +2172,8 @@ RndStdIds SwWW8ImplReader::ProcessEscherAlign(SvxMSDffImportRec* pRecord,
     if (pFSPA)
     {
         // #i18732#
-        //Given new layout where everything is changed to be anchored to
-        //character the following 4 tables may need to be changed.
+        // Given new layout where everything is changed to be anchored to
+        // character the following 4 tables may need to be changed.
 
         // horizontal Adjustment
         static const sal_Int16 aHoriOriTab[ nCntXAlign ] =
@@ -2283,8 +2281,8 @@ RndStdIds SwWW8ImplReader::ProcessEscherAlign(SvxMSDffImportRec* pRecord,
         }
 
 
-        //Writer honours this wrap distance when aligned as "left" or "right",
-        //Word doesn't. Writer doesn't honour it when its "from left".
+        // Writer honours this wrap distance when aligned as "left" or "right",
+        // Word doesn't. Writer doesn't honour it when its "from left".
         if (eHoriOri == text::HoriOrientation::LEFT)
             pRecord->nDxWrapDistLeft=0;
         else if (eHoriOri == text::HoriOrientation::RIGHT)
@@ -2306,8 +2304,8 @@ RndStdIds SwWW8ImplReader::ProcessEscherAlign(SvxMSDffImportRec* pRecord,
             eVertOri = aVertOriTab[ nYAlign ];
         }
 
-        //Below line in word is a positive value, while in writer its
-        //negative
+        // Below line in word is a positive value, while in writer its
+        // negative
         long nYPos = pFSPA->nYaTop;
         // #i22673#
         if ((eVertRel == text::RelOrientation::TEXT_LINE) && (eVertOri == text::VertOrientation::NONE))
@@ -2406,7 +2404,7 @@ SwFrmFmt* SwWW8ImplReader::Read_GrafLayer( long nGrafAnchorCp )
         return 0;
     }
 
-    //Normal case of Word 8+ version stuff
+    // Normal case of Word 8+ version stuff
     pPF->SeekPos( nGrafAnchorCp );
 
     WW8_FC nStartFc;
@@ -2440,12 +2438,12 @@ SwFrmFmt* SwWW8ImplReader::Read_GrafLayer( long nGrafAnchorCp )
     sorts of trouble later on
     */
     SwDocShell* pPersist = rDoc.GetDocShell();
-    rDoc.SetDocShell(0);         //#i20540# Persist guard
+    rDoc.SetDocShell(0);         // #i20540# Persist guard
 
     SdrObject* pObject = 0;
     bool bOk = (pMSDffManager->GetShape(pF->nSpId, pObject, aData) && pObject);
 
-    rDoc.SetDocShell(pPersist);  //#i20540# Persist guard
+    rDoc.SetDocShell(pPersist);  // #i20540# Persist guard
 
     if (!bOk)
     {
@@ -2479,18 +2477,18 @@ SwFrmFmt* SwWW8ImplReader::Read_GrafLayer( long nGrafAnchorCp )
     bool bContour = false;
     switch (pF->nwr)
     {
-        case 0: //0 like 2, but doesn't require absolute object
-        case 2: //2 wrap around absolute object
+        case 0: // 0 like 2, but doesn't require absolute object
+        case 2: // 2 wrap around absolute object
             eSurround = SURROUND_PARALLEL;
             break;
-        case 1: //1 no text next to shape
+        case 1: // 1 no text next to shape
             eSurround = SURROUND_NONE;
             break;
-        case 3: //3 wrap as if no object present
+        case 3: // 3 wrap as if no object present
             eSurround = SURROUND_THROUGHT;
             break;
-        case 4: //4 wrap tightly around object
-        case 5: //5 wrap tightly, but allow holes
+        case 4: // 4 wrap tightly around object
+        case 5: // 5 wrap tightly, but allow holes
             eSurround = SURROUND_PARALLEL;
             bContour = true;
             break;
@@ -2501,19 +2499,19 @@ SwFrmFmt* SwWW8ImplReader::Read_GrafLayer( long nGrafAnchorCp )
     {
         switch( pF->nwrk )
         {
-            //0 wrap both sides
+            // 0 wrap both sides
             case 0:
                 eSurround = SURROUND_PARALLEL;
                 break;
-            //1 wrap only on left
+            // 1 wrap only on left
             case 1:
                 eSurround = SURROUND_LEFT;
                 break;
-            //2 wrap only on right
+            // 2 wrap only on right
             case 2:
                 eSurround = SURROUND_RIGHT;
                 break;
-            //3 wrap only on largest side
+            // 3 wrap only on largest side
             case 3:
                 eSurround = SURROUND_IDEAL;
                 break;
@@ -2565,8 +2563,8 @@ SwFrmFmt* SwWW8ImplReader::Read_GrafLayer( long nGrafAnchorCp )
     }
 
 
-    //#i21847#
-    //Some shapes are set to *hidden*, don't import those ones.
+    // #i21847#
+    // Some shapes are set to *hidden*, don't import those ones.
     if (pRecord->bHidden)
         return 0;
 
@@ -2620,13 +2618,13 @@ SwFrmFmt* SwWW8ImplReader::Read_GrafLayer( long nGrafAnchorCp )
     SwFrmFmt* pRetFrmFmt = 0;
     if (bReplaceable)
     {
-        //Single graphics or ole objects
+        // Single graphics or ole objects
         pRetFrmFmt = ImportReplaceableDrawables(pObject, pOurNewObject, pRecord,
             pF, aFlySet);
     }
     else
     {
-        //Drawing objects, (e.g. ovals or drawing groups)
+        // Drawing objects, (e.g. ovals or drawing groups)
         if (pF->bRcaSimple)
         {
             pF->nbx = WW8_FSPA::RelPageBorder;
@@ -2831,7 +2829,7 @@ SwFlyFrmFmt* SwWW8ImplReader::ConvertDrawTextToFly(SdrObject* &rpObject,
     {
         // The Text is not read into SdrTextObj!  Rather insert a frame and
         // insert the text from nStartCp to nEndCp.
-        //
+        // 
         // More attributes can be used in a frame compared to the
         // Edit-Engine, and it can contain field, OLEs or graphics...
         Rectangle aInnerDist(pRecord->nDxTextLeft, pRecord->nDyTextTop,
@@ -2957,8 +2955,8 @@ SwFlyFrmFmt* SwWW8ImplReader::ImportReplaceableDrawables( SdrObject* &rpObject,
 
     if (pRecord)
     {
-        //Note that the escher inner distance only seems to be honoured in
-        //word for textboxes, not for graphics and ole objects.
+        // Note that the escher inner distance only seems to be honoured in
+        // word for textboxes, not for graphics and ole objects.
         Rectangle aInnerDist(0, 0, 0, 0);
 
         MatchSdrItemsIntoFlySet(rpObject, rFlySet, pRecord->eLineStyle,
@@ -3009,8 +3007,8 @@ SwFlyFrmFmt* SwWW8ImplReader::ImportReplaceableDrawables( SdrObject* &rpObject,
         // mehrfaches Auftreten gleicher Grafik-Namen vermeiden
         maGrfNameGenerator.SetUniqueGraphName(pRetFrmFmt, aObjectName);
     }
-    //falls alles Ok, Zeiger auf neues Objekt ermitteln und Z-Order-Liste
-    //entsprechend korrigieren (oder Eintrag loeschen)
+    // falls alles Ok, Zeiger auf neues Objekt ermitteln und Z-Order-Liste
+    // entsprechend korrigieren (oder Eintrag loeschen)
     rpOurNewObject = CreateContactObject(pRetFrmFmt);
 
     // altes Objekt aus der Z-Order-Liste entfernen
@@ -3055,8 +3053,8 @@ void SwWW8ImplReader::GrafikCtor()  // Fuer SVDraw und VCControls und Escher
         pMSDffManager = new SwMSDffManager(*this);
         pMSDffManager->SetModel(pDrawModel, 1440);
         /*
-         Now the dff manager always needs a controls //converter as well, but a
-         control converter may still exist //without a dffmanager. cmc
+         Now the dff manager always needs a controls // converter as well, but a
+         control converter may still exist // without a dffmanager. cmc
         */
         pFormImpl = new SwMSConvertControls(mpDocShell, pPaM);
 
-- 
1.8.5.3

