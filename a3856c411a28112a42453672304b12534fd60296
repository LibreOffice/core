{
  "comments": [
    {
      "key": {
        "uuid": "6b89d0e6_c03f4dcf",
        "filename": "include/comphelper/interfacecontainer4.hxx",
        "patchSetId": 1
      },
      "lineNbr": 43,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-08-05T06:50:48Z",
      "side": 1,
      "message": "rather \"OInterfaceContainerHelper4\"?",
      "range": {
        "startLine": 43,
        "startChar": 29,
        "endLine": 43,
        "endChar": 53
      },
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f7ce701_53014aaf",
        "filename": "include/comphelper/interfacecontainer4.hxx",
        "patchSetId": 1
      },
      "lineNbr": 48,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-08-05T06:50:48Z",
      "side": 1,
      "message": "rather \"OInterfaceContainerHelper4\"?",
      "range": {
        "startLine": 48,
        "startChar": 7,
        "endLine": 48,
        "endChar": 32
      },
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "21ee2b23_9767cbdb",
        "filename": "include/comphelper/interfacecontainer4.hxx",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-08-05T06:50:48Z",
      "side": 1,
      "message": "As, according to the commit message, this class is a slightly modified copy of comphelper::OInterfaceContainerHelper3 from include/comphelper/interfacecontainer3.hxx, it should state that here, and state what the differences are.",
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a01cc125_116e2b2b",
        "filename": "include/comphelper/interfacecontainer4.hxx",
        "patchSetId": 1
      },
      "lineNbr": 112,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-08-05T06:50:48Z",
      "side": 1,
      "message": "rather \"OInterfaceIteratorHelper4\"?",
      "range": {
        "startLine": 112,
        "startChar": 7,
        "endLine": 112,
        "endChar": 31
      },
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e1332f7_9bfce8f6",
        "filename": "ucb/source/cacher/dynamicresultsetwrapper.hxx",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-08-05T06:50:48Z",
      "side": 1,
      "message": "Recursive mutexes are a bad idea, cf. e.g. David Butenhof\u0027s comp.programming.threads \"Re: recursive mutexes\" (preserved at \u003chttp://zaval.org/resources/library/butenhof1.html\u003e).  While this change would at least indicate that the code relies upon the recursive nature of the originally used osl::Mutex, I\u0027m not convinced that migrating to a dedicatedly recursive mutex (rather than cleaning up the code to only require a non-recursive mutex) is a good move overall.",
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eca0c217_823d795e",
        "filename": "ucb/source/cacher/dynamicresultsetwrapper.hxx",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000083
      },
      "writtenOn": "2021-08-05T07:21:25Z",
      "side": 1,
      "message": "Yeah, I still think that specific complaint is related to allow mutex\u0027s to be visible outside of a class, rather than recursive mutexes in general.\n\nIn our specific UNO case, it is virtually impossible to avoid them because we \n(a) often need to hold the mutex while calling listeners\n(b) the listeners call graph is arbitrarily complex, and often calls back into the listener-firing class.\n\nI\u0027m open to suggestions, but I don\u0027t know of any technique that can preserve multi-threading and support behaviour composition that includes listeners.",
      "parentUuid": "9e1332f7_9bfce8f6",
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ad87930b_bcbc4c3b",
        "filename": "ucb/source/cacher/dynamicresultsetwrapper.hxx",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-08-05T09:08:44Z",
      "side": 1,
      "message": "\u003e Yeah, I still think that specific complaint is related to allow mutex\u0027s to be visible outside of a class, rather than recursive mutexes in general.\n\nI don\u0027t see how that makes a difference with the arguments provided there (\"1) The biggest of all the big problems with recursive mutexes is that they encourage you to completely lose track of your locking scheme and scope...\" and \"2) Sometimes you need to unlock...\").\n\n\u003e In our specific UNO case, it is virtually impossible to avoid them because we \n\u003e (a) often need to hold the mutex while calling listeners\n\u003e (b) the listeners call graph is arbitrarily complex, and often calls back into the listener-firing class.\n\nWith UNO, you must not hold mutexes while calling listeners.  Do the actual, mutating work upfront while holding a mutex and record the relevant notification data, then afterwards do the actual notifications asynchronously, after releasing the mutex.",
      "parentUuid": "eca0c217_823d795e",
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    }
  ]
}