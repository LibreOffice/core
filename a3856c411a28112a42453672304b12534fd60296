{
  "comments": [
    {
      "key": {
        "uuid": "6b89d0e6_c03f4dcf",
        "filename": "include/comphelper/interfacecontainer4.hxx",
        "patchSetId": 1
      },
      "lineNbr": 43,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-08-05T06:50:48Z",
      "side": 1,
      "message": "rather \"OInterfaceContainerHelper4\"?",
      "range": {
        "startLine": 43,
        "startChar": 29,
        "endLine": 43,
        "endChar": 53
      },
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f7ce701_53014aaf",
        "filename": "include/comphelper/interfacecontainer4.hxx",
        "patchSetId": 1
      },
      "lineNbr": 48,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-08-05T06:50:48Z",
      "side": 1,
      "message": "rather \"OInterfaceContainerHelper4\"?",
      "range": {
        "startLine": 48,
        "startChar": 7,
        "endLine": 48,
        "endChar": 32
      },
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "21ee2b23_9767cbdb",
        "filename": "include/comphelper/interfacecontainer4.hxx",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-08-05T06:50:48Z",
      "side": 1,
      "message": "As, according to the commit message, this class is a slightly modified copy of comphelper::OInterfaceContainerHelper3 from include/comphelper/interfacecontainer3.hxx, it should state that here, and state what the differences are.",
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a01cc125_116e2b2b",
        "filename": "include/comphelper/interfacecontainer4.hxx",
        "patchSetId": 1
      },
      "lineNbr": 112,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-08-05T06:50:48Z",
      "side": 1,
      "message": "rather \"OInterfaceIteratorHelper4\"?",
      "range": {
        "startLine": 112,
        "startChar": 7,
        "endLine": 112,
        "endChar": 31
      },
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e1332f7_9bfce8f6",
        "filename": "ucb/source/cacher/dynamicresultsetwrapper.hxx",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-08-05T06:50:48Z",
      "side": 1,
      "message": "Recursive mutexes are a bad idea, cf. e.g. David Butenhof\u0027s comp.programming.threads \"Re: recursive mutexes\" (preserved at \u003chttp://zaval.org/resources/library/butenhof1.html\u003e).  While this change would at least indicate that the code relies upon the recursive nature of the originally used osl::Mutex, I\u0027m not convinced that migrating to a dedicatedly recursive mutex (rather than cleaning up the code to only require a non-recursive mutex) is a good move overall.",
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eca0c217_823d795e",
        "filename": "ucb/source/cacher/dynamicresultsetwrapper.hxx",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000083
      },
      "writtenOn": "2021-08-05T07:21:25Z",
      "side": 1,
      "message": "Yeah, I still think that specific complaint is related to allow mutex\u0027s to be visible outside of a class, rather than recursive mutexes in general.\n\nIn our specific UNO case, it is virtually impossible to avoid them because we \n(a) often need to hold the mutex while calling listeners\n(b) the listeners call graph is arbitrarily complex, and often calls back into the listener-firing class.\n\nI\u0027m open to suggestions, but I don\u0027t know of any technique that can preserve multi-threading and support behaviour composition that includes listeners.",
      "parentUuid": "9e1332f7_9bfce8f6",
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ad87930b_bcbc4c3b",
        "filename": "ucb/source/cacher/dynamicresultsetwrapper.hxx",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-08-05T09:08:44Z",
      "side": 1,
      "message": "\u003e Yeah, I still think that specific complaint is related to allow mutex\u0027s to be visible outside of a class, rather than recursive mutexes in general.\n\nI don\u0027t see how that makes a difference with the arguments provided there (\"1) The biggest of all the big problems with recursive mutexes is that they encourage you to completely lose track of your locking scheme and scope...\" and \"2) Sometimes you need to unlock...\").\n\n\u003e In our specific UNO case, it is virtually impossible to avoid them because we \n\u003e (a) often need to hold the mutex while calling listeners\n\u003e (b) the listeners call graph is arbitrarily complex, and often calls back into the listener-firing class.\n\nWith UNO, you must not hold mutexes while calling listeners.  Do the actual, mutating work upfront while holding a mutex and record the relevant notification data, then afterwards do the actual notifications asynchronously, after releasing the mutex.",
      "parentUuid": "eca0c217_823d795e",
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "053d820a_db823f9a",
        "filename": "ucb/source/cacher/dynamicresultsetwrapper.hxx",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000083
      },
      "writtenOn": "2021-08-05T12:23:44Z",
      "side": 1,
      "message": "\u003e (\"1) The biggest of all the big problems with recursive mutexes is that they encourage you to completely lose track of your locking scheme and scope...\n\nThat is, literally, what the bulk of the code we right is about - allow you to lose track of other stuff so that you can focus on a writing code that does not require keeping massive scope in your head.\nI maintain, that properly used (like everything else in this world), recursive mutexes are just fine and dandy.\n\n\u003e With UNO, you must not hold mutexes while calling listeners.  Do the actual, mutating work upfront while holding a mutex and record the relevant notification data, then afterwards do the actual notifications asynchronously, after releasing the mutex.\n\nUnfortunately that idyllic state of affairs is rather rare in our codebase :-)\n\nI\u0027m am happy to do the rather mechanical work of converting stuff from osl::Mutex to std::recursive_mutex.\n\nBut I\u0027m not keen on signing up for deeper changes, that have a much strong likelihood of breaking stuff.",
      "parentUuid": "ad87930b_bcbc4c3b",
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "40f6fe0b_ddc2d831",
        "filename": "ucb/source/cacher/dynamicresultsetwrapper.hxx",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-08-05T12:43:02Z",
      "side": 1,
      "message": "\u003e \u003e (\"1) The biggest of all the big problems with recursive mutexes is that they encourage you to completely lose track of your locking scheme and scope...\n\u003e \n\u003e That is, literally, what the bulk of the code we right is about - allow you to lose track of other stuff so that you can focus on a writing code that does not require keeping massive scope in your head.\n\n\"lose track of your [class-local, say] locking scheme and scope\", I would clarify.  This is not about (e.g., class-)encapsulation allowing you to focus on just a small part of the overall code, but rather about turning even such a small, encapsulated part of the code into a quicksand that you drown in.\n\n\u003e I maintain, that properly used (like everything else in this world), recursive mutexes are just fine and dandy.\n\nThat doesn\u0027t match my experience, in which you want to be very clear about which data is controlled by a given mutex, and thus where exactly that mutex must be held in the code.  And where else it should not be held, to avoid deadlocks and bottlenecks.  And then, from my experience at least, you naturally arrive at a design that doesn\u0027t need recursive mutexes.\n\n\u003e I\u0027m am happy to do the rather mechanical work of converting stuff from osl::Mutex to std::recursive_mutex.\n\u003e \n\u003e But I\u0027m not keen on signing up for deeper changes, that have a much strong likelihood of breaking stuff.\n\nThen why not simply leave those problematic occurrences of osl::Mutex as they are, for now?",
      "parentUuid": "053d820a_db823f9a",
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "132ed3f8_f4d9bddd",
        "filename": "ucb/source/cacher/dynamicresultsetwrapper.hxx",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000083
      },
      "writtenOn": "2021-08-06T13:50:44Z",
      "side": 1,
      "message": "\u003e \n\u003e Then why not simply leave those problematic occurrences of osl::Mutex as they are, for now?\n\nYou suggested on IRC that might be nice to mark remaining places by converting them to std::recursive_mutex, to make it obvious that those places do, in fact, need a recursive mutex and not a non-recursive one.\n\nBut sure, quite happy to leave them alone.",
      "parentUuid": "40f6fe0b_ddc2d831",
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "64b2c485_7673e503",
        "filename": "ucb/source/cacher/dynamicresultsetwrapper.hxx",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-08-06T13:59:33Z",
      "side": 1,
      "message": "Yeah,\n\n\u003e Aug 03 09:13:13 \u003csberg\u003e\tmikekaganski, one advantage osl::Mutex -\u003e std::recursive_mutex would be to clarify that that osl::Mutex instance is actually meant to be recursive (similar to how replacing OSL_ASSERT et al with SAL_WARN/assert/... clarified what those ambiguous OSL_ASSERT actually meant)\n\n...but meanwhile I\u0027ve become rather unsure whether that would be a good idea, \"blessing\" those unfortunate uses of recursive mutexes and making it look like we are fine with the status quo there (which I think we are not; at least I\u0027m not)",
      "parentUuid": "132ed3f8_f4d9bddd",
      "revId": "a3856c411a28112a42453672304b12534fd60296",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    }
  ]
}