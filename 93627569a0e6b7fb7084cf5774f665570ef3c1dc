{
  "comments": [
    {
      "key": {
        "uuid": "1f1a1f67_4882abca",
        "filename": "sc/source/core/data/table3.cxx",
        "patchSetId": 5
      },
      "lineNbr": 2609,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2018-10-22T12:02:32Z",
      "side": 1,
      "message": "So here we want to test for case significant equality. That doesn\u0027t need OUString::compareTo() which also determines the raw Unicode character order, it can use the simple equal operator, so\n\n bOk \u003d (*pValueSource2 \u003d\u003d rItem.maString.getString());",
      "revId": "93627569a0e6b7fb7084cf5774f665570ef3c1dc",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f1a1f67_7c6408ba",
        "filename": "sc/source/core/data/table3.cxx",
        "patchSetId": 5
      },
      "lineNbr": 2609,
      "author": {
        "id": 1001119
      },
      "writtenOn": "2018-10-22T19:15:41Z",
      "side": 1,
      "message": "The proposed operator\u003d\u003d uses equals() method from the same class, which finally uses rtl_ustr_reverseCompare_WithLength() method.\n\nIn compareTo() method a rtl_ustr_compare_WithLength() method is used directly.\n\nFrom the description of these two methods I could say they perform the same job but with different order of characters. But I do not think that we are really needed to handle reverse order here.\n\nFrom other side, there are predefined following helpers:\n\n    friend bool     operator \u003d\u003d ( const OUString\u0026 rStr1,    const OUString\u0026 rStr2 )\n                        { return rStr1.equals(rStr2); }\n    friend bool     operator \u003d\u003d ( const OUString\u0026 rStr1,    const sal_Unicode * pStr2 )\n                        { return rStr1.compareTo( pStr2 ) \u003d\u003d 0; }\n    friend bool     operator \u003d\u003d ( const sal_Unicode * pStr1,    const OUString\u0026 rStr2 )\n                        { return OUString( pStr1 ).compareTo( rStr2 ) \u003d\u003d 0; }\n\nSo, in most cases compareTo() is used :)\n\nI\u0027ll prefer your suggestion while it looks to be more compact and clear. The effectiveness of the internal implementation inside this class is still questionable...",
      "parentUuid": "1f1a1f67_4882abca",
      "revId": "93627569a0e6b7fb7084cf5774f665570ef3c1dc",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f1a1f67_5c838c05",
        "filename": "sc/source/core/data/table3.cxx",
        "patchSetId": 5
      },
      "lineNbr": 2609,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2018-10-22T20:26:58Z",
      "side": 1,
      "message": "operator\u003d\u003d() using OUString::equals() has the advantage that it immediately returns false if lengths differ, determining the character distance is unnecessary then.",
      "parentUuid": "1f1a1f67_7c6408ba",
      "revId": "93627569a0e6b7fb7084cf5774f665570ef3c1dc",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f1a1f67_5f081e27",
        "filename": "sc/source/core/data/table3.cxx",
        "patchSetId": 5
      },
      "lineNbr": 2609,
      "author": {
        "id": 1001119
      },
      "writtenOn": "2018-10-23T07:44:39Z",
      "side": 1,
      "message": "Why other methods do not use this advantage?\n\n    friend bool     operator \u003d\u003d ( const OUString\u0026 rStr1,    const sal_Unicode * pStr2 )\n                        { return rStr1.compareTo( pStr2 ) \u003d\u003d 0; }\n    friend bool     operator \u003d\u003d ( const sal_Unicode * pStr1,    const OUString\u0026 rStr2 )\n                        { return OUString( pStr1 ).compareTo( rStr2 ) \u003d\u003d 0; }\n\n    friend bool     operator \u003c  ( const OUString\u0026 rStr1,    const OUString\u0026 rStr2 )\n                        { return rStr1.compareTo( rStr2 ) \u003c 0; }\n    friend bool     operator \u003e  ( const OUString\u0026 rStr1,    const OUString\u0026 rStr2 )\n                        { return rStr1.compareTo( rStr2 ) \u003e 0; }\n    friend bool     operator \u003c\u003d ( const OUString\u0026 rStr1,    const OUString\u0026 rStr2 )\n                        { return rStr1.compareTo( rStr2 ) \u003c\u003d 0; }\n    friend bool     operator \u003e\u003d ( const OUString\u0026 rStr1,    const OUString\u0026 rStr2 )\n                        { return rStr1.compareTo( rStr2 ) \u003e\u003d 0; }",
      "parentUuid": "1f1a1f67_5c838c05",
      "revId": "93627569a0e6b7fb7084cf5774f665570ef3c1dc",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f1a1f67_ff680a22",
        "filename": "sc/source/core/data/table3.cxx",
        "patchSetId": 5
      },
      "lineNbr": 2609,
      "author": {
        "id": 1000023
      },
      "writtenOn": "2018-10-23T15:36:18Z",
      "side": 1,
      "message": "Because both operator\u003d\u003d() with a sal_Unicode* don\u0027t know the length in advance, and for operator\u003c() and all the others they don\u0027t test equality so actually need the compareTo() functionality.",
      "parentUuid": "1f1a1f67_5f081e27",
      "revId": "93627569a0e6b7fb7084cf5774f665570ef3c1dc",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1f1a1f67_5fd01eca",
        "filename": "sc/source/core/data/table3.cxx",
        "patchSetId": 5
      },
      "lineNbr": 2609,
      "author": {
        "id": 1001119
      },
      "writtenOn": "2018-10-23T16:14:21Z",
      "side": 1,
      "message": "Thank you for the answers! Now I see the point.",
      "parentUuid": "1f1a1f67_ff680a22",
      "revId": "93627569a0e6b7fb7084cf5774f665570ef3c1dc",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": false
    }
  ]
}