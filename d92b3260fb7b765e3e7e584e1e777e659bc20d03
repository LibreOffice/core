{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "bf89fcd7_8d81fa8c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000092
      },
      "writtenOn": "2022-03-15T07:57:53Z",
      "side": 1,
      "message": "Any thoughts on making OUString::equals() use simply memcmp() instead of rtl_ustr_reverseCompare_WithLength()? And possibly also replacing our custom string comparing code with libc functions where possible. This specific document results in comparing very long strings, so maybe it\u0027s an exception, but on the other hand comparing strings that differ only in the last characters is probably rare enough too. I don\u0027t have data on this, but I\u0027d expect that 99% of string comparisons either bail out on first characters (which immediately follow the length, which is the first thing to check, so they\u0027re likely already prefetched) or they\u0027ll match completely. This seems like one of those design decisions that seem smart in theory but just don\u0027t match reality.\n",
      "revId": "d92b3260fb7b765e3e7e584e1e777e659bc20d03",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e505978_5ba70843",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000083
      },
      "writtenOn": "2022-03-15T08:18:34Z",
      "side": 1,
      "message": "I have already tried to use libc functions where possible for the string stuff (but possibly there are still more places).\n\nThere are quite a few places in our codebase where comparing the strings in reverse is more efficient that comparing forward (e.g. think of strings with namespace-like names in them), where the last few characters are much more likely to be different than the first few characters.\n\nBut possibly that tradeoff does not apply any more.\n\nIf you have a performance problem with comparison, it might be worth caching the hash of the string somewhere (which is quite Java does).\n\nIt might also be worth doing some SSE coding for our string compare.",
      "parentUuid": "bf89fcd7_8d81fa8c",
      "revId": "d92b3260fb7b765e3e7e584e1e777e659bc20d03",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d844362_547c1116",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000092
      },
      "writtenOn": "2022-03-15T09:11:43Z",
      "side": 1,
      "message": "\u003e There are quite a few places in our codebase where comparing the strings in reverse is more efficient that comparing forward (e.g. think of strings with namespace-like names in them), where the last few characters are much more likely to be different than the first few characters.\n\u003e \n\u003e But possibly that tradeoff does not apply any more.\n\nYes, that\u0027s basically the question.\n \n\u003e If you have a performance problem with comparison, it might be worth caching the hash of the string somewhere (which is quite Java does).\n\nThat seems like quite some work, and you still need to compare the string itself afterwards, unless you\u0027re willing to bet that hash equality guarantees string equality.\n \n\u003e It might also be worth doing some SSE coding for our string compare.\n\nCalling memcmp() does that. Presumably one of the reasons it\u0027s way faster here is because it actually ends up being AVX2 code.",
      "parentUuid": "0e505978_5ba70843",
      "revId": "d92b3260fb7b765e3e7e584e1e777e659bc20d03",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "caf278c5_c373018a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2022-03-15T09:13:12Z",
      "side": 1,
      "message": "\u003e There are quite a few places in our codebase where comparing the strings in reverse is more efficient that comparing forward (e.g. think of strings with namespace-like names in them), where the last few characters are much more likely to be different than the first few characters.\n\nYeah, that was the original motivation for using reverse comparison back then; I think the use case was comparing URLs or pathnames which tended to have equal lengths and long common prefixes but no to short common suffixes.  (And IIRC java.lang.String.equals also employed such an optimization back in the day.)  No idea whether that would still be a relevant optimization overall, or just a pessimization today.",
      "parentUuid": "0e505978_5ba70843",
      "revId": "d92b3260fb7b765e3e7e584e1e777e659bc20d03",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e9c6f260_06d1c353",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000092
      },
      "writtenOn": "2022-03-15T13:38:39Z",
      "side": 1,
      "message": "On the other hand, we have many more maps than just this case that use OUString as the key, and at least some of those are in performance-important parts, and those will end up comparing entire keys on match. My guess would be these matter more, but I have no data on that.",
      "parentUuid": "caf278c5_c373018a",
      "revId": "d92b3260fb7b765e3e7e584e1e777e659bc20d03",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    }
  ]
}