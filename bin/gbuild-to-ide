#! /usr/bin/env python3
# -*- Mode: python; tab-width: 4; indent-tabs-mode: t -*-
#
# This file is part of the LibreOffice project.
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#

import argparse
import os
import os.path
import shutil
import re
import sys
import uuid
import json
import xml.etree.ElementTree as ET
import xml.dom.minidom as minidom
import traceback
import collections
import subprocess

class GbuildLinkTarget:
    def __init__(self, name, location, include, include_sys, defs, cxxobjects, cxxflags, linked_libs,
                 asmobjects, cflags, gencobjects, gencxxobjects, ilibtarget, linked_static_libs, linktarget,
                 objcflags, objcobjects, objcxxflags, objcxxobjects, yaccobjects, build_type):
        (self.name, self.location, self.include,
         self.include_sys, self.defs, self.cxxobjects,
         self.cxxflags, self.linked_libs,
         self.asmobjects, self.cflags, self.gencobjects,
         self.gencxxobjects, self.ilibtarget, self.linked_static_libs,
         self.linktarget, self.objcflags, self.objcobjects,
         self.objcxxflags, self.objcxxobjects, self.yaccobjects,
         self.build_type) = (name, location, include,
                             include_sys, defs, cxxobjects,
                             cxxflags, linked_libs, asmobjects,
                             cflags, gencobjects, gencxxobjects,
                             ilibtarget, linked_static_libs, linktarget,
                             objcflags, objcobjects, objcxxflags,
                             objcxxobjects, yaccobjects, build_type)
        self.target_name = self.build_type + '_' + self.name


class GbuildParser:
    def __init__(self, makecmd):
        self.makecmd = makecmd
        self.binpath = os.path.dirname(os.environ['GPERF']) # woha, this is quite a hack
        (self.srcdir, self.builddir, self.instdir, self.workdir) = (os.environ['SRCDIR'], os.environ['BUILDDIR'],
                                                                    os.environ['INSTDIR'], os.environ['WORKDIR'])
        self.modules = collections.OrderedDict()

    _includepattern = re.compile('-I(\S+)')
    _isystempattern = re.compile('-isystem\s*(\S+)')
    _warningpattern = re.compile('-W\S+')
    _buildpattern = {'Library': re.compile('Library_(.*)\.mk'),
                     'Executable': re.compile('Executable_(.*)\.mk'),
                     'CppunitTest': re.compile('CppunitTest_(.*)\.mk')}

    @staticmethod
    def __split_includes(includes):
        foundisystem = GbuildParser._isystempattern.findall(includes)
        foundincludes = [includeswitch.strip() for includeswitch in GbuildParser._includepattern.findall(includes) if
                len(includeswitch) > 2]
        return (foundincludes, foundisystem)

    @staticmethod
    def __split_objs(objsline):
        return [obj for obj in objsline.strip().split(' ') if len(obj) > 0 and obj != 'CXXOBJECTS' and obj != '+=']

    @staticmethod
    def __split_defs(defsline):
        defs = {}
        alldefs = [defswitch.strip() for defswitch in defsline.strip().lstrip('-D').split(' -D') if len(defswitch) > 2]
        for d in alldefs:
            defparts = d.split('=')
            if len(defparts) == 1:
                defparts.append(None)
            defs[defparts[0]] = defparts[1]
        defs["LIBO_INTERNAL_ONLY"] = None
        return defs

    @staticmethod
    def __split_flags(flagsline, flagslineappend):
        return [cxxflag.strip() for cxxflag in GbuildParser._warningpattern.sub('', '%s %s' % (flagsline, flagslineappend)).split(' ') if len(cxxflag) > 1]

    def parse(self):
        # Relation between json object and file extension
        # Missing relations: .hxx  .hpp .hrc  .src  .java  .py  .h  .s  .c  .pl  .S  .ui  .l  .cpp
        jsonSrc = {'ASMOBJECTS':    '.asm',
                   'CXXOBJECTS':    '.cxx',
                   'GENCOBJECTS':   '?',
                   'GENCXXOBJECTS': '.cxx', # this does not sound right
                   'OBJCOBJECTS':   '.m',
                   'OBJCXXOBJECTS': '.mm',
                   'YACCOBJECTS':   '.y'
                   }


        moduleDict = {}
        for jsontype in ['Library', 'Executable', 'CppunitTest']:
            for jsonfilename in os.listdir(os.path.join(self.workdir, 'GbuildToJson', jsontype)):
                with open(os.path.join(self.workdir, 'GbuildToJson', jsontype, jsonfilename), 'r') as f:
                    jsondata = json.load(f)

                    (foundincludes, foundisystem) = GbuildParser.__split_includes(jsondata['INCLUDE'])
                    match = GbuildParser._buildpattern[jsontype].match(os.path.basename(jsondata['MAKEFILE'])).group(1)
                    location = os.path.dirname(jsondata['MAKEFILE'])
                    filesSorted = {}
                    for i in jsonSrc:
                        if len(jsondata[i]) > 0:
                            if jsonSrc[i] == '?':
                                raise Exception('type need conversion')
                            filesSorted[i] = sorted(GbuildParser.__split_objs(jsondata[i]))
                        else:
                            filesSorted[i] = []

                    newObj = GbuildLinkTarget(match,
                                              location,
                                              foundincludes,
                                              foundisystem,
                                              GbuildParser.__split_defs(jsondata['DEFS']),
                                              filesSorted['CXXOBJECTS'],
                                              GbuildParser.__split_flags(jsondata['CXXFLAGS'], jsondata['CXXFLAGSAPPEND']),
                                              jsondata['LINKED_LIBS'].strip().split(' '),
                                              filesSorted['ASMOBJECTS'],
                                              GbuildParser.__split_flags(jsondata['CFLAGS'], jsondata['CFLAGSAPPEND']),
                                              filesSorted['GENCOBJECTS'],
                                              filesSorted['GENCXXOBJECTS'],
                                              jsondata['ILIBTARGET'],
                                              jsondata['LINKED_STATIC_LIBS'],
                                              jsondata['LINKTARGET'],
                                              GbuildParser.__split_flags(jsondata['OBJCFLAGS'], jsondata['OBJCFLAGSAPPEND']),
                                              filesSorted['OBJCOBJECTS'],
                                              GbuildParser.__split_flags(jsondata['OBJCXXFLAGS'], jsondata['OBJCXXFLAGSAPPEND']),
                                              filesSorted['OBJCXXOBJECTS'],
                                              filesSorted['YACCOBJECTS'],
                                              jsontype)
                    module = location.split('/')[-1]
                    if not module in moduleDict:
                        moduleDict[module] = {'targets': set(),'headers':{}}
                    moduleDict[module]['targets'] |= set([newObj])
                    moduleDict[module]['headers'] =self.find_all_headers_in_module(module)


        moduleDict['include']={ 'targets': {}, 'headers':self.find_all_headers_in_module('include')}

        # sort ['sources'] and ['headers'] for each module
        for module in sorted(moduleDict):
            self.modules[module] = moduleDict[module]
        return self

    def find_all_headers_in_module(self,modulename):

        cmdResult1=subprocess.Popen(('git', 'ls-files', modulename), cwd=self.srcdir,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        try:
            cmdResult2=subprocess.check_output(('grep', '-i', '-E', '".*\.hxx$|.*\.h$|.*\.hpp$"'),cwd=self.srcdir,stdin=cmdResult1.stdout,stderr=subprocess.PIPE)

            #decode from byte to string
            allfiles=[]
            for file in cmdResult2.splitlines():
                allfiles.append(file.decode()[len(modulename)+1:])
            return allfiles
        except subprocess.CalledProcessError as e:
            return[]
            #catch the error when there aren't hxx,h,hpp files in that module (like smoketest)

class IdeIntegrationGenerator:

    def __init__(self, gbuildparser, ide):
        (self.gbuildparser, self.ide) = (gbuildparser, ide)

    def emit(self):
        pass

class EclipseCDTIntegrationGenerator(IdeIntegrationGenerator):

    def __init__(self, gbuildparser, ide):
        IdeIntegrationGenerator.__init__(self, gbuildparser, ide)

    def create_include_path(self):
        for module in self.gbuildparser.modules:
            if module == 'include':
                continue
            modulepath = os.path.join(self.gbuildparser.builddir, module)
            includedirfile = open(os.path.join(modulepath, '.eclipsesettingfile'), 'w')
            modulelibs = []
            for lib in self.target_path.keys():
                if lib.startswith(module+'/'):
                    modulelibs.append(lib)
            include = set()
            for lib in modulelibs:
                for target in self.target_path[lib]:
                    include |= set(target.include)
            includedirfile.write('\n'.join(include))
            includedirfile.close()


    def create_macros(self):
        for module in self.gbuildparser.modules:
            if module == 'include':
                continue
            modulepath = os.path.join(self.gbuildparser.builddir, module)
            macrofile = open(os.path.join(modulepath, '.macros'), 'w')
            modulelibs = []
            for lib in self.target_path.keys():
                if lib.startswith(module+'/'):
                    modulelibs.append(lib)
            define = []
            defineset = set()
            for lib in modulelibs:
                for target in self.target_path[lib]:
                    for i in target.defs.keys():
                        tmp = str(i) +','+str(target.defs[i])
                        if tmp not in defineset:
                            defineset.add(tmp)
            macrofile.write('\n'.join(defineset))
            macrofile.close()


    def create_settings_file(self):

        settingsfiletemplate = """\
<?xml version="1.0" encoding="UTF-8"?>
<cdtprojectproperties>
<section name="org.eclipse.cdt.internal.ui.wizards.settingswizards.IncludePaths">
<language name="C++ Source File">


</language>
<language name="C Source File">

</language>
<language name="Object File">

</language>
<language name="Assembly Source File">

</language>
</section>
<section name="org.eclipse.cdt.internal.ui.wizards.settingswizards.Macros">
<language name="C++ Source File">

</language>
<language name="C Source File">

</language>
<language name="Object File">

</language>
<language name="Assembly Source File">

</language>
</section>
</cdtprojectproperties>
"""

        for module in self.gbuildparser.modules:
            if module == 'include':
                continue
            tempxml = []
            modulepath = os.path.join(self.gbuildparser.builddir, module)

            settingsfile = open(os.path.join(modulepath, 'eclipsesettingfile.xml'), 'w')
            settingsfile.write(settingsfiletemplate)
            settingsfile.close()

            settingsfile = open(os.path.join(modulepath, 'eclipsesettingfile.xml'), 'r')
            tempxml = settingsfile.readlines()
            tempinclude = open(os.path.join(modulepath, '.eclipsesettingfile'), 'r')
            tempmacro = open(os.path.join(modulepath, '.macros'), 'r')
            for includepath in tempinclude:
                if includepath[-1:] == "\n":
                    includepath = includepath[:-1]
                templine = "<includepath>%s</includepath>\n" % includepath
                tempxml.insert(5, templine)

            for line in tempmacro:
                macroskeyvalue = line.split(',')
                macrokey = macroskeyvalue[0]
                macrovalue = macroskeyvalue[1]
                if macrovalue[-1:] == "\n":
                    macrovalue = macrovalue[:-1]
                templine = "<macro><name>%s</name><value>%s</value></macro>\n" %(macrokey, macrovalue)
                tempxml.insert(-13, templine)
            tempxml="".join(tempxml)
            settingsfile.close

            settingsfile = open(os.path.join(modulepath, 'eclipsesettingfile.xml'), 'w')
            settingsfile.write(tempxml)
            settingsfile.close()
            os.remove(os.path.join(modulepath, '.eclipsesettingfile'))
            os.remove(os.path.join(modulepath, '.macros'))

    def emit(self):
        self.target_path = {}
        for m in self.gbuildparser.modules:
            if m == 'include':
                continue
            for target in self.gbuildparser.modules[m]['targets']:
                for cxx in target.cxxobjects:
                    path = '/'.join(cxx.split('/')[:-1])
                    if path not in self.target_path:
                        self.target_path[path] = set()
                    self.target_path[path] |= set([target])
        self.create_include_path()
        self.create_macros()
        self.create_settings_file()

class DebugIntegrationGenerator(IdeIntegrationGenerator):

    def __init__(self, gbuildparser, ide):
        IdeIntegrationGenerator.__init__(self, gbuildparser, ide)

    def emit(self):
        print(self.gbuildparser.srcdir)
        print(self.gbuildparser.builddir)
        for f in self.gbuildparser.modules:
            for j in self.gbuildparser.modules[f]['targets']:
                print(j)

        VisualStudioIntegrationGenerator(self.gbuildparser, self.ide).emit()
        XcodeIntegrationGenerator(self.gbuildparser, self.ide).emit()

        EclipseCDTIntegrationGenerator(self.gbuildparser, self.ide).emit()
        KdevelopIntegrationGenerator(self.gbuildparser, self.ide).emit()
        VimIntegrationGenerator(self.gbuildparser, self.ide).emit()
        QtCreatorIntegrationGenerator(self.gbuildparser, self.ide).emit()


class VimIntegrationGenerator(IdeIntegrationGenerator):

    def __init__(self, gbuildparser, ide):
        IdeIntegrationGenerator.__init__(self, gbuildparser, ide)

    def emit(self):
        global_list = []
        for m in self.gbuildparser.modules:
            for lib in self.gbuildparser.modules[m]['targets']:
                entries = []
                for file in lib.cxxobjects:
                    filePath = os.path.join(self.gbuildparser.srcdir, file) + ".cxx"
                    entry = {'directory': lib.location, 'file': filePath, 'command': self.generateCommand(lib, filePath)}
                    entries.append(entry)
                global_list.extend(entries)
        export_file = open('compile_commands.json', 'w')
        json.dump(global_list, export_file)

    def generateCommand(self, lib, file):
        command = 'clang++ -Wall'
        for key, value in lib.defs.items():
            command += ' -D'
            command += key
            if value is not None:
                command += '='
                command += value

        # The directory of the file is missing from lib's include list, as that
        # one is not the same for all source files in the lib.
        command += ' -I' + os.path.dirname(file)

        for include in lib.include:
            command += ' -I'
            command += include
        for isystem in lib.include_sys:
            command += ' -isystem '
            command += isystem
        for cxxflag in lib.cxxflags:
            command += ' '
            command += cxxflag
        command += ' -c '
        command += file
        # Help clang when the tree is configured for gcc.
        for gnu in ('-std=gnu++11', '-std=gnu++1y'):
            command = command.replace(gnu, '-std=c++11')
        return command


class KdevelopIntegrationGenerator(IdeIntegrationGenerator):

    def encode_int(self, i):
        temp = '%08x' % i
        return '\\x%s\\x%s\\x%s\\x%s' % (temp[0:2], temp[2:4], temp[4:6], temp[6:8])

    def encode_string(self, string):
        result = self.encode_int(len(string) * 2)
        for c in string.encode('utf-16-be'):
            if c in range(32, 126):
                result += chr(c)
            else:
                result += '\\x%02x' % c
        return result

    def generate_buildsystemconfigtool(self, configid, tool, args, exe, typenr):
        return KdevelopIntegrationGenerator.buildsystemconfigtooltemplate % {'configid': configid, 'tool': tool,
                                                                             'args': args, 'exe': exe, 'typenr': typenr}

    buildsystemconfigtooltemplate = """
[CustomBuildSystem][BuildConfig%(configid)d][Tool%(tool)s]
Arguments=%(args)s
Enabled=true
Environment=
Executable=%(exe)s
Type=%(typenr)d

"""

    def generate_buildsystemconfig(self, configid, moduledir, builddir, title, buildparms=''):
        result = KdevelopIntegrationGenerator.buildsystemconfigtemplate % {'configid': configid, 'builddir': builddir,
                                                                           'title': title}
        result += self.generate_buildsystemconfigtool(configid, 'Clean', 'clean %s' % buildparms,
                                                      self.gbuildparser.makecmd, 3)
        result += self.generate_buildsystemconfigtool(configid, 'Build', 'all %s' % buildparms,
                                                      self.gbuildparser.makecmd, 0)
        return result

    buildsystemconfigtemplate = """
[CustomBuildSystem][BuildConfig%(configid)d]
BuildDir=file://%(builddir)s
Title=%(title)s

"""

    def generate_buildsystem(self, moduledir):
        result = KdevelopIntegrationGenerator.buildsystemtemplate % {'defaultconfigid': 0}
        result += self.generate_buildsystemconfig(0, moduledir, moduledir, 'Module Build -- Release')
        result += self.generate_buildsystemconfig(1, moduledir, self.gbuildparser.builddir, 'Full Build -- Release')
        result += self.generate_buildsystemconfig(2, moduledir, moduledir, 'Module Build -- Debug', 'debug=T')
        result += self.generate_buildsystemconfig(3, moduledir, self.gbuildparser.builddir, 'Full Build -- Debug',
                                                  'debug=T')
        return result

    buildsystemtemplate = """
[CustomBuildSystem]
CurrentConfiguration=BuildConfig%(defaultconfigid)d

"""

    def generate_launch(self, launchid, launchname, executablepath, args, workdir):
        return KdevelopIntegrationGenerator.launchtemplate % {'launchid': launchid, 'launchname': launchname,
                                                              'executablepath': executablepath, 'args': args,
                                                              'workdir': workdir}

    launchtemplate = """
[Launch][Launch Configuration %(launchid)d]
Configured Launch Modes=execute
Configured Launchers=nativeAppLauncher
Name=%(launchname)s
Type=Native Application

[Launch][Launch Configuration %(launchid)d][Data]
Arguments=%(args)s
Dependencies=@Variant(\\x00\\x00\\x00\\t\\x00\\x00\\x00\\x00\\x00)
Dependency Action=Nothing
EnvironmentGroup=default
Executable=file://%(executablepath)s
External Terminal=konsole --noclose --workdir %%workdir -e %%exe
Project Target=
Use External Terminal=false
Working Directory=file://%(workdir)s
isExecutable=true

"""

    def generate_launches(self, moduledir):
        launches = ','.join(['Launch Configuration %d' % i for i in range(7)])
        result = KdevelopIntegrationGenerator.launchestemplate % {'launches': launches}
        result += self.generate_launch(0, 'Local tests -- quick tests (unitcheck)', self.gbuildparser.makecmd,
                                       'unitcheck', moduledir)
        result += self.generate_launch(1, 'Local tests -- slow tests (unitcheck, slowcheck, screenshot)', self.gbuildparser.makecmd,
                                       'unitcheck slowcheck screenshot', moduledir)
        result += self.generate_launch(2, 'Local tests -- integration tests (unitcheck, slowcheck, screenshot, subsequentcheck)',
                                       self.gbuildparser.makecmd, 'unitcheck slowcheck screenshot subsequentcheck', moduledir)
        result += self.generate_launch(3, 'Global tests -- quick tests (unitcheck)', self.gbuildparser.makecmd,
                                       'unitcheck', self.gbuildparser.builddir)
        result += self.generate_launch(4, 'Global tests -- slow tests (unitcheck, slowcheck, screenshot)',
                                       self.gbuildparser.makecmd, 'unitcheck slowcheck screenshot', self.gbuildparser.builddir)
        result += self.generate_launch(5, 'Global tests -- integration tests (unitcheck, slowcheck, screenshot, subsequentcheck)',
                                       self.gbuildparser.makecmd, 'unitcheck slowcheck screenshot subsequentcheck',
                                       self.gbuildparser.builddir)
        result += self.generate_launch(6, 'Run LibreOffice',
                                       os.path.join(self.gbuildparser.instdir, 'program/soffice.bin'), '',
                                       self.gbuildparser.instdir)
        return result

    launchestemplate = """
[Launch]
Launch Configurations=%(launches)s

"""

    def write_modulebeef(self, moduledir, modulename):
        beefdir = os.path.join(moduledir, '.kdev4')
        os.mkdir(beefdir)
        beeffile = open(os.path.join(beefdir, 'Module_%s.kdev4' % modulename), 'w')
        beeffile.write(self.generate_buildsystem(moduledir))
        beeffile.write(self.generate_launches(moduledir))
        beeffile.close()

    def write_modulestub(self, moduledir, modulename):
        stubfile = open(os.path.join(moduledir, 'Module_%s.kdev4' % modulename), 'w')
        stubfile.write(KdevelopIntegrationGenerator.modulestubtemplate % {'modulename': modulename,
                                                                          'builditem': self.encode_string(
                                                                              'Module_%s' % modulename)})
        stubfile.close()

    modulestubtemplate = """
[Buildset]
BuildItems=@Variant(\\x00\\x00\\x00\\t\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x0b\\x00\\x00\\x00\\x00\\x01%(builditem)s)

[Project]
Name=Module_%(modulename)s
Manager=KDevCustomBuildSystem
VersionControl=kdevgit
"""

    def write_includepaths(self, path):
        includedirfile = open(os.path.join(path, '.kdev_include_paths'), 'w')
        include = set()
        for target in self.target_path[path]:
            include |= set(target.include)
        includedirfile.write('\n'.join(include))
        includedirfile.close()

    def __init__(self, gbuildparser, ide):
        IdeIntegrationGenerator.__init__(self, gbuildparser, ide)

    def emit(self):
        self.target_path = {}
        for m in self.gbuildparser.modules:
            for target in self.gbuildparser.modules[m]['targets']:
                for cxx in target.cxxobjects:
                    path = '/'.join(cxx.split('/')[:-1])
                    if path not in self.target_path:
                        self.target_path[path] = set()
                    self.target_path[path] |= set([target])

        for path in self.target_path:
            self.write_includepaths(path)
        for modulename in self.gbuildparser.modules:
            if modulename=='include':
                continue
            location = self.gbuildparser.srcdir + '/' + modulename
            self.write_modulestub(location, modulename)
            self.write_modulebeef(location, modulename)
            for f in os.listdir(location):
                if f.endswith('.kdev4'):
                    try:
                        os.remove(os.path.join(location, f))
                    except OSError:
                        shutil.rmtree(os.path.join(location, f))


class XcodeIntegrationGenerator(IdeIntegrationGenerator):
    def __init__(self, gbuildparser, ide):
        IdeIntegrationGenerator.__init__(self, gbuildparser, ide)


    def emit(self):
        rootId = 'X0000001'
        mainGroupId = 'X0000002'
        self.rootObj = {'attributes': {'LastUpgradeCheck': '0820',
                                       'ORGANIZATIONNAME': 'LibreOffice',
                                       'TargetAttributes': {}},
                        'compatibilityVersion': 'Xcode 3.2',
                        'developmentRegion': 'English',
                        'isa': 'PBXProject',
                        'hasScannedForEncodings': 0,
                        'knownRegions': ['en'],
                        'mainGroup': mainGroupId,
                        'projectDirPath': self.gbuildparser.srcdir,
                        'projectRoot': '',
                        'buildConfigurationList': '',
                        'targets': []}
        mainGroup = {'isa': 'PBXGroup', 'children': [], 'sourceTree': '<group>'}
        pbxproj = {'archiveVersion': 1,
                   'classes': {},
                   'objectVersion': 46,
                   'objects': {rootId : self.rootObj,
                               mainGroupId : mainGroup},
                   'rootObject': rootId}
        for module in self.gbuildparser.modules:
            if module == 'include':
                continue
            sourceId, self.sourceObj = self.define_pbxgroup('Sources')
            includeId, self.includeObj = self.define_pbxgroup('Headers')
            moduleId, self.moduleObj = self.define_pbxgroup(module)

            self.moduleObj['children'] = [sourceId, includeId]
            pbxproj['objects'].update( {sourceId: self.sourceObj,
                                        includeId: self.includeObj,
                                        moduleId: self.moduleObj})
            mainGroup['children'].append(moduleId)

            for target in self.gbuildparser.modules[module]['targets']:
                pbxproj['objects'].update(self.generate_project(target))

        xcodeprojdir = './osx/libreoffice.xcodeproj'
        try:
            os.mkdir(xcodeprojdir)
        except:
            pass
        with open(os.path.join(xcodeprojdir, 'project.pbxproj'), 'w') as f:
            f.write('// !$*UTF8*$!\n')
            self.write_object(pbxproj, f, 0)


    def define_pbxgroup(self, name):
        return self.generate_id(), {'isa': 'PBXGroup','children': [],'name': name,'sourceTree': '<group>'}

    counter = 16777216

    def generate_id(self):
        XcodeIntegrationGenerator.counter += 1
        return str('X%07x' % XcodeIntegrationGenerator.counter)

    def indent(self, file, level):
        if level != 0:
            for i in range(0, level):
                file.write('\t')

    def write_object(self, object, file, indent):
        if isinstance(object, int):
            file.write('%d' % object)
        elif isinstance(object, str):
          if object == '':
              file.write('""')
          elif not re.search('[^A-Za-z0-9_]', object):
            file.write('%s' % object)
          else:
            file.write('"%s"' % object)
        elif isinstance(object, dict):
            file.write('{')
            file.write('\n')
            for key in sorted(object.keys()):
                self.indent(file, indent + 1)
                file.write('%s = ' % key)
                self.write_object(object[key], file, indent + 1)
                file.write(';\n')
            self.indent(file, indent)
            file.write('}')
        elif isinstance(object, list):
            file.write('(')
            for key in object:
                self.write_object(key, file, 1)
                file.write(',')
            file.write(')')
        elif isinstance(object, GbuildLinkTarget):
            file.write('""')


    def generate_target(self, modulename):
        if modulename.build_type == 'Library':
            product = 'com.apple.product-type.library.dynamic'
        elif modulename.build_type == 'Executable':
            product = 'com.apple.product-type.executable'
        elif modulename.build_type == 'CppunitTest':
            product = 'com.apple.product-type.cppunit'
        else:
            product = 'com.apple.product-type.something'

        result = {'isa': 'PBXLegacyTarget',
                  'buildConfigurationList': self.configurationListId,
                  'buildArgumentsString': modulename.target_name,
                  'buildPhases': [],
                  'dependencies': [],
                  'buildToolPath': 'make',
                  'buildWorkingDirectory': self.gbuildparser.builddir,
                  'name': modulename.target_name,
                  'productName': modulename.name,
                  'passBuildSettingsEnvironment': 1}
        return result

    def generate_configuration_debug(self, modulename):
        result = {'isa': 'XCBuildConfiguration',
                  'buildSettings': {
                      'ALWAYS_SEARCH_USER_PATHS': 'NO',
                      'CLANG_ANALYZER_NONNULL': 'YES',
                      'CLANG_CXX_LANGUAGE_STANDARD': 'gnu++0x',
                      'CLANG_CXX_LIBRARY': 'libc++',
                      'CLANG_ENABLE_MODULES': 'YES',
                      'CLANG_ENABLE_OBJC_ARC': 'YES',
                      'CLANG_WARN_BOOL_CONVERSION': 'YES',
                      'CLANG_WARN_CONSTANT_CONVERSION': 'YES',
                      'CLANG_WARN_DIRECT_OBJC_ISA_USAGE': 'YES_ERROR',
                      'CLANG_WARN_DOCUMENTATION_COMMENTS': 'YES',
                      'CLANG_WARN_EMPTY_BODY': 'YES',
                      'CLANG_WARN_ENUM_CONVERSION': 'YES',
                      'CLANG_WARN_INFINITE_RECURSION': 'YES',
                      'CLANG_WARN_INT_CONVERSION': 'YES',
                      'CLANG_WARN_OBJC_ROOT_CLASS': 'YES_ERROR',
                      'CLANG_WARN_SUSPICIOUS_MOVE': 'YES',
                      'CLANG_WARN_UNREACHABLE_CODE': 'YES',
                      'CLANG_WARN__DUPLICATE_METHOD_MATCH': 'YES',
                      'CODE_SIGN_IDENTITY': '-',
                      'COPY_PHASE_STRIP': 'NO',
                      'DEBUG_INFORMATION_FORMAT': 'dwarf',
                      'ENABLE_STRICT_OBJC_MSGSEND': 'YES',
                      'ENABLE_TESTABILITY': 'YES',
                      'GCC_C_LANGUAGE_STANDARD': 'gnu99',
                      'GCC_DYNAMIC_NO_PIC': 'NO',
                      'GCC_NO_COMMON_BLOCKS': 'YES',
                      'GCC_OPTIMIZATION_LEVEL': 0,
                      'GCC_PREPROCESSOR_DEFINITIONS': [
                            'DEBUG=1',
                            '$(inherited)'],
                      'GCC_WARN_64_TO_32_BIT_CONVERSION': 'YES',
                      'GCC_WARN_ABOUT_RETURN_TYPE': 'YES_ERROR',
                      'GCC_WARN_UNDECLARED_SELECTOR': 'YES',
                      'GCC_WARN_UNINITIALIZED_AUTOS': 'YES_AGGRESSIVE',
                      'GCC_WARN_UNUSED_FUNCTION': 'YES',
                      'GCC_WARN_UNUSED_VARIABLE': 'YES',
                      'MACOSX_DEPLOYMENT_TARGET': '10.12',
                      'MTL_ENABLE_DEBUG_INFO': 'YES',
                      'ONLY_ACTIVE_ARCH': 'YES',
                      'PRODUCT_NAME': '$(TARGET_NAME)',
                      'SDKROOT': 'macosx',
                      'HEADER_SEARCH_PATHS': modulename.include},
                  'name': 'Debug'}
        return result

    def generate_configuration_list(self, modulename):
        result = {'isa': 'XCConfigurationList',
                  'buildConfigurations': [self.configurationDebugId],
                  'defaultConfigurationIsVisible': 0,
                  'defaultConfigurationName': 'Debug'}
        return result

    def build_source_list(self, module):
        self.sourceRefList = {}
        self.sourceList = {}

        for i in module.cxxobjects:
            ref = self.generate_id()
            self.sourceList[self.generate_id()] = ref
            self.sourceRefList[ref] = {'lastKnownFileType': 'sourcecode.cpp.cpp',
                                       'path': i + '.cxx',
                                       'sourceTree': '<group>'}

    def generate_project(self, target):
        self.targetId = self.generate_id()
        self.configurationListId = self.generate_id()
        self.configurationDebugId = self.generate_id()

        self.productReferenceId = self.generate_id()
        self.productGroupId = self.generate_id()
        self.build_source_list(target)
        self.sourceObj['children'].extend(list(self.sourceRefList.keys()))

        self.rootObj['attributes']['TargetAttributes'].update({
        self.targetId: {'CreatedOnToolsVersion': '8.2',
                        'ProvisioningStyle': 'Automatic'}})
        self.rootObj['buildConfigurationList'] = self.configurationListId
        self.rootObj['targets'].append(self.targetId)
        objects = {self.targetId: self.generate_target(target),
                   self.configurationListId: self.generate_configuration_list(target),
                   self.configurationDebugId: self.generate_configuration_debug(target)
                   }
        for i in self.sourceList.keys():
            ref = self.sourceList[i]
            path = self.sourceRefList[ref]['path']
            name = '/'.join(path.split('/')[2:])
            objects[ref] = {'isa': 'PBXFileReference',
                            'lastKnownFileType': self.sourceRefList[ref]['lastKnownFileType'],
                            'path': path,
                            'name': name,
                            'fileEncoding': 4,
                            'sourceTree': '<group>'}
        return objects


class VisualStudioIntegrationGenerator(IdeIntegrationGenerator):

    def __init__(self, gbuildparser, ide):
        IdeIntegrationGenerator.__init__(self, gbuildparser, ide)
        self.toolset = self.retrieve_toolset()
        self.solution_directory = './'
        self.configurations = {
            'Build': {
                'build': self.module_make_command('%(target)s'),
                'clean': self.module_make_command('%(target)s.clean'),
                'rebuild': self.module_make_command('%(target)s.clean %(target)s')
            },
            'Unit Tests': {
                'build': self.module_make_command('unitcheck'),
                'clean': self.module_make_command('clean'),
                'rebuild': self.module_make_command('clean unitcheck'),
            },
            'Integration tests': {
                'build': self.module_make_command('unitcheck slowcheck screenshot subsequentcheck'),
                'clean': self.module_make_command('clean'),
                'rebuild': self.module_make_command('clean unitcheck slowcheck screenshot subsequentcheck')
            }
        }

    def retrieve_toolset(self):
        return {'vs2013': 'v120', 'vs2015': 'v140'}.get(self.ide, None)

    def module_make_command(self, targets):
        return '%(sh)s -c "PATH=\\"/bin:$PATH\\";BUILDDIR=\\"%(builddir)s\\" %(makecmd)s -rsC %(location)s ' + targets + '"'

    class Project:

        def __init__(self, guid, target, project_path):
            self.guid = guid
            self.target = target
            self.path = project_path

    def emit(self):
        all_projects = []
        for module in self.gbuildparser.modules:
            projects = []
            module_directory = os.path.join(self.solution_directory, module)
            if module != 'include': #FIXME
                for target in self.gbuildparser.modules[module]['targets']:
                    project_path = os.path.join(module_directory, '%s.vcxproj' % target.target_name)
                    project_guid = self.write_project(project_path, target)
                    p = VisualStudioIntegrationGenerator.Project(project_guid, target, project_path)
                    projects.append(p)
                self.write_solution(os.path.join(module_directory, '%s.sln' % module), projects)
                all_projects += projects

        self.write_solution(os.path.join(self.solution_directory, 'LibreOffice.sln'), all_projects)

    nmake_project_guid = '8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942'

    def get_dependency_libs(self, linked_libs, library_projects):
        dependency_libs = {}
        for linked_lib in linked_libs:
            for library_project in library_projects:
                if library_project.target.name == linked_lib:
                    dependency_libs[library_project.guid] = library_project
        return dependency_libs

    def write_solution(self, solution_path, projects):
        print('Solution %s:' % os.path.splitext(os.path.basename(solution_path))[0], end='')
        library_projects = [project for project in projects if project.target.build_type == 'Library']
        with open(solution_path, 'w') as f:
            f.write('Microsoft Visual Studio Solution File, Format Version 12.00\n')
            for project in projects:
                target = project.target
                print(' %s' % target.target_name, end='')
                proj_path = os.path.relpath(project.path, os.path.abspath(os.path.dirname(solution_path)))
                f.write('Project("{%s}") = "%s", "%s", "{%s}"\n' %
                        (VisualStudioIntegrationGenerator.nmake_project_guid,
                         target.target_name, proj_path, project.guid))
                libs_in_solution = self.get_dependency_libs(target.linked_libs,
                                                            library_projects)
                if libs_in_solution:
                    f.write('\tProjectSection(ProjectDependencies) = postProject\n')
                    for lib_guid in libs_in_solution.keys():
                        f.write('\t\t{%(guid)s} = {%(guid)s}\n' % {'guid': lib_guid})
                    f.write('\tEndProjectSection\n')
                f.write('EndProject\n')
            f.write('Global\n')
            platform = 'Win32'
            f.write('\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n')
            for cfg in self.configurations:
                f.write('\t\t%(cfg)s|%(platform)s = %(cfg)s|%(platform)s\n' % {'cfg': cfg, 'platform': platform})
            f.write('\tEndGlobalSection\n')
            f.write('\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n')
            # Specifies project configurations for solution configuration
            for project in projects:
                for cfg in self.configurations:
                    params = {'guid': project.guid, 'sol_cfg': cfg, 'proj_cfg': cfg, 'platform': platform}
                    f.write('\t\t{%(guid)s}.%(sol_cfg)s|%(platform)s.ActiveCfg = %(proj_cfg)s|%(platform)s\n' % params)
                    # Build.0 is basically 'Build checkbox' in configuration manager
                    f.write('\t\t{%(guid)s}.%(sol_cfg)s|%(platform)s.Build.0 = %(proj_cfg)s|%(platform)s\n' % params)
            f.write('\tEndGlobalSection\n')
            f.write('EndGlobal\n')
        print('')

    def write_project(self, project_path, target):
        # See info at http://blogs.msdn.com/b/visualstudio/archive/2010/05/14/a-guide-to-vcxproj-and-props-file-structure.aspx
        folder = os.path.dirname(project_path)
        if not os.path.exists(folder):
            os.makedirs(folder)
        project_guid = str(uuid.uuid4()).upper()
        ns = 'http://schemas.microsoft.com/developer/msbuild/2003'
        ET.register_namespace('', ns)
        proj_node = ET.Element('{%s}Project' % ns, DefaultTargets='Build', ToolsVersion='4.0')
        proj_confs_node = ET.SubElement(proj_node, '{%s}ItemGroup' % ns, Label='ProjectConfigurations')
        platform = 'Win32'
        for configuration in self.configurations:
            proj_conf_node = ET.SubElement(proj_confs_node,
                                           '{%s}ProjectConfiguration' % ns,
                                           Include='%s|%s' % (configuration, platform))
            conf_node = ET.SubElement(proj_conf_node, '{%s}Configuration' % ns)
            conf_node.text = configuration
            platform_node = ET.SubElement(proj_conf_node, '{%s}Platform' % ns)
            platform_node.text = platform

        globals_node = ET.SubElement(proj_node, '{%s}PropertyGroup' % ns, Label='Globals')
        proj_guid_node = ET.SubElement(globals_node, '{%s}ProjectGuid' % ns)
        proj_guid_node.text = '{%s}' % project_guid
        proj_keyword_node = ET.SubElement(globals_node, '{%s}Keyword' % ns)
        proj_keyword_node.text = 'MakeFileProj'
        proj_name_node = ET.SubElement(globals_node, '{%s}ProjectName' % ns)
        proj_name_node.text = target.target_name

        ET.SubElement(proj_node, '{%s}Import' % ns, Project='$(VCTargetsPath)\Microsoft.Cpp.Default.props')
        for configuration in self.configurations:
            conf_node = ET.SubElement(proj_node, '{%s}PropertyGroup' % ns, Label="Configuration",
                                      Condition="'$(Configuration)|$(Platform)'=='%s|%s'" % (configuration, platform))
            # Type of project used by the MSBuild to determine build process, see Microsoft.Makefile.targets
            conf_type_node = ET.SubElement(conf_node, '{%s}ConfigurationType' % ns)
            conf_type_node.text = 'Makefile'
            # VS2012: I need to have this otherwise the names of projects will contain text Visual Studio 2010 in the Solution Explorer
            platform_toolset_node = ET.SubElement(conf_node, '{%s}PlatformToolset' % ns)
            platform_toolset_node.text = self.toolset

        ET.SubElement(proj_node, '{%s}Import' % ns, Project='$(VCTargetsPath)\Microsoft.Cpp.props')
        ET.SubElement(proj_node, '{%s}ImportGroup' % ns, Label='ExtensionSettings')
        for configuration in self.configurations:
            prop_sheets_node = ET.SubElement(proj_node, '{%s}ImportGroup' % ns, Label='Configuration',
                                             Condition="'$(Configuration)|$(Platform)'=='%s|%s'" % (configuration, platform))
            ET.SubElement(prop_sheets_node, '{%s}Import' % ns,
                          Project='$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props',
                          Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')",
                          Label='LocalAppDataPlatform')

        ET.SubElement(proj_node, '{%s}PropertyGroup' % ns, Label='UserMacros')
        for cfg_name, cfg_targets in self.configurations.items():
            conf_node = ET.SubElement(proj_node, '{%s}PropertyGroup' % ns,
                                      Condition="'$(Configuration)|$(Platform)'=='%s|%s'" % (cfg_name, platform))
            nmake_params = {
                'sh': os.path.join(self.gbuildparser.binpath, 'dash.exe'),
                'builddir': self.gbuildparser.builddir,
                'location': target.location,
                'makecmd': self.gbuildparser.makecmd,
                'target': target.target_name}
            nmake_build_node = ET.SubElement(conf_node, '{%s}NMakeBuildCommandLine' % ns)
            nmake_build_node.text = cfg_targets['build'] % nmake_params
            nmake_clean_node = ET.SubElement(conf_node, '{%s}NMakeCleanCommandLine' % ns)
            nmake_clean_node.text = cfg_targets['clean'] % nmake_params
            nmake_rebuild_node = ET.SubElement(conf_node, '{%s}NMakeReBuildCommandLine' % ns)
            nmake_rebuild_node.text = cfg_targets['rebuild'] % nmake_params
            nmake_output_node = ET.SubElement(conf_node, '{%s}NMakeOutput' % ns)
            nmake_output_node.text = os.path.join(self.gbuildparser.instdir, 'program', 'soffice.exe')
            nmake_defs_node = ET.SubElement(conf_node, '{%s}NMakePreprocessorDefinitions' % ns)
            nmake_defs_node.text = ';'.join(list(target.defs) + ['$(NMakePreprocessorDefinitions)'])
            include_path_node = ET.SubElement(conf_node, '{%s}IncludePath' % ns)
            include_path_node.text = ';'.join(target.include + ['$(IncludePath)'])

        ET.SubElement(proj_node, '{%s}ItemDefinitionGroup' % ns)

        cxxobjects_node = ET.SubElement(proj_node, '{%s}ItemGroup' % ns)
        for cxxobject in target.cxxobjects:
            cxxabspath = os.path.join(self.gbuildparser.srcdir, cxxobject)
            cxxfile = cxxabspath + '.cxx'
            if os.path.isfile(cxxfile):
                ET.SubElement(cxxobjects_node, '{%s}ClCompile' % ns, Include=cxxfile)
            else:
                print('Source %s in project %s does not exist' % (cxxfile, target.target_name))

        includes_node = ET.SubElement(proj_node, '{%s}ItemGroup' % ns)
        for cxxobject in target.cxxobjects:
            include_abs_path = os.path.join(self.gbuildparser.srcdir, cxxobject)
            hxxfile = include_abs_path + '.hxx'
            if os.path.isfile(hxxfile):
                ET.SubElement(includes_node, '{%s}ClInclude' % ns, Include=hxxfile)
            # Few files have corresponding .h files
            hfile = include_abs_path + '.h'
            if os.path.isfile(hfile):
                ET.SubElement(includes_node, '{%s}ClInclude' % ns, Include=hfile)
        ET.SubElement(proj_node, '{%s}Import' % ns, Project='$(VCTargetsPath)\Microsoft.Cpp.targets')
        ET.SubElement(proj_node, '{%s}ImportGroup' % ns, Label='ExtensionTargets')
        self.write_pretty_xml(proj_node, project_path)
        self.write_filters(project_path + '.filters',
                           os.path.join(self.gbuildparser.srcdir, os.path.basename(target.location)),
                           [cxx_node.get('Include') for cxx_node in cxxobjects_node.findall('{%s}ClCompile' % ns)],
                           [include_node.get('Include') for include_node in includes_node.findall('{%s}ClInclude' % ns)])
        return project_guid

    def get_filter(self, module_dir, proj_file):
        return '\\'.join(os.path.relpath(proj_file, module_dir).split('/')[:-1])

    def get_subfilters(self, proj_filter):
        parts = proj_filter.split('\\')
        subfilters = set([proj_filter])
        for i in range(1, len(parts)):
            subfilters.add('\\'.join(parts[:i]))
        return subfilters

    def write_pretty_xml(self, node, file_path):
        xml_str = ET.tostring(node, encoding='unicode')
        pretty_str = minidom.parseString(xml_str).toprettyxml(encoding='utf-8')
        with open(file_path, 'w') as f:
            f.write(pretty_str.decode())

    def add_nodes(self, files_node, module_dir, tag, project_files):
        ns = 'http://schemas.microsoft.com/developer/msbuild/2003'
        filters = set()
        for project_file in project_files:
            file_node = ET.SubElement(files_node, tag, Include=project_file)
            if os.path.commonprefix([module_dir, project_file]) == module_dir:
                project_filter = self.get_filter(module_dir, project_file)
                filter_node = ET.SubElement(file_node, '{%s}Filter' % ns)
                filter_node.text = project_filter
                filters |= self.get_subfilters(project_filter)
        return filters

    def write_filters(self, filters_path, module_dir, compile_files, include_files):
        ns = 'http://schemas.microsoft.com/developer/msbuild/2003'
        ET.register_namespace('', ns)
        proj_node = ET.Element('{%s}Project' % ns, ToolsVersion='4.0')
        filters = set()
        compiles_node = ET.SubElement(proj_node, '{%s}ItemGroup' % ns)
        filters |= self.add_nodes(compiles_node, module_dir, '{%s}ClCompile' % ns, compile_files)
        include_node = ET.SubElement(proj_node, '{%s}ItemGroup' % ns)
        filters |= self.add_nodes(include_node, module_dir, '{%s}ClInclude' % ns, include_files)

        filters_node = ET.SubElement(proj_node, '{%s}ItemGroup' % ns)
        for proj_filter in filters:
            filter_node = ET.SubElement(filters_node, '{%s}Filter' % ns, Include=proj_filter)
            filter_id_node = ET.SubElement(filter_node, '{%s}UniqueIdentifier' % ns)
            filter_id_node.text = '{%s}' % str(uuid.uuid4())
        self.write_pretty_xml(proj_node, filters_path)


class QtCreatorIntegrationGenerator(IdeIntegrationGenerator):

    def __init__(self, gbuildparser, ide):
        IdeIntegrationGenerator.__init__(self, gbuildparser, ide)
        self.target_by_location = {}
        for m in self.gbuildparser.modules:
            for target in self.gbuildparser.modules[m]['targets']:
                if target.location not in self.target_by_location:
                    self.target_by_location[target.location] = set()
                self.target_by_location[target.location] |= set([target])

        self._do_log = False  # set to 'True' to activate log of QtCreatorIntegrationGenerator
        if self._do_log:
            qtlog_path = os.path.abspath('../qtlog_.txt')
            self.qtlog = open(qtlog_path, 'w')

    def _log(self, message):
        if self._do_log:
            self.qtlog.write(message)

    def log_close(self):
        if self._do_log:
            self.qtlog.close()

    def generate_build_configs(self, lib_folder):
        module_folder = os.path.join(self.base_folder, lib_folder)
        xml = ""
        # In QtCreator UI, build configs are listed alphabetically,
        # so it can be different from the creation order.
        # So we prefix the names with the index.
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '0',
            'base_folder': module_folder,
            'arg': "",
            'name': "1-Build %s" % lib_folder,
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '1',
            'base_folder': module_folder,
            'arg': "unitcheck",
            'name': "2-Local tests -- quick tests (unitcheck)",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '2',
            'base_folder': module_folder,
            'arg': "unitcheck slowcheck screenshot",
            'name': "3-Local tests -- slow tests (unitcheck, slowcheck, screenshot)",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '3',
            'base_folder': module_folder,
            'arg': "unitcheck slowcheck screenshot subsequentcheck",
            'name': "4-Local tests -- integration tests (unitcheck, slowcheck, screenshot, subsequentcheck)",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '4',
            'base_folder': self.base_folder,
            'arg': "unitcheck",
            'name': "5-Global tests -- quick tests (unitcheck)",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '5',
            'base_folder': self.base_folder,
            'arg': "unitcheck slowcheck screenshot",
            'name': "6-Global tests -- slow tests (unitcheck, slowcheck, screenshot)",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '6',
            'base_folder': self.base_folder,
            'arg': "unitcheck slowcheck screenshot subsequentcheck",
            'name': "7-Global tests -- integration tests (unitcheck, slowcheck, screenshot, subsequentcheck)",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '7',
            'base_folder': self.base_folder,
            'arg': "build-nocheck",
            'name': "8-Global build -- nocheck",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '8',
            'base_folder': self.base_folder,
            'arg': "",
            'name': "9-Global build",
        }

        xml += QtCreatorIntegrationGenerator.build_configs_count_template % {
            'nb': '9',
        }
        return xml

    def generate_meta_build_configs(self):
        xml = ""
        # In QtCreator UI, build configs are listed alphabetically,
        # so it can be different from the creation order.
        # So we prefix the names with the index.
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '0',
            'base_folder': self.base_folder,
            'arg': "",
            'name': "01-Global Build",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '1',
            'base_folder': self.base_folder,
            'arg': "unitcheck",
            'name': "02-Global tests -- quick tests (unitcheck)",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '2',
            'base_folder': self.base_folder,
            'arg': "unitcheck slowcheck screenshot",
            'name': "03-Global tests -- slow tests (unitcheck, slowcheck, screenshot)",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '3',
            'base_folder': self.base_folder,
            'arg': "unitcheck slowcheck screenshot subsequentcheck",
            'name': "04-Global tests -- integration tests (unitcheck, slowcheck, screenshot, subsequentcheck)",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '4',
            'base_folder': self.base_folder,
            'arg': "perfcheck",
            'name': "05-Global tests -- performance tests (perfcheck)",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '5',
            'base_folder': self.base_folder,
            'arg': "check",
            'name': "06-Global tests -- tests (check)",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '6',
            'base_folder': self.base_folder,
            'arg': "build-nocheck",
            'name': "07-Global build -- nocheck",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '7',
            'base_folder': self.base_folder,
            'arg': "build-l10n-only",
            'name': "08-Global build -- build-l10n-only",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '8',
            'base_folder': self.base_folder,
            'arg': "build-non-l10n-only",
            'name': "09-Global build -- build-non-l10n-only",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '9',
            'base_folder': self.base_folder,
            'arg': "clean",
            'name': "10-Global build -- clean",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '10',
            'base_folder': self.base_folder,
            'arg': "clean-build",
            'name': "11-Global build -- clean-build",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_template % {
            'index': '11',
            'base_folder': self.base_folder,
            'arg': "clean-host",
            'name': "12-Global build -- clean-host",
        }
        xml += QtCreatorIntegrationGenerator.build_configs_count_template % {
            'nb': '12',
        }
        return xml

    # By default, QtCreator creates 2 BuildStepList : "Build" et "Clean"
    # but the "clean" can be empty.
    build_configs_template = """
    <valuemap type="QVariantMap" key="ProjectExplorer.Target.BuildConfiguration.%(index)s">
    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory">%(base_folder)s</value>

    <valuemap type="QVariantMap" key="ProjectExplorer.BuildConfiguration.BuildStepList.0">

     <valuemap type="QVariantMap" key="ProjectExplorer.BuildStepList.Step.0">
      <value type="bool" key="ProjectExplorer.BuildStep.Enabled">true</value>
      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Make</value>
      <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
      <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.MakeStep</value>
      <valuelist type="QVariantList" key="Qt4ProjectManager.MakeStep.AutomaticallyAddedMakeArguments">
       <value type="QString">-w</value>
       <value type="QString">-r</value>
      </valuelist>
      <value type="bool" key="Qt4ProjectManager.MakeStep.Clean">false</value>
      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeArguments">%(arg)s</value>
      <value type="QString" key="Qt4ProjectManager.MakeStep.MakeCommand"></value>
     </valuemap>

     <value type="int" key="ProjectExplorer.BuildStepList.StepsCount">1</value>
     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Build</value>
     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
     <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.BuildSteps.Build</value>
    </valuemap>

    <value type="int" key="ProjectExplorer.BuildConfiguration.BuildStepListCount">1</value>
    <value type="bool" key="ProjectExplorer.BuildConfiguration.ClearSystemEnvironment">false</value>
    <valuelist type="QVariantList" key="ProjectExplorer.BuildConfiguration.UserEnvironmentChanges"/>
    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">%(name)s</value>
    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
    <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">Qt4ProjectManager.Qt4BuildConfiguration</value>
    <value type="int" key="Qt4ProjectManager.Qt4BuildConfiguration.BuildConfiguration">%(index)s</value>
    <value type="bool" key="Qt4ProjectManager.Qt4BuildConfiguration.UseShadowBuild">true</value>
   </valuemap>
   """

    build_configs_count_template = """
   <!-- nb build configurations -->
   <value type="int" key="ProjectExplorer.Target.BuildConfigurationCount">%(nb)s</value>
   """

    def generate_deploy_configs(self, lib_folder):
        xml = QtCreatorIntegrationGenerator.deploy_configs_template % {}
        return xml

    deploy_configs_template = """
   <valuemap type="QVariantMap" key="ProjectExplorer.Target.DeployConfiguration.0">
    <valuemap type="QVariantMap" key="ProjectExplorer.BuildConfiguration.BuildStepList.0">
     <value type="int" key="ProjectExplorer.BuildStepList.StepsCount">0</value>
     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Deploy</value>
     <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
     <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.BuildSteps.Deploy</value>
    </valuemap>
    <value type="int" key="ProjectExplorer.BuildConfiguration.BuildStepListCount">1</value>
    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Deploy locally</value>
    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
    <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.DefaultDeployConfiguration</value>
   </valuemap>
   <value type="int" key="ProjectExplorer.Target.DeployConfigurationCount">1</value>
    """

    def generate_run_configs(self, lib_folder):

        # If we use 'soffice', it's ok only for "Run", not for "Debug".
        # So we put "soffice.bin" that is ok for both.
        loexec = "%s/instdir/program/soffice.bin" % self.base_folder
        xml = QtCreatorIntegrationGenerator.run_configs_template % {
            'loexec': loexec,
            'workdir': self.base_folder
        }
        return xml

    run_configs_template = """
   <valuemap type="QVariantMap" key="ProjectExplorer.Target.RunConfiguration.0">
    <valuelist type="QVariantList" key="Analyzer.Valgrind.AddedSuppressionFiles"/>
    <value type="bool" key="Analyzer.Valgrind.Callgrind.CollectBusEvents">false</value>
    <value type="bool" key="Analyzer.Valgrind.Callgrind.CollectSystime">false</value>
    <value type="bool" key="Analyzer.Valgrind.Callgrind.EnableBranchSim">false</value>
    <value type="bool" key="Analyzer.Valgrind.Callgrind.EnableCacheSim">false</value>
    <value type="bool" key="Analyzer.Valgrind.Callgrind.EnableEventToolTips">true</value>
    <value type="double" key="Analyzer.Valgrind.Callgrind.MinimumCostRatio">0.01</value>
    <value type="double" key="Analyzer.Valgrind.Callgrind.VisualisationMinimumCostRatio">10</value>
    <value type="bool" key="Analyzer.Valgrind.FilterExternalIssues">true</value>
    <value type="int" key="Analyzer.Valgrind.LeakCheckOnFinish">1</value>
    <value type="int" key="Analyzer.Valgrind.NumCallers">25</value>
    <valuelist type="QVariantList" key="Analyzer.Valgrind.RemovedSuppressionFiles"/>
    <value type="int" key="Analyzer.Valgrind.SelfModifyingCodeDetection">1</value>
    <value type="bool" key="Analyzer.Valgrind.Settings.UseGlobalSettings">true</value>
    <value type="bool" key="Analyzer.Valgrind.ShowReachable">false</value>
    <value type="bool" key="Analyzer.Valgrind.TrackOrigins">true</value>
    <value type="QString" key="Analyzer.Valgrind.ValgrindExecutable">valgrind</value>
    <valuelist type="QVariantList" key="Analyzer.Valgrind.VisibleErrorKinds">
     <value type="int">0</value>
     <value type="int">1</value>
     <value type="int">2</value>
     <value type="int">3</value>
     <value type="int">4</value>
     <value type="int">5</value>
     <value type="int">6</value>
     <value type="int">7</value>
     <value type="int">8</value>
     <value type="int">9</value>
     <value type="int">10</value>
     <value type="int">11</value>
     <value type="int">12</value>
     <value type="int">13</value>
     <value type="int">14</value>
    </valuelist>
    <value type="int" key="PE.EnvironmentAspect.Base">2</value>
    <valuelist type="QVariantList" key="PE.EnvironmentAspect.Changes"/>

    <value type="QString" key="ProjectExplorer.CustomExecutableRunConfiguration.Arguments"></value>
    <value type="QString" key="ProjectExplorer.CustomExecutableRunConfiguration.Executable">%(loexec)s</value>
    <value type="bool" key="ProjectExplorer.CustomExecutableRunConfiguration.UseTerminal">false</value>
    <value type="QString" key="ProjectExplorer.CustomExecutableRunConfiguration.WorkingDirectory">%(workdir)s</value>
    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Run libreoffice/instdir/program/soffice</value>
    <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName"></value>
    <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">ProjectExplorer.CustomExecutableRunConfiguration</value>
    <value type="uint" key="RunConfiguration.QmlDebugServerPort">3768</value>
    <value type="bool" key="RunConfiguration.UseCppDebugger">false</value>
    <value type="bool" key="RunConfiguration.UseCppDebuggerAuto">true</value>
    <value type="bool" key="RunConfiguration.UseMultiProcess">false</value>
    <value type="bool" key="RunConfiguration.UseQmlDebugger">false</value>
    <value type="bool" key="RunConfiguration.UseQmlDebuggerAuto">true</value>

   </valuemap>
   <value type="int" key="ProjectExplorer.Target.RunConfigurationCount">1</value>
    """

    def generate_pro_user_content(self, lib_folder):

        build_configs = self.generate_build_configs(lib_folder)
        deploy_configs = self.generate_deploy_configs(lib_folder)
        run_configs = self.generate_run_configs(lib_folder)

        xml = QtCreatorIntegrationGenerator.pro_user_template % {
            'build_configs': build_configs,
            'deploy_configs': deploy_configs,
            'run_configs': run_configs,
        }
        return xml

    def generate_meta_pro_user_content(self):

        build_configs = self.generate_meta_build_configs()
        deploy_configs = self.generate_deploy_configs("")
        run_configs = self.generate_run_configs("")

        xml = QtCreatorIntegrationGenerator.pro_user_template % {
            'build_configs': build_configs,
            'deploy_configs': deploy_configs,
            'run_configs': run_configs,
        }
        return xml

    pro_user_template = """<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE QtCreatorProject>
<!-- Written by QtCreator 3.1.1, 2015-05-14T15:54:34. -->
<qtcreator>
 <data>
  <variable>ProjectExplorer.Project.ActiveTarget</variable>
  <value type="int">0</value>
 </data>

 <!-- editor settings -->
 <data>
  <variable>ProjectExplorer.Project.EditorSettings</variable>
  <valuemap type="QVariantMap">
   <value type="bool" key="EditorConfiguration.AutoIndent">true</value>
   <value type="bool" key="EditorConfiguration.AutoSpacesForTabs">false</value>
   <value type="bool" key="EditorConfiguration.CamelCaseNavigation">true</value>
   <valuemap type="QVariantMap" key="EditorConfiguration.CodeStyle.0">
    <value type="QString" key="language">Cpp</value>
    <valuemap type="QVariantMap" key="value">
     <value type="QByteArray" key="CurrentPreferences">CppGlobal</value>
    </valuemap>
   </valuemap>
   <valuemap type="QVariantMap" key="EditorConfiguration.CodeStyle.1">
    <value type="QString" key="language">QmlJS</value>
    <valuemap type="QVariantMap" key="value">
     <value type="QByteArray" key="CurrentPreferences">QmlJSGlobal</value>
    </valuemap>
   </valuemap>
   <value type="int" key="EditorConfiguration.CodeStyle.Count">2</value>
   <value type="QByteArray" key="EditorConfiguration.Codec">UTF-8</value>
   <value type="bool" key="EditorConfiguration.ConstrainTooltips">false</value>
   <value type="int" key="EditorConfiguration.IndentSize">4</value>
   <value type="bool" key="EditorConfiguration.KeyboardTooltips">false</value>
   <value type="int" key="EditorConfiguration.MarginColumn">80</value>
   <value type="bool" key="EditorConfiguration.MouseHiding">true</value>
   <value type="bool" key="EditorConfiguration.MouseNavigation">true</value>
   <value type="int" key="EditorConfiguration.PaddingMode">1</value>
   <value type="bool" key="EditorConfiguration.ScrollWheelZooming">true</value>
   <value type="bool" key="EditorConfiguration.ShowMargin">false</value>
   <value type="int" key="EditorConfiguration.SmartBackspaceBehavior">1</value>
   <value type="bool" key="EditorConfiguration.SpacesForTabs">true</value>
   <value type="int" key="EditorConfiguration.TabKeyBehavior">0</value>
   <value type="int" key="EditorConfiguration.TabSize">8</value>
   <value type="bool" key="EditorConfiguration.UseGlobal">true</value>
   <value type="int" key="EditorConfiguration.Utf8BomBehavior">1</value>
   <value type="bool" key="EditorConfiguration.addFinalNewLine">true</value>
   <value type="bool" key="EditorConfiguration.cleanIndentation">true</value>
   <value type="bool" key="EditorConfiguration.cleanWhitespace">true</value>
   <value type="bool" key="EditorConfiguration.inEntireDocument">false</value>
  </valuemap>
 </data>

 <data>
  <variable>ProjectExplorer.Project.PluginSettings</variable>
  <valuemap type="QVariantMap"/>
 </data>

 <!-- target -->
 <data>
  <variable>ProjectExplorer.Project.Target.0</variable>
  <valuemap type="QVariantMap">
   <value type="QString" key="ProjectExplorer.ProjectConfiguration.DefaultDisplayName">Desktop</value>
   <value type="QString" key="ProjectExplorer.ProjectConfiguration.DisplayName">Desktop</value>
   <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">{0701de51-c96e-4e4f-85c3-e70b223c5076}</value>
   <value type="int" key="ProjectExplorer.Target.ActiveBuildConfiguration">0</value>
   <value type="int" key="ProjectExplorer.Target.ActiveDeployConfiguration">0</value>
   <value type="int" key="ProjectExplorer.Target.ActiveRunConfiguration">0</value>

   <!-- build configurations -->
   %(build_configs)s

   <!-- deploy configurations -->
   %(deploy_configs)s

   <!-- plugin settings -->
   <valuemap type="QVariantMap" key="ProjectExplorer.Target.PluginSettings"/>

   <!-- run configurations -->
   %(run_configs)s

  </valuemap>
 </data>
 <!-- nb targets : 1 -->
 <data>
  <variable>ProjectExplorer.Project.TargetCount</variable>
  <value type="int">1</value>
 </data>
 <data>
  <variable>ProjectExplorer.Project.Updater.EnvironmentId</variable>
  <value type="QByteArray">{5abcafed-86f6-49f6-b1cb-380fadd21211}</value>
 </data>
 <data>
  <variable>ProjectExplorer.Project.Updater.FileVersion</variable>
  <value type="int">15</value>
 </data>
</qtcreator>
"""

    def remove_qt_files(self):

        def do_remove_file(loc, afile):
            try:
                os.remove(os.path.join(loc, afile))
                self._log("removed %s\n" % afile)
            except OSError:
                self._log("unable to remove %s\n" % afile)

        do_remove_file(self.base_folder, "lo.pro")
        do_remove_file(self.base_folder, "lo.pro.user")
        for location in self.target_by_location:
            for f in os.listdir(location):
                if f.endswith('.pro') or f.endswith('.pro.user'):
                    do_remove_file(location, f)

    def get_source_extension(self, src_file):
        path = os.path.join(self.base_folder, src_file)
        for ext in (".cxx", ".cpp", ".c", ".mm"):
            if os.path.isfile(path + ext):
                return ext
        return ""

    def get_header_extension(self, src_file):
        path = os.path.join(self.base_folder, src_file)
        for ext in (".hxx", ".hpp", ".h"):
            if os.path.isfile(path + ext):
                return ext
        return ""

    def build_data_libs(self):

        self.data_libs = {}

        all_libs = []
        for m in self.gbuildparser.modules:
            for f in self.gbuildparser.modules[m]['targets']:
                all_libs.append(f)
        for lib in all_libs:
            self._log("\nlibrary : %s, loc=%s" % (lib.target_name, lib.location))
            lib_name = os.path.basename(lib.location)
            lib_folder = os.path.relpath(lib.location, self.base_folder)

            def lopath(path):
                return os.path.relpath(path, lib.location)

            defines_list = []
            sources_list = []
            includepath_list = []
            # The explicit headers list is not mandatory :
            # QtCreator just needs 'include_path_list' to find all headers files.
            # But files listed in 'header_list' will be shown
            # in a specific "Headers" folder in QtCreator's Project panel.
            # We will list here only headers files of current lib.
            headers_list = []
            for file_ in lib.cxxobjects:
                # the file has no extension : search it
                # self._log("\n    file : %s" % file_)
                ext = self.get_source_extension(file_)
                if ext:
                    sources_list.append(lopath(file_ + ext))

                # few cxxobject files have a header beside
                ext = self.get_header_extension(file_)
                if ext:
                    headers_list.append(lopath(file_ + ext))

            # List all include paths
            for hdir in lib.include:
                hf_lopath = lopath(hdir)
                includepath_list.append(hf_lopath)

            # List headers files from current lib
            for hdir in lib.include:
                if hdir.startswith(lib.location):
                    for hf in os.listdir(hdir):
                        if hf.endswith(('.h', '.hxx', '.hpp', '.hrc')):
                            hf_lopath = lopath(os.path.join(hdir, hf))
                            headers_list.append(hf_lopath)

            # List defines
            for key, value in lib.defs.items():
                define = key
                if value is not None:
                    define += '=' + value
                defines_list.append(define)

            # All datas are prepared, store them for the lib.
            if lib_folder in self.data_libs:
                self.data_libs[lib_folder]['sources'] |= set(sources_list)
                self.data_libs[lib_folder]['headers'] |= set(headers_list)
                self.data_libs[lib_folder]['includepath'] |= set(includepath_list)
                self.data_libs[lib_folder]['defines'] |= set(defines_list)
            else:
                self.data_libs[lib_folder] = {
                    'sources': set(sources_list),
                    'headers': set(headers_list),
                    'includepath': set(includepath_list),
                    'defines': set(defines_list),
                    'loc': lib.location,
                    'name': lib_name
                }

    def emit(self):

        self.base_folder = self.gbuildparser.builddir

        # we remove existing '.pro' and '.pro.user' files
        self.remove_qt_files()

        # for .pro files, we must explicitly list all files (.c, .h)
        # so we can't reuse directly the same method than for kde integration.
        self.build_data_libs()

        subdirs_list = self.data_libs.keys()
        # Now we can create Qt files
        for lib_folder in subdirs_list:
            sources_list = sorted(self.data_libs[lib_folder]['sources'])
            headers_list = sorted(self.data_libs[lib_folder]['headers'])
            includepath_list = sorted(self.data_libs[lib_folder]['includepath'])
            defines_list = sorted(self.data_libs[lib_folder]['defines'])
            lib_loc = self.data_libs[lib_folder]['loc']
            lib_name = self.data_libs[lib_folder]['name']

            sources = " \\\n".join(sources_list)
            headers = " \\\n".join(headers_list)
            includepath = " \\\n".join(includepath_list)
            defines = " \\\n".join(defines_list)

            # create .pro file
            qt_pro_file = '%s/%s.pro' % (lib_loc, lib_name)
            try:
                content = QtCreatorIntegrationGenerator.pro_template % {'sources': sources, 'headers': headers, 'includepath': includepath, 'defines': defines}
                mode = 'w+'
                with open(qt_pro_file, mode) as fpro:
                    fpro.write(content)
                self._log("created %s\n" % qt_pro_file)

            except Exception as e:
                print("ERROR : creating pro file=" + qt_pro_file, file=sys.stderr)
                print(e, file=sys.stderr)
                temp = traceback.format_exc()  # .decode('utf8')
                print(temp, file=sys.stderr)
                print("\n\n", file=sys.stderr)

            # create .pro.user file
            qt_pro_user_file = '%s/%s.pro.user' % (lib_loc, lib_name)
            try:
                with open(qt_pro_user_file, mode) as fprouser:
                    fprouser.write(self.generate_pro_user_content(lib_folder))
                self._log("created %s\n" % qt_pro_user_file)

            except Exception as e:
                print("ERROR : creating pro.user file=" + qt_pro_user_file, file=sys.stderr)
                print(e, file=sys.stderr)
                temp = traceback.format_exc()
                print(temp, file=sys.stderr)
                print("\n\n", file=sys.stderr)

        # create meta .pro file (lists all sub projects)
        qt_meta_pro_file = 'lo.pro'
        try:
            subdirs = " \\\n".join(subdirs_list)
            content = QtCreatorIntegrationGenerator.pro_meta_template % {'subdirs': subdirs}
            with open(qt_meta_pro_file, 'w+') as fmpro:
                fmpro.write(content)

        except Exception as e:
            print("ERROR : creating lo.pro file=" + qt_meta_pro_file, file=sys.stderr)
            print(e, file=sys.stderr)
            temp = traceback.format_exc()
            print(temp, file=sys.stderr)
            print("\n\n", file=sys.stderr)

        # create meta .pro.user file
        qt_meta_pro_user_file = 'lo.pro.user'
        try:
            with open(qt_meta_pro_user_file, mode) as fmprouser:
                fmprouser.write(self.generate_meta_pro_user_content())
            self._log("created %s\n" % qt_meta_pro_user_file)

        except Exception as e:
            print("ERROR : creating lo.pro.user file=" + qt_meta_pro_user_file, file=sys.stderr)
            print(e, file=sys.stderr)
            temp = traceback.format_exc()
            print(temp, file=sys.stderr)
            print("\n\n", file=sys.stderr)

        self.log_close()

    pro_template = """TEMPLATE = app
CONFIG += console
CONFIG -= app_bundle
CONFIG -= qt

INCLUDEPATH += %(includepath)s

SOURCES += %(sources)s

HEADERS += %(headers)s

DEFINES += %(defines)s

"""
    pro_meta_template = """TEMPLATE = subdirs

SUBDIRS = %(subdirs)s
"""


def get_options():
    parser = argparse.ArgumentParser(
        description='LibreOffice gbuild IDE project generator')
    parser.add_argument('--ide', dest='ide', required=True,
                        help='the IDE to generate project files for')
    parser.add_argument('--make', dest='makecmd', required=True,
                        help='the command to execute make')
    #add to debug a new functions in the project keeping contributors
    parser.add_argument('--debug',dest='debug',required=False,
                        help='debug the new functions')
    return parser.parse_args()


if __name__ == '__main__':
    args = get_options()
    # FIXME: Hack
    if args.makecmd == 'make':
        args.makecmd = '/usr/bin/make'


    paths = {}
    generators = {
        # Supported platforms
        'vs2013': VisualStudioIntegrationGenerator,
        'xcode': XcodeIntegrationGenerator,
        'debug': DebugIntegrationGenerator,

        # Old platforms
        'eclipsecdt': EclipseCDTIntegrationGenerator,
        'kdevelop': KdevelopIntegrationGenerator,
        'vs2015': VisualStudioIntegrationGenerator,
        'vim': VimIntegrationGenerator,
        'qtcreator': QtCreatorIntegrationGenerator,
    }

    if args.ide not in generators.keys():
        print("Invalid ide. valid values are %s" % ','.join(generators.keys()))
        sys.exit(1)

    gbuildparser = GbuildParser(args.makecmd).parse()

    generators[args.ide](gbuildparser, args.ide).emit()
    print("Successfully created the project files.")

# Local Variables:
# indent-tabs-mode: nil
# End:
#
# vim: set et sw=4 ts=4:
