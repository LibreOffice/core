#! /usr/bin/env python3
# -*- Mode: python; tab-width: 4; indent-tabs-mode: t -*-
#
# This file is part of the LibreOffice project.
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#

import re
import sys

class GbuildParserState:
    def __init__(self):
        self.include = []
        self.defs = []
        self.cxxobjects = []
        self.linked_libs = []

class GbuildLinkTarget:
    def __init__(self, name, location, include, defs, cxxobjects, linked_libs):
        (self.name, self.location, self.include, self.defs, self.cxxobjects, self.linked_libs) = (name, location, include, defs, cxxobjects, linked_libs)
    def short_name(self):
        return self.name
    def __str__(self):
        return '%s at %s with include path: %s, defines %s, objects: %s and linked libs: %s' % (self.short_name(), self.location, self.include, self.defs, self.cxxobjects, self.linked_libs)

class GbuildLib(GbuildLinkTarget):
    def __init__(self, name, location, include, defs, cxxobjects, linked_libs):
        GbuildLinkTarget.__init__(self, name, location, include, defs, cxxobjects, linked_libs)
    def short_name(self):
        return 'Library %s' % self.name

class GbuildExe(GbuildLinkTarget):
    def __init__(self, name, location, include, defs, cxxobjects, linked_libs):
        GbuildLinkTarget.__init__(self, name, location, include, defs, cxxobjects, linked_libs)
    def short_name(self):
        return 'Executable %s' % self.name

class GbuildParser:
    makecmdpattern = re.compile('^MAKE_COMMAND := (.*)')
    srcdirpattern = re.compile('^SRCDIR = (.*)')
    builddirpattern = re.compile('^BUILDDIR = (.*)')
    libpattern = re.compile('#  [a-z]+ to execute \(from `(.*)/Library_(.*)\.mk\', line [0-9]*\):')
    exepattern = re.compile('#  [a-z]+ to execute \(from `(.*)/Executable_(.*)\.mk\', line [0-9]*\):')
    includepattern = re.compile('# INCLUDE := (.*)')
    defspattern = re.compile('# DEFS := (.*)')
    cxxpattern = re.compile('# CXXOBJECTS := (.*)')
    linkedlibspattern = re.compile('# LINKED_LIBS := (.*)')
    def __init__(self):
        (self.makecmd, self.srcdir, self.builddir, self.libs, self.exes) = ('', '', '', [], [])
    def parse(self, gbuildstate):
        state = GbuildParserState()
        for line in gbuildstate:
            if not line.startswith('#'):
                makecmdmatch = GbuildParser.makecmdpattern.match(line)
                if makecmdmatch:
                    self.makecmd = makecmdmatch.group(1)
                    continue
                srcdirmatch = GbuildParser.srcdirpattern.match(line)
                if srcdirmatch:
                    self.srcdir = srcdirmatch.group(1)
                    continue
                builddirmatch = GbuildParser.builddirpattern.match(line)
                if builddirmatch:
                    self.builddir = builddirmatch.group(1)
                    continue
                state = GbuildParserState()
                continue
            libmatch = GbuildParser.libpattern.match(line)
            if libmatch:
                self.libs.append(GbuildLib(libmatch.group(2), libmatch.group(1), state.include, state.defs, state.cxxobjects, state.linked_libs))
                state = GbuildParserState()
                continue
            exematch = GbuildParser.exepattern.match(line)
            if exematch:
                self.exes.append(GbuildExe(exematch.group(2), exematch.group(1), state.include, state.defs, state.cxxobjects, state.linked_libs))
                state = GbuildParserState()
                continue
            includematch = GbuildParser.includepattern.match(line)
            if includematch:
                state.include = [includeswitch.strip()[2:] for includeswitch in includematch.group(1).split(' ') if len(includeswitch) > 2]
                continue
            defsmatch = GbuildParser.defspattern.match(line)
            if defsmatch:
                state.defs = [defswitch.strip()[2:] for defswitch in defsmatch.group(1).split(' ') if len(defswitch) >2]
                continue
            cxxmatch = GbuildParser.cxxpattern.match(line)
            if cxxmatch:
                state.cxxobjects = [obj for obj in cxxmatch.group(1).split(' ') if len(obj) > 0]
                continue
            linkedlibsmatch = GbuildParser.linkedlibspattern.match(line)
            if linkedlibsmatch:
                state.linked_libs = linkedlibsmatch.group(1).strip().split(' ')
                continue
            #we could match a lot of other stuff here if needed for integration rpaths etc.
        return self

class IdeIntegrationGenerator:
    def __init__(self, gbuildparser):
        self.gbuildparser = gbuildparser
    def emit(self):
        pass

class DebugIntegrationGenerator(IdeIntegrationGenerator):
    def __init__(self, gbuildparser):
        IdeIntegrationGenerator.__init__(self, gbuildparser)
    def emit(self):
        print(self.gbuildparser.srcdir)
        print(self.gbuildparser.builddir)
        for lib in self.gbuildparser.libs:
            print(lib)
        for exe in self.gbuildparser.exes:
            print(exe)

class KdevelopIntegrationGenerator(IdeIntegrationGenerator):
    buildsystemtemplate = """
[CustomBuildSystem]
CurrentConfiguration=BuildConfig%(defaultconfigid)d
"""
    buildsystemconfigtemplate = """
[CustomBuildSystem][BuildConfig%(configid)d]
BuildDir=file://%(builddir)s
Title=%(title)s

[CustomBuildSystem][BuildConfig%(configid)d][ProjectPath0]
Defines=\\x00\\x00\\x00\\x00
Includes=\\x00\\x00\\x00\\x00
Path=.
"""
    buildsystemconfigtooltemplate = """
[CustomBuildSystem][BuildConfig%(configid)d][Tool%(tool)s]
Arguments=%(args)s
Enabled=true
Environment=
Executable=%(exe)s
Type=%(typenr)d
"""
    def generate_buildsystemconfigtool(self, configid, tool, args, exe, typenr):
        return KdevelopIntegrationGenerator.buildsystemconfigtooltemplate % { 'configid' : configid, 'tool' : tool, 'args' : args, 'exe' : exe, 'typenr' : typenr }
    def generate_buildsystemconfig(self, configid, builddir, title, buildparms = ''):
        result = KdevelopIntegrationGenerator.buildsystemconfigtemplate % { 'configid' : configid, 'builddir' : builddir, 'title' : title }
        result += self.generate_buildsystemconfigtool(configid, 'Clean', 'clean %s' % buildparms, self.gbuildparser.makecmd, 3)
        result += self.generate_buildsystemconfigtool(configid, 'Build', 'all %s' % buildparms, self.gbuildparser.makecmd, 0)
        return result
    def generate_buildsystem(self, moduledir):
        result = KdevelopIntegrationGenerator.buildsystemtemplate % { 'defaultconfigid' : 0 }
        result += self.generate_buildsystemconfig(0, moduledir, 'Module Build -- Release')
        result += self.generate_buildsystemconfig(1, self.gbuildparser.builddir, 'Full Build -- Release')
        result += self.generate_buildsystemconfig(2, moduledir, 'Module Build -- Debug', 'debug=T')
        result += self.generate_buildsystemconfig(3, self.gbuildparser.builddir, 'Full Build -- Debug', 'debug=T')
        return result
    def __init__(self, gbuildparser):
        IdeIntegrationGenerator.__init__(self, gbuildparser)
        self.target_by_location = {}
        self.target_by_path = {}
        for target in set(self.gbuildparser.libs) | set(self.gbuildparser.exes):
            if not target.location in self.target_by_location:
                self.target_by_location[target.location] = set()
            self.target_by_location[target.location] |= set([target])
            for cxx in target.cxxobjects:
                path = '/'.join(cxx.split('/')[:-1])
                if not path in self.target_by_path:
                    self.target_by_path[path] = set()
                self.target_by_path[path] |= set([target])
#        for exe in self.gbuildparser.exes:
#            for cxx in exe.cxxobjects:
#                path = '/'.join(cxx.split('/')[:-1])
#                if not path in self.target_by_path:
#                    self.target_by_path[path] = set()
#                self.target_by_path[path] |= set([exe])
        for path in self.target_by_path:
            if len(self.target_by_path[path]) > 1:
                print('fdo#70422: multiple target use dir %s: %s' % (path, ', '.join([target.short_name() for target in self.target_by_path[path]])))
    def emit(self):
        dirs = set([lib.location for lib in self.gbuildparser.libs])
        dirs |= set([exe.location for exe in self.gbuildparser.exes])
        #for d in dirs:
        #    print(self.generate_buildsystem(d))

if __name__ == '__main__':
    paths = {}
    gbuildparser = GbuildParser().parse(sys.stdin)
    #DebugIntegrationGenerator(gbuildparser).emit()
    KdevelopIntegrationGenerator(gbuildparser).emit()
    #    for cxx in lib.cxxobjects:
    #        path = '/'.join(cxx.split('/')[:-1])
    #        paths[path] = lib.include
    #for path in paths:
    #    print('Path %s has include: %s' % (path, paths[path]))

# vim: set noet sw=4 ts=4:
