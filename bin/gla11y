#!/usr/bin/env python
# -*- tab-width: 4; indent-tabs-mode: nil; py-indent-offset: 4 -*-
#
# This file is part of the LibreOffice project.
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
# This file incorporates work covered by the following license notice:
#
#   Copyright (c) 2018 Martin Pieuchot
#   Copyright (c) 2018 Samuel Thibault <sthibault@hypra.fr>
#
#   Permission to use, copy, modify, and distribute this software for any
#   purpose with or without fee is hereby granted, provided that the above
#   copyright notice and this permission notice appear in all copies.
#
#   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
#   WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
#   MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
#   ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
#   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
#   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
#   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# Take LibreOffice (glade) .ui files and check for non accessible widgets

from __future__ import print_function

import os
import sys
import getopt
try:
    import lxml.etree as ET
    lxml = True
except ImportError:
    import xml.etree.ElementTree as ET
    lxml = False

progname = os.path.basename(sys.argv[0])
outfile = None
Werror = False
Wnone = False
errors = 0
warnings = 0

def step_elm(elm):
    """
    Return the XML class path step corresponding to elm.
    This can be empty if the elm does not have any class or id.
    """
    step = elm.attrib.get('class')
    if step is None:
        step = ""
    oid = elm.attrib.get('id')
    if oid is not None:
        oid = oid.encode('ascii','ignore').decode('ascii')
        step += "[@id='%s']" % oid
    if len(step) > 0:
        step += '/'
    return step

def find_elm(root, elm):
    """
    Return the XML class path of the element from the given root.
    This is the slow version used when getparent is not available.
    """
    if root == elm:
        return ""
    for o in root:
        path = find_elm(o, elm)
        if path is not None:
            step = step_elm(o)
            return step + path
    return None


def elm_prefix(filename, elm):
    """
    Return the display prefix of the element
    """
    if elm == None or not lxml:
        return "%s:" % filename
    else:
        return "%s:%u" % (filename, elm.sourceline)

def elm_name(elm):
    """
    Return a display name of the element
    """
    if elm is not None:
        name = ""
        if 'class' in elm.attrib:
            name = "'%s' " % elm.attrib['class']
        if 'id' in elm.attrib:
            id = elm.attrib['id'].encode('ascii','ignore').decode('ascii')
            name += "'%s' " % id
        return name
    return ""

def err(filename, tree, elm, msg):
    global errors

    prefix = elm_prefix(filename, elm)

    errors += 1
    msg = "%s ERROR: %s%s" % (prefix, elm_name(elm), msg)
    print(msg)
    if outfile is not None:
        print(msg, file=outfile)


def warn(filename, elm, msg):
    global Werror, Wnone, errors, warnings

    if Wnone:
        return

    prefix = elm_prefix(filename, elm)

    if Werror:
        errors += 1
    else:
        warnings += 1

    msg = "%s WARNING: %s%s" % (prefix, elm_name(elm), msg)
    print(msg)
    if outfile is not None:
        print(msg, file=outfile)


def check_objects(filename, tree, elm, objects, target):
    """
    Check that objects contains exactly one object
    """
    length = len(list(objects))
    if length == 0:
        err(filename, tree, elm, "uses undeclared target '%s'" % target)
    elif length > 1:
        err(filename, tree, elm, "several targets are named '%s'" % target)

def check_props(filename, tree, root, elm, props):
    """
    Check the given list of relation properties
    """
    for prop in props:
        objects = root.iterfind(".//object[@id='%s']" % prop.text)
        check_objects(filename, tree, elm, objects, prop.text)

def check_rels(filename, tree, root, elm, rels):
    """
    Check the given list of relations
    """
    for rel in rels:
        target = rel.attrib['target']
        targets = root.iterfind(".//object[@id='%s']" % target)
        check_objects(filename, tree, elm, targets, target)

def elms_lines(elms):
    """
    Return the list of lines for the given elements.
    """
    if lxml:
        return ": lines " + ', '.join([str(l.sourceline) for l in elms])
    else:
        return ""

def check_a11y_relation(filename, tree):
    """
    Emit an error message if any of the 'object' elements of the XML
    document represented by `root' doesn't comply with Accessibility
    rules.
    """
    root = tree.getroot()

    for obj in root.iter('object'):

        label_for = obj.findall("accessibility/relation[@type='label-for']")
        check_rels(filename, tree, root, obj, label_for)

        labelled_by = obj.findall("accessibility/relation[@type='labelled-by']")
        check_rels(filename, tree, root, obj, labelled_by)

        member_of = obj.findall("accessibility/relation[@type='member-of']")
        check_rels(filename, tree, root, obj, member_of)

        if obj.attrib['class'] == 'GtkLabel':
            # Case 0: A 'GtkLabel' must contain one or more "label-for"
            # pointing to existing elements or...
            if len(label_for) > 0:
                continue

            # ...a single "mnemonic_widget"
            properties = obj.findall("property[@name='mnemonic_widget']")
            check_props(filename, tree, root, obj, properties)
            if len(properties) > 1:
                # It does not make sense for a label to be a mnemonic for
                # several actions.
                err(filename, tree, obj, "multiple-mnemonic", "has too many sub-elements"
                    ", expected single <property name='mnemonic_widgets'>"
                    "%s" % elms_lines(properties))
                continue
            if len(properties) == 1:
                continue
            # TODO: warn that it is a label for nothing
            continue

        # Case 1: has a <child internal-child="accessible"> sub-element
        children = obj.findall("child[@internal-child='accessible']")
        if children:
            if len(children) > 1:
                err(filename, tree, obj, "multiple-accessible", "has too many sub-elements"
                    ", expected single <child internal-child='accessible'>"
                    "%s" % elms_lines(children))
            continue

        # Case 2: has an <accessibility> sub-element with a "labelled-by"
        # <relation> pointing to an existing element.
        if len(labelled_by) > 0:
            continue

        # TODO: after a few more checks and false-positives filtering, warn
        # that this does not have a label


def usage():
    print("%s [-W error|none] [-o LOG_FILE] [file ... | -L filelist]" % progname,
          file=sys.stderr)
    print("  -o Also prints errors and warnings to given file");
    sys.exit(2)


def main():
    global Werror, Wnone, errors, outfile

    try:
        opts, args = getopt.getopt(sys.argv[1:], "W:o:L:")
    except getopt.GetoptError:
        usage()

    out = None
    filelist = None
    for o, a in opts:
        if o == "-W":
            if a == "error":
                Werror = True
            elif a == "none":
                Wnone = True
        elif o == "-o":
            out = a
        elif o == "-L":
            filelist = a

    if out is not None:
        outfile = open(out, 'w')

    if filelist is not None:
        try:
            filelistfile = open(filelist, 'r')
            for line in filelistfile.readlines():
                line = line.strip()
                if line:
                    args += line.split(' ')
            filelistfile.close()
        except IOError:
            err(filelist, None, None, "unable to read file list file")

    for filename in args:
        try:
            tree = ET.parse(filename)
        except ET.ParseError:
            err(filename, None, None, "malformatted xml file")
            continue
        except IOError:
            err(filename, None, None, "unable to read file")
            continue

        try:
            check_a11y_relation(filename, tree)
        except Exception as error:
            import traceback
            traceback.print_exc()
            err(filename, None, None, "error parsing file")

    if outfile is not None:
        outfile.close()
    if errors > 0:
        sys.exit(1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass

# vim: set shiftwidth=4 softtabstop=4 expandtab:
