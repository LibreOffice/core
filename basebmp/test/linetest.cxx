/**************************************************************
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 *************************************************************/



// autogenerated file with codegen.pl

#include "preextstl.h"
#include "gtest/gtest.h"
#include "postextstl.h"

#include <basegfx/vector/b2isize.hxx>
#include <basegfx/point/b2ipoint.hxx>

#include <basebmp/color.hxx>
#include <basebmp/scanlineformats.hxx>
#include <basebmp/bitmapdevice.hxx>
#include <basebmp/debug.hxx>
#include "tools.hxx"

#include <iostream>
#include <fstream>

using namespace ::basebmp;

namespace
{
/*
  std::ofstream output("32bpp_test.dump");
  debugDump( mpDevice32bpp, output );
*/

class LineTest : public ::testing::Test
{
protected:
    BitmapDeviceSharedPtr mpDevice1bpp;
    BitmapDeviceSharedPtr mpDevice32bpp;

    void implTestBasicDiagonalLines(const BitmapDeviceSharedPtr& rDevice)
    {
        rDevice->clear(Color(0));

        const basegfx::B2IPoint aPt1(1,1);
        const basegfx::B2IPoint aPt2(9,9);
        const Color aCol(0xFFFFFFFF);
        rDevice->drawLine( aPt1, aPt2, aCol, DrawMode_PAINT );
        ASSERT_TRUE(rDevice->getPixel(aPt1) == aCol) << "first pixel set";
        ASSERT_TRUE(rDevice->getPixel(aPt2) == aCol) << "last pixel set";
        const basegfx::B2IPoint aPt3(0,0);
        ASSERT_TRUE(rDevice->getPixel(aPt3) != aCol) << "topmost pixel not set";
        const basegfx::B2IPoint aPt4(10,10);
        ASSERT_TRUE(rDevice->getPixel(aPt4) != aCol) << "bottommost pixel not set";

        ASSERT_TRUE(countPixel( rDevice, aCol ) == 9) << "number of rendered pixel is not 9";

        rDevice->drawLine( aPt2, aPt1, aCol, DrawMode_PAINT );

        ASSERT_TRUE(countPixel( rDevice, aCol ) == 9)
            << "number of rendered pixel after reversed paint is not 9";
    }

    void implTestBasicHorizontalLines(const BitmapDeviceSharedPtr& rDevice)
    {
        rDevice->clear(Color(0));

        const basegfx::B2IPoint aPt1(10,10);
        const basegfx::B2IPoint aPt2(0,10);
        const Color aCol(0xFFFFFFFF);
        rDevice->drawLine( aPt1, aPt2, aCol, DrawMode_PAINT );
        ASSERT_TRUE(rDevice->getPixel(aPt1) == aCol) << "first pixel set";
        ASSERT_TRUE(rDevice->getPixel(aPt2) == aCol) << "last pixel set";
        ASSERT_TRUE(countPixel( rDevice, aCol ) == 11) << "number of rendered pixel is not 11";

        rDevice->clear(Color(0));
        rDevice->drawLine( aPt2, aPt1, aCol, DrawMode_PAINT );
        ASSERT_TRUE(rDevice->getPixel(aPt1) == aCol) << "first pixel set";
        ASSERT_TRUE(rDevice->getPixel(aPt2) == aCol) << "last pixel set";
        ASSERT_TRUE(countPixel( rDevice, aCol ) == 11) << "number of rendered pixel is not 11";
    }

    void implTestBasicVerticalLines(const BitmapDeviceSharedPtr& rDevice)
    {
        rDevice->clear(Color(0));

        const basegfx::B2IPoint aPt1(1,1);
        const basegfx::B2IPoint aPt2(1,9);
        const Color aCol(0xFFFFFFFF);
        rDevice->drawLine( aPt1, aPt2, aCol, DrawMode_PAINT );
        ASSERT_TRUE(rDevice->getPixel(aPt1) == aCol) << "first pixel set";
        ASSERT_TRUE(rDevice->getPixel(aPt2) == aCol) << "last pixel set";
        const basegfx::B2IPoint aPt3(0,0);
        ASSERT_TRUE(rDevice->getPixel(aPt3) != aCol) << "topmost pixel not set";
        const basegfx::B2IPoint aPt4(0,10);
        ASSERT_TRUE(rDevice->getPixel(aPt4) != aCol) << "bottommost pixel not set";

        ASSERT_TRUE(countPixel( rDevice, aCol ) == 9) << "number of rendered pixel is not 9";
    }

    // test pixel rounding (should always tend towards start point of
    // the line)
    void implTestTieBreaking(const BitmapDeviceSharedPtr& rDevice)
    {
        rDevice->clear(Color(0));

        const basegfx::B2IPoint aPt1(1,1);
        const basegfx::B2IPoint aPt2(3,2);
        const Color aCol(0xFFFFFFFF);
        rDevice->drawLine( aPt1, aPt2, aCol, DrawMode_PAINT );
        ASSERT_TRUE(rDevice->getPixel(aPt1) == aCol) << "first pixel set";
        ASSERT_TRUE(rDevice->getPixel(basegfx::B2IPoint(2,1)) == aCol) << "second pixel set";
        ASSERT_TRUE(rDevice->getPixel(aPt2) == aCol) << "last pixel set";
        ASSERT_TRUE(countPixel( rDevice, aCol ) == 3)
            << "number of rendered pixel after reversed paint is not 3";

        rDevice->drawLine( aPt2, aPt1, aCol, DrawMode_PAINT );
        ASSERT_TRUE(rDevice->getPixel(basegfx::B2IPoint(2,2)) == aCol)
            << "alternate second pixel set";

        ASSERT_TRUE(countPixel( rDevice, aCol ) == 4)
            << "number of rendered pixel after reversed paint is not 4";
    }

public:
    virtual void SetUp()
    {
        const basegfx::B2ISize aSize(11,11);
        mpDevice1bpp = createBitmapDevice( aSize,
                                           true,
                                           Format::ONE_BIT_MSB_PAL );
        mpDevice32bpp = createBitmapDevice( aSize,
                                           true,
                                           Format::THIRTYTWO_BIT_TC_MASK );
    }
};

TEST_F(LineTest, testBasicDiagonalLines)
{
    implTestBasicDiagonalLines( mpDevice1bpp );
    implTestBasicDiagonalLines( mpDevice32bpp );
}

TEST_F(LineTest, testBasicHorizontalLines)
{
    implTestBasicHorizontalLines( mpDevice1bpp );
    implTestBasicHorizontalLines( mpDevice32bpp );
}

TEST_F(LineTest, testBasicVerticalLines)
{
    implTestBasicVerticalLines( mpDevice1bpp );
    implTestBasicVerticalLines( mpDevice32bpp );
}

// test pixel rounding (should always tend towards start point of
// the line)
TEST_F(LineTest, testTieBreaking)
{
    implTestTieBreaking( mpDevice1bpp );
    implTestTieBreaking( mpDevice32bpp );
}


}
