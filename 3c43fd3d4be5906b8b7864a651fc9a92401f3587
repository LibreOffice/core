{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "65dada8f_a8c3bddc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1003564
      },
      "writtenOn": "2022-06-29T23:51:47Z",
      "side": 1,
      "message": "So in order to make the tests more thorough and more specialized for each png file, I made each test case optionally take a std::vector\u003cstd::function\u003c\u003e\u003e. This way I can pass a bunch of assert functions I want to each test, and they can be different for each test but common ones can be reused.\n\nThis is not the final result ofc. But I want to hear your thoughts, is this a good approach? If not let me know so I don\u0027t continue because this is going to be a pretty big one since there\u0027s so many files to specialize tests for.\n\nPS: This does work. For example if you bind the wrong values to fAssertSize the test will fail (see line 455)",
      "revId": "3c43fd3d4be5906b8b7864a651fc9a92401f3587",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4b5c29c6_bb42080a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000154
      },
      "writtenOn": "2022-06-30T13:29:08Z",
      "side": 1,
      "message": "Not sure how I feel about that as IMHO test should be a straightforward as possible, so in this case I think it is better to just create another test method that tests a certain set of images where you assert the expected size and/or expected bit-count, even if you have to repeat the import/export/import cycle for those. Alternatively, why not check the size and bit-count for all of the images?",
      "parentUuid": "65dada8f_a8c3bddc",
      "revId": "3c43fd3d4be5906b8b7864a651fc9a92401f3587",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c8110b1a_cc9d3c9a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1003564
      },
      "writtenOn": "2022-06-30T18:59:50Z",
      "side": 1,
      "message": "Well you need to check for different stuff for every different file in the suite. For example, not all files need to be checked for size, most are 32x32. Some need to be checked for bit depth and others for palette count. Some can be checked for transparency and pixel colors at each corner for example. That is *if* we need to make the test that thorough. If I just check size and bit count for all of the images isn\u0027t that still not a thorough enough test?\n\nThe purpose of this test (when finished) is to catch regressions if pngimagewriter/reader is ever modified I would say.",
      "parentUuid": "4b5c29c6_bb42080a",
      "revId": "3c43fd3d4be5906b8b7864a651fc9a92401f3587",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "29b1ebc3_f6d6c77e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000154
      },
      "writtenOn": "2022-07-01T09:03:18Z",
      "side": 1,
      "message": "What different stuff you need to check for different files? The most I see is to check the properties of the imported Bitmap, which are size, BPP, palette (yes/no), transparency (yes/no),... which are applicable to all of them. What else? If there is something super special you need to test for a test PNG, you can do it again in a different test for the same file. \n\nEven if most use size 32x32 this is still an expectation, which can be asserted - even if it\u0027s not a corner case. You don\u0027t really know what could fail so you need to be thorough. A 32x32 image could still produce a Bitmap that is 0x0 in size for some reason and you wouldn\u0027t catch this.",
      "parentUuid": "c8110b1a_cc9d3c9a",
      "revId": "3c43fd3d4be5906b8b7864a651fc9a92401f3587",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "14767f5d_b5998881",
        "filename": "vcl/qa/cppunit/png/PngFilterTest.cxx",
        "patchSetId": 5
      },
      "lineNbr": 345,
      "author": {
        "id": 1000154
      },
      "writtenOn": "2022-06-30T07:04:46Z",
      "side": 1,
      "message": "I think you can use std::u16string_view here and all the way down.",
      "range": {
        "startLine": 345,
        "startChar": 8,
        "endLine": 345,
        "endChar": 27
      },
      "revId": "3c43fd3d4be5906b8b7864a651fc9a92401f3587",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3bf44adb_0575e130",
        "filename": "vcl/qa/cppunit/png/PngFilterTest.cxx",
        "patchSetId": 5
      },
      "lineNbr": 345,
      "author": {
        "id": 1003564
      },
      "writtenOn": "2022-07-04T11:02:24Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "14767f5d_b5998881",
      "range": {
        "startLine": 345,
        "startChar": 8,
        "endLine": 345,
        "endChar": 27
      },
      "revId": "3c43fd3d4be5906b8b7864a651fc9a92401f3587",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    }
  ]
}