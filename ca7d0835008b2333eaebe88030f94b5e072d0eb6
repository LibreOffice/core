{
  "comments": [
    {
      "key": {
        "uuid": "01121cc5_debf77ef",
        "filename": "xmloff/source/style/xmlstyle.cxx",
        "patchSetId": 2
      },
      "lineNbr": 602,
      "author": {
        "id": 1000994
      },
      "writtenOn": "2020-12-23T06:45:20Z",
      "side": 1,
      "message": "Do I understand it correctly that in c++20, this is better re-written as\n\n  OUString sName \u003d bPara ? OUStringLiteral( u\"ParagraphStyles\" ): OUStringLiteral( u\"CharacterStyles\" );\n\nwith OUStringLiterals being always not automatic? Or consteval will not turn them to pre-compiled literals?",
      "range": {
        "startLine": 602,
        "startChar": 12,
        "endLine": 602,
        "endChar": 121
      },
      "revId": "ca7d0835008b2333eaebe88030f94b5e072d0eb6",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fefce521_1b7c23f1",
        "filename": "xmloff/source/style/xmlstyle.cxx",
        "patchSetId": 2
      },
      "lineNbr": 602,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2020-12-23T08:42:36Z",
      "side": 1,
      "message": "No (and that wouldn\u0027t even compile, as the OUString(OUStringLiteral\u0026\u0026) ctor is deliberately deleted).  The issue is that constructing an OUString from an OUStringLiteral stores the address of the OUStringLiteral, which means the OUStringLiteral instance must outlive the OUString\u0027s refcounted rtl_uString instance.  The only generally safe use of OUStringLiteral is with static storage duration, and there\u0027s an upcoming loplugin that will check that (which found this place, which I submitted ahead of the plugin).",
      "parentUuid": "01121cc5_debf77ef",
      "range": {
        "startLine": 602,
        "startChar": 12,
        "endLine": 602,
        "endChar": 121
      },
      "revId": "ca7d0835008b2333eaebe88030f94b5e072d0eb6",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "17c183d3_3318cc08",
        "filename": "xmloff/source/style/xmlstyle.cxx",
        "patchSetId": 2
      },
      "lineNbr": 602,
      "author": {
        "id": 1000994
      },
      "writtenOn": "2020-12-23T08:47:40Z",
      "side": 1,
      "message": "My idea was that consteval ctor would make a notation \"OUStringLiteral(u\"Foo\")\" behave like using plain string literal \"Foo\", where we easily may write:\n\n  char* c \u003d b ? \"Foo\" : \"Bar\";\n\nand the two strings used there are in no way some automatic memory blocks, but guaranteed to be static, and so it\u0027s OK to return the pointer from the function etc.\n\nIn this line, I hoped that the consteval OUStringLiteral ctor would make this:\n\n  OUString sName \u003d bPara ? OUStringLiteral( u\"ParagraphStyles\" ): OUStringLiteral( u\"CharacterStyles\" );\n\nto make sName to be constructed from one of the two *static* objects created at compile time.",
      "parentUuid": "fefce521_1b7c23f1",
      "range": {
        "startLine": 602,
        "startChar": 12,
        "endLine": 602,
        "endChar": 121
      },
      "revId": "ca7d0835008b2333eaebe88030f94b5e072d0eb6",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "46c47abd_18853e1e",
        "filename": "xmloff/source/style/xmlstyle.cxx",
        "patchSetId": 2
      },
      "lineNbr": 602,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2020-12-23T10:12:01Z",
      "side": 1,
      "message": "consteval vs. constexpr doesn\u0027t make any difference here.  The created objects would still be temporaries with automatic storage duration (and a program could take their addresses and compare them, so an implementation must not \"cheat\" by re-using the same static storage in, say, a function-call expression\n\n  f(b ? OUStringLiteral(u\"foo\") : OUStringLiteral(u\"foo\"))\n\n).  What is still missing from C++20 is a way to create a kind of user-defined literal with semantics similar to string literals: static storage duration, and potentially even no unique-addresss guarantee.",
      "parentUuid": "17c183d3_3318cc08",
      "range": {
        "startLine": 602,
        "startChar": 12,
        "endLine": 602,
        "endChar": 121
      },
      "revId": "ca7d0835008b2333eaebe88030f94b5e072d0eb6",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b39422bc_3b89bc7f",
        "filename": "xmloff/source/style/xmlstyle.cxx",
        "patchSetId": 2
      },
      "lineNbr": 602,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2020-12-23T11:31:29Z",
      "side": 1,
      "message": "\u003e (and a program could take their addresses and compare them, so an implementation must not \"cheat\" by re-using the same static storage in, say, a function-call expression\n\u003e \n\u003e   f(b ? OUStringLiteral(u\"foo\") : OUStringLiteral(u\"foo\"))\n\u003e \n\u003e ).\n\nsorry, I meant a function-call expression like\n\n  f(OUStringLiteral(u\"foo\"), OUStringLiteral(u\"foo\"))\n\nwhere f takes its arguments by reference and could compare their addresses, and they would need to be different",
      "parentUuid": "46c47abd_18853e1e",
      "range": {
        "startLine": 602,
        "startChar": 12,
        "endLine": 602,
        "endChar": 121
      },
      "revId": "ca7d0835008b2333eaebe88030f94b5e072d0eb6",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": true
    }
  ]
}