*** misc/mozilla/build/autoconf/mozconfig-find	2004-07-16 20:13:24.000000000 +0200
--- misc/build/mozilla/build/autoconf/mozconfig-find	2005-07-13 17:26:54.000000000 +0200
***************
*** 51,60 ****
                 $topsrcdir/.mozconfig \
                 $topsrcdir/mozconfig \
                 $topsrcdir/mozconfig.sh \
!                $topsrcdir/myconfig.sh \
!                $HOME/.mozconfig \
!                $HOME/.mozconfig.sh \
!                $HOME/.mozmyconfig.sh
  do
    if test -f $_config; then
      echo $_config;
--- 51,57 ----
                 $topsrcdir/.mozconfig \
                 $topsrcdir/mozconfig \
                 $topsrcdir/mozconfig.sh \
!                $topsrcdir/myconfig.sh
  do
    if test -f $_config; then
      echo $_config;
*** misc/mozilla/config/config.mk	2004-10-12 06:13:31.000000000 +0200
--- misc/build/mozilla/config/config.mk	2005-07-13 17:26:54.000000000 +0200
***************
*** 771,776 ****
--- 771,793 ----
  endif
  
  #
+ # Shared library RUNPATH linker option(s)
+ #
+ ifeq ($(OS_ARCH),Linux)
+ EXTRA_DSO_LDOPTS += -Wl,-rpath,\$$ORIGIN
+ ifdef IS_COMPONENT
+ EXTRA_DSO_LDOPTS += -Wl,-rpath,\$$ORIGIN/..
+ endif # IS_COMPONENT
+ endif # Linux
+ 
+ ifeq ($(OS_ARCH),SunOS)
+ EXTRA_DSO_LDOPTS += -R '$$ORIGIN'
+ ifdef IS_COMPONENT
+ EXTRA_DSO_LDOPTS += -R '$$ORIGIN/..'
+ endif # IS_COMPONENT
+ endif # SunOS
+ 
+ #
  # Include any personal overrides the user might think are needed.
  #
  -include $(MY_CONFIG)
*** misc/mozilla/config/Makefile.in	2004-11-01 19:30:40.000000000 +0100
--- misc/build/mozilla/config/Makefile.in	2005-07-13 17:26:54.000000000 +0200
***************
*** 135,141 ****
  
  ifdef MOZ_ENABLE_GTK2
    GLIB_CFLAGS = $(MOZ_GTK2_CFLAGS)
!   GLIB_LIBS = $(MOZ_GTK2_LIBS)
  endif
  
  build_number: FORCE
--- 135,141 ----
  
  ifdef MOZ_ENABLE_GTK2
    GLIB_CFLAGS = $(MOZ_GTK2_CFLAGS)
!   GLIB_LIBS = $(filter -lglib% -L%,$(MOZ_GTK2_LIBS))
  endif
  
  build_number: FORCE
*** misc/mozilla/configure	2004-10-12 06:13:29.000000000 +0200
--- misc/build/mozilla/configure	2005-07-14 12:53:22.400073064 +0200
***************
*** 5895,5901 ****
         MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_FLAGS) -G -Wl,-z -Wl,muldefs -o $@'
         MKSHLIB_FORCE_ALL='-Qoption ld -z,allextract'
         MKSHLIB_UNFORCE_ALL=''
!        DSO_LDOPTS='-G -Qoption ld -z,muldefs -h $@'
         AR_LIST="$AR t"
         AR_EXTRACT="$AR x"
         AR_DELETE="$AR d"
--- 5895,5901 ----
         MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_FLAGS) -G -Wl,-z -Wl,muldefs -o $@'
         MKSHLIB_FORCE_ALL='-Qoption ld -z,allextract'
         MKSHLIB_UNFORCE_ALL=''
!        DSO_LDOPTS='-G -norunpath -Qoption ld -z,muldefs -h $@'
         AR_LIST="$AR t"
         AR_EXTRACT="$AR x"
         AR_DELETE="$AR d"
*** misc/mozilla/configure.in	2004-10-12 06:13:29.000000000 +0200
--- misc/build/mozilla/configure.in	2005-07-13 17:26:54.000000000 +0200
***************
*** 1536,1542 ****
         MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_FLAGS) -G -Wl,-z -Wl,muldefs -o $@'
         MKSHLIB_FORCE_ALL='-Qoption ld -z,allextract'
         MKSHLIB_UNFORCE_ALL=''
!        DSO_LDOPTS='-G -Qoption ld -z,muldefs -h $@'
         AR_LIST="$AR t"
         AR_EXTRACT="$AR x"
         AR_DELETE="$AR d"
--- 1536,1542 ----
         MKCSHLIB='$(CC) $(CFLAGS) $(DSO_PIC_FLAGS) -G -Wl,-z -Wl,muldefs -o $@'
         MKSHLIB_FORCE_ALL='-Qoption ld -z,allextract'
         MKSHLIB_UNFORCE_ALL=''
!        DSO_LDOPTS='-G -norunpath -Qoption ld -z,muldefs -h $@'
         AR_LIST="$AR t"
         AR_EXTRACT="$AR x"
         AR_DELETE="$AR d"
*** misc/mozilla/directory/c-sdk/config/Makefile	2004-02-11 05:01:16.000000000 +0100
--- misc/build/mozilla/directory/c-sdk/config/Makefile	2005-07-13 17:27:32.000000000 +0200
***************
*** 48,58 ****
  
  include $(topsrcdir)/config/config.mk
  
! CSRCS	= nsinstall.c now.c
  
  PLSRCS	= nfspwd.pl
  
! ifneq (,$(filter WINNT OS2,$(OS_ARCH)))
  PROG_SUFFIX = .exe
  else
  PROG_SUFFIX =
--- 48,62 ----
  
  include $(topsrcdir)/config/config.mk
  
! ifndef MOZILLA_CLIENT
! CSRCS	= nsinstall.c 
! endif
! 
! CSRCS	+= now.c
  
  PLSRCS	= nfspwd.pl
  
! ifneq (,$(CROSS_COMPILE)$(filter WINNT OS2,$(OS_ARCH)))
  PROG_SUFFIX = .exe
  else
  PROG_SUFFIX =
***************
*** 92,100 ****
      XLDOPTS += $(LDFLAGS)
  endif
  
! ifdef XP_OS2_EMX
  XCFLAGS = $(OS_EXE_CFLAGS)
! XLDOPTS = -Zlinker /PM:VIO
  endif
  
  ifeq ($(MOZ_OS2_TOOLS),VACPP)
--- 96,104 ----
      XLDOPTS += $(LDFLAGS)
  endif
  
! ifeq ($(MOZ_OS2_TOOLS),EMX)
  XCFLAGS = $(OS_EXE_CFLAGS)
! XLDOPTS = -Zomf -Zlinker /PM:VIO
  endif
  
  ifeq ($(MOZ_OS2_TOOLS),VACPP)
***************
*** 114,121 ****
--- 118,127 ----
  
  OUTOPTION = -o # end of the line
  ifeq (,$(filter-out WINNT OS2,$(OS_ARCH)))
+ ifndef NS_USE_GCC
  OUTOPTION = /Fe
  endif
+ endif
  
  # Redefine MAKE_OBJDIR for just this directory
  define MAKE_OBJDIR
*** misc/mozilla/directory/c-sdk/configure	2004-09-14 23:14:38.000000000 +0200
--- misc/build/mozilla/directory/c-sdk/configure	2005-07-13 17:26:54.000000000 +0200
***************
*** 3832,3837 ****
--- 3832,3838 ----
      MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'
      DSO_CFLAGS=-fPIC
      DSO_LDOPTS='-shared -Wl,-soname -Wl,$(notdir $@)'
+     DSO_LDOPTS="$DSO_LDOPTS -Wl,-rpath,'$\$ORIGIN'"
      OS_LIBS="$OS_LIBS -lc"
      _OPTIMIZE_FLAGS=-O2
      _DEBUG_FLAGS="-g -fno-inline"  # most people on linux use gcc/gdb, and that
***************
*** 4685,4690 ****
--- 4686,4692 ----
      LD=/usr/ccs/bin/ld
      RANLIB=/usr/ccs/bin/ranlib
      DSO_LDOPTS='-G -h $(notdir $@)'
+     DSO_LDOPTS="$DSO_LDOPTS -R '$\$ORIGIN'"
      if test -n "$GNU_CC"; then
          DSO_CFLAGS=-fPIC
      else
*** misc/mozilla/directory/c-sdk/configure.in	2004-09-14 23:14:38.000000000 +0200
--- misc/build/mozilla/directory/c-sdk/configure.in	2005-07-13 17:26:54.000000000 +0200
***************
*** 1144,1149 ****
--- 1144,1150 ----
      MKSHLIB='$(CC) $(DSO_LDOPTS) -o $@'
      DSO_CFLAGS=-fPIC
      DSO_LDOPTS='-shared -Wl,-soname -Wl,$(notdir $@)'
+     DSO_LDOPTS="$DSO_LDOPTS -Wl,-rpath,'$\$ORIGIN'"
      OS_LIBS="$OS_LIBS -lc"
      _OPTIMIZE_FLAGS=-O2
      _DEBUG_FLAGS="-g -fno-inline"  # most people on linux use gcc/gdb, and that
***************
*** 1686,1691 ****
--- 1687,1693 ----
      LD=/usr/ccs/bin/ld
      RANLIB=/usr/ccs/bin/ranlib
      DSO_LDOPTS='-G -h $(notdir $@)'
+     DSO_LDOPTS="$DSO_LDOPTS -R '$\$ORIGIN'"
      if test -n "$GNU_CC"; then
          DSO_CFLAGS=-fPIC
      else
*** misc/mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile	2004-02-11 05:01:15.000000000 +0100
--- misc/build/mozilla/directory/c-sdk/ldap/libraries/libssldap/Makefile	2005-07-13 17:27:33.000000000 +0200
***************
*** 92,97 ****
--- 92,106 ----
  endif
  
  ifeq ($(OS_ARCH), WINNT)
+ ifdef NS_USE_GCC
+ EXTRA_DLL_LIBS = -L$(dist_libdir) -l$(LDAP_LIBNAME) -l$(PRLDAP_LIBNAME) \
+ 	-l$(NSS_LIBNAME)
+ ifeq ($(NSS_DYNAMIC_SOFTOKN),1)
+ EXTRA_DLL_LIBS += -l$(SOFTOKN_LIBNAME)
+ endif
+ EXTRA_DLL_LIBS += -l$(SSL_LIBNAME) \
+ 	-l$(PLC_BASENAME) -l$(PLDS_BASENAME) -l$(NSPR_BASENAME)
+ else
  EXTRA_LIBS =wsock32.lib kernel32.lib user32.lib gdi32.lib winspool.lib \
              comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib \
              rpcrt4.lib uuid.lib odbc32.lib odbccp32.lib winmm.lib
***************
*** 106,111 ****
--- 115,121 ----
  endif
  EXTRA_LIBS += $(dist_libdir)/$(SSL_LIBNAME).lib
  endif
+ endif
  
  ifeq ($(OS_ARCH),OS2)
  EXTRA_LIBS = $(OS_LIBS)
*** misc/mozilla/embedding/browser/gtk/src/Makefile.in	2004-04-08 21:18:25.000000000 +0200
--- misc/build/mozilla/embedding/browser/gtk/src/Makefile.in	2005-07-13 17:26:54.000000000 +0200
***************
*** 111,117 ****
  		gtkmozembed_internal.h
  
  ifdef MOZ_ENABLE_GTK
! EXTRA_DSO_LDOPTS = \
  		$(MOZ_COMPONENT_LIBS) \
  		$(XPCOM_GLUE_LIBS) \
  		-lgtksuperwin \
--- 111,117 ----
  		gtkmozembed_internal.h
  
  ifdef MOZ_ENABLE_GTK
! EXTRA_DSO_LDOPTS += \
  		$(MOZ_COMPONENT_LIBS) \
  		$(XPCOM_GLUE_LIBS) \
  		-lgtksuperwin \
***************
*** 119,125 ****
  endif
  
  ifdef MOZ_ENABLE_GTK2
! EXTRA_DSO_LDOPTS = \
  		$(MOZ_COMPONENT_LIBS) \
  		$(NULL)
  endif
--- 119,125 ----
  endif
  
  ifdef MOZ_ENABLE_GTK2
! EXTRA_DSO_LDOPTS += \
  		$(MOZ_COMPONENT_LIBS) \
  		$(NULL)
  endif
*** misc/mozilla/embedding/browser/gtk/tests/Makefile.in	2003-10-07 04:43:00.000000000 +0200
--- misc/build/mozilla/embedding/browser/gtk/tests/Makefile.in	2005-07-14 12:58:38.361111472 +0200
***************
*** 46,55 ****
  		TestGtkEmbedNotebook.cpp \
  		TestGtkEmbedSocket.cpp \
  		TestGtkEmbedChild.cpp
- endif
  
  SIMPLE_PROGRAMS = $(CPPSRCS:.cpp=)
  
  # ENABLE_GNOME=1
  
  ifdef ENABLE_GNOME
--- 46,56 ----
  		TestGtkEmbedNotebook.cpp \
  		TestGtkEmbedSocket.cpp \
  		TestGtkEmbedChild.cpp
  
  SIMPLE_PROGRAMS = $(CPPSRCS:.cpp=)
  
+ endif
+ 
  # ENABLE_GNOME=1
  
  ifdef ENABLE_GNOME
*** misc/mozilla/extensions/pref/autoconfig/src/Makefile.in	2004-01-07 14:36:25.000000000 +0100
--- misc/build/mozilla/extensions/pref/autoconfig/src/Makefile.in	2005-07-13 17:26:54.000000000 +0200
***************
*** 68,74 ****
  endif
  
  
! EXTRA_DSO_LDOPTS = \
                     $(LIBS_DIR) \
                     $(MOZ_JS_LIBS) \
                     $(MOZ_COMPONENT_LIBS) \
--- 68,74 ----
  endif
  
  
! EXTRA_DSO_LDOPTS += \
                     $(LIBS_DIR) \
                     $(MOZ_JS_LIBS) \
                     $(MOZ_COMPONENT_LIBS) \
*** misc/mozilla/gfx/idl/nsIFreeType2.idl	2004-04-16 03:09:33.000000000 +0200
--- misc/build/mozilla/gfx/idl/nsIFreeType2.idl	2005-07-13 17:26:54.000000000 +0200
***************
*** 76,85 ****
  native FT_Sfnt_Tag(FT_Sfnt_Tag);
  native FT_Size(FT_Size);
  
! [ptr] native FTC_Image_Desc_p(FTC_Image_Desc);
  native FTC_Face_Requester(FTC_Face_Requester);
  native FTC_Font(FTC_Font);
! native FTC_Image_Cache(FTC_Image_Cache);
  native FTC_Manager(FTC_Manager);
  
  // #ifdef MOZ_SVG
--- 76,86 ----
  native FT_Sfnt_Tag(FT_Sfnt_Tag);
  native FT_Size(FT_Size);
  
! [ptr] native FTC_ImageType_p(FTC_ImageType);
  native FTC_Face_Requester(FTC_Face_Requester);
  native FTC_Font(FTC_Font);
! native FTC_FaceID(FTC_FaceID);
! native FTC_ImageCache(FTC_ImageCache);
  native FTC_Manager(FTC_Manager);
  
  // #ifdef MOZ_SVG
***************
*** 99,105 ****
  
      readonly attribute FT_Library library;
      readonly attribute FTC_Manager FTCacheManager;
!     readonly attribute FTC_Image_Cache ImageCache;
  
      void    doneFace(in FT_Face face);
      void    doneFreeType(in FT_Library lib);
--- 100,106 ----
  
      readonly attribute FT_Library library;
      readonly attribute FTC_Manager FTCacheManager;
!     readonly attribute FTC_ImageCache ImageCache;
  
      void    doneFace(in FT_Face face);
      void    doneFreeType(in FT_Library lib);
***************
*** 115,130 ****
      void    outlineDecompose(in FT_Outline_p outline,
                               in const_FT_Outline_Funcs_p funcs, in voidPtr p);
      void    setCharmap(in FT_Face face, in FT_CharMap charmap);
!     void    imageCacheLookup(in FTC_Image_Cache cache, in FTC_Image_Desc_p desc,
                               in FT_UInt gindex, out FT_Glyph glyph);
!     void    managerLookupSize(in FTC_Manager manager, in FTC_Font font,
!                               out FT_Face face, out FT_Size size);
      void    managerDone(in FTC_Manager manager);
      void    managerNew(in FT_Library lib, in FT_UInt max_faces,
                         in FT_UInt max_sizes, in FT_ULong max_bytes,
                         in FTC_Face_Requester requester, in FT_Pointer req_data,
                         out FTC_Manager manager);
!     void    imageCacheNew(in FTC_Manager manager, out FTC_Image_Cache cache);
  /* #ifdef MOZ_SVG */
      void glyphTransform(in FT_Glyph glyph, in FT_Matrix_p matrix,
                          in FT_Vector_p delta);
--- 116,131 ----
      void    outlineDecompose(in FT_Outline_p outline,
                               in const_FT_Outline_Funcs_p funcs, in voidPtr p);
      void    setCharmap(in FT_Face face, in FT_CharMap charmap);
!     void    imageCacheLookup(in FTC_ImageCache cache, in FTC_ImageType_p desc,
                               in FT_UInt gindex, out FT_Glyph glyph);
!     void    managerLookupFace(in FTC_Manager manager, in FTC_FaceID face_id,
!                               out FT_Face face);
      void    managerDone(in FTC_Manager manager);
      void    managerNew(in FT_Library lib, in FT_UInt max_faces,
                         in FT_UInt max_sizes, in FT_ULong max_bytes,
                         in FTC_Face_Requester requester, in FT_Pointer req_data,
                         out FTC_Manager manager);
!     void    imageCacheNew(in FTC_Manager manager, out FTC_ImageCache cache);
  /* #ifdef MOZ_SVG */
      void glyphTransform(in FT_Glyph glyph, in FT_Matrix_p matrix,
                          in FT_Vector_p delta);
*** misc/mozilla/gfx/src/freetype/nsFreeType.cpp	2004-02-07 16:22:30.000000000 +0100
--- misc/build/mozilla/gfx/src/freetype/nsFreeType.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 111,117 ****
    {"FT_Outline_Decompose",    NS_FT2_OFFSET(nsFT_Outline_Decompose),    PR_TRUE},
    {"FT_Set_Charmap",          NS_FT2_OFFSET(nsFT_Set_Charmap),          PR_TRUE},
    {"FTC_Image_Cache_Lookup",  NS_FT2_OFFSET(nsFTC_Image_Cache_Lookup),  PR_TRUE},
!   {"FTC_Manager_Lookup_Size", NS_FT2_OFFSET(nsFTC_Manager_Lookup_Size), PR_TRUE},
    {"FTC_Manager_Done",        NS_FT2_OFFSET(nsFTC_Manager_Done),        PR_TRUE},
    {"FTC_Manager_New",         NS_FT2_OFFSET(nsFTC_Manager_New),         PR_TRUE},
    {"FTC_Image_Cache_New",     NS_FT2_OFFSET(nsFTC_Image_Cache_New),     PR_TRUE},
--- 111,117 ----
    {"FT_Outline_Decompose",    NS_FT2_OFFSET(nsFT_Outline_Decompose),    PR_TRUE},
    {"FT_Set_Charmap",          NS_FT2_OFFSET(nsFT_Set_Charmap),          PR_TRUE},
    {"FTC_Image_Cache_Lookup",  NS_FT2_OFFSET(nsFTC_Image_Cache_Lookup),  PR_TRUE},
!   {"FTC_Manager_LookupFace",  NS_FT2_OFFSET(nsFTC_Manager_LookupFace),  PR_TRUE},
    {"FTC_Manager_Done",        NS_FT2_OFFSET(nsFTC_Manager_Done),        PR_TRUE},
    {"FTC_Manager_New",         NS_FT2_OFFSET(nsFTC_Manager_New),         PR_TRUE},
    {"FTC_Image_Cache_New",     NS_FT2_OFFSET(nsFTC_Image_Cache_New),     PR_TRUE},
***************
*** 282,288 ****
  } 
   
  NS_IMETHODIMP
! nsFreeType2::ImageCacheLookup(FTC_Image_Cache cache, FTC_Image_Desc *desc,
                                FT_UInt glyphID, FT_Glyph *glyph)
  { 
    // call the FreeType2 function via the function pointer
--- 282,288 ----
  } 
   
  NS_IMETHODIMP
! nsFreeType2::ImageCacheLookup(FTC_ImageCache cache, FTC_ImageType *desc,
                                FT_UInt glyphID, FT_Glyph *glyph)
  { 
    // call the FreeType2 function via the function pointer
***************
*** 291,301 ****
  } 
   
  NS_IMETHODIMP
! nsFreeType2::ManagerLookupSize(FTC_Manager manager, FTC_Font font,
!                                FT_Face *face, FT_Size *size)
  { 
    // call the FreeType2 function via the function pointer
!   FT_Error error = nsFTC_Manager_Lookup_Size(manager, font, face, size);
    return error ? NS_ERROR_FAILURE : NS_OK;
  } 
   
--- 291,301 ----
  } 
   
  NS_IMETHODIMP
! nsFreeType2::ManagerLookupFace(FTC_Manager manager, FTC_FaceID font,
!                                FT_Face *face)
  { 
    // call the FreeType2 function via the function pointer
!   FT_Error error = nsFTC_Manager_LookupFace(manager, font, face);
    return error ? NS_ERROR_FAILURE : NS_OK;
  } 
   
***************
*** 320,326 ****
  } 
   
  NS_IMETHODIMP
! nsFreeType2::ImageCacheNew(FTC_Manager manager, FTC_Image_Cache *cache)
  { 
    // call the FreeType2 function via the function pointer
    FT_Error error = nsFTC_Image_Cache_New(manager, cache);
--- 320,326 ----
  } 
   
  NS_IMETHODIMP
! nsFreeType2::ImageCacheNew(FTC_Manager manager, FTC_ImageCache *cache)
  { 
    // call the FreeType2 function via the function pointer
    FT_Error error = nsFTC_Image_Cache_New(manager, cache);
***************
*** 389,395 ****
  } 
   
  NS_IMETHODIMP
! nsFreeType2::GetImageCache(FTC_Image_Cache *aCache)
  {
    *aCache = mImageCache;
    return NS_OK;
--- 389,395 ----
  } 
   
  NS_IMETHODIMP
! nsFreeType2::GetImageCache(FTC_ImageCache *aCache)
  {
    *aCache = mImageCache;
    return NS_OK;
*** misc/mozilla/gfx/src/freetype/nsFreeType.h	2004-04-16 23:31:42.000000000 +0200
--- misc/build/mozilla/gfx/src/freetype/nsFreeType.h	2005-07-13 17:26:54.000000000 +0200
***************
*** 104,116 ****
  typedef FT_Error (*FT_New_Face_t)(FT_Library, const char*, FT_Long, FT_Face*);
  typedef FT_Error (*FT_Set_Charmap_t)(FT_Face face, FT_CharMap  charmap);
  typedef FT_Error (*FTC_Image_Cache_Lookup_t)
!                       (FTC_Image_Cache, FTC_Image_Desc*, FT_UInt, FT_Glyph*);
! typedef FT_Error (*FTC_Manager_Lookup_Size_t)
!                       (FTC_Manager, FTC_Font, FT_Face*, FT_Size*);
  typedef FT_Error (*FTC_Manager_Done_t)(FTC_Manager);
  typedef FT_Error (*FTC_Manager_New_t)(FT_Library, FT_UInt, FT_UInt, FT_ULong,
                         FTC_Face_Requester, FT_Pointer, FTC_Manager*);
! typedef FT_Error (*FTC_Image_Cache_New_t)(FTC_Manager, FTC_Image_Cache*);
  // #ifdef MOZ_SVG
  typedef FT_Error (*FT_Glyph_Transform_t)(FT_Glyph, FT_Matrix*, FT_Vector*);
  typedef FT_Error (*FT_Get_Kerning_t)
--- 104,116 ----
  typedef FT_Error (*FT_New_Face_t)(FT_Library, const char*, FT_Long, FT_Face*);
  typedef FT_Error (*FT_Set_Charmap_t)(FT_Face face, FT_CharMap  charmap);
  typedef FT_Error (*FTC_Image_Cache_Lookup_t)
!                        (FTC_ImageCache, FTC_ImageType*, FT_UInt, FT_Glyph*);
! typedef FT_Error (*FTC_Manager_LookupFace_t)
!                        (FTC_Manager, FTC_FaceID, FT_Face*);
  typedef FT_Error (*FTC_Manager_Done_t)(FTC_Manager);
  typedef FT_Error (*FTC_Manager_New_t)(FT_Library, FT_UInt, FT_UInt, FT_ULong,
                         FTC_Face_Requester, FT_Pointer, FTC_Manager*);
! typedef FT_Error (*FTC_Image_Cache_New_t)(FTC_Manager, FTC_ImageCache*);
  // #ifdef MOZ_SVG
  typedef FT_Error (*FT_Glyph_Transform_t)(FT_Glyph, FT_Matrix*, FT_Vector*);
  typedef FT_Error (*FT_Get_Kerning_t)
***************
*** 165,171 ****
    FT_Outline_Decompose_t    nsFT_Outline_Decompose;
    FT_Set_Charmap_t          nsFT_Set_Charmap;
    FTC_Image_Cache_Lookup_t  nsFTC_Image_Cache_Lookup;
!   FTC_Manager_Lookup_Size_t nsFTC_Manager_Lookup_Size;
    FTC_Manager_Done_t        nsFTC_Manager_Done;
    FTC_Manager_New_t         nsFTC_Manager_New;
    FTC_Image_Cache_New_t     nsFTC_Image_Cache_New;
--- 165,171 ----
    FT_Outline_Decompose_t    nsFT_Outline_Decompose;
    FT_Set_Charmap_t          nsFT_Set_Charmap;
    FTC_Image_Cache_Lookup_t  nsFTC_Image_Cache_Lookup;
!   FTC_Manager_LookupFace_t  nsFTC_Manager_LookupFace;
    FTC_Manager_Done_t        nsFTC_Manager_Done;
    FTC_Manager_New_t         nsFTC_Manager_New;
    FTC_Image_Cache_New_t     nsFTC_Image_Cache_New;
***************
*** 213,219 ****
    PRLibrary      *mSharedLib;
    FT_Library      mFreeTypeLibrary;
    FTC_Manager     mFTCacheManager;
!   FTC_Image_Cache mImageCache;
  
    static nsHashtable   *sFontFamilies;
    static nsHashtable   *sRange1CharSetNames;
--- 213,219 ----
    PRLibrary      *mSharedLib;
    FT_Library      mFreeTypeLibrary;
    FTC_Manager     mFTCacheManager;
!   FTC_ImageCache  mImageCache;
  
    static nsHashtable   *sFontFamilies;
    static nsHashtable   *sRange1CharSetNames;
*** misc/mozilla/gfx/src/gtk/Makefile.in	2003-11-10 13:24:51.000000000 +0100
--- misc/build/mozilla/gfx/src/gtk/Makefile.in	2005-07-13 17:26:54.000000000 +0200
***************
*** 176,181 ****
--- 176,185 ----
  CXXFLAGS	+= $(MOZ_GTK_CFLAGS) $(MOZ_GTK2_CFLAGS)
  CFLAGS		+= $(MOZ_GTK_CFLAGS) $(MOZ_GTK2_CFLAGS)
  
+ ifeq ($(OS_ARCH), Darwin)
+ EXTRA_DSO_LDOPTS += $(XLDFLAGS) $(XLIBS)
+ endif
+ 
  ifeq ($(OS_ARCH), SunOS)
  ifndef GNU_CC
  # When using Sun's WorkShop compiler, including
*** misc/mozilla/gfx/src/ps/nsFontMetricsPS.cpp	2004-02-05 02:57:05.000000000 +0100
--- misc/build/mozilla/gfx/src/ps/nsFontMetricsPS.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 1141,1150 ****
    
    mPixelSize = NSToIntRound(app2dev * mFont->size);
  
!   mImageDesc.font.face_id    = (void*)mEntry;
!   mImageDesc.font.pix_width  = mPixelSize;
!   mImageDesc.font.pix_height = mPixelSize;
!   mImageDesc.image_type = 0;
  
    nsresult rv;
    mFt2 = do_GetService(NS_FREETYPE2_CONTRACTID, &rv);
--- 1141,1150 ----
    
    mPixelSize = NSToIntRound(app2dev * mFont->size);
  
!   mImageDesc->face_id = (FTC_FaceID)&mEntry;
!   mImageDesc->width  = mPixelSize;
!   mImageDesc->height = mPixelSize;
!   mImageDesc->flags = 0;
  
    nsresult rv;
    mFt2 = do_GetService(NS_FREETYPE2_CONTRACTID, &rv);
***************
*** 1190,1196 ****
    if (!face)
      return 0;
  
!   FTC_Image_Cache iCache;
    nsresult rv = mFt2->GetImageCache(&iCache);
    if (NS_FAILED(rv)) {
      NS_ERROR("Failed to get Image Cache");
--- 1190,1196 ----
    if (!face)
      return 0;
  
!   FTC_ImageCache iCache;
    nsresult rv = mFt2->GetImageCache(&iCache);
    if (NS_FAILED(rv)) {
      NS_ERROR("Failed to get Image Cache");
***************
*** 1228,1235 ****
    
    FTC_Manager cManager;
    mFt2->GetFTCacheManager(&cManager);
!   nsresult rv = mFt2->ManagerLookupSize(cManager, &mImageDesc.font,
!                                         &face, nsnull);
    NS_ASSERTION(rv==0, "failed to get face/size");
    if (rv)
      return nsnull;
--- 1228,1235 ----
    
    FTC_Manager cManager;
    mFt2->GetFTCacheManager(&cManager);
!   nsresult rv = mFt2->ManagerLookupFace(cManager, mImageDesc->face_id,
!                                         &face);
    NS_ASSERTION(rv==0, "failed to get face/size");
    if (rv)
      return nsnull;
***************
*** 1622,1637 ****
    mEntry->GetFamilyName(fontName);
    mEntry->GetStyleName(styleName);
    
!   mImageDesc.font.face_id    = (void*)mEntry;
    // TT glyph has no relation to size
!   mImageDesc.font.pix_width  = 16;
!   mImageDesc.font.pix_height = 16;
!   mImageDesc.image_type = 0;
    FT_Face face = nsnull;
    FTC_Manager cManager;
    mFt2->GetFTCacheManager(&cManager);
!   nsresult rv = mFt2->ManagerLookupSize(cManager, &mImageDesc.font,
!                                         &face, nsnull);
    if (NS_FAILED(rv))
      return;
   
--- 1622,1637 ----
    mEntry->GetFamilyName(fontName);
    mEntry->GetStyleName(styleName);
    
!   mImageDesc->face_id = (FTC_FaceID)&mEntry;
    // TT glyph has no relation to size
!   mImageDesc->width  = 16;
!   mImageDesc->height = 16;
!   mImageDesc->flags = 0;
    FT_Face face = nsnull;
    FTC_Manager cManager;
    mFt2->GetFTCacheManager(&cManager);
!   nsresult rv = mFt2->ManagerLookupFace(cManager, mImageDesc->face_id,
!                                         &face);
    if (NS_FAILED(rv))
      return;
   
*** misc/mozilla/gfx/src/ps/nsFontMetricsPS.h	2003-04-22 18:25:09.000000000 +0200
--- misc/build/mozilla/gfx/src/ps/nsFontMetricsPS.h	2005-07-13 17:26:54.000000000 +0200
***************
*** 320,326 ****
    nsCOMPtr<nsITrueTypeFontCatalogEntry> mFaceID;
    nsCOMPtr<nsIFreeType2> mFt2;
    PRUint16        mPixelSize;
!   FTC_Image_Desc  mImageDesc;
  
  
    static PRBool AddUserPref(nsIAtom *aLang, const nsFont& aFont,
--- 320,326 ----
    nsCOMPtr<nsITrueTypeFontCatalogEntry> mFaceID;
    nsCOMPtr<nsIFreeType2> mFt2;
    PRUint16        mPixelSize;
!   FTC_ImageType   mImageDesc;
  
  
    static PRBool AddUserPref(nsIAtom *aLang, const nsFont& aFont,
***************
*** 363,369 ****
  protected:
    nsCOMPtr<nsITrueTypeFontCatalogEntry> mEntry;
    nsCOMPtr<nsIFreeType2> mFt2;
!   FTC_Image_Desc  mImageDesc;
  };
  #endif
  
--- 363,369 ----
  protected:
    nsCOMPtr<nsITrueTypeFontCatalogEntry> mEntry;
    nsCOMPtr<nsIFreeType2> mFt2;
!   FTC_ImageType   mImageDesc;
  };
  #endif
  
*** misc/mozilla/gfx/src/x11shared/nsFontFreeType.cpp	2003-12-25 09:24:52.000000000 +0100
--- misc/build/mozilla/gfx/src/x11shared/nsFontFreeType.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 177,183 ****
    FTC_Manager mgr;
    nsresult rv;
    mFt2->GetFTCacheManager(&mgr);
!   rv = mFt2->ManagerLookupSize(mgr, &mImageDesc.font, &face, nsnull);
    NS_ASSERTION(NS_SUCCEEDED(rv), "failed to get face/size");
    if (NS_FAILED(rv))
      return nsnull;
--- 177,183 ----
    FTC_Manager mgr;
    nsresult rv;
    mFt2->GetFTCacheManager(&mgr);
!   rv = mFt2->ManagerLookupFace(mgr, mImageDesc->face_id, &face);
    NS_ASSERTION(NS_SUCCEEDED(rv), "failed to get face/size");
    if (NS_FAILED(rv))
      return nsnull;
***************
*** 191,212 ****
    PRBool embedded_bimap = PR_FALSE;
    mFaceID = aFaceID;
    mPixelSize = aPixelSize;
!   mImageDesc.font.face_id    = (void*)mFaceID;
!   mImageDesc.font.pix_width  = aPixelSize;
!   mImageDesc.font.pix_height = aPixelSize;
!   mImageDesc.image_type = 0;
  
    if (aPixelSize < nsFreeType2::gAntiAliasMinimum) {
-     mImageDesc.image_type |= ftc_image_mono;
      anti_alias = PR_FALSE;
    }
  
-   if (nsFreeType2::gFreeType2Autohinted)
-     mImageDesc.image_type |= ftc_image_flag_autohinted;
- 
-   if (nsFreeType2::gFreeType2Unhinted)
-     mImageDesc.image_type |= ftc_image_flag_unhinted;
- 
    PRUint32  num_embedded_bitmaps, i;
    PRInt32*  embedded_bitmapheights;
    mFaceID->GetEmbeddedBitmapHeights(&num_embedded_bitmaps,
--- 191,205 ----
    PRBool embedded_bimap = PR_FALSE;
    mFaceID = aFaceID;
    mPixelSize = aPixelSize;
!   mImageDesc->face_id = (FTC_FaceID)&mFaceID;
!   mImageDesc->width  = aPixelSize;
!   mImageDesc->height = aPixelSize;
!   mImageDesc->flags = 0;
  
    if (aPixelSize < nsFreeType2::gAntiAliasMinimum) {
      anti_alias = PR_FALSE;
    }
  
    PRUint32  num_embedded_bitmaps, i;
    PRInt32*  embedded_bitmapheights;
    mFaceID->GetEmbeddedBitmapHeights(&num_embedded_bitmaps,
***************
*** 218,224 ****
          if (embedded_bitmapheights[i] == aPixelSize) {
            embedded_bimap = PR_TRUE;
            // unhinted must be set for embedded bitmaps to be used
-           mImageDesc.image_type |= ftc_image_flag_unhinted;
            break;
          }
        }
--- 211,216 ----
***************
*** 312,318 ****
    if (!face)
      return NS_ERROR_FAILURE;
  
!   FTC_Image_Cache icache;
    mFt2->GetImageCache(&icache);
    if (!icache)
      return NS_ERROR_FAILURE;
--- 304,310 ----
    if (!face)
      return NS_ERROR_FAILURE;
  
!   FTC_ImageCache icache;
    mFt2->GetImageCache(&icache);
    if (!icache)
      return NS_ERROR_FAILURE;
***************
*** 401,407 ****
    if (!face)
      return 0;
  
!   FTC_Image_Cache icache;
    mFt2->GetImageCache(&icache);
    if (!icache)
      return 0;
--- 393,399 ----
    if (!face)
      return 0;
  
!   FTC_ImageCache icache;
    mFt2->GetImageCache(&icache);
    if (!icache)
      return 0;
***************
*** 723,729 ****
      if (y%4==0) (*blendPixelFunc)(sub_image, y, ascent-1, black, 255/2);
  #endif
  
!   FTC_Image_Cache icache;
    mFt2->GetImageCache(&icache);
    if (!icache)
      return 0;
--- 715,721 ----
      if (y%4==0) (*blendPixelFunc)(sub_image, y, ascent-1, black, 255/2);
  #endif
  
!   FTC_ImageCache icache;
    mFt2->GetImageCache(&icache);
    if (!icache)
      return 0;
*** misc/mozilla/gfx/src/x11shared/nsFontFreeType.h	2003-04-22 18:25:13.000000000 +0200
--- misc/build/mozilla/gfx/src/x11shared/nsFontFreeType.h	2005-07-13 17:26:54.000000000 +0200
***************
*** 110,116 ****
    XImage *GetXImage(PRUint32 width, PRUint32 height);
    nsITrueTypeFontCatalogEntry *mFaceID;
    PRUint16        mPixelSize;
!   FTC_Image_Desc  mImageDesc;
    nsCOMPtr<nsIFreeType2> mFt2;
  };
  
--- 110,116 ----
    XImage *GetXImage(PRUint32 width, PRUint32 height);
    nsITrueTypeFontCatalogEntry *mFaceID;
    PRUint16        mPixelSize;
!   FTC_ImageType   mImageDesc;
    nsCOMPtr<nsIFreeType2> mFt2;
  };
  
*** misc/mozilla/jpeg/jmorecfg.h	2004-03-26 02:17:16.000000000 +0100
--- misc/build/mozilla/jpeg/jmorecfg.h	2005-07-13 17:26:54.000000000 +0200
***************
*** 108,115 ****
  /* Defines for MMX/SSE2 support. */
  
  #if defined(XP_WIN32) && defined(_M_IX86) && !defined(__GNUC__)
! #define HAVE_MMX_INTEL_MNEMONICS 
! #define HAVE_SSE2_INTEL_MNEMONICS 
  #endif
  
  /* Compressed datastreams are represented as arrays of JOCTET.
--- 108,115 ----
  /* Defines for MMX/SSE2 support. */
  
  #if defined(XP_WIN32) && defined(_M_IX86) && !defined(__GNUC__)
! //#define HAVE_MMX_INTEL_MNEMONICS 
! //#define HAVE_SSE2_INTEL_MNEMONICS 
  #endif
  
  /* Compressed datastreams are represented as arrays of JOCTET.
*** misc/mozilla/js/src/xpconnect/src/Makefile.in	2004-01-07 14:36:33.000000000 +0100
--- misc/build/mozilla/js/src/xpconnect/src/Makefile.in	2005-07-13 17:26:54.000000000 +0200
***************
*** 148,151 ****
  .NOTPARALLEL::
  endif
  endif
- 
--- 148,150 ----
*** misc/mozilla/layout/svg/renderer/src/libart/nsSVGLibartGlyphMetricsFT.cpp	2004-03-19 02:36:16.000000000 +0100
--- misc/build/mozilla/layout/svg/renderer/src/libart/nsSVGLibartGlyphMetricsFT.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 440,458 ****
      return;
    }
  
!   FTC_Image_Desc imageDesc;
!   imageDesc.font.face_id=(void*)font_data.font_entry.get(); // XXX do we need to addref?
    float twipstopixel = GetTwipsToPixels();
    float scale = GetPixelScale();
!   imageDesc.font.pix_width = (int)((float)(font_data.font.size)*twipstopixel/scale);
!   imageDesc.font.pix_height = (int)((float)(font_data.font.size)*twipstopixel/scale);
!   imageDesc.image_type |= ftc_image_grays;
  
    // get the face
    nsresult rv;
    FTC_Manager mgr;
    nsSVGLibartFreetype::ft2->GetFTCacheManager(&mgr);
!   rv = nsSVGLibartFreetype::ft2->ManagerLookupSize(mgr, &imageDesc.font, &mFace, nsnull);
    NS_ASSERTION(mFace, "failed to get face/size");
  }
  
--- 440,458 ----
      return;
    }
  
!   FTC_ImageType imageDesc;
!   imageDesc->face_id=(FTC_FaceID)font_data.font_entry.get(); // XXX do we need to addref?
    float twipstopixel = GetTwipsToPixels();
    float scale = GetPixelScale();
!   imageDesc->width = (int)((float)(font_data.font.size)*twipstopixel/scale);
!   imageDesc->height = (int)((float)(font_data.font.size)*twipstopixel/scale);
!   imageDesc->flags |= /* ftc_image_grays */0;
  
    // get the face
    nsresult rv;
    FTC_Manager mgr;
    nsSVGLibartFreetype::ft2->GetFTCacheManager(&mgr);
!   rv = nsSVGLibartFreetype::ft2->ManagerLookupFace(mgr, imageDesc->face_id, &mFace);
    NS_ASSERTION(mFace, "failed to get face/size");
  }
  
*** misc/mozilla/mailnews/addrbook/src/Makefile.in	2003-10-06 19:48:56.000000000 +0200
--- misc/build/mozilla/mailnews/addrbook/src/Makefile.in	2005-07-13 17:26:54.000000000 +0200
***************
*** 86,91 ****
--- 86,92 ----
                  nsVCard.cpp \
                  nsVCardObj.cpp \
                  nsMsgVCardService.cpp \
+                 nsAbMD5sum.cpp	\
  		$(NULL)
  
  EXPORTS		= \
*** misc/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.cpp	2002-10-11 10:17:13.000000000 +0200
--- misc/build/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 39,44 ****
--- 39,45 ----
  #include "nsAbBoolExprToLDAPFilter.h"
  #include "nsAbLDAPProperties.h"
  #include "nsXPIDLString.h"
+ #include "nsAbUtils.h"
  
  const int nsAbBoolExprToLDAPFilter::TRANSLATE_CARD_PROPERTY = 1 << 0 ;
  const int nsAbBoolExprToLDAPFilter::ALLOW_NON_CONVERTABLE_CARD_PROPERTY = 1 << 1 ;
***************
*** 186,198 ****
      rv = condition->GetName (getter_Copies (name));
      NS_ENSURE_SUCCESS(rv, rv);
  
!     const char* ldapProperty = name.get ();
      if (flags & TRANSLATE_CARD_PROPERTY)
      {
!         const MozillaLdapPropertyRelation* p =
!             MozillaLdapPropertyRelator::findLdapPropertyFromMozilla (name.get ());
!         if (p)
!             ldapProperty = p->ldapProperty;
          else if (!(flags & ALLOW_NON_CONVERTABLE_CARD_PROPERTY))
              return NS_OK;
      }
--- 187,202 ----
      rv = condition->GetName (getter_Copies (name));
      NS_ENSURE_SUCCESS(rv, rv);
  
!     CharPtrArrayGuard attrs;
      if (flags & TRANSLATE_CARD_PROPERTY)
      {
!         if(const MozillaLdapPropertyRelation* property =
!             MozillaLdapPropertyRelator::findLdapPropertyFromMozilla (name.get ()))
!         {
!             // allow even single ldap attribute mapppings to go through this to simplify the filter creation later.
!             rv = MozillaLdapPropertyRelator::getAllLDAPAttrsFromMozilla (property->ldapProperty, attrs.GetSizeAddr(), attrs.GetArrayAddr() );
!             NS_ENSURE_SUCCESS(rv, rv);
!         }
          else if (!(flags & ALLOW_NON_CONVERTABLE_CARD_PROPERTY))
              return NS_OK;
      }
***************
*** 202,207 ****
--- 206,242 ----
      NS_ENSURE_SUCCESS(rv, rv);
      NS_ConvertUCS2toUTF8 vUTF8 (value);
  
+     // check if using multiple ldap attributes
+     if(attrs.GetSize() == 1 ) 
+         GenerateSingleFilter(conditionType,filter,vUTF8,attrs.GetArray()[0]);
+     else
+     {
+         // add the opening brace if using multiple ldap attributes
+         switch (conditionType)
+         {
+             // 'NOT' conditionals use the 'AND' operator 
+             case nsIAbBooleanConditionTypes::DoesNotExist:
+             case nsIAbBooleanConditionTypes::DoesNotContain:
+             case nsIAbBooleanConditionTypes::IsNot:
+                 filter += NS_LITERAL_CSTRING("(&");
+                 break;
+             default:
+                 filter += NS_LITERAL_CSTRING("(|");
+                 break;
+         }
+         GenerateMultipleFilter(conditionType,filter,vUTF8,&attrs);
+         // add the closing brace if using multiple ldap attributes
+         filter += NS_LITERAL_CSTRING(")");
+     }
+ 
+     return rv;
+ }
+ void nsAbBoolExprToLDAPFilter:: GenerateSingleFilter(
+     nsAbBooleanConditionType conditionType,
+     nsCString& filter,
+     NS_ConvertUCS2toUTF8 &vUTF8,
+     const char *ldapProperty)
+ {
      switch (conditionType)
      {
          case nsIAbBooleanConditionTypes::DoesNotExist:
***************
*** 282,288 ****
          default:
              break;
      }
- 
-     return rv;
  }
  
--- 317,363 ----
          default:
              break;
      }
  }
+ void nsAbBoolExprToLDAPFilter:: GenerateMultipleFilter(
+     nsAbBooleanConditionType conditionType,
+     nsCString& filter,
+     NS_ConvertUCS2toUTF8 &vUTF8,
+     CharPtrArrayGuard *pAttrs)
+ {
+     PRUint16 i = 0;
+     PRUint16 inner = 0;
+ 
+     /*
+      * This function is based on the fact that we are trying to generate support
+      * for multiple occurring ldap attributes. Consider the following query:
+      * (PagerNumber,=,123456) where PagerNumber = pager|pagerphone translates to: 
+      * (|(&(pager=*)(pager=123456))(&(!(pager=*))(pagerphone=123456)))
+      * This can be shortened to:
+      * (|(pager=123456)(&(!(pager=*))(pagerphone=123456)))
+      *
+      * i.e. use the first occurring attribute if it exists otherwise if first 
+      * does not exist use the second etc. The assumption is that the first
+      * always takes precedence.
+      * This translates to: 
+      *      GenerateSingleFilter(Is);
+      *          GenerateSingleFilter(DoesNotExists); 
+      *          GenerateSingleFilter(Is);
+     */
  
+     for (i = 0; i < pAttrs->GetSize(); i++)
+     {
+         if(i == 0)
+             GenerateSingleFilter(conditionType,filter,vUTF8,pAttrs->GetArray()[i]); 
+         else
+         {
+             filter += NS_LITERAL_CSTRING("(&");
+             nsAbBooleanConditionType doesNotExistsType = nsIAbBooleanConditionTypes::DoesNotExist; 
+             for(inner = 0; inner < i; ++inner)
+             {
+                 GenerateSingleFilter(doesNotExistsType,filter,vUTF8,pAttrs->GetArray()[inner]); 
+             }
+             GenerateSingleFilter(conditionType,filter,vUTF8,pAttrs->GetArray()[i]); 
+             filter += NS_LITERAL_CSTRING(")");
+         }
+     }
+ }
*** misc/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.h	2001-09-28 22:06:21.000000000 +0200
--- misc/build/mozilla/mailnews/addrbook/src/nsAbBoolExprToLDAPFilter.h	2005-07-13 17:26:54.000000000 +0200
***************
*** 42,47 ****
--- 42,48 ----
  #include "nsIAbBooleanExpression.h"
  #include "nsCOMPtr.h"
  #include "nsString.h"
+ #include "nsAbUtils.h"
  
  class nsAbBoolExprToLDAPFilter
  {
***************
*** 67,72 ****
--- 68,83 ----
          nsIAbBooleanConditionString* condition,
          nsCString& filter,
          int flags);
+     static void GenerateMultipleFilter(
+        nsAbBooleanConditionType conditionType,
+        nsCString& filter,
+        NS_ConvertUCS2toUTF8 &vUTF8,
+        CharPtrArrayGuard *pAttrs);
+     static void GenerateSingleFilter(
+        nsAbBooleanConditionType conditionType,
+        nsCString& filter,
+        NS_ConvertUCS2toUTF8 &vUTF8,
+        const char *ldapProperty);
  };
  
  #endif
*** misc/mozilla/mailnews/addrbook/src/nsAbLDAPDirectory.cpp	2004-02-14 03:09:27.000000000 +0100
--- misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPDirectory.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 118,128 ****
  
      // use mURINoQuery to get a prefName
      nsCAutoString prefName;
!     prefName = nsDependentCString(mURINoQuery.get() + kLDAPDirectoryRootLen) + NS_LITERAL_CSTRING(".uri");
  
      // turn moz-abldapdirectory://ldap_2.servers.nscpphonebook into -> "ldap_2.servers.nscpphonebook.uri"
      nsXPIDLCString URI;
!     rv = prefs->CopyCharPref(prefName.get(), getter_Copies(URI));
      if (NS_FAILED(rv))
      {
          /*
--- 118,130 ----
  
      // use mURINoQuery to get a prefName
      nsCAutoString prefName;
!     prefName = nsDependentCString(mURINoQuery.get() + kLDAPDirectoryRootLen) ;
  
      // turn moz-abldapdirectory://ldap_2.servers.nscpphonebook into -> "ldap_2.servers.nscpphonebook.uri"
      nsXPIDLCString URI;
!     nsCAutoString uriPrefName;
!     uriPrefName = prefName + NS_LITERAL_CSTRING(".uri");
!     rv = prefs->CopyCharPref(uriPrefName.get(), getter_Copies(URI));
      if (NS_FAILED(rv))
      {
          /*
***************
*** 146,151 ****
--- 148,174 ----
          nsCAutoString tempLDAPURL(mURINoQuery);
          tempLDAPURL.ReplaceSubstring("moz-abldapdirectory:", "ldap:");
          rv = mURL->SetSpec(tempLDAPURL);
+ 		NS_ENSURE_SUCCESS(rv,rv);
+     
+         nsCAutoString aHost;
+         mURL->GetHost(aHost);
+         aHost.ReplaceChar('.','_');
+         prefName = nsDependentCString("ldap_2.servers.") + aHost;
+         PRBool useSSL=0;
+         rv = prefs->GetBoolPref(
+                 PromiseFlatCString(prefName
+                 + NS_LITERAL_CSTRING(".UseSSL")).get(),
+                 &useSSL
+             );
+         
+         // If use SSL,ldap url will look like this ldaps://host:port/.....
+         if (!NS_FAILED(rv) && useSSL)
+         {
+             tempLDAPURL.ReplaceSubstring("ldap:", "ldaps:"); 
+             rv = mURL->SetSpec(tempLDAPURL);
+         }
+         //NS_FAILED(rv) means ldap_2.servers.nscpphonebook.UseSSL not exist
+         rv = 0;
      }
      else
      {
***************
*** 156,179 ****
      // get the login information, if there is any 
      //
      rv = prefs->GetCharPref(
!         PromiseFlatCString(
!             Substring(mURINoQuery, kLDAPDirectoryRootLen,
!                       mURINoQuery.Length() - kLDAPDirectoryRootLen)
              + NS_LITERAL_CSTRING(".auth.dn")).get(),
          getter_Copies(mLogin));
      if (NS_FAILED(rv)) {
          mLogin.Truncate();  // zero out mLogin
      }
  
      // get the protocol version, if there is any.  using a string pref
      // here instead of an int, as protocol versions sometimes have names like
      // "4bis".
      //
      nsXPIDLCString protocolVersion;
      rv = prefs->GetCharPref(
!         PromiseFlatCString(
!             Substring(mURINoQuery, kLDAPDirectoryRootLen,
!                       mURINoQuery.Length() - kLDAPDirectoryRootLen)
              + NS_LITERAL_CSTRING(".protocolVersion")).get(),
          getter_Copies(protocolVersion));
  
--- 179,207 ----
      // get the login information, if there is any 
      //
      rv = prefs->GetCharPref(
!         PromiseFlatCString(prefName
              + NS_LITERAL_CSTRING(".auth.dn")).get(),
          getter_Copies(mLogin));
      if (NS_FAILED(rv)) {
          mLogin.Truncate();  // zero out mLogin
      }
  
+     // get the password information, if there is any 
+     //
+     rv = prefs->GetCharPref(
+         PromiseFlatCString(prefName
+             + NS_LITERAL_CSTRING(".auth.pwd")).get(),
+         getter_Copies(mPassword));
+     if (NS_FAILED(rv)) {
+         mPassword.Truncate();  // zero out mLogin
+     }
      // get the protocol version, if there is any.  using a string pref
      // here instead of an int, as protocol versions sometimes have names like
      // "4bis".
      //
      nsXPIDLCString protocolVersion;
      rv = prefs->GetCharPref(
!         PromiseFlatCString(prefName
              + NS_LITERAL_CSTRING(".protocolVersion")).get(),
          getter_Copies(protocolVersion));
  
*** misc/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.cpp	2004-02-14 03:09:27.000000000 +0100
--- misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 74,80 ****
          PRInt32 resultLimit = -1,
          PRInt32 timeOut = 0);
      virtual ~nsAbQueryLDAPMessageListener ();
! 
  protected:
      nsresult OnLDAPMessageBind (nsILDAPMessage *aMessage);
      nsresult OnLDAPMessageSearchEntry (nsILDAPMessage *aMessage,
--- 74,80 ----
          PRInt32 resultLimit = -1,
          PRInt32 timeOut = 0);
      virtual ~nsAbQueryLDAPMessageListener ();
!     void SetPassword(const nsAString& aPassword){m_sPassword = aPassword;};
  protected:
      nsresult OnLDAPMessageBind (nsILDAPMessage *aMessage);
      nsresult OnLDAPMessageSearchEntry (nsILDAPMessage *aMessage,
***************
*** 105,110 ****
--- 105,112 ----
      PRBool mInitialized;
      PRBool mCanceled;
  
+     nsAutoString m_sPassword;
+ 
      nsCOMPtr<nsILDAPOperation> mSearchOperation;
  
      PRLock* mLock;
***************
*** 255,261 ****
  
      // If mLogin is set, we're expected to use it to get a password.
      //
!     if (!mDirectoryQuery->mLogin.IsEmpty()) {
  // XXX hack until nsUTF8AutoString exists
  #define nsUTF8AutoString nsCAutoString
          nsUTF8AutoString spec;
--- 257,263 ----
  
      // If mLogin is set, we're expected to use it to get a password.
      //
!     if (!mDirectoryQuery->mLogin.IsEmpty() && !m_sPassword.Length()) {
  // XXX hack until nsUTF8AutoString exists
  #define nsUTF8AutoString nsCAutoString
          nsUTF8AutoString spec;
***************
*** 398,407 ****
      rv = ldapOperation->Init(mConnection, proxyListener, nsnull);
      NS_ENSURE_SUCCESS(rv, rv);
  
!     // Bind
!     rv = ldapOperation->SimpleBind(NS_ConvertUCS2toUTF8(passwd));
      NS_ENSURE_SUCCESS(rv, rv);
- 
      return rv;
  }
  
--- 400,412 ----
      rv = ldapOperation->Init(mConnection, proxyListener, nsnull);
      NS_ENSURE_SUCCESS(rv, rv);
  
! 	
! 	// Bind
!     if (m_sPassword.Length())
! 		rv = ldapOperation->SimpleBind(NS_ConvertUCS2toUTF8(m_sPassword));
! 	else
! 	    rv = ldapOperation->SimpleBind(NS_ConvertUCS2toUTF8(passwd));
      NS_ENSURE_SUCCESS(rv, rv);
      return rv;
  }
  
***************
*** 685,691 ****
      rv = getLdapReturnAttributes (arguments, returnAttributes);
      NS_ENSURE_SUCCESS(rv, rv);
  
! 
      // Get the filter
      nsCOMPtr<nsISupports> supportsExpression;
      rv = arguments->GetExpression (getter_AddRefs (supportsExpression));
--- 690,696 ----
      rv = getLdapReturnAttributes (arguments, returnAttributes);
      NS_ENSURE_SUCCESS(rv, rv);
  
!     
      // Get the filter
      nsCOMPtr<nsISupports> supportsExpression;
      rv = arguments->GetExpression (getter_AddRefs (supportsExpression));
***************
*** 811,816 ****
--- 816,826 ----
                  timeOut);
      if (_messageListener == NULL)
              return NS_ERROR_OUT_OF_MEMORY;
+     
+     nsAutoString wPassword;
+     wPassword.AssignWithConversion(mPassword.get());
+     _messageListener->SetPassword(wPassword);
+ 
      messageListener = _messageListener;
      nsVoidKey key (NS_REINTERPRET_CAST(void *,contextID));
  
*** misc/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.h	2004-02-14 03:09:27.000000000 +0100
--- misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPDirectoryQuery.h	2005-07-13 17:26:54.000000000 +0200
***************
*** 74,79 ****
--- 74,80 ----
      nsresult RemoveListener (PRInt32 contextID);
      nsresult Initiate ();
      nsXPIDLCString mLogin; // authenticate to the LDAP server as...
+     nsXPIDLCString mPassword; // password to the LDAP server as...
      nsCOMPtr<nsILDAPURL> mDirectoryUrl; // the URL for the server
      PRUint32 mProtocolVersion; // version of LDAP (see nsILDAPConnection.idl)
  
*** misc/mozilla/mailnews/addrbook/src/nsAbLDAPProperties.cpp	2003-03-22 16:43:29.000000000 +0100
--- misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPProperties.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 39,44 ****
--- 39,45 ----
  #include "nsAbLDAPProperties.h"
  
  #include "nsAbUtils.h"
+ #include "nsCRT.h"
  
  #include "nsCOMPtr.h"
  #include "nsString.h"
***************
*** 59,64 ****
--- 60,80 ----
      If there are multiple entries for a mozilla
      property the first takes precedence.
  
+     But where we need to do a query against 
+     a multiple occurring ldap attribute we 
+     need to OR all the possible ldap entries e.g.
+ 
+     (CellularNumber=123456) translates to 
+     (|(mobile=123456)(&(!(mobile=*))(cellphone=123456))(&(!(mobile=*))(!(cellphone=*))(carphone=123456)))
+ 
+     i.e. use the first occurring attribute otherwise if 
+     first does not exist use the second etc.
+ 
+     [Multiple occurring ldap attributes do not
+     include aliases. We have also ignored the case 
+     for including 'displayname' as the first occurring
+     attribute 'cn' is a required attribute.] 
+ 
      This ensures that
      
          1) Generality is maintained when mapping from
***************
*** 101,152 ****
      {MozillaProperty_String, "FaxNumber",        "fax"},
      // organizationalPerson
      {MozillaProperty_String, "FaxNumber",        "facsimiletelephonenumber"},
!     // inetOrgPerson
!     {MozillaProperty_String, "PagerNumber",        "pager"},
!     // ?
!     {MozillaProperty_String, "PagerNumber",        "pagerphone"},
!     // inetOrgPerson
!     {MozillaProperty_String, "CellularNumber",    "mobile"},
!     // ?
!     {MozillaProperty_String, "CellularNumber",    "cellphone"},
!     // ?
!     {MozillaProperty_String, "CellularNumber",    "carphone"},
  
      // No Home* properties defined yet
  
!     // organizationalPerson
!     {MozillaProperty_String, "WorkAddress",        "postofficebox"},
!     // ?
!     {MozillaProperty_String, "WorkAddress",        "streetaddress"},
      // ?
      {MozillaProperty_String, "WorkCity",        "l"},
      // ?
      {MozillaProperty_String, "WorkCity",        "locality"},
      // ?
!     {MozillaProperty_String, "WorkState",        "st"},
!     // ?
!     {MozillaProperty_String, "WorkState",        "region"},
!     // organizationalPerson
!     {MozillaProperty_String, "WorkZipCode",        "postalcode"},
!     // ?
!     {MozillaProperty_String, "WorkZipCode",        "zip"},
      // ?
      {MozillaProperty_String, "WorkCountry",        "countryname"},
  
      // organizationalPerson
      {MozillaProperty_String, "JobTitle",        "title"},
      // ?
!     {MozillaProperty_String, "Department",        "ou"},
!     // ?
!     {MozillaProperty_String, "Department",        "orgunit"},
!     // ?
!     {MozillaProperty_String, "Department",        "department"},
!     // ?
!     {MozillaProperty_String, "Department",        "departmentnumber"},
!     // inetOrgPerson
!     {MozillaProperty_String, "Company",        "o"},
!     // ?
!     {MozillaProperty_String, "Company",        "company"},
      // ?
      {MozillaProperty_String, "WorkCountry",        "countryname"},
      // ?
--- 117,148 ----
      {MozillaProperty_String, "FaxNumber",        "fax"},
      // organizationalPerson
      {MozillaProperty_String, "FaxNumber",        "facsimiletelephonenumber"},
!     // inetOrgPerson,?
!     {MozillaProperty_String, "PagerNumber",        "pager,pagerphone"},
!     // inetOrgPerson,?,?
!     {MozillaProperty_String, "CellularNumber",    "mobile,cellphone,carphone"},
  
      // No Home* properties defined yet
  
!     // organizationalPerson,?
!     {MozillaProperty_String, "WorkAddress",        "postofficebox,streetaddress"},
      // ?
      {MozillaProperty_String, "WorkCity",        "l"},
      // ?
      {MozillaProperty_String, "WorkCity",        "locality"},
      // ?
!     {MozillaProperty_String, "WorkState",        "st,region"},
!     // organizationalPerson,?
!     {MozillaProperty_String, "WorkZipCode",        "postalcode,zip"},
      // ?
      {MozillaProperty_String, "WorkCountry",        "countryname"},
  
      // organizationalPerson
      {MozillaProperty_String, "JobTitle",        "title"},
      // ?
!     {MozillaProperty_String, "Department",      "ou,orgunit,department,departmentnumber"},
!    // inetOrgPerson,?
!     {MozillaProperty_String, "Company",        "o,company"},
      // ?
      {MozillaProperty_String, "WorkCountry",        "countryname"},
      // ?
***************
*** 168,177 ****
      // ?
      {MozillaProperty_String, "Custom4",        "custom4"},
  
!     // ?
!     {MozillaProperty_String, "Notes",        "notes"},
!     // person
!     {MozillaProperty_String, "Notes",        "description"},
  
      // mozilla specfic
      {MozillaProperty_Int, "PreferMailFormat",    "xmozillausehtmlmail"},
--- 164,171 ----
      // ?
      {MozillaProperty_String, "Custom4",        "custom4"},
  
!     // ?,person
!     {MozillaProperty_String, "Notes",        "notes,description"},
  
      // mozilla specfic
      {MozillaProperty_Int, "PreferMailFormat",    "xmozillausehtmlmail"},
***************
*** 209,218 ****
      if (IsInitialized) { return ; }
  
      for (int i = tableSize - 1 ; i >= 0 ; -- i) {
-         nsCStringKey keyMozilla (table [i].mozillaProperty, -1, nsCStringKey::NEVER_OWN);
-         nsCStringKey keyLdap (table [i].ldapProperty, -1, nsCStringKey::NEVER_OWN);
  
          mLdapToMozilla.Put(&keyLdap, NS_REINTERPRET_CAST(void *, NS_CONST_CAST(MozillaLdapPropertyRelation*, &table[i]))) ;
          mMozillaToLdap.Put(&keyMozilla, NS_REINTERPRET_CAST(void *, NS_CONST_CAST(MozillaLdapPropertyRelation*, &table[i]))) ;
      }
      IsInitialized = PR_TRUE;
--- 203,224 ----
      if (IsInitialized) { return ; }
  
      for (int i = tableSize - 1 ; i >= 0 ; -- i) {
  
+         char *attrToken = nsnull;
+         char *LDAPProperty = nsCRT::strdup(table[i].ldapProperty);
+         char *tmpLDAPProperty;
+ 
+         attrToken = nsCRT::strtok(LDAPProperty, ",", &tmpLDAPProperty);
+         while (attrToken != nsnull)
+         {
+             while ( ' ' == *attrToken) 
+                 attrToken++;
+             nsCStringKey keyLdap (attrToken, -1, nsCStringKey::NEVER_OWN);
          mLdapToMozilla.Put(&keyLdap, NS_REINTERPRET_CAST(void *, NS_CONST_CAST(MozillaLdapPropertyRelation*, &table[i]))) ;
+             attrToken = nsCRT::strtok(tmpLDAPProperty, ",", &tmpLDAPProperty);
+         }
+ 
+         nsCStringKey keyMozilla (table [i].mozillaProperty, -1, nsCStringKey::NEVER_OWN);
          mMozillaToLdap.Put(&keyMozilla, NS_REINTERPRET_CAST(void *, NS_CONST_CAST(MozillaLdapPropertyRelation*, &table[i]))) ;
      }
      IsInitialized = PR_TRUE;
***************
*** 234,243 ****
  const MozillaLdapPropertyRelation* MozillaLdapPropertyRelator::findMozillaPropertyFromLdap (const char* ldapProperty)
  {
      Initialize();
      // ensure that we always do a case insensitive comparison
      // against the incoming ldap attributes.
!     nsCAutoString lowercasedProp(ldapProperty);
!     ToLowerCase(nsDependentCString(ldapProperty), lowercasedProp);
      nsCStringKey key(lowercasedProp);
  
      return NS_REINTERPRET_CAST(const MozillaLdapPropertyRelation *, mLdapToMozilla.Get(&key)) ;
--- 240,252 ----
  const MozillaLdapPropertyRelation* MozillaLdapPropertyRelator::findMozillaPropertyFromLdap (const char* ldapProperty)
  {
      Initialize();
+     char *attrToken;
+     char *tmpLDAPProperty;
+     attrToken = nsCRT::strtok(NS_CONST_CAST(char *,ldapProperty), ",", &tmpLDAPProperty);
      // ensure that we always do a case insensitive comparison
      // against the incoming ldap attributes.
!     nsCAutoString lowercasedProp (attrToken) ;
!     ToLowerCase(nsDependentCString(attrToken),lowercasedProp);
      nsCStringKey key(lowercasedProp);
  
      return NS_REINTERPRET_CAST(const MozillaLdapPropertyRelation *, mLdapToMozilla.Get(&key)) ;
***************
*** 289,291 ****
--- 298,361 ----
  
      return rv;
  }
+ 
+ // Parse the input string which may contain a single ldap attribute or multiple attributes in the form
+ // "string" or "string1,string2,string3" respectively and assign to the array.
+ nsresult MozillaLdapPropertyRelator::getAllLDAPAttrsFromMozilla (const char* aLDAPProperty, PRUint32 *aAttrCount, char * **aAttributes)
+ {
+     NS_ENSURE_ARG_POINTER(aAttrCount);
+     NS_ENSURE_ARG_POINTER(aAttributes);
+ 
+     nsresult rv = NS_OK;
+ 
+     *aAttributes = 0;
+     // we must have at least one attribute 
+     *aAttrCount = 1;
+ 
+     // if no multiple ldap attributes then allocate our single entry and exit
+     if (!strchr(aLDAPProperty,','))
+     {
+         if (!(*aAttributes = NS_STATIC_CAST(char **, nsMemory::Alloc(sizeof(char *)))))
+             return NS_ERROR_OUT_OF_MEMORY;
+         if (!((*aAttributes)[0] = nsCRT::strdup(aLDAPProperty)))
+             return NS_ERROR_OUT_OF_MEMORY;
+ 
+         return rv;
+     }
+ 
+     char *attrToken = nsnull;
+     char *LDAPProperty = nsnull;
+     char *tmpLDAPProperty;
+ 
+     if((LDAPProperty = nsCRT::strdup(aLDAPProperty)) == nsnull)
+         return NS_ERROR_OUT_OF_MEMORY;
+ 
+     // set our tokenizer to the start 
+     attrToken = nsCRT::strtok(LDAPProperty, ",", &tmpLDAPProperty); 
+ 
+     // Count up the attribute names 
+     while ((attrToken = nsCRT::strtok(tmpLDAPProperty, ",", &tmpLDAPProperty)) != nsnull)
+         *aAttrCount += 1;
+ 
+     nsCRT::free (LDAPProperty);
+     if(!(*aAttributes = NS_STATIC_CAST(char **, nsMemory::Alloc(*aAttrCount * sizeof(char *)))))
+         return NS_ERROR_OUT_OF_MEMORY;
+ 
+     if((LDAPProperty = nsCRT::strdup(aLDAPProperty)) == nsnull)
+         return NS_ERROR_OUT_OF_MEMORY;
+ 
+     PRInt32 j = 0;
+     attrToken = nsCRT::strtok(LDAPProperty, ",", &tmpLDAPProperty);
+     while (nsnull != attrToken) {
+         if(((*aAttributes)[j++] = nsCRT::strdup(attrToken)) == nsnull)
+         {
+             nsCRT::free(LDAPProperty);
+             return NS_ERROR_OUT_OF_MEMORY;
+         }
+ 		
+         attrToken = nsCRT::strtok(tmpLDAPProperty, ",", &tmpLDAPProperty);
+     }
+ 
+     nsCRT::free(LDAPProperty);
+     return rv;
+ }
*** misc/mozilla/mailnews/addrbook/src/nsAbLDAPProperties.h	2002-04-09 11:27:24.000000000 +0200
--- misc/build/mozilla/mailnews/addrbook/src/nsAbLDAPProperties.h	2005-07-13 17:26:54.000000000 +0200
***************
*** 85,90 ****
--- 85,91 ----
      static nsresult createCardPropertyFromLDAPMessage (nsILDAPMessage* message,
              nsIAbCard* card,
              PRBool* hasSetCardProperty);
+     static nsresult getAllLDAPAttrsFromMozilla (const char* aLDAPProperty, PRUint32 *aAttrCount, char * **aAttributes);
  };
  
  #endif
*** misc/mozilla/mailnews/addrbook/src/nsAbMD5sum.cpp	2005-07-13 17:11:03.000000000 +0200
--- misc/build/mozilla/mailnews/addrbook/src/nsAbMD5sum.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 1 ****
! dummy
--- 1,633 ----
! /*
!  * The contents of this file are subject to the Mozilla Public
!  * License Version 1.1 (the "License"); you may not use this file
!  * except in compliance with the License. You may obtain a copy of
!  * the License at http://www.mozilla.org/MPL/
!  * 
!  * Software distributed under the License is distributed on an "AS
!  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
!  * implied. See the License for the specific language governing
!  * rights and limitations under the License.
!  * 
!  * The Original Code is the Netscape security libraries.
!  * 
!  * The Initial Developer of the Original Code is Netscape
!  * Communications Corporation.	Portions created by Netscape are 
!  * Copyright (C) 1994-2000 Netscape Communications Corporation.  All
!  * Rights Reserved.
!  * 
!  * Contributor(s):
!  * 
!  * Alternatively, the contents of this file may be used under the
!  * terms of the GNU General Public License Version 2 or later (the
!  * "GPL"), in which case the provisions of the GPL are applicable 
!  * instead of those above.	If you wish to allow use of your 
!  * version of this file only under the terms of the GPL and not to
!  * allow others to use your version of this file under the MPL,
!  * indicate your decision by deleting the provisions above and
!  * replace them with the notice and other provisions required by
!  * the GPL.  If you do not delete the provisions above, a recipient
!  * may use your version of this file under either the MPL or the
!  * GPL.
!  */
! #include <stdio.h>
! #include <stdlib.h>
! 
! #include "prerr.h"
! 
! #include "prtypes.h"
! #include "prlong.h"
! #include "plstr.h"
! #include "nsMemory.h"
! 
! #define MD5_HASH_LEN 16
! #define MD5_BUFFER_SIZE 64
! #define MD5_END_BUFFER (MD5_BUFFER_SIZE - 8)
! 
! #define CV0_1 0x67452301
! #define CV0_2 0xefcdab89
! #define CV0_3 0x98badcfe
! #define CV0_4 0x10325476
! 
! #define T1_0  0xd76aa478
! #define T1_1  0xe8c7b756
! #define T1_2  0x242070db
! #define T1_3  0xc1bdceee
! #define T1_4  0xf57c0faf
! #define T1_5  0x4787c62a
! #define T1_6  0xa8304613
! #define T1_7  0xfd469501
! #define T1_8  0x698098d8
! #define T1_9  0x8b44f7af
! #define T1_10 0xffff5bb1
! #define T1_11 0x895cd7be
! #define T1_12 0x6b901122
! #define T1_13 0xfd987193
! #define T1_14 0xa679438e
! #define T1_15 0x49b40821
! 
! #define T2_0  0xf61e2562
! #define T2_1  0xc040b340
! #define T2_2  0x265e5a51
! #define T2_3  0xe9b6c7aa
! #define T2_4  0xd62f105d
! #define T2_5  0x02441453
! #define T2_6  0xd8a1e681
! #define T2_7  0xe7d3fbc8
! #define T2_8  0x21e1cde6
! #define T2_9  0xc33707d6
! #define T2_10 0xf4d50d87
! #define T2_11 0x455a14ed
! #define T2_12 0xa9e3e905
! #define T2_13 0xfcefa3f8
! #define T2_14 0x676f02d9
! #define T2_15 0x8d2a4c8a
! 
! #define T3_0  0xfffa3942
! #define T3_1  0x8771f681
! #define T3_2  0x6d9d6122
! #define T3_3  0xfde5380c
! #define T3_4  0xa4beea44
! #define T3_5  0x4bdecfa9
! #define T3_6  0xf6bb4b60
! #define T3_7  0xbebfbc70
! #define T3_8  0x289b7ec6
! #define T3_9  0xeaa127fa
! #define T3_10 0xd4ef3085
! #define T3_11 0x04881d05
! #define T3_12 0xd9d4d039
! #define T3_13 0xe6db99e5
! #define T3_14 0x1fa27cf8
! #define T3_15 0xc4ac5665
! 
! #define T4_0  0xf4292244
! #define T4_1  0x432aff97
! #define T4_2  0xab9423a7
! #define T4_3  0xfc93a039
! #define T4_4  0x655b59c3
! #define T4_5  0x8f0ccc92
! #define T4_6  0xffeff47d
! #define T4_7  0x85845dd1
! #define T4_8  0x6fa87e4f
! #define T4_9  0xfe2ce6e0
! #define T4_10 0xa3014314
! #define T4_11 0x4e0811a1
! #define T4_12 0xf7537e82
! #define T4_13 0xbd3af235
! #define T4_14 0x2ad7d2bb
! #define T4_15 0xeb86d391
! 
! #define R1B0  0
! #define R1B1  1
! #define R1B2  2
! #define R1B3  3
! #define R1B4  4
! #define R1B5  5
! #define R1B6  6
! #define R1B7  7
! #define R1B8  8
! #define R1B9  9
! #define R1B10 10
! #define R1B11 11
! #define R1B12 12
! #define R1B13 13
! #define R1B14 14
! #define R1B15 15
! 
! #define R2B0  1
! #define R2B1  6
! #define R2B2  11
! #define R2B3  0
! #define R2B4  5
! #define R2B5  10
! #define R2B6  15
! #define R2B7  4
! #define R2B8  9
! #define R2B9  14
! #define R2B10 3 
! #define R2B11 8 
! #define R2B12 13
! #define R2B13 2 
! #define R2B14 7 
! #define R2B15 12
! 
! #define R3B0  5
! #define R3B1  8
! #define R3B2  11
! #define R3B3  14
! #define R3B4  1
! #define R3B5  4
! #define R3B6  7
! #define R3B7  10
! #define R3B8  13
! #define R3B9  0
! #define R3B10 3 
! #define R3B11 6 
! #define R3B12 9 
! #define R3B13 12
! #define R3B14 15
! #define R3B15 2 
! 
! #define R4B0  0
! #define R4B1  7
! #define R4B2  14
! #define R4B3  5
! #define R4B4  12
! #define R4B5  3
! #define R4B6  10
! #define R4B7  1
! #define R4B8  8
! #define R4B9  15
! #define R4B10 6 
! #define R4B11 13
! #define R4B12 4 
! #define R4B13 11
! #define R4B14 2 
! #define R4B15 9 
! 
! #define S1_0 7
! #define S1_1 12
! #define S1_2 17
! #define S1_3 22
! 
! #define S2_0 5
! #define S2_1 9
! #define S2_2 14
! #define S2_3 20
! 
! #define S3_0 4
! #define S3_1 11
! #define S3_2 16
! #define S3_3 23
! 
! #define S4_0 6
! #define S4_1 10
! #define S4_2 15
! #define S4_3 21
! 
! struct MD5ContextStr {
! 	PRUint32      lsbInput;
! 	PRUint32      msbInput;
! 	PRUint32      cv[4];
! 	union {
! 		PRUint8 b[64];
! 		PRUint32 w[16];
! 	} u;
! };
! typedef struct MD5ContextStr        MD5Context;
! 
! #define inBuf u.b
! 
! int MD5_Hash(unsigned char *dest, const char *src);
! int MD5_HashBuf(unsigned char *dest, const unsigned char *src, uint32 src_length);
! MD5Context * MD5_NewContext(void);
! void MD5_DestroyContext(MD5Context *cx, PRBool freeit);
! void MD5_Begin(MD5Context *cx);
! static void md5_compress(MD5Context *cx);
! void MD5_Update(MD5Context *cx, const unsigned char *input, unsigned int inputLen);
! void MD5_End(MD5Context *cx, unsigned char *digest,
!         unsigned int *digestLen, unsigned int maxDigestLen);
! unsigned int MD5_FlattenSize(MD5Context *cx);
! int MD5_Flatten(MD5Context *cx, unsigned char *space);
! MD5Context * MD5_Resurrect(unsigned char *space, void *arg);
! void MD5_TraceState(MD5Context *cx);
! 
! int 
! MD5_Hash(unsigned char *dest, const char *src)
! {
! 	return MD5_HashBuf(dest, (unsigned char *)src, PL_strlen(src));
! }
! 
! int 
! MD5_HashBuf(unsigned char *dest, const unsigned char *src, uint32 src_length)
! {
! 	unsigned int len;
! 	MD5Context *cx = MD5_NewContext();
! 	if (cx == NULL) {
! //		PORT_SetError(PR_OUT_OF_MEMORY_ERROR);
! 		return -1;
! 	}
! 	MD5_Begin(cx);
! 	MD5_Update(cx, src, src_length);
! 	MD5_End(cx, dest, &len, MD5_HASH_LEN);
! 	MD5_DestroyContext(cx, PR_TRUE);
! 	return 0;
! }
! 
! MD5Context *
! MD5_NewContext(void)
! {
! 	MD5Context *cx = (MD5Context *)malloc(sizeof(MD5Context));
! 	if (cx == NULL) {
! //		PORT_SetError(PR_OUT_OF_MEMORY_ERROR);
! 		return NULL;
! 	}
! 	return cx;
! }
! 
! void 
! MD5_DestroyContext(MD5Context *cx, PRBool freeit)
! {
! 	if (freeit) {
! 		free(cx);
! 	}
! }
! 
! void 
! MD5_Begin(MD5Context *cx)
! {
! 	cx->lsbInput = 0;
! 	cx->msbInput = 0;
! 	memset(cx->inBuf, 0, sizeof(cx->inBuf));
! 	cx->cv[0] = CV0_1;
! 	cx->cv[1] = CV0_2;
! 	cx->cv[2] = CV0_3;
! 	cx->cv[3] = CV0_4;
! }
! 
! #define cls(i32, s) (tmp = i32, tmp << s | tmp >> (32 - s))
! 
! #define MASK 0x00ff00ff
! #ifdef IS_LITTLE_ENDIAN
! #define lendian(i32) \
! 	(i32)
! #else
! #define lendian(i32) \
! 	(tmp = i32 >> 16 | i32 << 16, (tmp & MASK) << 8 | tmp >> 8 & MASK)
! #endif
! 
! #if defined(SOLARIS) || defined(HPUX)
! #define addto64(sumhigh, sumlow, addend) \
! 	sumlow += addend; sumhigh += (sumlow < addend);
! #else
! #define addto64(sumhigh, sumlow, addend) \
! 	sumlow += addend; if (sumlow < addend) ++sumhigh;
! #endif
! 
! #define F(X, Y, Z) \
! 	((X & Y) | ((~X) & Z))
! 
! #define G(X, Y, Z) \
! 	((X & Z) | (Y & (~Z)))
! 
! #define H(X, Y, Z) \
! 	(X ^ Y ^ Z)
! 
! #define I(X, Y, Z) \
! 	(Y ^ (X | (~Z)))
! 
! #define FF(a, b, c, d, bufint, s, ti) \
! 	a = b + cls(a + F(b, c, d) + bufint + ti, s)
! 
! #define GG(a, b, c, d, bufint, s, ti) \
! 	a = b + cls(a + G(b, c, d) + bufint + ti, s)
! 
! #define HH(a, b, c, d, bufint, s, ti) \
! 	a = b + cls(a + H(b, c, d) + bufint + ti, s)
! 
! #define II(a, b, c, d, bufint, s, ti) \
! 	a = b + cls(a + I(b, c, d) + bufint + ti, s)
! 
! static void
! md5_compress(MD5Context *cx)
! {
! 	PRUint32 a, b, c, d;
! 	PRUint32 tmp;
! 	a = cx->cv[0];
! 	b = cx->cv[1];
! 	c = cx->cv[2];
! 	d = cx->cv[3];
! #ifndef IS_LITTLE_ENDIAN
! 	cx->u.w[0] = lendian(cx->u.w[0]);
! 	cx->u.w[1] = lendian(cx->u.w[1]);
! 	cx->u.w[2] = lendian(cx->u.w[2]);
! 	cx->u.w[3] = lendian(cx->u.w[3]);
! 	cx->u.w[4] = lendian(cx->u.w[4]);
! 	cx->u.w[5] = lendian(cx->u.w[5]);
! 	cx->u.w[6] = lendian(cx->u.w[6]);
! 	cx->u.w[7] = lendian(cx->u.w[7]);
! 	cx->u.w[8] = lendian(cx->u.w[8]);
! 	cx->u.w[9] = lendian(cx->u.w[9]);
! 	cx->u.w[10] = lendian(cx->u.w[10]);
! 	cx->u.w[11] = lendian(cx->u.w[11]);
! 	cx->u.w[12] = lendian(cx->u.w[12]);
! 	cx->u.w[13] = lendian(cx->u.w[13]);
! 	cx->u.w[14] = lendian(cx->u.w[14]);
! 	cx->u.w[15] = lendian(cx->u.w[15]);
! #endif
! 	FF(a, b, c, d, cx->u.w[R1B0 ], S1_0, T1_0);
! 	FF(d, a, b, c, cx->u.w[R1B1 ], S1_1, T1_1);
! 	FF(c, d, a, b, cx->u.w[R1B2 ], S1_2, T1_2);
! 	FF(b, c, d, a, cx->u.w[R1B3 ], S1_3, T1_3);
! 	FF(a, b, c, d, cx->u.w[R1B4 ], S1_0, T1_4);
! 	FF(d, a, b, c, cx->u.w[R1B5 ], S1_1, T1_5);
! 	FF(c, d, a, b, cx->u.w[R1B6 ], S1_2, T1_6);
! 	FF(b, c, d, a, cx->u.w[R1B7 ], S1_3, T1_7);
! 	FF(a, b, c, d, cx->u.w[R1B8 ], S1_0, T1_8);
! 	FF(d, a, b, c, cx->u.w[R1B9 ], S1_1, T1_9);
! 	FF(c, d, a, b, cx->u.w[R1B10], S1_2, T1_10);
! 	FF(b, c, d, a, cx->u.w[R1B11], S1_3, T1_11);
! 	FF(a, b, c, d, cx->u.w[R1B12], S1_0, T1_12);
! 	FF(d, a, b, c, cx->u.w[R1B13], S1_1, T1_13);
! 	FF(c, d, a, b, cx->u.w[R1B14], S1_2, T1_14);
! 	FF(b, c, d, a, cx->u.w[R1B15], S1_3, T1_15);
! 	GG(a, b, c, d, cx->u.w[R2B0 ], S2_0, T2_0);
! 	GG(d, a, b, c, cx->u.w[R2B1 ], S2_1, T2_1);
! 	GG(c, d, a, b, cx->u.w[R2B2 ], S2_2, T2_2);
! 	GG(b, c, d, a, cx->u.w[R2B3 ], S2_3, T2_3);
! 	GG(a, b, c, d, cx->u.w[R2B4 ], S2_0, T2_4);
! 	GG(d, a, b, c, cx->u.w[R2B5 ], S2_1, T2_5);
! 	GG(c, d, a, b, cx->u.w[R2B6 ], S2_2, T2_6);
! 	GG(b, c, d, a, cx->u.w[R2B7 ], S2_3, T2_7);
! 	GG(a, b, c, d, cx->u.w[R2B8 ], S2_0, T2_8);
! 	GG(d, a, b, c, cx->u.w[R2B9 ], S2_1, T2_9);
! 	GG(c, d, a, b, cx->u.w[R2B10], S2_2, T2_10);
! 	GG(b, c, d, a, cx->u.w[R2B11], S2_3, T2_11);
! 	GG(a, b, c, d, cx->u.w[R2B12], S2_0, T2_12);
! 	GG(d, a, b, c, cx->u.w[R2B13], S2_1, T2_13);
! 	GG(c, d, a, b, cx->u.w[R2B14], S2_2, T2_14);
! 	GG(b, c, d, a, cx->u.w[R2B15], S2_3, T2_15);
! 	HH(a, b, c, d, cx->u.w[R3B0 ], S3_0, T3_0);
! 	HH(d, a, b, c, cx->u.w[R3B1 ], S3_1, T3_1);
! 	HH(c, d, a, b, cx->u.w[R3B2 ], S3_2, T3_2);
! 	HH(b, c, d, a, cx->u.w[R3B3 ], S3_3, T3_3);
! 	HH(a, b, c, d, cx->u.w[R3B4 ], S3_0, T3_4);
! 	HH(d, a, b, c, cx->u.w[R3B5 ], S3_1, T3_5);
! 	HH(c, d, a, b, cx->u.w[R3B6 ], S3_2, T3_6);
! 	HH(b, c, d, a, cx->u.w[R3B7 ], S3_3, T3_7);
! 	HH(a, b, c, d, cx->u.w[R3B8 ], S3_0, T3_8);
! 	HH(d, a, b, c, cx->u.w[R3B9 ], S3_1, T3_9);
! 	HH(c, d, a, b, cx->u.w[R3B10], S3_2, T3_10);
! 	HH(b, c, d, a, cx->u.w[R3B11], S3_3, T3_11);
! 	HH(a, b, c, d, cx->u.w[R3B12], S3_0, T3_12);
! 	HH(d, a, b, c, cx->u.w[R3B13], S3_1, T3_13);
! 	HH(c, d, a, b, cx->u.w[R3B14], S3_2, T3_14);
! 	HH(b, c, d, a, cx->u.w[R3B15], S3_3, T3_15);
! 	II(a, b, c, d, cx->u.w[R4B0 ], S4_0, T4_0);
! 	II(d, a, b, c, cx->u.w[R4B1 ], S4_1, T4_1);
! 	II(c, d, a, b, cx->u.w[R4B2 ], S4_2, T4_2);
! 	II(b, c, d, a, cx->u.w[R4B3 ], S4_3, T4_3);
! 	II(a, b, c, d, cx->u.w[R4B4 ], S4_0, T4_4);
! 	II(d, a, b, c, cx->u.w[R4B5 ], S4_1, T4_5);
! 	II(c, d, a, b, cx->u.w[R4B6 ], S4_2, T4_6);
! 	II(b, c, d, a, cx->u.w[R4B7 ], S4_3, T4_7);
! 	II(a, b, c, d, cx->u.w[R4B8 ], S4_0, T4_8);
! 	II(d, a, b, c, cx->u.w[R4B9 ], S4_1, T4_9);
! 	II(c, d, a, b, cx->u.w[R4B10], S4_2, T4_10);
! 	II(b, c, d, a, cx->u.w[R4B11], S4_3, T4_11);
! 	II(a, b, c, d, cx->u.w[R4B12], S4_0, T4_12);
! 	II(d, a, b, c, cx->u.w[R4B13], S4_1, T4_13);
! 	II(c, d, a, b, cx->u.w[R4B14], S4_2, T4_14);
! 	II(b, c, d, a, cx->u.w[R4B15], S4_3, T4_15);
! 	cx->cv[0] += a;
! 	cx->cv[1] += b;
! 	cx->cv[2] += c;
! 	cx->cv[3] += d;
! }
! 
! void 
! MD5_Update(MD5Context *cx, const unsigned char *input, unsigned int inputLen)
! {
! 	PRUint32 bytesToConsume;
! 	PRUint32 inBufIndex = cx->lsbInput & 63;
! 
! 	/* Add the number of input bytes to the 64-bit input counter. */
! 	addto64(cx->msbInput, cx->lsbInput, inputLen);
! 	if (inBufIndex) {
! 		/* There is already data in the buffer.  Fill with input. */
! 		bytesToConsume = PR_MIN(inputLen, MD5_BUFFER_SIZE - inBufIndex);
! 		memcpy(&cx->inBuf[inBufIndex], input, bytesToConsume);
! 		if (inBufIndex + bytesToConsume >= MD5_BUFFER_SIZE)
! 			/* The buffer is filled.  Run the compression function. */
! 			md5_compress(cx);
! 		/* Remaining input. */
! 		inputLen -= bytesToConsume;
! 		input += bytesToConsume;
! 	}
! 
! 	/* Iterate over 64-byte chunks of the message. */
! 	while (inputLen >= MD5_BUFFER_SIZE) {
! 		memcpy(cx->inBuf, input, MD5_BUFFER_SIZE);
! 		md5_compress(cx);
! 		inputLen -= MD5_BUFFER_SIZE;
! 		input += MD5_BUFFER_SIZE;
! 	}
! 
! 	/* Tail of message (message bytes mod 64). */
! 	if (inputLen)
! 		memcpy(cx->inBuf, input, inputLen);
! }
! 
! static const unsigned char padbytes[] = {
! 	0x80, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
! 	0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00
! };
! 
! void 
! MD5_End(MD5Context *cx, unsigned char *digest,
!         unsigned int *digestLen, unsigned int maxDigestLen)
! {
! #ifndef IS_LITTLE_ENDIAN
! 	PRUint32 tmp;
! #endif
! 	PRUint32 lowInput, highInput;
! 	PRUint32 inBufIndex = cx->lsbInput & 63;
! 
! 	if (maxDigestLen < MD5_HASH_LEN) {
! //		PORT_SetError(SEC_ERROR_INVALID_ARGS);
! 		return;
! 	}
! 
! 	/* Copy out the length of bits input before padding. */
! 	lowInput = cx->lsbInput; 
! 	highInput = (cx->msbInput << 3) | (lowInput >> 29);
! 	lowInput <<= 3;
! 
! 	if (inBufIndex < MD5_END_BUFFER) {
! 		MD5_Update(cx, padbytes, MD5_END_BUFFER - inBufIndex);
! 	} else {
! 		MD5_Update(cx, padbytes, 
! 		           MD5_END_BUFFER + MD5_BUFFER_SIZE - inBufIndex);
! 	}
! 
! 	/* Store the number of bytes input (before padding) in final 64 bits. */
! 	cx->u.w[14] = lendian(lowInput);
! 	cx->u.w[15] = lendian(highInput);
! 
! 	/* Final call to compress. */
! 	md5_compress(cx);
! 
! 	/* Copy the resulting values out of the chain variables into return buf. */
! 	*digestLen = MD5_HASH_LEN;
! #ifndef IS_LITTLE_ENDIAN
! 	cx->cv[0] = lendian(cx->cv[0]);
! 	cx->cv[1] = lendian(cx->cv[1]);
! 	cx->cv[2] = lendian(cx->cv[2]);
! 	cx->cv[3] = lendian(cx->cv[3]);
! #endif
! 	memcpy(digest, cx->cv, MD5_HASH_LEN);
! }
! 
! unsigned int 
! MD5_FlattenSize(MD5Context *cx)
! {
! 	return sizeof(*cx);
! }
! 
! int 
! MD5_Flatten(MD5Context *cx, unsigned char *space)
! {
! 	memcpy(space, cx, sizeof(*cx));
! 	return 0;
! }
! 
! MD5Context * 
! MD5_Resurrect(unsigned char *space, void *arg)
! {
! 	MD5Context *cx = MD5_NewContext();
! 	if (cx)
! 		memcpy(cx, space, sizeof(*cx));
! 	return cx;
! }
! 
! void 
! MD5_TraceState(MD5Context *cx)
! {
! //	PORT_SetError(PR_NOT_IMPLEMENTED_ERROR);
! }
! 
! int
! md5_stream (FILE *stream, unsigned char *dest)
! {
!   /* Important: BLOCKSIZE must be a multiple of 64.  */
! #define BLOCKSIZE 4096
! 	unsigned int len;
! 	MD5Context *cx = MD5_NewContext();
! 	if (cx == NULL) {
! //		PORT_SetError(PR_OUT_OF_MEMORY_ERROR);
! 		return -1;
! 	}
! 
!   unsigned char buffer[BLOCKSIZE + 72];
!   size_t sum;
! 
!   /* Initialize the computation context.  */
!   MD5_Begin(cx);
! 
!   /* Iterate over full file contents.  */
!   while (1)
!     {
!       /* We read the file in blocks of BLOCKSIZE bytes.  One call of the
! 	 computation function processes the whole buffer so that with the
! 	 next round of the loop another block can be read.  */
!       size_t n;
!       sum = 0;
! 
!       /* Read block.  Take care for partial reads.  */
!       do
! 	{
! 	  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);
! 
! 	  sum += n;
! 	}
!       while (sum < BLOCKSIZE && n != 0);
!       if (n == 0 && ferror (stream))
!         return 1;
! 
!       /* If end of file is reached, end the loop.  */
!       if (n == 0)
! 	break;
! 
!       /* Process buffer with BLOCKSIZE bytes.  Note that
! 			BLOCKSIZE % 64 == 0
!        */
! 	MD5_Update(cx, buffer, BLOCKSIZE);
!     }
! 
!   /* Add the last bytes if necessary.  */
!   if (sum > 0)
! 	MD5_Update(cx, buffer, sum);
! 
! 	MD5_End(cx, dest, &len, MD5_HASH_LEN);
! 	MD5_DestroyContext(cx, PR_TRUE);
! 	return len;
! 
! }
! 
! int getMD5sum(const char * fileName,char * sum)
! {
! 	unsigned char bin_sum[16];
! 	int len=0;
! 	if (fileName)
! 	{
! 		FILE *fp=fopen(fileName,"rb");
! 		if (fp)
! 		{
! 			len=md5_stream(fp,bin_sum);
! 			memset(sum,0,33);
! 			for (int i = 0; i < len; ++i)
! 				sprintf (sum,"%s%02x",sum, bin_sum[i]);
! 			fclose(fp);
! 			return 0;
! 		}
! 	}
! 	return 1;
! }
! 
! int testMD5sum(const char * fileName,char * sum)
! {
! 	char newSum[33]="";
! 	if (getMD5sum(fileName,newSum))
! 		return 1;
! 	return strcmp(newSum,sum);
! }
*** misc/mozilla/mailnews/addrbook/src/nsAbMDBCardProperty.cpp	2002-11-12 20:19:56.000000000 +0100
--- misc/build/mozilla/mailnews/addrbook/src/nsAbMDBCardProperty.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 266,273 ****
  	if (mCardDatabase)
  	{
  		mCardDatabase->EditCard(this, PR_TRUE);
!     mCardDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
! 		return NS_OK;
  	}
  	else
  		return NS_ERROR_FAILURE;
--- 266,272 ----
  	if (mCardDatabase)
  	{
  		mCardDatabase->EditCard(this, PR_TRUE);
! 		return mCardDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
  	}
  	else
  		return NS_ERROR_FAILURE;
*** misc/mozilla/mailnews/addrbook/src/nsAbMDBDirectory.cpp	2004-03-09 15:42:24.000000000 +0100
--- misc/build/mozilla/mailnews/addrbook/src/nsAbMDBDirectory.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 537,543 ****
          }
        }
      }
!     mDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
    }
    return rv;
  }
--- 537,543 ----
          }
        }
      }
!     rv = mDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
    }
    return rv;
  }
***************
*** 684,689 ****
--- 684,690 ----
      return NS_ERROR_NOT_IMPLEMENTED;
  
    nsresult rv = NS_OK;
+ 
    if (!mDatabase)
      rv = GetAbDatabase();
  
***************
*** 713,722 ****
      mDatabase->CreateNewListCardAndAddToDB(this, m_dbRowID, newCard, PR_TRUE);
    else
      mDatabase->CreateNewCardAndAddToDB(newCard, PR_TRUE);
!   mDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
  
    NS_IF_ADDREF(*addedCard = newCard);
!   return NS_OK;
  }
  
  NS_IMETHODIMP nsAbMDBDirectory::DropCard(nsIAbCard* aCard, PRBool needToCopyCard)
--- 714,724 ----
      mDatabase->CreateNewListCardAndAddToDB(this, m_dbRowID, newCard, PR_TRUE);
    else
      mDatabase->CreateNewCardAndAddToDB(newCard, PR_TRUE);
!   rv = mDatabase->Commit(nsAddrDBCommitType::kLargeCommit);
  
+   NS_ENSURE_SUCCESS(rv, rv);
    NS_IF_ADDREF(*addedCard = newCard);
!   return rv;
  }
  
  NS_IMETHODIMP nsAbMDBDirectory::DropCard(nsIAbCard* aCard, PRBool needToCopyCard)
*** misc/mozilla/mailnews/addrbook/src/nsAbOutlookCard.cpp	2004-03-09 16:18:40.000000000 +0100
--- misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookCard.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 97,102 ****
--- 97,103 ----
  {
      index_DisplayName = 0,
      index_EmailAddress,
+     index_SecondEmailAddress,
      index_FirstName,
      index_LastName,
      index_NickName,
***************
*** 124,155 ****
  
  static const ULONG OutlookCardMAPIProps [] = 
  {
!     PR_DISPLAY_NAME_W,
!     PR_EMAIL_ADDRESS_W,
!     PR_GIVEN_NAME_W,
!     PR_SURNAME_W,
!     PR_NICKNAME_W,
!     PR_BUSINESS_TELEPHONE_NUMBER_W,
!     PR_HOME_TELEPHONE_NUMBER_W,
!     PR_BUSINESS_FAX_NUMBER_W,
!     PR_PAGER_TELEPHONE_NUMBER_W,
!     PR_MOBILE_TELEPHONE_NUMBER_W,
!     PR_HOME_ADDRESS_CITY_W,
!     PR_HOME_ADDRESS_STATE_OR_PROVINCE_W,
!     PR_HOME_ADDRESS_POSTAL_CODE_W,
!     PR_HOME_ADDRESS_COUNTRY_W,
!     PR_BUSINESS_ADDRESS_CITY_W,
!     PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_W,
!     PR_BUSINESS_ADDRESS_POSTAL_CODE_W,
!     PR_BUSINESS_ADDRESS_COUNTRY_W,
!     PR_TITLE_W,
!     PR_DEPARTMENT_NAME_W,
!     PR_COMPANY_NAME_W,
!     PR_BUSINESS_HOME_PAGE_W,
!     PR_PERSONAL_HOME_PAGE_W,
!     PR_COMMENT_W
  } ;
  
  nsresult nsAbOutlookCard::Init(const char *aUri)
  {
      nsresult retCode = nsRDFResource::Init(aUri) ;
--- 125,158 ----
  
  static const ULONG OutlookCardMAPIProps [] = 
  {
!     PR_DISPLAY_NAME_A,//0x8035001E
!     PR_EMAIL_ADDRESS_A,//0x8034001E
!     PR_SECOND_EMAIL_ADDRESS_A,//Second Email Address
!     PR_GIVEN_NAME_A,
!     PR_SURNAME_A,
!     PR_NICKNAME_A,
!     PR_BUSINESS_TELEPHONE_NUMBER_A,
!     PR_HOME_TELEPHONE_NUMBER_A,
!     PR_BUSINESS_FAX_NUMBER_A,
!     PR_PAGER_TELEPHONE_NUMBER_A,
!     PR_MOBILE_TELEPHONE_NUMBER_A,
!     PR_HOME_ADDRESS_CITY_A,
!     PR_HOME_ADDRESS_STATE_OR_PROVINCE_A,
!     PR_HOME_ADDRESS_POSTAL_CODE_A,
!     PR_HOME_ADDRESS_COUNTRY_A,
!     PR_BUSINESS_ADDRESS_CITY_A,
!     PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_A,
!     PR_BUSINESS_ADDRESS_POSTAL_CODE_A,
!     PR_BUSINESS_ADDRESS_COUNTRY_A,
!     PR_TITLE_A,
!     PR_DEPARTMENT_NAME_A,
!     PR_COMPANY_NAME_A,
!     PR_BUSINESS_HOME_PAGE_A,
!     PR_PERSONAL_HOME_PAGE_A,
!     PR_COMMENT_A
  } ;
  
+ 
  nsresult nsAbOutlookCard::Init(const char *aUri)
  {
      nsresult retCode = nsRDFResource::Init(aUri) ;
***************
*** 176,181 ****
--- 179,185 ----
          SetDisplayName(unichars [index_DisplayName]->get()) ;
          SetNickName(unichars [index_NickName]->get()) ;
          SetPrimaryEmail(unichars [index_EmailAddress]->get()) ;
+         SetSecondEmail(unichars [index_SecondEmailAddress]->get()) ;
          SetWorkPhone(unichars [index_WorkPhoneNumber]->get()) ;
          SetHomePhone(unichars [index_HomePhoneNumber]->get()) ;
          SetFaxNumber(unichars [index_WorkFaxNumber]->get()) ;
***************
*** 210,221 ****
      nsAutoString unichar ;
      nsAutoString unicharBis ;
  
!     if (mapiAddBook->GetPropertyUString(*mMapiData, PR_HOME_ADDRESS_STREET_W, unichar)) {
          splitString(unichar, unicharBis) ;
          SetHomeAddress(unichar.get()) ;
          SetHomeAddress2(unicharBis.get()) ;
      }
!     if (mapiAddBook->GetPropertyUString(*mMapiData, PR_BUSINESS_ADDRESS_STREET_W, unichar)) {
          splitString(unichar, unicharBis) ;
          SetWorkAddress(unichar.get()) ;
          SetWorkAddress2(unicharBis.get()) ;
--- 214,225 ----
      nsAutoString unichar ;
      nsAutoString unicharBis ;
  
!     if (mapiAddBook->GetPropertyUString(*mMapiData, PR_HOME_ADDRESS_STREET_A, unichar)) {
          splitString(unichar, unicharBis) ;
          SetHomeAddress(unichar.get()) ;
          SetHomeAddress2(unicharBis.get()) ;
      }
!     if (mapiAddBook->GetPropertyUString(*mMapiData, PR_BUSINESS_ADDRESS_STREET_A, unichar)) {
          splitString(unichar, unicharBis) ;
          SetWorkAddress(unichar.get()) ;
          SetWorkAddress2(unicharBis.get()) ;
***************
*** 297,302 ****
--- 301,307 ----
      SetDisplayName(properties [index_DisplayName]) ;
      GetNickName(getter_Copies(properties [index_NickName])) ;
      GetPrimaryEmail(getter_Copies(properties [index_EmailAddress])) ;
+     GetSecondEmail(getter_Copies(properties [index_SecondEmailAddress])) ;
      GetWorkPhone(getter_Copies(properties [index_WorkPhoneNumber])) ;
      GetHomePhone(getter_Copies(properties [index_HomePhoneNumber])) ;
      GetFaxNumber(getter_Copies(properties [index_WorkFaxNumber])) ;
***************
*** 316,324 ****
      GetWebPage1(getter_Copies(properties [index_WorkWebPage])) ;
      GetWebPage2(getter_Copies(properties [index_HomeWebPage])) ;
      GetNotes(getter_Copies(properties [index_Comments])) ;
!     if (!mapiAddBook->SetPropertiesUString(*mMapiData, OutlookCardMAPIProps, 
!         index_LastProp, properties)) {
!         PRINTF(("Cannot set general properties.\n")) ;
      }
      delete [] properties ;
      nsXPIDLString unichar ;
--- 321,336 ----
      GetWebPage1(getter_Copies(properties [index_WorkWebPage])) ;
      GetWebPage2(getter_Copies(properties [index_HomeWebPage])) ;
      GetNotes(getter_Copies(properties [index_Comments])) ;
! 
!     int i=0;
!     for (i=0;i<index_LastProp;i++)
!     {
!         if (!mapiAddBook->SetPropertyUString(*mMapiData,
!                                             OutlookCardMAPIProps[i],
!                                             properties[i]))
!         {
!             PRINTF(("Cannot set properties:%d.\n",OutlookCardMAPIProps[i])) ;
!     }
      }
      delete [] properties ;
      nsXPIDLString unichar ;
*** misc/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.cpp	2004-02-05 19:33:06.000000000 +0100
--- misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 126,132 ****
          PRINTF(("Cannot get type.\n")) ;
          return NS_ERROR_FAILURE ;
      }
!     if (!mapiAddBook->GetPropertyUString(*mMapiData, PR_DISPLAY_NAME_W, unichars)) {
          PRINTF(("Cannot get name.\n")) ;
          return NS_ERROR_FAILURE ;
      }
--- 126,132 ----
          PRINTF(("Cannot get type.\n")) ;
          return NS_ERROR_FAILURE ;
      }
!     if (!mapiAddBook->GetPropertyUString(*mMapiData, PR_DISPLAY_NAME_A, unichars)) {
          PRINTF(("Cannot get name.\n")) ;
          return NS_ERROR_FAILURE ;
      }
***************
*** 163,207 ****
      return retCode;
  }
  
  NS_IMETHODIMP nsAbOutlookDirectory::GetChildCards(nsIEnumerator **aCards)
  {
      if (!aCards) { return NS_ERROR_NULL_POINTER ; }
      *aCards = nsnull ;
      nsCOMPtr<nsISupportsArray> cardList ;
      nsresult retCode ;
      
-     mCardList.Reset() ;
      if (mIsQueryURI) {
          retCode = StartSearch() ;
-         NS_NewISupportsArray(getter_AddRefs(cardList)) ;
      }
      else {
!         retCode = GetChildCards(getter_AddRefs(cardList), nsnull) ;
      }
      if (NS_SUCCEEDED(retCode)) {
          // Fill the results array and update the card list
          // Also update the address list and notify any changes.
          PRUint32 nbCards = 0 ;
!         nsCOMPtr<nsISupports> element ;
          
-         cardList->Enumerate(aCards) ;
-         cardList->Count(&nbCards) ;
          for (PRUint32 i = 0 ; i < nbCards ; ++ i) {
!             cardList->GetElementAt(i, getter_AddRefs(element)) ;
!             nsVoidKey newKey (NS_STATIC_CAST(void *, element)) ;
!             nsCOMPtr<nsISupports> oldElement = mCardList.Get(&newKey) ;
  
!             if (!oldElement) {
                  // We are dealing with a new element (probably directly
                  // added from Outlook), we may need to sync m_AddressList
!                 mCardList.Put(&newKey, element) ;
!                 nsCOMPtr<nsIAbCard> card (do_QueryInterface(element, &retCode)) ;
  
                  NS_ENSURE_SUCCESS(retCode, retCode) ;
                  PRBool isMailList = PR_FALSE ;
  
                  retCode = card->GetIsMailList(&isMailList) ;
                  NS_ENSURE_SUCCESS(retCode, retCode) ;
                  if (isMailList) {
                      // We can have mailing lists only in folder, 
                      // we must add the directory to m_AddressList
--- 163,247 ----
      return retCode;
  }
  
+ nsresult nsAbOutlookDirectory::BuildCardFromURI(const nsCString& uriName,nsIAbCard **aNewCard, 
+                                                 PRBool aSearchForOld, PRBool& aIsNewCard)
+ {   
+     nsresult retCode = NS_OK ;
+     if (aSearchForOld) {
+         nsCStringKey key(uriName) ;
+         nsCOMPtr<nsISupports> existingCard = mCardList.Get(&key) ;
+         
+         if (existingCard) {
+             nsCOMPtr<nsIAbCard> card(do_QueryInterface(existingCard, &retCode)) ;
+             
+             NS_ENSURE_SUCCESS(retCode, retCode) ;
+             NS_IF_ADDREF(*aNewCard = card) ;
+             aIsNewCard = PR_FALSE ;
+             return retCode ;
+         }
+     }
+     aIsNewCard = PR_TRUE ;
+     nsCOMPtr<nsIRDFResource> resource ;
+ 
+     nsCOMPtr<nsIAbCard> childCard = do_CreateInstance(NS_ABOUTLOOKCARD_CONTRACTID, &retCode);
+     NS_ENSURE_SUCCESS(retCode, retCode) ;
+     resource = do_QueryInterface(childCard, &retCode) ;
+     NS_ENSURE_SUCCESS(retCode, retCode) ;
+     retCode = resource->Init(uriName.get()) ;
+     NS_ENSURE_SUCCESS(retCode, retCode) ;
+     NS_IF_ADDREF(*aNewCard = childCard);
+     return retCode ;
+ }
+ 
  NS_IMETHODIMP nsAbOutlookDirectory::GetChildCards(nsIEnumerator **aCards)
  {
      if (!aCards) { return NS_ERROR_NULL_POINTER ; }
      *aCards = nsnull ;
      nsCOMPtr<nsISupportsArray> cardList ;
+     nsCStringArray uriList ;
+     nsAbWinHelperGuard mapiAddBook (mAbWinType) ;
      nsresult retCode ;
      
      if (mIsQueryURI) {
          retCode = StartSearch() ;
      }
      else {
!         retCode = GetChildCards(uriList, nsnull) ;
      }
+     NS_NewISupportsArray(getter_AddRefs(cardList)) ;
      if (NS_SUCCEEDED(retCode)) {
          // Fill the results array and update the card list
          // Also update the address list and notify any changes.
          PRUint32 nbCards = 0 ;
!         nsCAutoString uriName;
!         nsCOMPtr <nsIAbCard> childCard;
!         PRBool searchForOldCards = 0; //(mCardList.Count() != 0) ;
! 
!         nbCards = uriList.Count();
! 		NS_NewISupportsArray(getter_AddRefs(m_AddressList));
          
          for (PRUint32 i = 0 ; i < nbCards ; ++ i) {
!             PRBool isNewCard = PR_FALSE ;
  
!             uriList.CStringAt(i,uriName);
!             retCode = BuildCardFromURI(uriName,getter_AddRefs(childCard), searchForOldCards, isNewCard);
!             NS_ENSURE_SUCCESS(retCode, retCode) ;
!             cardList->AppendElement(childCard);
! 
!             if (isNewCard) {
                  // We are dealing with a new element (probably directly
                  // added from Outlook), we may need to sync m_AddressList
!                 nsCStringKey newKey(uriName) ;
! 
!                 mCardList.Put(&newKey, childCard) ;
!                 nsCOMPtr<nsIAbCard> card (do_QueryInterface(childCard, &retCode)) ;
  
                  NS_ENSURE_SUCCESS(retCode, retCode) ;
                  PRBool isMailList = PR_FALSE ;
  
                  retCode = card->GetIsMailList(&isMailList) ;
                  NS_ENSURE_SUCCESS(retCode, retCode) ;
+ 
                  if (isMailList) {
                      // We can have mailing lists only in folder, 
                      // we must add the directory to m_AddressList
***************
*** 224,241 ****
                      NotifyItemAddition(card) ;
                  }
              }
-             else {
-                 NS_ASSERTION(oldElement == element, "Different card stored") ;
              }
          }
      }
      return retCode ;
  }
  
  NS_IMETHODIMP nsAbOutlookDirectory::HasCard(nsIAbCard *aCard, PRBool *aHasCard)
  {
      if (!aCard || !aHasCard) { return NS_ERROR_NULL_POINTER ; }
!     nsVoidKey key (NS_STATIC_CAST(void *, aCard)) ;
  
      *aHasCard = mCardList.Exists(&key) ;
      return NS_OK ;
--- 264,296 ----
                      NotifyItemAddition(card) ;
                  }
              }
              }
          }
+     return cardList->Enumerate(aCards) ;
      }
+ 
+ static nsresult ExtractUriFromCard(nsIAbCard *aCard, nsCString& aUri) {
+     nsresult retCode = NS_OK ;
+     nsCOMPtr<nsIRDFResource> resource (do_QueryInterface(aCard, &retCode)) ;
+     
+     // Receiving a non-RDF card is accepted
+     if (NS_FAILED(retCode)) { return NS_OK ; }
+     nsXPIDLCString uri ;
+     
+     retCode = resource->GetValue(getter_Copies(uri)) ;
+     NS_ENSURE_SUCCESS(retCode, retCode) ;
+     aUri = uri.get() ;
      return retCode ;
  }
  
  NS_IMETHODIMP nsAbOutlookDirectory::HasCard(nsIAbCard *aCard, PRBool *aHasCard)
  {
      if (!aCard || !aHasCard) { return NS_ERROR_NULL_POINTER ; }
!     *aHasCard = PR_FALSE ;
!     nsCString uri ;
! 
!     ExtractUriFromCard(aCard, uri) ;
!     nsCStringKey key(uri) ;
  
      *aHasCard = mCardList.Exists(&key) ;
      return NS_OK ;
***************
*** 317,323 ****
                  PRINTF(("Cannot delete card %s.\n", entryString.get())) ;
              }
              else {
!                 nsVoidKey key (NS_STATIC_CAST(void *, element)) ;
                  
                  mCardList.Remove(&key) ;
                  if (m_IsMailList) { m_AddressList->RemoveElement(element) ; }
--- 372,381 ----
                  PRINTF(("Cannot delete card %s.\n", entryString.get())) ;
              }
              else {
!                 nsCString uri ;
! 
!                 ExtractUriFromCard(card, uri) ;
!                 nsCStringKey key(uri) ;
                  
                  mCardList.Remove(&key) ;
                  if (m_IsMailList) { m_AddressList->RemoveElement(element) ; }
***************
*** 386,392 ****
      }
      retCode = CreateCard(aData, addedCard) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
!     nsVoidKey newKey (NS_STATIC_CAST(void *, *addedCard)) ;
      
      mCardList.Put(&newKey, *addedCard) ;
      if (m_IsMailList) { m_AddressList->AppendElement(*addedCard) ; }
--- 444,453 ----
      }
      retCode = CreateCard(aData, addedCard) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
!     nsCString uri ;
! 
!     ExtractUriFromCard(*addedCard, uri) ;
!     nsCStringKey newKey(uri) ;
      
      mCardList.Put(&newKey, *addedCard) ;
      if (m_IsMailList) { m_AddressList->AppendElement(*addedCard) ; }
***************
*** 457,463 ****
      if (!mapiAddBook->IsOK()) { return NS_ERROR_FAILURE ; }
      retCode = GetDirName(getter_Copies(name)) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
!     if (!mapiAddBook->SetPropertyUString(*mMapiData, PR_DISPLAY_NAME_W, name.get())) {
          return NS_ERROR_FAILURE ;
      }
      retCode = CommitAddressList() ;
--- 518,524 ----
      if (!mapiAddBook->IsOK()) { return NS_ERROR_FAILURE ; }
      retCode = GetDirName(getter_Copies(name)) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
!     if (!mapiAddBook->SetPropertyUString(*mMapiData, PR_DISPLAY_NAME_A, name.get())) {
          return NS_ERROR_FAILURE ;
      }
      retCode = CommitAddressList() ;
***************
*** 518,523 ****
--- 579,585 ----
      {"DisplayName", PR_DISPLAY_NAME_A},
      {"NickName", PR_NICKNAME_A},
      {"PrimaryEmail", PR_EMAIL_ADDRESS_A},
+     {"SecondEmail",PR_SECOND_EMAIL_ADDRESS_A},
      {"WorkPhone", PR_BUSINESS_TELEPHONE_NUMBER_A},
      {"HomePhone", PR_HOME_TELEPHONE_NUMBER_A},
      {"FaxNumber", PR_BUSINESS_FAX_NUMBER_A},
***************
*** 1032,1038 ****
  
  nsresult nsAbOutlookDirectory::OnSearchFoundCard(nsIAbCard *aCard) 
  {
!     nsVoidKey newKey (NS_STATIC_CAST(void *, aCard)) ;
      nsresult retCode = NS_OK ;
      
      mCardList.Put(&newKey, aCard) ;
--- 1094,1103 ----
  
  nsresult nsAbOutlookDirectory::OnSearchFoundCard(nsIAbCard *aCard) 
  {
!     nsCString uri ;
! 
!     ExtractUriFromCard(aCard, uri) ;
!     nsCStringKey newKey(uri) ;
      nsresult retCode = NS_OK ;
      
      mCardList.Put(&newKey, aCard) ;
***************
*** 1056,1069 ****
      retCode = BuildRestriction(aArguments, arguments) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
      nsCOMPtr<nsISupportsArray> resultsArray ;
      PRUint32 nbResults = 0 ;
      
!     retCode = GetChildCards(getter_AddRefs(resultsArray), 
                              arguments.rt == RES_COMMENT ? nsnull : &arguments) ;
      DestroyRestriction(arguments) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
!     retCode = resultsArray->Count(&nbResults) ;
!     NS_ENSURE_SUCCESS(retCode, retCode) ;
      nsCOMPtr<nsIAbDirectoryQueryResult> result ;
      nsAbDirectoryQueryResult *newResult = nsnull ;
  
--- 1121,1134 ----
      retCode = BuildRestriction(aArguments, arguments) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
      nsCOMPtr<nsISupportsArray> resultsArray ;
+     nsCStringArray uriArray ;
      PRUint32 nbResults = 0 ;
      
!     retCode = GetChildCards(uriArray, 
                              arguments.rt == RES_COMMENT ? nsnull : &arguments) ;
      DestroyRestriction(arguments) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
!     nbResults = uriArray.Count() ;
      nsCOMPtr<nsIAbDirectoryQueryResult> result ;
      nsAbDirectoryQueryResult *newResult = nsnull ;
  
***************
*** 1071,1085 ****
          nbResults = NS_STATIC_CAST(PRUint32, aResultLimit) ; 
      }
      PRUint32 i = 0 ;
-     nsCOMPtr<nsISupports> element ;
      nsCOMPtr<nsISupportsArray> propertyValues ;
      
      for (i = 0 ; i < nbResults ; ++ i) {
!         retCode = resultsArray->GetElementAt(i, getter_AddRefs(element)) ;
!         NS_ENSURE_SUCCESS(retCode, retCode) ;
!         nsCOMPtr<nsIAbCard> card (do_QueryInterface(element, &retCode)) ;
          
          NS_ENSURE_SUCCESS(retCode, retCode) ;
          FillPropertyValues(card, aArguments, getter_AddRefs(propertyValues)) ;
          newResult = new nsAbDirectoryQueryResult(0, aArguments,
                                                   nsIAbDirectoryQueryResult::queryResultMatch, 
--- 1136,1153 ----
          nbResults = NS_STATIC_CAST(PRUint32, aResultLimit) ; 
      }
      PRUint32 i = 0 ;
      nsCOMPtr<nsISupportsArray> propertyValues ;
      
+     nsCAutoString uriName;
+     nsCOMPtr <nsIAbCard> card;
+ 
      for (i = 0 ; i < nbResults ; ++ i) {
!         PRBool isNewCard = PR_FALSE ;
          
+         uriArray.CStringAt(i,uriName);
+         retCode = BuildCardFromURI(uriName,getter_AddRefs(card), PR_FALSE, isNewCard);
          NS_ENSURE_SUCCESS(retCode, retCode) ;
+         
          FillPropertyValues(card, aArguments, getter_AddRefs(propertyValues)) ;
          newResult = new nsAbDirectoryQueryResult(0, aArguments,
                                                   nsIAbDirectoryQueryResult::queryResultMatch, 
***************
*** 1104,1116 ****
      if (!aCards) { return NS_ERROR_NULL_POINTER ; }
      *aCards = nsnull ;
      nsresult retCode = NS_OK ;
!     nsCOMPtr<nsISupportsArray> cards ;
      nsAbWinHelperGuard mapiAddBook (mAbWinType) ;
      nsMapiEntryArray cardEntries ;
      LPSRestriction restriction = (LPSRestriction) aRestriction ;
  
      if (!mapiAddBook->IsOK()) { return NS_ERROR_FAILURE ; }
-     retCode = NS_NewISupportsArray(getter_AddRefs(cards)) ;
      NS_ENSURE_SUCCESS(retCode, retCode) ;
      if (!mapiAddBook->GetCards(*mMapiData, restriction, cardEntries)) {
          PRINTF(("Cannot get cards.\n")) ;
--- 1172,1214 ----
      if (!aCards) { return NS_ERROR_NULL_POINTER ; }
      *aCards = nsnull ;
      nsresult retCode = NS_OK ;
! 
!     nsCOMPtr<nsISupportsArray> cards;
!     retCode = NS_NewISupportsArray(getter_AddRefs(cards));
!     NS_ENSURE_SUCCESS(retCode, retCode) ;
! 
!     nsCStringArray uriList;
!     retCode = GetChildCards(uriList,aRestriction);
!     NS_ENSURE_SUCCESS(retCode, retCode) ;
!     
!     nsCAutoString uriName;
!     nsCOMPtr <nsIAbCard> childCard;
!     PRUint32 nbURIs = 0 ;
!     nbURIs = uriList.Count();
!     PRUint32 i = 0 ;
!         
!     for (i = 0 ; i < nbURIs ; ++ i) {
!         PRBool isNewCard = PR_FALSE ;
! 
!         uriList.CStringAt(i,uriName);
!         retCode = BuildCardFromURI(uriName,getter_AddRefs(childCard), PR_TRUE, isNewCard);
!         NS_ENSURE_SUCCESS(retCode, retCode) ;
!         cards->AppendElement(childCard);
!     }        
!     
!     NS_IF_ADDREF(*aCards = cards);
!     return retCode ;
! }
! 
! nsresult nsAbOutlookDirectory::GetChildCards(nsCStringArray& aURI, 
!                                              void *aRestriction)
! {
!     nsresult retCode = NS_OK ;
      nsAbWinHelperGuard mapiAddBook (mAbWinType) ;
      nsMapiEntryArray cardEntries ;
      LPSRestriction restriction = (LPSRestriction) aRestriction ;
  
      if (!mapiAddBook->IsOK()) { return NS_ERROR_FAILURE ; }
      NS_ENSURE_SUCCESS(retCode, retCode) ;
      if (!mapiAddBook->GetCards(*mMapiData, restriction, cardEntries)) {
          PRINTF(("Cannot get cards.\n")) ;
***************
*** 1119,1140 ****
      nsCAutoString entryId ;
      nsCAutoString uriName ;
      nsCOMPtr<nsIRDFResource> resource ;
!     nsCOMPtr <nsIAbCard> childCard;
!         
!     for (ULONG card = 0 ; card < cardEntries.mNbEntries ; ++ card) {
!         cardEntries.mEntries [card].ToString(entryId) ;
          buildAbWinUri(kOutlookCardScheme, mAbWinType, uriName) ;
          uriName.Append(entryId) ;
!         childCard = do_CreateInstance(NS_ABOUTLOOKCARD_CONTRACTID, &retCode);
!         NS_ENSURE_SUCCESS(retCode, retCode) ;
!         resource = do_QueryInterface(childCard, &retCode) ;
!         NS_ENSURE_SUCCESS(retCode, retCode) ;
!         retCode = resource->Init(uriName.get()) ;
!         NS_ENSURE_SUCCESS(retCode, retCode) ;
!         cards->AppendElement(childCard) ;
      }
-     *aCards = cards ;
-     NS_ADDREF(*aCards) ;
      return retCode ;
  }
  
--- 1217,1230 ----
      nsCAutoString entryId ;
      nsCAutoString uriName ;
      nsCOMPtr<nsIRDFResource> resource ;
!     aURI.Clear();
!     
!     for (ULONG card = 0 ; card < cardEntries.GetSize() ; ++ card) {
!         cardEntries [card].ToString(entryId) ;
          buildAbWinUri(kOutlookCardScheme, mAbWinType, uriName) ;
          uriName.Append(entryId) ;
!         aURI.AppendCString(uriName);
      }
      return retCode ;
  }
  
***************
*** 1158,1165 ****
      nsCAutoString uriName ;
      nsCOMPtr <nsIRDFResource> resource ;
  
!     for (ULONG node = 0 ; node < nodeEntries.mNbEntries ; ++ node) {
!         nodeEntries.mEntries [node].ToString(entryId) ;
          buildAbWinUri(kOutlookDirectoryScheme, mAbWinType, uriName) ;
          uriName.Append(entryId) ;
          retCode = gRDFService->GetResource(uriName, getter_AddRefs(resource)) ;
--- 1248,1255 ----
      nsCAutoString uriName ;
      nsCOMPtr <nsIRDFResource> resource ;
  
!     for (ULONG node = 0 ; node < nodeEntries.GetSize() ; ++ node) {
!         nodeEntries [node].ToString(entryId) ;
          buildAbWinUri(kOutlookDirectoryScheme, mAbWinType, uriName) ;
          uriName.Append(entryId) ;
          retCode = gRDFService->GetResource(uriName, getter_AddRefs(resource)) ;
***************
*** 1280,1286 ****
          // In the case of a mailing list, we cannot directly create a new card,
          // we have to create a temporary one in a real folder (to be able to use
          // templates) and then copy it to the mailing list.
!         if (m_IsMailList) {
              nsMapiEntry parentEntry ;
              nsMapiEntry temporaryEntry ;
  
--- 1370,1376 ----
          // In the case of a mailing list, we cannot directly create a new card,
          // we have to create a temporary one in a real folder (to be able to use
          // templates) and then copy it to the mailing list.
!         if (m_IsMailList && mAbWinType == nsAbWinType_OutlookExp) {
              nsMapiEntry parentEntry ;
              nsMapiEntry temporaryEntry ;
  
*** misc/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.h	2004-02-05 19:33:06.000000000 +0100
--- misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookDirectory.h	2005-07-13 17:26:54.000000000 +0200
***************
*** 46,51 ****
--- 46,52 ----
  #include "nsHashtable.h"
  
  #include "nsISupportsArray.h"
+ #include "nsVoidArray.h"
  
  struct nsMapiEntry ;
  
***************
*** 92,97 ****
--- 93,100 ----
  protected:
      // Retrieve hierarchy as cards, with an optional restriction
      nsresult GetChildCards(nsISupportsArray **aCards, void *aRestriction) ;
+     // Retrieve hierarchy as URIs, with an optional restriction
+     nsresult GetChildCards(nsCStringArray& aURI, void *aRestriction) ;
      // Retrieve hierarchy as directories
      nsresult GetChildNodes(nsISupportsArray **aNodes) ;
      // Create a new card
***************
*** 103,108 ****
--- 106,114 ----
      nsresult CommitAddressList(void) ;
      // Read MAPI repository
      nsresult UpdateAddressList(void) ;
+     // Search for an existing card or build a new one
+     nsresult BuildCardFromURI(const nsCString& uriName,nsIAbCard **aNewCard, 
+                               PRBool aSearchForOld, PRBool& aIsNewCard) ;
  
      nsMapiEntry *mMapiData ;
      // Container for the query threads
*** misc/mozilla/mailnews/addrbook/src/nsAbOutlookDirFactory.cpp	2003-02-25 22:36:33.000000000 +0100
--- misc/build/mozilla/mailnews/addrbook/src/nsAbOutlookDirFactory.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 124,131 ****
      nsCAutoString uri ;
      nsCOMPtr<nsIRDFResource> resource ;
  
!     for (ULONG i = 0 ; i < folders.mNbEntries ; ++ i) {
!         folders.mEntries [i].ToString(entryId) ;
          buildAbWinUri(kOutlookDirectoryScheme, abType, uri) ;
          uri.Append(entryId) ;
          
--- 124,131 ----
      nsCAutoString uri ;
      nsCOMPtr<nsIRDFResource> resource ;
  
!     for (ULONG i = 0 ; i < folders.GetSize() ; ++ i) {
!         folders[i].ToString(entryId) ;
          buildAbWinUri(kOutlookDirectoryScheme, abType, uri) ;
          uri.Append(entryId) ;
          
*** misc/mozilla/mailnews/addrbook/src/nsAbWinHelper.cpp	2004-04-14 22:16:12.000000000 +0200
--- misc/build/mozilla/mailnews/addrbook/src/nsAbWinHelper.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 41,46 ****
--- 41,49 ----
  #define USES_IID_IABContainer
  #define USES_IID_IMAPITable
  #define USES_IID_IDistList
+ #define USES_IID_IMsgStore
+ #define USES_IID_IMessage
+ #define USES_IID_IMAPIFolder
  
  #include "nsAbWinHelper.h"
  #include "nsAbUtils.h"
***************
*** 59,77 ****
  
  #define PRINTF(args) PR_LOG(gAbWinHelperLog, PR_LOG_DEBUG, args)
  
- // Small utility to ensure release of all MAPI interfaces
- template <class tInterface> struct nsMapiInterfaceWrapper
- {
-     tInterface mInterface ;
- 
-     nsMapiInterfaceWrapper(void) : mInterface(NULL) {}
-     ~nsMapiInterfaceWrapper(void) {
-         if (mInterface != NULL) { mInterface->Release() ; }
-     }
-     operator LPUNKNOWN *(void) { return NS_REINTERPRET_CAST(LPUNKNOWN *, &mInterface) ; }
-     tInterface operator -> (void) const { return mInterface ; }
-     operator tInterface *(void) { return &mInterface ; }
- } ;
  
  static void assignEntryID(LPENTRYID& aTarget, LPENTRYID aSource, ULONG aByteCount)
  {
--- 62,67 ----
***************
*** 249,272 ****
  MOZ_DECL_CTOR_COUNTER(nsMapiEntryArray)
  
  nsMapiEntryArray::nsMapiEntryArray(void)
- : mEntries(NULL), mNbEntries(0)
  {
      MOZ_COUNT_CTOR(nsMapiEntryArray) ;
  }
  
  nsMapiEntryArray::~nsMapiEntryArray(void)
  {
!     if (mEntries) { delete [] mEntries ; }
      MOZ_COUNT_DTOR(nsMapiEntryArray) ;
  }
! 
  void nsMapiEntryArray::CleanUp(void)
  {
!     if (mEntries != NULL) { 
!         delete [] mEntries ;
!         mEntries = NULL ;
!         mNbEntries = 0 ;
      }
  }
  
  MOZ_DECL_CTOR_COUNTER(nsAbWinHelper)
--- 239,266 ----
  MOZ_DECL_CTOR_COUNTER(nsMapiEntryArray)
  
  nsMapiEntryArray::nsMapiEntryArray(void)
  {
      MOZ_COUNT_CTOR(nsMapiEntryArray) ;
  }
  
  nsMapiEntryArray::~nsMapiEntryArray(void)
  {
!     CleanUp();
      MOZ_COUNT_DTOR(nsMapiEntryArray) ;
  }
! void  nsMapiEntryArray::AddItem(nsMapiEntry * aEntries)
! {
!     m_array.AppendElement(aEntries);
! }
  void nsMapiEntryArray::CleanUp(void)
  {
!     nsMapiEntry *pEntries;
!     for (int i = 0; i < m_array.Count(); i++)
!     {
!         pEntries = (nsMapiEntry *)m_array.ElementAt( i);
!         delete pEntries;
      }
+     m_array.Clear();
  }
  
  MOZ_DECL_CTOR_COUNTER(nsAbWinHelper)
***************
*** 280,379 ****
  // same protection (MAPI is supposed to be thread-safe).
  PRLock *nsAbWinHelper::mMutex = PR_NewLock() ;
  
  nsAbWinHelper::nsAbWinHelper(void)
! : mAddressBook(NULL), mLastError(S_OK)
  {
      MOZ_COUNT_CTOR(nsAbWinHelper) ;
  }
  
  nsAbWinHelper::~nsAbWinHelper(void)
  {
      MOZ_COUNT_DTOR(nsAbWinHelper) ;
! }
! 
! BOOL nsAbWinHelper::GetFolders(nsMapiEntryArray& aFolders)
  {
!     aFolders.CleanUp() ;
!     nsMapiInterfaceWrapper<LPABCONT> rootFolder ;
!     nsMapiInterfaceWrapper<LPMAPITABLE> folders ;
!     ULONG objType = 0 ;
!     ULONG rowCount = 0 ;
!     SRestriction restriction ;
!     SPropTagArray folderColumns ;
! 
!     mLastError = mAddressBook->OpenEntry(0, NULL, NULL, 0, &objType, 
!                                          rootFolder) ;
!     if (HR_FAILED(mLastError)) { 
!         PRINTF(("Cannot open root %08x.\n", mLastError)) ;
!         return FALSE ; 
      }
-     mLastError = rootFolder->GetHierarchyTable(0, folders) ;
-     if (HR_FAILED(mLastError)) {
-         PRINTF(("Cannot get hierarchy %08x.\n", mLastError)) ;
-         return FALSE ; 
      }
!     // We only take into account modifiable containers, 
!     // otherwise, we end up with all the directory services...
!     restriction.rt = RES_BITMASK ;
!     restriction.res.resBitMask.ulPropTag = PR_CONTAINER_FLAGS ;
!     restriction.res.resBitMask.relBMR = BMR_NEZ ;
!     restriction.res.resBitMask.ulMask = AB_MODIFIABLE ;
!     mLastError = folders->Restrict(&restriction, 0) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot restrict table %08x.\n", mLastError)) ;
!     }
!     folderColumns.cValues = 1 ;
!     folderColumns.aulPropTag [0] = PR_ENTRYID ;
!     mLastError = folders->SetColumns(&folderColumns, 0) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
!         return FALSE ;
!     }
!     mLastError = folders->GetRowCount(0, &rowCount) ;
!     if (HR_SUCCEEDED(mLastError)) {
!         aFolders.mEntries = new nsMapiEntry [rowCount] ;
!         aFolders.mNbEntries = 0 ;
!         do {
!             LPSRowSet rowSet = NULL ;
! 
!             rowCount = 0 ;
!             mLastError = folders->QueryRows(1, 0, &rowSet) ;
!             if (HR_SUCCEEDED(mLastError)) {
!                 rowCount = rowSet->cRows ;
!                 if (rowCount > 0) {
!                     nsMapiEntry& current = aFolders.mEntries [aFolders.mNbEntries ++] ;
!                     SPropValue& currentValue = rowSet->aRow->lpProps [0] ;
!                     
!                     current.Assign(currentValue.Value.bin.cb,
!                                    NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
!                 }
!                 MyFreeProws(rowSet) ;
!             }
!             else {
!                 PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
!             }
!         } while (rowCount > 0) ;
!     }
!     return HR_SUCCEEDED(mLastError) ;
! }
  
  BOOL nsAbWinHelper::GetCards(const nsMapiEntry& aParent, LPSRestriction aRestriction,
                               nsMapiEntryArray& aCards)
  {
      aCards.CleanUp() ;
!     return GetContents(aParent, aRestriction, &aCards.mEntries, aCards.mNbEntries, 0) ;
  }
   
  BOOL nsAbWinHelper::GetNodes(const nsMapiEntry& aParent, nsMapiEntryArray& aNodes)
  { 
      aNodes.CleanUp() ;
!     return GetContents(aParent, NULL, &aNodes.mEntries, aNodes.mNbEntries, MAPI_DISTLIST) ;
  }
  
  BOOL nsAbWinHelper::GetCardsCount(const nsMapiEntry& aParent, ULONG& aNbCards) 
  {
!     aNbCards = 0 ;
!     return GetContents(aParent, NULL, NULL, aNbCards, 0) ;
  }
  
  BOOL nsAbWinHelper::GetPropertyString(const nsMapiEntry& aObject,
--- 274,328 ----
  // same protection (MAPI is supposed to be thread-safe).
  PRLock *nsAbWinHelper::mMutex = PR_NewLock() ;
  
+ int            nsAbWinHelper::m_clients = 0;
+ 
+ PRUnichar *    nsAbWinHelper::m_pUniBuff = NULL;
+ int            nsAbWinHelper::m_uniBuffLen = 0;
+ char      *    nsAbWinHelper::m_pCStrBuff = NULL;
+ int            nsAbWinHelper::m_cstrBuffLen = 0;
+ 
  nsAbWinHelper::nsAbWinHelper(void)
! :mLastError(S_OK)
  {
      MOZ_COUNT_CTOR(nsAbWinHelper) ;
+     m_clients++;
  }
  
  nsAbWinHelper::~nsAbWinHelper(void)
  {
      MOZ_COUNT_DTOR(nsAbWinHelper) ;
!     m_clients--;
!     if (!m_clients)
  {
!         delete [] m_pUniBuff;
!         m_pUniBuff = NULL;
!         m_uniBuffLen = 0;
!         delete [] m_pCStrBuff;
!         m_pCStrBuff = NULL;
!         m_cstrBuffLen = 0;
      }
      }
! 
  
  BOOL nsAbWinHelper::GetCards(const nsMapiEntry& aParent, LPSRestriction aRestriction,
                               nsMapiEntryArray& aCards)
  {
      aCards.CleanUp() ;
!     return GetContents(aParent, aRestriction, &aCards, 0) ;
  }
   
  BOOL nsAbWinHelper::GetNodes(const nsMapiEntry& aParent, nsMapiEntryArray& aNodes)
  { 
      aNodes.CleanUp() ;
!     return GetContents(aParent, NULL, &aNodes, MAPI_DISTLIST) ;
  }
  
  BOOL nsAbWinHelper::GetCardsCount(const nsMapiEntry& aParent, ULONG& aNbCards) 
  {
!     nsMapiEntryArray aCards;
!     BOOL ret=GetContents(aParent, NULL, &aCards,  0) ;
!     aNbCards=aCards.GetSize();
!     return ret;
  }
  
  BOOL nsAbWinHelper::GetPropertyString(const nsMapiEntry& aObject,
***************
*** 390,396 ****
              aName = values->Value.lpszA ;
          }
          else if (PROP_TYPE(values->ulPropTag) == PT_UNICODE) {
!             aName.AssignWithConversion(values->Value.lpszW) ;
          }
      }
      FreeBuffer(values) ;
--- 339,345 ----
              aName = values->Value.lpszA ;
          }
          else if (PROP_TYPE(values->ulPropTag) == PT_UNICODE) {
!             UnicodeToCStr(values->Value.lpszW,aName) ;
          }
      }
      FreeBuffer(values) ;
***************
*** 410,416 ****
              aName = values->Value.lpszW ;
          }
          else if (PROP_TYPE(values->ulPropTag) == PT_STRING8) {
!             aName.AssignWithConversion(values->Value.lpszA) ;
          }
      }
      FreeBuffer(values) ;
--- 359,365 ----
              aName = values->Value.lpszW ;
          }
          else if (PROP_TYPE(values->ulPropTag) == PT_STRING8) {
!             CStrToUnicode(values->Value.lpszA,aName) ;
          }
      }
      FreeBuffer(values) ;
***************
*** 431,446 ****
          ULONG i = 0 ;
  
          for (i = 0 ; i < valueCount ; ++ i) {
!             if (PROP_ID(values [i].ulPropTag) == PROP_ID(aPropertyTags [i])) {
                  if (PROP_TYPE(values [i].ulPropTag) == PT_STRING8) {
                      nsAutoString temp ;
  
!                     temp.AssignWithConversion (values [i].Value.lpszA) ;
                      aNames.AppendString(temp) ;
                  }
                  else if (PROP_TYPE(values [i].ulPropTag) == PT_UNICODE) {
                      aNames.AppendString(nsAutoString (values [i].Value.lpszW)) ;
                  }
                  else {
                      aNames.AppendString(nsAutoString((const PRUnichar *) "")) ;
                  }
--- 380,401 ----
          ULONG i = 0 ;
  
          for (i = 0 ; i < valueCount ; ++ i) {
!             if (PROP_TYPE( values [i].ulPropTag) != PT_ERROR && values [i].Value.l != MAPI_E_NOT_FOUND){
                  if (PROP_TYPE(values [i].ulPropTag) == PT_STRING8) {
                      nsAutoString temp ;
  
!                     CStrToUnicode(values [i].Value.lpszA,temp) ;
                      aNames.AppendString(temp) ;
                  }
                  else if (PROP_TYPE(values [i].ulPropTag) == PT_UNICODE) {
                      aNames.AppendString(nsAutoString (values [i].Value.lpszW)) ;
                  }
+                 else if (aPropertyTags [i] == PR_EMAIL_ADDRESS_A) {
+                     nsAutoString temp ;
+ 
+                     CStrToUnicode (values [i].Value.lpszA,temp) ;
+                     aNames.AppendString(temp) ;
+                 }
                  else {
                      aNames.AppendString(nsAutoString((const PRUnichar *) "")) ;
                  }
***************
*** 466,472 ****
      if (!GetMAPIProperties(aObject, &aPropertyTag, 1, values, valueCount)) { return FALSE ; }
      if (valueCount == 1 && values != NULL && PROP_TYPE(values->ulPropTag) == PT_SYSTIME) {
          SYSTEMTIME readableTime ;
- 
          if (FileTimeToSystemTime(&values->Value.ft, &readableTime)) {
              aYear = readableTime.wYear ;
              aMonth = readableTime.wMonth ;
--- 421,426 ----
***************
*** 518,524 ****
      nsMapiInterfaceWrapper<LPMAPIPROP> subObject ;
      ULONG objType = 0 ;
      
!     mLastError = mAddressBook->OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                           &IID_IMAPIContainer, 0, &objType, 
                                           container) ;
      if (HR_FAILED(mLastError)) {
--- 472,478 ----
      nsMapiInterfaceWrapper<LPMAPIPROP> subObject ;
      ULONG objType = 0 ;
      
!     mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                           &IID_IMAPIContainer, 0, &objType, 
                                           container) ;
      if (HR_FAILED(mLastError)) {
***************
*** 537,543 ****
      SBinary entry ;
      SBinaryArray entryArray ;
  
!     mLastError = mAddressBook->OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                           &IID_IABContainer, MAPI_MODIFY, &objType, 
                                           container) ;
      if (HR_FAILED(mLastError)) {
--- 491,497 ----
      SBinary entry ;
      SBinaryArray entryArray ;
  
!     mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                           &IID_IABContainer, MAPI_MODIFY, &objType, 
                                           container) ;
      if (HR_FAILED(mLastError)) {
***************
*** 567,580 ****
          value.Value.lpszW = NS_CONST_CAST(WORD *, aValue) ;
      }
      else if (PROP_TYPE(aPropertyTag) == PT_STRING8) {
!         alternativeValue.AssignWithConversion(aValue) ;
          value.Value.lpszA = NS_CONST_CAST(char *, alternativeValue.get()) ;
      }
      else {
          PRINTF(("Property %08x is not a string.\n", aPropertyTag)) ;
          return TRUE ;
      }
!     return SetMAPIProperties(aObject, 1, &value) ;
  }
  
  BOOL nsAbWinHelper::SetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag,
--- 521,535 ----
          value.Value.lpszW = NS_CONST_CAST(WORD *, aValue) ;
      }
      else if (PROP_TYPE(aPropertyTag) == PT_STRING8) {
!         UnicodeToCStr(aValue,alternativeValue) ;
          value.Value.lpszA = NS_CONST_CAST(char *, alternativeValue.get()) ;
      }
      else {
          PRINTF(("Property %08x is not a string.\n", aPropertyTag)) ;
          return TRUE ;
      }
!     LPSPropValue values=&value;
!     return SetMAPIProperties(aObject, 1, values) ;
  }
  
  BOOL nsAbWinHelper::SetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag,
***************
*** 595,601 ****
              values [currentValue ++].Value.lpszW = NS_CONST_CAST(WORD *, aValues [i].get()) ;
          }
          else if (PROP_TYPE(aPropertiesTag [i]) == PT_STRING8) {
!             alternativeValue.AssignWithConversion(aValues [i].get()) ;
              char *av = nsCRT::strdup(alternativeValue.get()) ;
              if (!av) {
                  retCode = FALSE ;
--- 550,556 ----
              values [currentValue ++].Value.lpszW = NS_CONST_CAST(WORD *, aValues [i].get()) ;
          }
          else if (PROP_TYPE(aPropertiesTag [i]) == PT_STRING8) {
!             UnicodeToCStr(aValues [i].get(),alternativeValue) ;
              char *av = nsCRT::strdup(alternativeValue.get()) ;
              if (!av) {
                  retCode = FALSE ;
***************
*** 633,639 ****
          readableTime.wSecond = 0 ;
          readableTime.wMilliseconds = 0 ;
          if (SystemTimeToFileTime(&readableTime, &value.Value.ft)) {
!             return SetMAPIProperties(aObject, 1, &value) ;
          }
          return TRUE ;
      }
--- 588,595 ----
          readableTime.wSecond = 0 ;
          readableTime.wMilliseconds = 0 ;
          if (SystemTimeToFileTime(&readableTime, &value.Value.ft)) {
!             LPSPropValue values=&value;
!             return SetMAPIProperties(aObject, 1, values) ;
          }
          return TRUE ;
      }
***************
*** 645,651 ****
      nsMapiInterfaceWrapper<LPABCONT> container ;
      ULONG objType = 0 ;
  
!     mLastError = mAddressBook->OpenEntry(aParent.mByteCount, aParent.mEntryId,
                                           &IID_IABContainer, MAPI_MODIFY, &objType,
                                           container) ;
      if (HR_FAILED(mLastError)) { 
--- 601,607 ----
      nsMapiInterfaceWrapper<LPABCONT> container ;
      ULONG objType = 0 ;
  
!     mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
                                           &IID_IABContainer, MAPI_MODIFY, &objType,
                                           container) ;
      if (HR_FAILED(mLastError)) { 
***************
*** 708,714 ****
      nsMapiInterfaceWrapper<LPABCONT> container ;
      ULONG objType = 0 ;
  
!     mLastError = mAddressBook->OpenEntry(aParent.mByteCount, aParent.mEntryId,
                                           &IID_IABContainer, MAPI_MODIFY, &objType,
                                           container) ;
      if (HR_FAILED(mLastError)) {
--- 664,670 ----
      nsMapiInterfaceWrapper<LPABCONT> container ;
      ULONG objType = 0 ;
  
!     mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
                                           &IID_IABContainer, MAPI_MODIFY, &objType,
                                           container) ;
      if (HR_FAILED(mLastError)) {
***************
*** 773,779 ****
      nsMapiInterfaceWrapper<LPABCONT> container ;
      ULONG objType = 0 ;
  
!     mLastError = mAddressBook->OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                           &IID_IABContainer, MAPI_MODIFY, &objType,
                                           container) ;
      if (HR_FAILED(mLastError)) { 
--- 729,735 ----
      nsMapiInterfaceWrapper<LPABCONT> container ;
      ULONG objType = 0 ;
  
!     mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
                                           &IID_IABContainer, MAPI_MODIFY, &objType,
                                           container) ;
      if (HR_FAILED(mLastError)) { 
***************
*** 810,1003 ****
      return TRUE ;
  }
  
- BOOL nsAbWinHelper::GetDefaultContainer(nsMapiEntry& aContainer)
- {
-     LPENTRYID entryId = NULL ; 
-     ULONG byteCount = 0 ;
- 
-     mLastError = mAddressBook->GetPAB(&byteCount, &entryId) ;
-     if (HR_FAILED(mLastError)) {
-         PRINTF(("Cannot get PAB %08x.\n", mLastError)) ;
-         return FALSE ;
-     }
-     aContainer.Assign(byteCount, entryId) ;
-     FreeBuffer(entryId) ;
-     return TRUE ;
- }
  
- enum
- {
-     ContentsColumnEntryId = 0,
-     ContentsColumnObjectType,
-     ContentsColumnsSize
- } ;
  
- static const SizedSPropTagArray(ContentsColumnsSize, ContentsColumns) =
- {
-     ContentsColumnsSize,
-     {
-         PR_ENTRYID,
-         PR_OBJECT_TYPE
-     }
- } ;
  
! BOOL nsAbWinHelper::GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction,
!                                 nsMapiEntry **aList, ULONG& aNbElements, ULONG aMapiType)
  {
!     if (aList != NULL) { *aList = NULL ; }
!     aNbElements = 0 ;
!     nsMapiInterfaceWrapper<LPMAPICONTAINER> parent ;
!     nsMapiInterfaceWrapper<LPMAPITABLE> contents ;
!     ULONG objType = 0 ;
!     ULONG rowCount = 0 ;
  
!     mLastError = mAddressBook->OpenEntry(aParent.mByteCount, aParent.mEntryId, 
!                                          &IID_IMAPIContainer, 0, &objType, 
!                                          parent) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot open parent %08x.\n", mLastError)) ;
!         return FALSE ; 
!     }
!     // Here, flags for WAB and MAPI could be different, so this works
!     // only as long as we don't want to use any flag in GetContentsTable
!     mLastError = parent->GetContentsTable(0, contents) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot get contents %08x.\n", mLastError)) ;
!         return FALSE ; 
      }
!     if (aRestriction != NULL) {
!         mLastError = contents->Restrict(aRestriction, 0) ;
!         if (HR_FAILED(mLastError)) {
!             PRINTF(("Cannot set restriction %08x.\n", mLastError)) ;
!             return FALSE ;
!         }
!     }
!     mLastError = contents->SetColumns((LPSPropTagArray) &ContentsColumns, 0) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
!         return FALSE ;
!     }
!     mLastError = contents->GetRowCount(0, &rowCount) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot get result count %08x.\n", mLastError)) ;
!         return FALSE ;
!     }
!     if (aList != NULL) { *aList = new nsMapiEntry [rowCount] ; }
!     aNbElements = 0 ;
!     do {
!         LPSRowSet rowSet = NULL ;
!         
!         rowCount = 0 ;
!         mLastError = contents->QueryRows(1, 0, &rowSet) ;
!         if (HR_FAILED(mLastError)) {
!             PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
!             return FALSE ;
!         }
!         rowCount = rowSet->cRows ;
!         if (rowCount > 0 &&
!             (aMapiType == 0 ||
!             rowSet->aRow->lpProps[ContentsColumnObjectType].Value.ul == aMapiType)) {
!             if (aList != NULL) {
!                 nsMapiEntry& current = (*aList) [aNbElements] ;
!                 SPropValue& currentValue = rowSet->aRow->lpProps[ContentsColumnEntryId] ;
!                 
!                 current.Assign(currentValue.Value.bin.cb,
!                     NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
              }
!             ++ aNbElements ;
          }
-         MyFreeProws(rowSet) ;
-     } while (rowCount > 0) ;
-     return TRUE ;
  }
! 
! BOOL nsAbWinHelper::GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
!                                       ULONG aNbProperties, LPSPropValue& aValue, 
!                                       ULONG& aValueCount)
  {
!     nsMapiInterfaceWrapper<LPMAPIPROP> object ;
!     ULONG objType = 0 ;
!     LPSPropTagArray properties = NULL ;
!     ULONG i = 0 ;
!     
!     mLastError = mAddressBook->OpenEntry(aObject.mByteCount, aObject.mEntryId,
!                                          &IID_IMAPIProp, 0, &objType, 
!                                          object) ;
!     if (HR_FAILED(mLastError)) { 
!         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
!         return FALSE ; 
      }
!     AllocateBuffer(CbNewSPropTagArray(aNbProperties), 
!                    NS_REINTERPRET_CAST(void **, &properties)) ;
!     properties->cValues = aNbProperties ;
!     for (i = 0 ; i < aNbProperties ; ++ i) {
!         properties->aulPropTag [i] = aPropertyTags [i] ;
!     }
!     mLastError = object->GetProps(properties, 0, &aValueCount, &aValue) ;
!     FreeBuffer(properties) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot get props %08x.\n", mLastError)) ;
      }
-     return HR_SUCCEEDED(mLastError) ;
  }
  
! BOOL nsAbWinHelper::SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
!                                       const LPSPropValue& aValues)
! {
!     nsMapiInterfaceWrapper<LPMAPIPROP> object ;
!     ULONG objType = 0 ;
!     LPSPropProblemArray problems = NULL ;
  
!     mLastError = mAddressBook->OpenEntry(aObject.mByteCount, aObject.mEntryId,
!                                          &IID_IMAPIProp, MAPI_MODIFY, &objType, 
!                                          object) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
!         return FALSE ;
!     }
!     mLastError = object->SetProps(aNbProperties, aValues, &problems) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot update the object %08x.\n", mLastError)) ;
!         return FALSE ;
!     }
!     if (problems != NULL) {
!         for (ULONG i = 0 ; i < problems->cProblem ; ++ i) {
!             PRINTF(("Problem %d: index %d code %08x.\n", i, 
!                 problems->aProblem [i].ulIndex, 
!                 problems->aProblem [i].scode)) ;
!         }
!     }
!     mLastError = object->SaveChanges(0) ;
!     if (HR_FAILED(mLastError)) {
!         PRINTF(("Cannot commit changes %08x.\n", mLastError)) ;
!     }
!     return HR_SUCCEEDED(mLastError) ;
  }
  
! void nsAbWinHelper::MyFreeProws(LPSRowSet aRowset)
! {
!     if (aRowset == NULL) { return ; }
!     ULONG i = 0 ; 
  
!     for (i = 0 ; i < aRowset->cRows ; ++ i) {
!         FreeBuffer(aRowset->aRow [i].lpProps) ;
!     }
!     FreeBuffer(aRowset) ;
  }
  
  nsAbWinHelperGuard::nsAbWinHelperGuard(PRUint32 aType)
  : mHelper(NULL) 
  {
      switch(aType) {
!     case nsAbWinType_Outlook: mHelper = new nsMapiAddressBook ; break ;
!     case nsAbWinType_OutlookExp: mHelper = new nsWabAddressBook ; break ;
      default: break ;
      }
  }
  
  nsAbWinHelperGuard::~nsAbWinHelperGuard(void)
  {
-     delete mHelper ;
  }
  
  const char *kOutlookDirectoryScheme = "moz-aboutlookdirectory://" ;
--- 766,842 ----
      return TRUE ;
  }
  
  
  
  
! void nsAbWinHelper::MyFreeProws(LPSRowSet aRowset)
  {
!     if (aRowset == NULL) { return ; }
!     ULONG i = 0 ;
  
!     for (i = 0 ; i < aRowset->cRows ; ++ i) {
!         FreeBuffer(aRowset->aRow [i].lpProps) ;
      }
!     FreeBuffer(aRowset) ;
!         }
! void nsAbWinHelper::CStrToUnicode( const char *pStr, nsString& result)
! {
!     result.Truncate( 0);
!     int wLen = MultiByteToWideChar( CP_ACP, 0, pStr, -1, m_pUniBuff, 0);
!     if (wLen >= m_uniBuffLen)
!     {
!         delete [] m_pUniBuff;
!         m_pUniBuff = new PRUnichar[wLen + 64];
!         m_uniBuffLen = wLen + 64;
              }
!     if (wLen)
!     {
!         MultiByteToWideChar( CP_ACP, 0, pStr, -1, m_pUniBuff, m_uniBuffLen);
!         result = m_pUniBuff;
          }
  }
! void nsAbWinHelper::UnicodeToCStr( const  PRUnichar *pUStr,nsCString& result)
  {
!     result.Truncate( 0);
!     int cLen = WideCharToMultiByte( CP_ACP, 0, pUStr, -1, m_pCStrBuff, 0,NULL,NULL);
!     if (cLen >= m_cstrBuffLen) {
!         if (m_pCStrBuff)
!             delete [] m_pCStrBuff;
!         m_pCStrBuff = new char[cLen + 64];
!         m_cstrBuffLen = cLen + 64;
      }
!     if (cLen) {
!         WideCharToMultiByte( CP_ACP, 0, pUStr, -1, m_pCStrBuff, m_cstrBuffLen,NULL,NULL);
!         result = m_pCStrBuff;
      }
  }
  
! static nsAbWinHelper *getOutlookAddressBook(void) {
!     static nsMapiAddressBook *addressBook = NULL ;
  
!     if (addressBook == NULL) { addressBook = new nsMapiAddressBook ; } 
!     return addressBook ;
  }
  
! static nsAbWinHelper *getOutlookExpAddressBook(void) {
!     static nsWabAddressBook *addressBook = NULL ;
  
!     if (addressBook == NULL) { addressBook = new nsWabAddressBook ; } 
!     return addressBook ;
  }
  
  nsAbWinHelperGuard::nsAbWinHelperGuard(PRUint32 aType)
  : mHelper(NULL) 
  {
      switch(aType) {
!     case nsAbWinType_Outlook: mHelper = getOutlookAddressBook() ; break ;
!     case nsAbWinType_OutlookExp: mHelper = getOutlookExpAddressBook() ; break ;
      default: break ;
      }
  }
  
  nsAbWinHelperGuard::~nsAbWinHelperGuard(void)
  {
  }
  
  const char *kOutlookDirectoryScheme = "moz-aboutlookdirectory://" ;
*** misc/mozilla/mailnews/addrbook/src/nsAbWinHelper.h	2004-04-14 22:16:12.000000000 +0200
--- misc/build/mozilla/mailnews/addrbook/src/nsAbWinHelper.h	2005-07-13 17:26:54.000000000 +0200
***************
*** 45,50 ****
--- 45,68 ----
  #include "nsVoidArray.h"
  #include "nsXPIDLString.h"
   
+ #define PR_SECOND_EMAIL_ADDRESS_A  0x8033001E
+ #define PR_SCREEN_NAME_A           0x805B001E
+  
+ 
+ // Small utility to ensure release of all MAPI interfaces
+ template <class tInterface> struct nsMapiInterfaceWrapper
+ {
+     tInterface mInterface ;
+ 
+     nsMapiInterfaceWrapper(void) : mInterface(NULL) {}
+     ~nsMapiInterfaceWrapper(void) {
+         if (mInterface ) { mInterface->Release() ; }
+     }
+     operator LPUNKNOWN *(void) { return NS_REINTERPRET_CAST(LPUNKNOWN *, &mInterface) ; }
+     tInterface operator -> (void) const { return mInterface ; }
+     operator tInterface *(void) { return &mInterface ; }
+ } ;
+ 
  struct nsMapiEntry
  {
      ULONG     mByteCount ;
***************
*** 62,75 ****
  
  struct nsMapiEntryArray 
  {
-     nsMapiEntry *mEntries ;
-     ULONG      mNbEntries ;
  
      nsMapiEntryArray(void) ;
      ~nsMapiEntryArray(void) ;
  
!     const nsMapiEntry& operator [] (int aIndex) const { return mEntries [aIndex] ; }
      void CleanUp(void) ;
  } ;
  
  class nsAbWinHelper
--- 80,107 ----
  
  struct nsMapiEntryArray 
  {
  
      nsMapiEntryArray(void) ;
      ~nsMapiEntryArray(void) ;
  
!     void  AddItem(nsMapiEntry * aEntries);
!     void  AddItem(    ULONG     mByteCount , LPENTRYID mEntryId )
!     {
!         nsMapiEntry * aEntries=new nsMapiEntry();
!         aEntries->Assign(mByteCount,mEntryId);
!         AddItem(aEntries);
!     }
! 
!     ULONG        GetSize( void) { return( m_array.Count());}
!     nsMapiEntry& operator [] (int aIndex)  { return *(nsMapiEntry*)m_array.ElementAt(aIndex); }
!     nsMapiEntry* ElementAt(int aIndex)  { return (nsMapiEntry*)m_array.ElementAt(aIndex); }
      void CleanUp(void) ;
+     void Remove(nsMapiEntry * aEntries){ m_array.RemoveElement(aEntries); }
+     void Remove(int index){ m_array.RemoveElementAt(index); }
+     ULONG IndexOf(nsMapiEntry * aEntries){return m_array.IndexOf(aEntries);};
+ private:
+     nsVoidArray        m_array;
+ 
  } ;
  
  class nsAbWinHelper
***************
*** 79,85 ****
      virtual ~nsAbWinHelper(void) ;
  
      // Get the top address books
!     BOOL GetFolders(nsMapiEntryArray& aFolders) ;
      // Get a list of entries for cards/mailing lists in a folder/mailing list
      BOOL GetCards(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
                    nsMapiEntryArray& aCards) ;
--- 111,117 ----
      virtual ~nsAbWinHelper(void) ;
  
      // Get the top address books
!     virtual BOOL GetFolders(nsMapiEntryArray& aFolders) =0;
      // Get a list of entries for cards/mailing lists in a folder/mailing list
      BOOL GetCards(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
                    nsMapiEntryArray& aCards) ;
***************
*** 97,114 ****
      BOOL GetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag, 
                                ULONG aNbProperties, nsStringArray& aValues) ;
      // Get the value of a MAPI property of type SYSTIME
!     BOOL GetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag, 
                           WORD& aYear, WORD& aMonth, WORD& aDay) ;
-     // Get the value of a MAPI property of type LONG
-     BOOL GetPropertyLong(const nsMapiEntry& aObject, ULONG aPropertyTag, ULONG& aValue) ;
      // Get the value of a MAPI property of type BIN
      BOOL GetPropertyBin(const nsMapiEntry& aObject, ULONG aPropertyTag, nsMapiEntry& aValue) ;
      // Tests if a container contains an entry
      BOOL TestOpenEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
-     // Delete an entry in the address book
-     BOOL DeleteEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
      // Set the value of a MAPI property of type string in unicode
!     BOOL SetPropertyUString (const nsMapiEntry& aObject, ULONG aPropertyTag, 
                               const PRUnichar *aValue) ;
      // Same as previous, but with a bunch of properties in one call
      BOOL SetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag,
--- 129,142 ----
      BOOL GetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag, 
                                ULONG aNbProperties, nsStringArray& aValues) ;
      // Get the value of a MAPI property of type SYSTIME
!     virtual BOOL GetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag, 
                           WORD& aYear, WORD& aMonth, WORD& aDay) ;
      // Get the value of a MAPI property of type BIN
      BOOL GetPropertyBin(const nsMapiEntry& aObject, ULONG aPropertyTag, nsMapiEntry& aValue) ;
      // Tests if a container contains an entry
      BOOL TestOpenEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
      // Set the value of a MAPI property of type string in unicode
!     virtual BOOL SetPropertyUString (const nsMapiEntry& aObject, ULONG aPropertyTag, 
                               const PRUnichar *aValue) ;
      // Same as previous, but with a bunch of properties in one call
      BOOL SetPropertiesUString(const nsMapiEntry& aObject, const ULONG *aPropertiesTag,
***************
*** 117,148 ****
      BOOL SetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag, 
                           WORD aYear, WORD aMonth, WORD aDay) ;
      // Create entry in the address book
!     BOOL CreateEntry(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
      // Create a distribution list in the address book
!     BOOL CreateDistList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
      // Copy an existing entry in the address book
!     BOOL CopyEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aSource, nsMapiEntry& aTarget) ;
      // Get a default address book container
!     BOOL GetDefaultContainer(nsMapiEntry& aContainer) ;
      // Is the helper correctly initialised?
!     BOOL IsOK(void) const { return mAddressBook != NULL ; }
  
  protected:
      HRESULT mLastError ;
-     LPADRBOOK mAddressBook ;
      static PRUint32 mEntryCounter ;
      static PRLock *mMutex ;
  
      // Retrieve the contents of a container, with an optional restriction
!     BOOL GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
!                      nsMapiEntry **aList, ULONG &aNbElements, ULONG aMapiType) ;
      // Retrieve the values of a set of properties on a MAPI object
!     BOOL GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
                             ULONG aNbProperties,
!                            LPSPropValue& aValues, ULONG& aValueCount) ;
      // Set the values of a set of properties on a MAPI object
!     BOOL SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
!                            const LPSPropValue& aValues) ;
      // Clean-up a rowset returned by QueryRows
      void MyFreeProws(LPSRowSet aSet) ;
      // Allocation of a buffer for transmission to interfaces
--- 145,188 ----
      BOOL SetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag, 
                           WORD aYear, WORD aMonth, WORD aDay) ;
      // Create entry in the address book
!     virtual BOOL CreateEntry(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
!     // Delete an entry in the address book
!     virtual BOOL DeleteEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
      // Create a distribution list in the address book
!     virtual BOOL CreateDistList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
      // Copy an existing entry in the address book
!     virtual BOOL CopyEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aSource, nsMapiEntry& aTarget) ;
      // Get a default address book container
!     virtual BOOL GetDefaultContainer(nsMapiEntry& aContainer) =0;
      // Is the helper correctly initialised?
!     virtual BOOL IsOK(void) =0;/*const { return mAddressBook != NULL ; }*/
! 
!     // Get the value of a MAPI property of type LONG
!     virtual BOOL GetPropertyLong(const nsMapiEntry& aObject, ULONG aPropertyTag, ULONG& aValue) ;
  
  protected:
      HRESULT mLastError ;
      static PRUint32 mEntryCounter ;
      static PRLock *mMutex ;
  
+     virtual HRESULT OpenEntry(ULONG cbEntryID,
+                     LPENTRYID lpEntryID,
+                     LPCIID lpInterface,
+                     ULONG ulFlags,
+                     ULONG FAR * lpulObjType,
+                     LPUNKNOWN FAR * lppUnk
+                     ) = 0;
+ 
      // Retrieve the contents of a container, with an optional restriction
!     virtual BOOL GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
!                      nsMapiEntryArray *aList, ULONG aMapiType) =0;
      // Retrieve the values of a set of properties on a MAPI object
!     virtual BOOL GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
                             ULONG aNbProperties,
!                            LPSPropValue& aValues, ULONG& aValueCount) =0;
      // Set the values of a set of properties on a MAPI object
!     virtual BOOL SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
!                            LPSPropValue& aValues) =0;
      // Clean-up a rowset returned by QueryRows
      void MyFreeProws(LPSRowSet aSet) ;
      // Allocation of a buffer for transmission to interfaces
***************
*** 150,156 ****
--- 190,205 ----
      // Destruction of a buffer provided by the interfaces
      virtual void FreeBuffer(LPVOID aBuffer) = 0 ;
  
+     static void            CStrToUnicode( const char *pStr, nsString& result);
+     static void            UnicodeToCStr( const PRUnichar *pStr, nsCString& result);
+ 
  private:
+     static int                m_clients;
+     static PRUnichar *        m_pUniBuff;
+     static int                m_uniBuffLen;
+     static char *             m_pCStrBuff;
+     static int                m_cstrBuffLen;
+ 
  } ;
  
  enum nsAbWinType 
***************
*** 168,173 ****
--- 217,223 ----
  
      nsAbWinHelper *operator ->(void) { return mHelper ; }
  
+     static void FreeWinAbLibrarys();
  private:
      nsAbWinHelper *mHelper ;
  } ;
*** misc/mozilla/mailnews/addrbook/src/nsAddrDatabase.cpp	2003-12-24 18:18:08.000000000 +0100
--- misc/build/mozilla/mailnews/addrbook/src/nsAddrDatabase.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 97,102 ****
--- 97,105 ----
  
  static const char kMailListAddressFormat[] = "Address%d";
  
+ extern int getMD5sum(const char * fileName,char * sum);
+ extern int testMD5sum(const char * fileName,char * sum);
+ 
  static NS_DEFINE_CID(kCMorkFactory, NS_MORK_CID);
  
  nsAddrDatabase::nsAddrDatabase()
***************
*** 166,171 ****
--- 169,175 ----
        m_LastRecordKey(0),
        m_dbDirectory(nsnull)
  {
+ 	memset(m_dbMd5Sum,0,33);
  }
  
  nsAddrDatabase::~nsAddrDatabase()
***************
*** 720,726 ****
            NS_RELEASE(oldFile); // always release our file ref, store has own
          }
        }
!       
        nsCRT::free(nativeFileName);
        
        if (NS_SUCCEEDED(ret) && thumb)
--- 724,734 ----
            NS_RELEASE(oldFile); // always release our file ref, store has own
          }
        }
! 
! 	  ret = getMD5sum(nativeFileName,m_dbMd5Sum);
! 	  if (ret == 1)
! 		ret = NS_ERROR_FAILURE;
! 
        nsCRT::free(nativeFileName);
        
        if (NS_SUCCEEDED(ret) && thumb)
***************
*** 817,822 ****
--- 825,841 ----
      nsresult    err = NS_OK;
      nsIMdbThumb    *commitThumb = nsnull;
  
+     const char *pFilename = m_dbName.GetCString(); /* do not free */
+     char    *nativeFileName = nsCRT::strdup(pFilename);
+ #if defined(XP_PC) || defined(XP_MAC)
+       UnixToNative(nativeFileName);
+ #endif
+ 	if (testMD5sum(nativeFileName,m_dbMd5Sum))
+     {
+         nsCRT::free(nativeFileName);
+         return NS_ERROR_FILE_ACCESS_DENIED;
+     }
+ 
    if (commitType == nsAddrDBCommitType::kLargeCommit || commitType == nsAddrDBCommitType::kSessionCommit)
    {
      mdb_percent outActualWaste = 0;
***************
*** 867,872 ****
--- 886,895 ----
      // ### do something with error, but clear it now because mork errors out on commits.
      if (GetEnv())
          GetEnv()->ClearErrors();
+ 	if (NS_SUCCEEDED(err) && getMD5sum(nativeFileName,m_dbMd5Sum))
+ 		err = NS_ERROR_FAILURE;
+     nsCRT::free(nativeFileName);
+ 
      return err;
  }
  
*** misc/mozilla/mailnews/addrbook/src/nsAddrDatabase.h	2004-01-28 18:22:13.000000000 +0100
--- misc/build/mozilla/mailnews/addrbook/src/nsAddrDatabase.h	2005-07-13 17:26:54.000000000 +0200
***************
*** 396,401 ****
--- 396,402 ----
  	nsIMdbTable		    *m_mdbPabTable;
  	nsIMdbTable                 *m_mdbDeletedCardsTable;
  	nsFileSpec		    m_dbName;
+ 	char				m_dbMd5Sum[33];
  	PRBool				m_mdbTokensInitialized;
      nsVoidArray /*<nsIAddrDBListener>*/ *m_ChangeListeners;
  
*** misc/mozilla/mailnews/addrbook/src/nsMapiAddressBook.cpp	2001-10-30 08:59:16.000000000 +0100
--- misc/build/mozilla/mailnews/addrbook/src/nsMapiAddressBook.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 41,46 ****
--- 41,62 ----
  
  #include "prlog.h"
  
+ static char * stristr(const char *big, const char *little)
+ {
+     PRUint32 len;
+ 
+     if (!big || !little || !*big || !*little)
+       return 0;
+     len = strlen(little);
+ 
+     for( ; *big; big++ )
+        if(!_strnicmp (big, little, 1) && ! _strnicmp (big, little, len) )
+           return (char *)big;
+ 
+     return (char *)0;
+ 
+ }
+ 
  #ifdef PR_LOGGING
  static PRLogModuleInfo* gMapiAddressBookLog
      = PR_NewLogModule("nsMapiAddressBookLog");
***************
*** 48,53 ****
--- 64,123 ----
  
  #define PRINTF(args) PR_LOG(gMapiAddressBookLog, PR_LOG_DEBUG, args)
  
+ #define    OUTLOOK_EMAIL_DIAPLAY_MAPI_ID    0x00008005  //use to get and set display
+ #define    OUTLOOK_EMAIL1_MAPI_ID           0x00008084  //use to get and set primary email address
+ #define    OUTLOOK_EMAIL2_MAPI_ID           0x00008094  //use to get and set second  email address
+ #define    OUTLOOK_EMAIL_SCREEN_NAME        0x8061001E  //use to get and set screen name
+ #define    OUTLOOK_EMAIL_ORGID              0x00008085  //use to get orginal entryid to add to distlist
+ #define    OUTLOOK_EMAIL_LIST1              0x00008054  //use to get distlist table
+ #define    OUTLOOK_EMAIL_LIST2              0x00008055  //use to set distlist table
+ 
+ static const TagMap TagMaps[]={
+     {PR_DISPLAY_NAME_A,         OUTLOOK_EMAIL_DIAPLAY_MAPI_ID,    PT_STRING8},
+     {PR_EMAIL_ADDRESS_A,        OUTLOOK_EMAIL1_MAPI_ID,           PT_STRING8},
+     {PR_SECOND_EMAIL_ADDRESS_A, OUTLOOK_EMAIL2_MAPI_ID,           PT_STRING8},
+     {PR_SCREEN_NAME_A,          OUTLOOK_EMAIL_SCREEN_NAME,        PT_STRING8}};
+ 
+ enum {
+     ieidPR_ENTRYID = 0,
+     ieidPR_OBJECT_TYPE,
+     ieidPR_DISPLAY_NAME,
+     ieidPR_MESSAGE_CLASS,
+     ieidPR_STORE_ENTRYID,
+     ieidPR_MESSAGE_RECIPIENTS,
+     ieidMax
+ };
+ 
+ static const SizedSPropTagArray(ieidMax, ptaEid)=
+ {
+     ieidMax,
+     {
+         PR_ENTRYID,
+         PR_OBJECT_TYPE,
+         PR_DISPLAY_NAME,
+         PR_MESSAGE_CLASS,
+         PR_STORE_ENTRYID,
+         PR_MESSAGE_RECIPIENTS
+     }
+ };
+ 
+ enum
+ {
+     ContentsColumnEntryId = 0,
+     ContentsColumnObjectType,
+     ContentsColumnMessageClass,
+     ContentsColumnsSize
+ } ;
+ 
+ static const SizedSPropTagArray(ContentsColumnsSize, ContentsColumns) =
+ {
+     ContentsColumnsSize,
+     {
+         PR_ENTRYID,
+         PR_OBJECT_TYPE,
+         PR_MESSAGE_CLASS
+     }
+ } ;
  
  HMODULE nsMapiAddressBook::mLibrary = NULL ;
  PRInt32 nsMapiAddressBook::mLibUsage = 0 ;
***************
*** 60,66 ****
  BOOL nsMapiAddressBook::mInitialized = FALSE ;
  BOOL nsMapiAddressBook::mLogonDone = FALSE ;
  LPMAPISESSION nsMapiAddressBook::mRootSession = NULL ;
! LPADRBOOK nsMapiAddressBook::mRootBook = NULL ;
  
  BOOL nsMapiAddressBook::LoadMapiLibrary(void)
  {
--- 130,136 ----
  BOOL nsMapiAddressBook::mInitialized = FALSE ;
  BOOL nsMapiAddressBook::mLogonDone = FALSE ;
  LPMAPISESSION nsMapiAddressBook::mRootSession = NULL ;
! #define MAPI_NO_COINIT 8
  
  BOOL nsMapiAddressBook::LoadMapiLibrary(void)
  {
***************
*** 92,98 ****
      mMAPILogonEx = NS_REINTERPRET_CAST(LPMAPILOGONEX, 
          GetProcAddress(mLibrary, "MAPILogonEx")) ;
      if (!mMAPILogonEx) { return FALSE ; }
!     MAPIINIT_0 mapiInit = { MAPI_INIT_VERSION, MAPI_MULTITHREAD_NOTIFICATIONS } ;
      HRESULT retCode = mMAPIInitialize(&mapiInit) ;
  
      if (HR_FAILED(retCode)) { 
--- 162,168 ----
      mMAPILogonEx = NS_REINTERPRET_CAST(LPMAPILOGONEX, 
          GetProcAddress(mLibrary, "MAPILogonEx")) ;
      if (!mMAPILogonEx) { return FALSE ; }
!     MAPIINIT_0 mapiInit = { MAPI_INIT_VERSION, MAPI_MULTITHREAD_NOTIFICATIONS | MAPI_NO_COINIT } ;
      HRESULT retCode = mMAPIInitialize(&mapiInit) ;
  
      if (HR_FAILED(retCode)) { 
***************
*** 106,127 ****
                             MAPI_NEW_SESSION,
                             &mRootSession) ;
      if (HR_FAILED(retCode)) { 
!         PRINTF(("Cannot logon to MAPI %08x.\n", retCode)) ; return FALSE ;
      }
      mLogonDone = TRUE ;
!     retCode = mRootSession->OpenAddressBook(0, NULL, 0, &mRootBook) ;
!     if (HR_FAILED(retCode)) { 
!         PRINTF(("Cannot open MAPI address book %08x.\n", retCode)) ;
!     }
      return HR_SUCCEEDED(retCode) ;
  }
  
  void nsMapiAddressBook::FreeMapiLibrary(void)
  {
      if (mLibrary) {
!         if (-- mLibUsage == 0) {
              {
-                 if (mRootBook) { mRootBook->Release() ; }
                  if (mRootSession) {
                      if (mLogonDone) { 
                          mRootSession->Logoff(NULL, 0, 0) ; 
--- 176,194 ----
                             MAPI_NEW_SESSION,
                             &mRootSession) ;
      if (HR_FAILED(retCode)) { 
!         PRINTF(("Cannot logon to MAPI %08x.\n", retCode)) ;
!         return FALSE ;
      }
      mLogonDone = TRUE ;
! 
      return HR_SUCCEEDED(retCode) ;
  }
  
  void nsMapiAddressBook::FreeMapiLibrary(void)
  {
      if (mLibrary) {
!         if (--mLibUsage < 0) {
              {
                  if (mRootSession) {
                      if (mLogonDone) { 
                          mRootSession->Logoff(NULL, 0, 0) ; 
***************
*** 135,140 ****
--- 202,208 ----
                  }
              }  
              FreeLibrary(mLibrary) ;
+             mRootSession = NULL;
              mLibrary = NULL ; 
          }
      }
***************
*** 146,152 ****
  : nsAbWinHelper()
  {
      BOOL result = Initialize() ;
- 
      NS_ASSERTION(result == TRUE, "Couldn't initialize Mapi Helper") ;
      MOZ_COUNT_CTOR(nsMapiAddressBook) ;
  }
--- 214,219 ----
***************
*** 154,175 ****
  nsMapiAddressBook::~nsMapiAddressBook(void)
  {
      nsAutoLock guard(mMutex) ;
! 
      FreeMapiLibrary() ;
      MOZ_COUNT_DTOR(nsMapiAddressBook) ;
  }
  
  BOOL nsMapiAddressBook::Initialize(void)
  {
!     if (mAddressBook) { return TRUE ; }
      nsAutoLock guard(mMutex) ;
  
      if (!LoadMapiLibrary()) {
          PRINTF(("Cannot load library.\n")) ;
          return FALSE ;
      }
!     mAddressBook = mRootBook ; 
!     return TRUE ;
  }
  
  void nsMapiAddressBook::AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer)
--- 221,1102 ----
  nsMapiAddressBook::~nsMapiAddressBook(void)
  {
      nsAutoLock guard(mMutex) ;
!     CleanUpMDB();
      FreeMapiLibrary() ;
      MOZ_COUNT_DTOR(nsMapiAddressBook) ;
  }
  
+ LPSPropValue nsMapiAddressBook::GetMapiProperty( LPMAPIPROP pProp, ULONG tag)
+ {
+     if (!pProp)
+         return( NULL);
+ 
+     int    sz = CbNewSPropTagArray( 1);
+     SPropTagArray *pTag = (SPropTagArray *) new char[sz];
+     pTag->cValues = 1;
+     pTag->aulPropTag[0] = tag;
+     LPSPropValue    lpProp = NULL;
+     ULONG    cValues = 0;
+     HRESULT hr = pProp->GetProps( pTag, 0, &cValues, &lpProp);
+     delete pTag;
+     if (HR_FAILED( hr) || (cValues != 1)) {
+         if (lpProp)
+             mMAPIFreeBuffer( lpProp);
+         return( NULL);
+     }
+     else {
+         if (PROP_TYPE( lpProp->ulPropTag) == PT_ERROR) {
+             if (lpProp->Value.l == MAPI_E_NOT_FOUND) {
+                 mMAPIFreeBuffer( lpProp);
+                 lpProp = NULL;
+             }
+         }
+     }
+ 
+     return( lpProp);
+ }
+ BOOL nsMapiAddressBook::GetEntryIdFromProp( LPSPropValue pVal, ULONG& cbEntryId, LPENTRYID& lpEntryId, BOOL delVal)
+ {
+     if (!pVal)
+         return( FALSE);
+     
+     BOOL bResult = TRUE;
+     switch (PROP_TYPE(pVal->ulPropTag))
+     {
+         case PT_BINARY:
+             cbEntryId = pVal->Value.bin.cb;
+             mMAPIAllocateBuffer( cbEntryId, (LPVOID *) &lpEntryId);
+             memcpy( lpEntryId, pVal->Value.bin.lpb, cbEntryId);
+         break;
+ 
+         default:
+             PRINTF(( "EntryId not in BINARY prop value\n"));
+             bResult = FALSE;
+         break;
+     }
+ 
+     if (pVal && delVal)
+         mMAPIFreeBuffer( pVal);
+ 
+     return( bResult);
+ }
+ 
+ BOOL nsMapiAddressBook::HandleContentsItem(ULONG oType, ULONG cb, LPENTRYID pEntry,nsMapiEntryArray& aFolders)
+ {
+     LPMDB  lpMsgStore;
+     ULONG objType=0;
+     HRESULT             hr;
+ 
+     if (oType == MAPI_MESSAGE)
+         return FALSE;
+     if (oType == MAPI_STORE)
+     {
+         hr=mRootSession->OpenEntry(
+                     cb,
+                     pEntry,
+                     &IID_IMsgStore,
+                     MAPI_BEST_ACCESS,
+                     &objType,
+                     (IUnknown**)&lpMsgStore);
+         if (FAILED(hr))
+         return FALSE ;
+         //Add MDB to a list to make it can be released when class  destroyed.
+         //We must leave it openned or else we can't open address store in it.
+         AddToMDBArray(lpMsgStore);
+ 
+         LPSPropValue    pVal;
+         pVal=GetMapiProperty(lpMsgStore,PR_IPM_SUBTREE_ENTRYID);
+         
+         
+         if (pVal) {
+             ULONG            cbEntry;
+             LPENTRYID        pEntry;
+             nsMapiInterfaceWrapper<LPMAPICONTAINER> lpSubTree;
+ 
+             if (GetEntryIdFromProp( pVal, cbEntry, pEntry)) {
+                 // Open up the folder!
+                 BOOL bResult = TRUE;
+                 bResult = lpMsgStore->OpenEntry(
+                                 cbEntry,
+                                 pEntry,
+                                 NULL,
+                                 MAPI_BEST_ACCESS,
+                                 &objType,
+                                 lpSubTree);
+                 mMAPIFreeBuffer( pEntry);
+                 if (!bResult && *(LPMAPICONTAINER*)&lpSubTree) {
+                     // Iterate the subtree with the results going into the folder list
+                     bResult = IterateHierarchy(*(LPMAPICONTAINER*)&lpSubTree,aFolders);
+     }
+                 else {
+                     PRINTF(( "GetStoreFolders: Error opening sub tree.\n"));
+                 }
+             }
+             else {
+                 PRINTF(( "GetStoreFolders: Error getting entryID from sub tree property val.\n"));
+     }
+         }
+         else {
+             PRINTF(( "GetStoreFolders: Error getting sub tree property.\n"));
+         }
+     }
+     else
+     {
+         PRINTF(("Type:%d\n",oType));
+     }
+ 
+     return TRUE ;
+ }
+ 
+ BOOL nsMapiAddressBook::IterateHierarchy(LPMAPICONTAINER pFolder,nsMapiEntryArray& aFolders, ULONG flags)
+ {
+     // flags can be CONVENIENT_DEPTH or 0
+     // CONVENIENT_DEPTH will return all depths I believe instead
+     // of just children
+     HRESULT        hr;
+     nsMapiInterfaceWrapper<LPMAPITABLE>    lpTable;
+     hr = pFolder->GetHierarchyTable( CONVENIENT_DEPTH , lpTable);
+     if (HR_FAILED(hr)) {
+         PRINTF(( "IterateHierarchy: GetContentsTable failed: 0x%lx, %d\n", (long)hr, (int)hr));
+         return( FALSE);
+ }
+ 
+     ULONG rowCount;
+     hr = lpTable->GetRowCount( 0, &rowCount);
+     if (!rowCount) {
+         return( TRUE);
+     }
+ 
+     hr = lpTable->SetColumns( (LPSPropTagArray)&ptaEid, 0);
+     if (HR_FAILED(hr)) {
+         PRINTF(( "IterateHierarchy: SetColumns failed: 0x%lx, %d\n", (long)hr, (int)hr));
+         return( FALSE);
+     }
+ 
+     hr = lpTable->SeekRow( BOOKMARK_BEGINNING, 0, NULL);
+     if (HR_FAILED(hr)) {
+         PRINTF(( "IterateHierarchy: SeekRow failed: 0x%lx, %d\n", (long)hr, (int)hr));
+         return( FALSE);
+     }
+ 
+     int            cNumRows = 0;
+     LPSRowSet    lpRow;
+     BOOL        keepGoing = TRUE;
+     BOOL        bResult = TRUE;
+     do {
+         
+         lpRow = NULL;
+         hr = lpTable->QueryRows( 1, 0, &lpRow);
+ 
+         if (HR_FAILED(hr))
+ {
+             PRINTF(( "QueryRows failed: 0x%lx, %d\n", (long)hr, (int)hr));
+             bResult = FALSE;
+             break;
+         }
+ 
+         if (lpRow){
+             cNumRows = lpRow->cRows;
+ 
+             if (cNumRows) {
+                 LPENTRYID    lpEntry = (LPENTRYID) lpRow->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
+                 ULONG        cb = lpRow->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;
+                 ULONG        oType = lpRow->aRow[0].lpProps[ieidPR_OBJECT_TYPE].Value.ul;
+                 
+                 keepGoing = HandleHierarchyItem( oType, cb, lpEntry,aFolders);
+ 
+             }
+             MyFreeProws(lpRow);
+         }
+ 
+     } while ( SUCCEEDED(hr) && cNumRows && lpRow && keepGoing);
+ 
+     
+     if (bResult && !keepGoing)
+         bResult = FALSE;
+ 
+     return( bResult);
+ }
+ BOOL nsMapiAddressBook::HandleHierarchyItem( ULONG oType, ULONG cb, LPENTRYID pEntry,nsMapiEntryArray& aFolders)
+ {
+     ULONG objType=0;
+     if (oType == MAPI_FOLDER)
+     {
+         nsMapiInterfaceWrapper<LPMAPICONTAINER> pFolder ;
+         if (!mRootSession->OpenEntry(
+                         cb,
+                         pEntry,
+                         0,
+                         MAPI_BEST_ACCESS,
+                         &objType,
+                         pFolder))
+         {
+             LPSPropValue        pVal;
+ 
+ 
+             pVal = GetMapiProperty(*(LPMAPICONTAINER*)&pFolder, PR_CONTAINER_CLASS);
+             if (pVal)
+             {
+                 if (strcmp("IPF.Contact",pVal->Value.lpszA) == 0)
+                 {
+                     SPropValue *currentValue=GetMapiProperty( *(LPMAPICONTAINER*)&pFolder, PR_ENTRYID);
+                     
+                     aFolders.AddItem(currentValue->Value.bin.cb,
+                                   NS_REINTERPRET_CAST(LPENTRYID, currentValue->Value.bin.lpb)) ;
+ 
+                 }
+             }
+         }
+     }
+     else
+     {
+         PRINTF(( "GetStoreFolders - HandleHierarchyItem: Unhandled ObjectType: %ld\n", oType));
+     }
+ 
+     return( TRUE);
+ }
+ 
+ 
+ BOOL nsMapiAddressBook::GetFolders(nsMapiEntryArray& aFolders)
+ {
+     aFolders.CleanUp() ;
+     nsMapiInterfaceWrapper<LPMAPICONTAINER> rootFolder ;
+     nsMapiInterfaceWrapper<LPMAPITABLE> folders ;
+     ULONG objType = 0 ;
+     ULONG rowCount = 0 ;
+ 
+     nsMapiInterfaceWrapper<LPMAPITABLE>    lpTable;
+ 
+     mLastError = mRootSession->GetMsgStoresTable( 0, lpTable);
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open MAPI MsgStores %08x.\n", mLastError));
+         return mLastError;
+     }
+ 
+     mLastError = lpTable->GetRowCount( 0, &rowCount);
+ 
+     mLastError = lpTable->SetColumns( (LPSPropTagArray)&ptaEid, 0);
+     if (FAILED(mLastError))
+         return( mLastError);
+     mLastError = lpTable->SeekRow( BOOKMARK_BEGINNING, 0, NULL);
+     if (FAILED(mLastError))
+         return mLastError;
+     
+     int            cNumRows = 0;
+     LPSRowSet    lpRow;
+     BOOL        keepGoing = TRUE;
+     BOOL        bResult = TRUE;
+     do {
+         
+         lpRow = NULL;
+         mLastError = lpTable->QueryRows( 1, 0, &lpRow);
+ 
+         if (HR_FAILED(mLastError)){
+             bResult = FALSE;
+             break;
+         }
+ 
+         if (lpRow){
+             cNumRows = lpRow->cRows;
+ 
+             if (cNumRows) {
+                 LPENTRYID    lpEID = (LPENTRYID) lpRow->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
+                 ULONG        cbEID = lpRow->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;
+                 ULONG        oType = lpRow->aRow[0].lpProps[ieidPR_OBJECT_TYPE].Value.ul;
+ 
+ 
+                 keepGoing = HandleContentsItem( oType, cbEID, lpEID,aFolders);
+             }
+             MyFreeProws( lpRow);
+         }
+ 
+     } while ( SUCCEEDED(mLastError) && cNumRows && lpRow && keepGoing);
+ 
+     
+     return HR_SUCCEEDED(mLastError) ;
+ }
+ BOOL nsMapiAddressBook::CorrectRestriction(const LPMAPIPROP aMapiProp,ULONG aRestrictionNum, LPSRestriction aRestriction)
+ {
+     ULONG conditionType = 0 ;
+     ULONG ulResIndex;
+     if (!aRestriction)
+         return FALSE;
+     for (ulResIndex=0;ulResIndex < aRestrictionNum;ulResIndex++)
+     {
+         conditionType = aRestriction[ulResIndex].rt;
+         switch (conditionType) 
+         {
+         case RES_EXIST  :
+             aRestriction[ulResIndex].res.resExist.ulPropTag =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resExist.ulPropTag);
+             break ;
+         case RES_BITMASK  :
+             aRestriction[ulResIndex].res.resBitMask.ulPropTag =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resBitMask.ulPropTag);
+             break ;
+         case RES_CONTENT :
+             aRestriction[ulResIndex].res.resContent.ulPropTag =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resContent.ulPropTag);
+             aRestriction[ulResIndex].res.resContent.lpProp->ulPropTag =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resContent.lpProp->ulPropTag);
+             break ;
+         case RES_PROPERTY :
+             aRestriction[ulResIndex].res.resProperty.ulPropTag =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resProperty.ulPropTag);
+             aRestriction[ulResIndex].res.resProperty.lpProp->ulPropTag =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resProperty.lpProp->ulPropTag);
+             break ;
+         case RES_SIZE :
+             aRestriction[ulResIndex].res.resSize.ulPropTag = 
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resSize.ulPropTag);
+             break ;
+         case RES_COMPAREPROPS :
+             aRestriction[ulResIndex].res.resCompareProps.ulPropTag1 =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resCompareProps.ulPropTag1);
+             aRestriction[ulResIndex].res.resCompareProps.ulPropTag2 =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resCompareProps.ulPropTag2);
+             break ;
+         case RES_NOT :
+             CorrectRestriction(aMapiProp,1,aRestriction[ulResIndex].res.resNot.lpRes);
+             break;
+         case RES_AND :
+             CorrectRestriction(aMapiProp,
+                                 aRestriction[ulResIndex].res.resAnd.cRes,
+                                 aRestriction[ulResIndex].res.resAnd.lpRes);
+             break;
+         case RES_OR :
+             CorrectRestriction(aMapiProp,
+                                 aRestriction[ulResIndex].res.resOr.cRes,
+                                 aRestriction[ulResIndex].res.resOr.lpRes);
+             break;
+ 
+         case RES_COMMENT :
+             CorrectRestriction(aMapiProp,1,aRestriction[ulResIndex].res.resComment.lpRes);
+             aRestriction[ulResIndex].res.resComment.lpProp->ulPropTag =
+                 GetRealMapiPropertyTag(aMapiProp,aRestriction[ulResIndex].res.resComment.lpProp->ulPropTag);
+             break;
+         case RES_SUBRESTRICTION :
+             CorrectRestriction(aMapiProp,1,aRestriction[ulResIndex].res.resSub.lpRes);
+             break;
+         default:
+             return FALSE;
+         }
+     }
+     return TRUE;
+ }
+ BOOL nsMapiAddressBook::Filter( LPSRestriction aRestriction,nsMapiEntryArray * aList)
+ {
+     if (!aRestriction)
+         return FALSE;
+ 
+     ULONG conditionType = 0 ;
+ 
+     nsMapiEntryArray listOut;
+     ULONG listindex=0;
+     
+     nsMapiEntryArray listDel;
+     ULONG delindex=0;
+ 
+     ULONG listsize;
+     ULONG resCount = 0;
+     ULONG resIndex = 0;
+ 
+     listsize = aList->GetSize();
+     conditionType = aRestriction->rt;
+     switch (conditionType) 
+     {
+     case RES_EXIST  :
+     case RES_BITMASK  :
+     case RES_CONTENT :
+     case RES_PROPERTY :
+     case RES_SIZE :
+     case RES_COMPAREPROPS :
+     case RES_COMMENT :
+     case RES_SUBRESTRICTION :
+         {
+             while(listindex < aList->GetSize())
+             {
+                 if (!FilterOnOneRow(aList->ElementAt(listindex),aRestriction))
+                     aList->Remove(listindex);
+                 else
+                     listindex++;
+             }
+         }
+         break;
+     case RES_NOT :
+         aRestriction->res.resNot.ulReserved = 1;
+     case RES_AND :
+     case RES_OR :
+         {
+             if (conditionType == RES_OR)
+             {
+                 for(listindex=0;listindex<aList->GetSize();listindex++)
+                 {
+                     listDel.AddItem(aList->ElementAt(listindex));
+                 }
+             }
+ 
+             resCount = aRestriction->res.resAnd.cRes;
+             //notice that SAndRestriction ,SNotRestriction ,SOrRestriction
+             //use the same struct
+             for (resIndex = 0;resIndex < resCount;resIndex++)
+             {
+                 //can't call listOut.CleanUp() here
+                 //because it will destroy all Element too
+                 while(listOut.GetSize())
+                 {
+                     listOut.Remove(0);
+                 }
+ 
+                 for(listindex=0;listindex<aList->GetSize();listindex++)
+                 {
+                     listOut.AddItem(aList->ElementAt(listindex));
+                 }
+ 
+                 Filter(&aRestriction->res.resAnd.lpRes[resIndex],&listOut);
+                 if (conditionType == RES_NOT)
+                 {
+                     for(listindex=0;listindex<listOut.GetSize();listindex++)
+                     {
+                         aList->Remove(listOut.ElementAt(listindex));
+                     }
+                 }
+                 else if (conditionType == RES_AND )
+                 {
+                     for(listindex=0;listindex<listOut.GetSize();listindex++)
+                     {
+                         if (!aList->IndexOf(listOut.ElementAt(listindex)))
+                         {
+                             aList->Remove(listOut.ElementAt(listindex));
+                         }
+                     }
+                 }
+                 else if (conditionType == RES_OR )
+                 {
+                     for(listindex=0;listindex<listOut.GetSize();listindex++)
+                     {
+                         listDel.Remove(listOut.ElementAt(listindex));
+                     }
+                     if (listDel.GetSize() == 0)
+                     {
+                         break;
+                     }
+                 }
+             }
+             if (conditionType == RES_OR)
+             {
+                 for(listindex=0;listindex<listDel.GetSize();listindex++)
+                 {
+                     aList->Remove(listDel.ElementAt(listindex));
+                 }
+             }
+         }
+ 
+     }
+     while(listDel.GetSize())
+     {
+         listDel.Remove(0);
+     }
+     while(listOut.GetSize())
+     {
+         listOut.Remove(0);
+     }
+ 
+ 
+     return TRUE;
+ }
+ 
+ BOOL nsMapiAddressBook::FilterOnOneRow(nsMapiEntry *aEntry,LPSRestriction aRestriction)
+ {
+     LPMAPIPROP object ;
+     ULONG objType = 0 ;
+     LPSPropValue realValue = NULL ;
+     LPSPropValue resValue  = NULL ;
+      ULONG valueCount = 0 ;
+    
+     mLastError = OpenEntry(aEntry->mByteCount, aEntry->mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType, 
+                                          (IUnknown **)&object) ;
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     
+     ULONG conditionType = 0 ;
+     conditionType = aRestriction->rt;
+ 
+     switch (conditionType) 
+     {
+     case RES_EXIST  :
+         if (!GetMAPIProperties(*aEntry,&aRestriction->res.resExist.ulPropTag,1,realValue,valueCount)) 
+             return FALSE;
+         resValue = NULL;
+         break ;
+     case RES_CONTENT :
+         if (!GetMAPIProperties(*aEntry,&aRestriction->res.resContent.ulPropTag,1,realValue,valueCount)) 
+             return FALSE;
+         resValue = aRestriction->res.resContent.lpProp;
+         break ;
+     case RES_PROPERTY :
+         if (!GetMAPIProperties(*aEntry,&aRestriction->res.resProperty.ulPropTag,1,realValue,valueCount)) 
+             return FALSE;
+         resValue = aRestriction->res.resProperty.lpProp;
+         break ;
+     case RES_BITMASK  :
+         return FALSE; //not support
+         break ;
+     case RES_SIZE :
+         return FALSE;//not been used now
+         break ;
+     case RES_COMPAREPROPS :
+         return FALSE;//not been used now
+         break ;
+     case RES_NOT :
+         return FALSE;//not need care here
+         break;
+     case RES_AND :
+         return FALSE;//not need care here
+         break;
+     case RES_OR :
+         return FALSE;//not need care here
+         break;
+     case RES_COMMENT :
+         return TRUE;//comment
+         break;
+     case RES_SUBRESTRICTION :
+         return FALSE;//not been used now
+         break ;
+ }
+     return AtomyFilter(aRestriction,realValue,resValue);
+ 
+ }
+ 
+ BOOL nsMapiAddressBook::AtomyFilter(LPSRestriction aRestriction,LPSPropValue aRealValue,LPSPropValue aFilterValue)
+ {
+     ULONG conditionType = 0 ;
+     conditionType = aRestriction->rt;
+ 
+     BOOL bTagEq=(aRealValue &&
+                 PROP_TYPE( aRealValue->ulPropTag ) != PT_ERROR) && 
+                 aFilterValue;
+                 // PROP_TYPE( aRealValue->ulPropTag ) == PROP_TYPE( aFilterValue->ulPropTag ));
+     switch (conditionType) 
+     {
+     case RES_EXIST  :
+         return (aRealValue && PROP_TYPE( aRealValue->ulPropTag ) != PT_ERROR) ;
+         break ;
+     case RES_CONTENT :
+         if (bTagEq)
+         {
+             switch(aRestriction->res.resContent.ulFuzzyLevel)
+             {
+             case FL_FULLSTRING :
+                 return !stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA);
+                 break;
+             case FL_PREFIX :
+                 return stristr(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) == aRealValue->Value.lpszA;
+                 break;
+             case FL_SUBSTRING :
+             default:
+                 return stristr(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) != NULL;
+                 break;
+             }
+         }
+         return FALSE;
+         break ;
+     case RES_PROPERTY :
+         if (bTagEq)
+         {
+             switch(aRestriction->res.resProperty.relop)
+             {
+             case RELOP_GE :
+                 return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) >= 0;
+                 break;
+             case RELOP_GT :
+                 return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) > 0;
+                 break;
+             case RELOP_LE :
+                 return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) <= 0;
+                 break;
+             case RELOP_LT :
+                 return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) < 0;
+                 break;
+             case RELOP_EQ :
+                 return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) == 0;
+                 break;
+             case RELOP_NE :
+                 return stricmp(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) != 0;
+                 break;
+             case RELOP_RE :
+             default:
+                 return stristr(aRealValue->Value.lpszA,aFilterValue->Value.lpszA) != NULL;
+                 break;
+ 
+             }
+         }
+         return FALSE;
+         break ;
+     case RES_BITMASK  :
+         return FALSE; //not support
+         break ;
+     case RES_SIZE :
+         return FALSE;//not been used now
+         break ;
+     case RES_COMPAREPROPS :
+         return FALSE;//not been used now
+         break ;
+     case RES_NOT :
+         return FALSE;//not need care here
+         break;
+     case RES_AND :
+         return FALSE;//not need care here
+         break;
+     case RES_OR :
+         return FALSE;//not need care here
+         break;
+     case RES_COMMENT :
+         return TRUE;//comment
+         break;
+     case RES_SUBRESTRICTION :
+         return FALSE;//not been used now
+         break ;
+     }
+     return TRUE;
+ }
+ 
+ BOOL nsMapiAddressBook::GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction,
+                                 nsMapiEntryArray *aList, ULONG aMapiType)
+ {
+     if (aList)
+         aList->CleanUp();
+ 
+     nsMapiInterfaceWrapper<LPMAPICONTAINER> parent ;
+     nsMapiInterfaceWrapper<LPMAPITABLE> contents ;
+     ULONG objType = 0 ;
+     ULONG rowCount = 0 ;
+ 
+ 
+     nsMapiInterfaceWrapper<LPMAPIPROP> pFolder;
+     nsCString cs;
+     aParent.ToString(cs);
+     
+     mLastError = OpenEntry(aParent.mByteCount,     aParent.mEntryId,
+                     0, MAPI_BEST_ACCESS, &objType, pFolder);
+     if (HR_FAILED(mLastError))
+     {
+         PRINTF(("Cannot open folder %08x.\n", mLastError)) ;
+         return FALSE;
+     }
+ 
+ 
+     LPSPropValue msgClass=GetMapiProperty(*(LPMAPIPROP*)&pFolder,PR_MESSAGE_CLASS);
+     if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+     {
+         HRESULT             hr;
+         LPSPropValue aValue = NULL ;
+         ULONG aValueCount = 0 ;
+ 
+         LPSPropTagArray properties = NULL ;
+         mMAPIAllocateBuffer(CbNewSPropTagArray(1),
+                            (void **)&properties);
+         properties->cValues = 1;
+         properties->aulPropTag [0] = GetEmailPropertyTag(*(LPMAPIPROP*)&pFolder,OUTLOOK_EMAIL_LIST1);
+         hr = pFolder->GetProps(properties, 0, &aValueCount, &aValue) ;
+ 
+         SBinaryArray *sa=&aValue->Value.MVbin;
+ 
+         LPENTRYID    lpEID;
+         ULONG        cbEID;
+         
+         ULONG idx;
+         nsMapiEntry testEntry;
+         nsCString sClass;
+         for (idx=0;sa->lpbin && idx<sa->cValues ;idx++)
+         {
+             lpEID= (LPENTRYID) sa->lpbin[idx].lpb;
+             cbEID = sa->lpbin[idx].cb;
+             testEntry.Assign(sa->lpbin[idx].cb,NS_REINTERPRET_CAST(LPENTRYID,sa->lpbin[idx].lpb));
+             
+             if (GetPropertyString(testEntry,PR_MESSAGE_CLASS,sClass)) //Error get property
+             {
+                 aList->AddItem(cbEID,lpEID);
+             }
+         }
+         Filter(aRestriction,aList);
+     }
+     else
+     {
+         if (aRestriction && !CorrectRestriction(*(LPMAPICONTAINER*)&pFolder,1,aRestriction))
+             return FALSE;
+         mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                          &IID_IMAPIContainer, MAPI_BEST_ACCESS, &objType,
+                                          parent) ;
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot open parent %08x.\n", mLastError)) ;
+             return FALSE ;
+         }
+ 
+         mLastError = parent->GetContentsTable(0, contents) ;
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot get contents %08x.\n", mLastError)) ;
+             return FALSE;
+         }
+         if (aRestriction) {
+             mLastError = contents->Restrict(aRestriction, TBL_BATCH) ;
+             if (HR_FAILED(mLastError)) {
+                 PRINTF(("Cannot set restriction %08x.\n", mLastError)) ;
+                 return FALSE ;
+             }
+         }
+         mLastError = contents->SetColumns((LPSPropTagArray)&ContentsColumns, 0);
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
+             return FALSE ;
+         }
+         mLastError = contents->GetRowCount(0, &rowCount) ;
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot get result count %08x.\n", mLastError)) ;
+             return FALSE ;
+         }
+         do {
+             LPSRowSet rowSet = NULL ;
+ 
+             rowCount = 0 ;
+             mLastError = contents->QueryRows(1, 0, &rowSet) ;
+             if (HR_FAILED(mLastError)) {
+                 PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
+                 return FALSE ;
+             }
+             rowCount = rowSet->cRows ;
+             if (rowCount > 0 && aList)
+             {
+                 if (aMapiType == 0 || rowSet->aRow->lpProps[ContentsColumnObjectType].Value.ul == aMapiType)
+                 {
+                     SPropValue& currentValue = rowSet->aRow->lpProps[ContentsColumnEntryId] ;
+                     aList->AddItem(currentValue.Value.bin.cb,
+                         NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+                 }
+                 else if (aMapiType == MAPI_DISTLIST)
+                 {
+                     if (strcmp("IPM.DistList",rowSet->aRow->lpProps[ContentsColumnMessageClass].Value.lpszA)==0)
+                     {
+                         SPropValue& currentValue = rowSet->aRow->lpProps[ContentsColumnEntryId] ;
+                         aList->AddItem(currentValue.Value.bin.cb,
+                             NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+ 
+                     }
+ }
+ 
+             }
+             MyFreeProws(rowSet) ;
+         } while (rowCount > 0) ;
+     }
+ 
+ 
+     return TRUE ;
+ }
+ 
+ BOOL nsMapiAddressBook::GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags,
+                                       ULONG aNbProperties, LPSPropValue& aValue,
+                                       ULONG& aValueCount)
+ {
+     nsMapiInterfaceWrapper<LPMAPIPROP> object ;
+     ULONG objType = 0 ;
+     LPSPropTagArray properties = NULL ;
+     ULONG i = 0 ;
+     
+     mLastError = OpenEntry(aObject.mByteCount, aObject.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType, 
+                                          object) ;
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     AllocateBuffer(CbNewSPropTagArray(aNbProperties),
+                    NS_REINTERPRET_CAST(void **, &properties));
+     properties->cValues = aNbProperties ;
+     for (i = 0 ; i < aNbProperties ; ++ i)
+     {
+         properties->aulPropTag [i] = GetRealMapiPropertyTag(*(LPMAPIPROP*)&object,aPropertyTags [i],TRUE);
+     }
+     mLastError = object->GetProps(properties, 0 , &aValueCount, &aValue) ;
+     FreeBuffer(properties) ;
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Error get props %08x.\n", mLastError)) ;
+     }
+     return HR_SUCCEEDED(mLastError);
+ }
+ 
+ BOOL nsMapiAddressBook::SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                                       LPSPropValue& aValues)
+ {
+     nsMapiInterfaceWrapper<LPMESSAGE> object;
+     ULONG objType = 0 ;
+     LPSPropProblemArray problems = NULL ;
+     ULONG i = 0 ;
+ 
+     LPMDB lpMsgStore=GetMsgStore(aObject);
+     
+     if (!lpMsgStore)
+     {
+         return FALSE;
+     }
+     mLastError = lpMsgStore->OpenEntry(aObject.mByteCount, aObject.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS  , &objType, 
+                                          object) ;
+     lpMsgStore->Release();
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     for (i = 0 ; i < aNbProperties ; ++ i)
+     {
+         aValues[i].ulPropTag = GetRealMapiPropertyTag(*(LPMESSAGE*)&object,aValues[i].ulPropTag,TRUE);
+     }
+     mLastError = object->SetProps(aNbProperties, aValues, &problems) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot update the object %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     if (problems) {
+         for (ULONG i = 0 ; i < problems->cProblem ; ++ i) {
+             PRINTF(("Problem %d: index %d code %08x.\n", i,
+                 problems->aProblem [i].ulIndex,
+                 problems->aProblem [i].scode)) ;
+         }
+     }
+     mLastError = object->SaveChanges(0) ;
+     if (MAPI_E_OBJECT_CHANGED == mLastError)
+     {
+         mLastError = object->SaveChanges(FORCE_SAVE ) ;
+     }
+     return HR_SUCCEEDED(mLastError) ;
+ }
+ 
+ BOOL nsMapiAddressBook::GetDefaultContainer(nsMapiEntry& aContainer)
+ {
+     return FALSE ;
+ }
+ 
+ BOOL nsMapiAddressBook::IsOK(void)
+ {
+     return mRootSession && mLibUsage;
+ }
+ 
  BOOL nsMapiAddressBook::Initialize(void)
  {
! 
      nsAutoLock guard(mMutex) ;
  
      if (!LoadMapiLibrary()) {
          PRINTF(("Cannot load library.\n")) ;
          return FALSE ;
      }
!     return TRUE;
  }
  
  void nsMapiAddressBook::AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer)
***************
*** 182,188 ****
--- 1109,1911 ----
      mMAPIFreeBuffer(aBuffer) ;
  }
  
+ ULONG nsMapiAddressBook::GetEmailPropertyTag(LPMAPIPROP lpProp, LONG nameID)
+ {
+     static GUID emailGUID =
+     {
+        0x00062004, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46
+     };
+ 
+ 
+   MAPINAMEID mapiNameID;
+   mapiNameID.lpguid = &emailGUID;
+   mapiNameID.ulKind = MNID_ID;
+   mapiNameID.Kind.lID = nameID;
+ 
+   LPMAPINAMEID lpMapiNames = &mapiNameID;
+   LPSPropTagArray lpMailTagArray = NULL;
+ 
+   HRESULT result = lpProp->GetIDsFromNames(1L, &lpMapiNames, 0, &lpMailTagArray);
+   if (result == S_OK)
+   {
+     ULONG lTag = lpMailTagArray->aulPropTag[0];
+     mMAPIFreeBuffer(lpMailTagArray);
+     return lTag;
+   }
+   return 0L;
+ }
+ ULONG nsMapiAddressBook::GetRealMapiPropertyTag(LPMAPIPROP lpProp, LONG aPropertyTag,BOOL aTest)
+ {
+     LPSPropValue addr;
+     ULONG        upRealTag=aPropertyTag;
+     ULONG        lSize=sizeof(TagMaps) / sizeof(TagMap);
+     
+     for(int i=0; i<lSize; i++)
+     {
+         if (TagMaps[i].AddressTag == aPropertyTag)
+         {
+ 
+             ULONG kPriEmailColumn=GetEmailPropertyTag(lpProp,TagMaps[i].NameID);
+             if (aTest)
+             {
+                 if (PR_DISPLAY_NAME_A == aPropertyTag)
+                 {
+                     //We need not change PR_DISPLAY_NAME_A tag if we are not using an address
+                     LPSPropValue msgClass=GetMapiProperty(lpProp,PR_MESSAGE_CLASS);
+                     if (msgClass && !strcmp("IPM.Contact",msgClass->Value.lpszA))
+                     {
+                         if (kPriEmailColumn)
+                             upRealTag  = kPriEmailColumn | TagMaps[i].TypeMask;
+                     }
+                     else
+                     {
+                         FreeBuffer(msgClass);
+                         upRealTag = aPropertyTag;
+                     }
+                 }
+                 else //PR_DISPLAY_NAME_A == aPropertyTag
+                 {
+                     addr=GetMapiProperty(lpProp,aPropertyTag);
+                     if (!addr || PROP_TYPE( addr->ulPropTag) == PT_ERROR ||
+                         addr->Value.l == MAPI_E_NOT_FOUND)
+                     {
+                         if (kPriEmailColumn)
+                             upRealTag  = kPriEmailColumn | TagMaps[i].TypeMask;
+                     }
+                 }
+             }
+             else //aTest
+             {
+                 if (kPriEmailColumn)
+                     upRealTag  = kPriEmailColumn | TagMaps[i].TypeMask;
+             }
+       
+             break; //we find it,exit
+         }
+     }
+ 
+     return upRealTag;
+ }
+ 
+ BOOL nsMapiAddressBook::GetPropertyLong(const nsMapiEntry& aObject,
+                                     ULONG aPropertyTag,
+                                     ULONG& aValue)
+ {
+     aValue = 0 ;
+     LPSPropValue values = NULL ;
+     ULONG valueCount = 0 ;
+ 
+     if (PR_OBJECT_TYPE == aPropertyTag)
+     {
+         nsMapiInterfaceWrapper<LPMAPIFOLDER> pFolder ;
+         ULONG objType=0;
+         mLastError = OpenEntry(aObject.mByteCount,aObject.mEntryId,
+                          NULL,MAPI_BEST_ACCESS,&objType, pFolder);
+         if (HR_FAILED(mLastError))
+         {
+             PRINTF(("Cannot open folder %08x.\n", mLastError)) ;
+             return FALSE;
+         }
+         LPSPropValue msgClass=GetMapiProperty(*(LPMAPIFOLDER*)&pFolder,PR_MESSAGE_CLASS);
+         if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+         {
+             FreeBuffer(msgClass);
+             aValue = MAPI_DISTLIST;
+             return TRUE;
+         }
+     }
  
+     if (!GetMAPIProperties(aObject, &aPropertyTag, 1, values, valueCount)) 
+         return FALSE ;
  
+     if (valueCount == 1 && values && PROP_TYPE(values->ulPropTag) == PT_LONG) {
+         aValue = values->Value.ul ;
+     }
+     FreeBuffer(values) ;
+     return TRUE ;
+ }
+ 
+ BOOL nsMapiAddressBook::GetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag,
+                                     WORD& aYear, WORD& aMonth, WORD& aDay)
+ {
+     aYear = 0;
+     aMonth = 0;
+     aDay = 0;
+     LPSPropValue values = NULL ;
+     ULONG valueCount = 0 ;
+ 
+     if (!GetMAPIProperties(aObject, &aPropertyTag, 1, values, valueCount))
+         return FALSE ;
+ 
+     if (valueCount == 1 && values && PROP_TYPE(values->ulPropTag) == PT_SYSTIME) {
+         SYSTEMTIME readableTime ;
+         FILETIME   localTime ;
+         FileTimeToLocalFileTime(&values->Value.ft,&localTime);
+         if (FileTimeToSystemTime(&localTime, &readableTime)) {
+             aYear = readableTime.wYear ;
+             aMonth = readableTime.wMonth ;
+             aDay = readableTime.wDay ;
+         }
+     }
+     FreeBuffer(values) ;
+     return TRUE ;
+ }
+ 
+ HRESULT     nsMapiAddressBook::OpenEntry(ULONG cbEntryID,
+                     LPENTRYID lpEntryID,
+                     LPCIID lpInterface,
+                     ULONG ulFlags,
+                     ULONG FAR * lpulObjType,
+                     LPUNKNOWN FAR * lppUnk
+                     )
+ {
+ 
+     int err;
+     HRESULT rv;
+     __try
+     {
+         rv=mRootSession->OpenEntry(cbEntryID,
+                     lpEntryID,
+                     lpInterface,
+                     ulFlags ,
+                     lpulObjType,
+                     lppUnk
+                     );
+     }__except(err)
+     {
+         return (-1);
+     }
+ 
+     if (HR_FAILED(rv) && !m_MDBArray.Count())
+     {
+         //There are no openned Message store,so we have to open them all
+         nsMapiEntryArray aFolders;
+         if (GetFolders(aFolders))
+         {
+             __try
+             {
+                 rv=mRootSession->OpenEntry(cbEntryID,
+                             lpEntryID,
+                             lpInterface,
+                             ulFlags ,
+                             lpulObjType,
+                             lppUnk
+                             );
+             }__except(err)
+             {
+                 return (-1);
+             }
+         }
+     }
+     return rv;
+ 
+ }
+ 
+ BOOL nsMapiAddressBook::AddEntryToList(const nsMapiEntry& aDistlist, const nsMapiEntry& aNewEntry)
+ {
+     nsMapiInterfaceWrapper<LPMAPIPROP> container ;
+     ULONG objType = 0 ;
+ 
+     nsMapiEntry parentEntry;
+     if (!GetEntryParent(aDistlist,parentEntry))
+         return FALSE;
+     
+     LPMDB lpMsgStore=GetMsgStore(parentEntry);
+     
+     if (!lpMsgStore)
+         return FALSE;
+     mLastError = lpMsgStore->OpenEntry(aDistlist.mByteCount, aDistlist.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                          container) ;
+     lpMsgStore->Release();
+ 
+     if (HR_FAILED(mLastError))       
+         return FALSE ;
+     
+ 
+     /*
+     When add mail address to distlist,Mapi need update 2 tag.
+     */
+     //update OUTLOOK_EMAIL_LIST1
+     ULONG listTag=GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_LIST1) | PT_MV_BINARY;
+     SBinaryArray oldChilds;
+     LPSBinary    bins=NULL;
+     SBinaryArray newChilds;
+     LPSPropValue oldChildValue = NULL ;
+     ULONG valueCount = 0 ;
+ 
+     if (!GetMAPIProperties(aDistlist, &listTag, 1, oldChildValue, valueCount))
+     {
+         PRINTF(("Cannot get old childs %08x.\n", mLastError)) ;
+         return FALSE;
+     }
+ 
+     if (! (oldChildValue->Value.l == MAPI_E_NOT_FOUND))
+     {
+         oldChilds = oldChildValue->Value.MVbin;
+         newChilds.cValues=oldChilds.cValues + 1;
+         mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+         newChilds.lpbin = bins;
+         for (ULONG i=0;i<oldChilds.cValues;i++)
+         {
+             newChilds.lpbin[i].lpb = oldChilds.lpbin[i].lpb;
+             newChilds.lpbin[i].cb = oldChilds.lpbin[i].cb;
+         }
+     }
+     else
+     {
+         newChilds.cValues = 1;
+         mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+         newChilds.lpbin = bins;
+     }
+ 
+     nsMapiEntry orgEntryID;
+     if (!GetPropertyBin(aNewEntry,
+         GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_ORGID) | PT_BINARY,
+         orgEntryID))
+     {
+         return FALSE;
+     }
+     newChilds.lpbin[newChilds.cValues-1].lpb = NS_REINTERPRET_CAST(unsigned char *, orgEntryID.mEntryId);
+     newChilds.lpbin[newChilds.cValues-1].cb  = orgEntryID.mByteCount;
+ 
+     SPropValue childs;
+     childs.ulPropTag = listTag;
+     childs.Value.MVbin = newChilds;
+ 
+     LPSPropProblemArray problems = NULL ;
+     mLastError = container->SetProps(1, &childs, &problems) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot set childs %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     //update OUTLOOK_EMAIL_LIST2
+     listTag = GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_LIST2) | PT_MV_BINARY;
+     if (!GetMAPIProperties(aDistlist, &listTag, 1, oldChildValue, valueCount))
+     {
+         PRINTF(("Cannot get old childs %08x.\n", mLastError)) ;
+         return FALSE;
+     }
+     
+     if (! (oldChildValue->Value.l == MAPI_E_NOT_FOUND))
+     {
+         oldChilds = oldChildValue->Value.MVbin;
+         newChilds.cValues=oldChilds.cValues + 1;
+         mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+         newChilds.lpbin = bins;
+         for (ULONG i=0;i<oldChilds.cValues;i++)
+         {
+             newChilds.lpbin[i].lpb = oldChilds.lpbin[i].lpb;
+             newChilds.lpbin[i].cb = oldChilds.lpbin[i].cb;
+         }
+     }
+     else
+     {
+         newChilds.cValues = 1;
+         mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+         newChilds.lpbin = bins;
+     }
+ 
+     /*
+     Need more work here.
+     There are two kind of mail address in outlook DistList.
+     One is sample,not include in parent folder.
+     The other is a link to a unattached address in parents folders.
+     Currently we can only add first kind of address to a outlook distlist.
+     */
+     
+     newChilds.lpbin[newChilds.cValues-1].lpb = NS_REINTERPRET_CAST(unsigned char *, orgEntryID.mEntryId);
+     newChilds.lpbin[newChilds.cValues-1].cb  = orgEntryID.mByteCount;
+ 
+     childs.ulPropTag = listTag;
+     childs.Value.MVbin = newChilds;
+ 
+     mLastError = container->SetProps(1, &childs, &problems) ;
+     if (HR_FAILED(mLastError))
+     {
+         PRINTF(("Cannot set childs %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     mMAPIFreeBuffer(bins);
+ 
+     mLastError = container->SaveChanges(KEEP_OPEN_READONLY) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot commit new entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     return TRUE ;
+ }
+ BOOL nsMapiAddressBook::DeleteEntryFromList(const nsMapiEntry& aDistlist, const nsMapiEntry& aNewEntry)
+ {
+     nsMapiInterfaceWrapper<LPMAPIPROP> container ;
+     ULONG objType = 0 ;
+ 
+     nsMapiEntry parentEntry;
+     if (!GetEntryParent(aDistlist,parentEntry))
+         return FALSE;
+ 
+     LPMDB lpMsgStore=GetMsgStore(parentEntry);
+     if (!lpMsgStore)
+         return FALSE;
+ 
+     mLastError = lpMsgStore->OpenEntry(aDistlist.mByteCount, aDistlist.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                          container) ;
+     lpMsgStore->Release();
+ 
+     if (HR_FAILED(mLastError))
+         return FALSE ;
+     /*
+     When delete mail address from distlist,Mapi need update 2 tag.
+     */
+     //update OUTLOOK_EMAIL_LIST1
+     ULONG listTag=GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_LIST1) | PT_MV_BINARY;
+ 
+     SBinaryArray oldChilds;
+     LPSBinary    bins=NULL;
+     SBinaryArray newChilds;
+     LPSPropValue oldChildValue = NULL ;
+     ULONG valueCount = 0 ;
+ 
+     newChilds.lpbin=NULL;
+ 
+     ULONG lDeleteEntry=0;
+     ULONG newIndex=0;
+     ULONG oldIndex=0;
+     if (!GetMAPIProperties(aDistlist, &listTag, 1, oldChildValue, valueCount))
+     {
+         PRINTF(("Cannot get old childs %08x.\n", mLastError)) ;
+         return FALSE;
+     }
+     
+     if (! (oldChildValue->Value.l == MAPI_E_NOT_FOUND))
+     {
+         oldChilds = oldChildValue->Value.MVbin;
+         newChilds.cValues=oldChilds.cValues - 1;
+         mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+         newChilds.lpbin = bins;
+         for (oldIndex=0;oldIndex<oldChilds.cValues;oldIndex++)
+         {
+             if ( oldChilds.lpbin[oldIndex].cb == aNewEntry.mByteCount &&
+                 !memcmp((void*)(oldChilds.lpbin[oldIndex].lpb+4),
+                         (void*)(aNewEntry.mEntryId->ab),
+                         oldChilds.lpbin[oldIndex].cb-4))
+             {
+                 lDeleteEntry=oldIndex;
+             }
+             else
+             {
+                 newChilds.lpbin[newIndex].lpb = oldChilds.lpbin[oldIndex].lpb;
+                 newChilds.lpbin[newIndex].cb = oldChilds.lpbin[oldIndex].cb;
+                 newIndex++;
+             }
+         }
+     }
+     else
+         return FALSE;
+ 
+ 
+     SPropValue childs;
+     LPSPropProblemArray problems = NULL ;
+     
+     if (newChilds.cValues == 0)
+     {
+         SPropTagArray delTags;
+         delTags.cValues = 1;
+         delTags.aulPropTag[0] = listTag;
+ 
+         mLastError = container->DeleteProps(&delTags, &problems) ;
+     }
+     else
+     {
+         childs.ulPropTag = listTag;
+         childs.Value.MVbin = newChilds;
+         mLastError = container->SetProps(1, &childs, &problems) ;
+     }
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot set childs %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     //update OUTLOOK_EMAIL_LIST2
+     listTag = GetEmailPropertyTag(*(LPMAPIPROP*)&container,OUTLOOK_EMAIL_LIST2) | PT_MV_BINARY;
+     if (!GetMAPIProperties(aDistlist, &listTag, 1, oldChildValue, valueCount))
+     {
+         PRINTF(("Cannot get old childs %08x.\n", mLastError)) ;
+         return FALSE;
+     }
+ 
+     newIndex=0;
+     if (! (oldChildValue->Value.l == MAPI_E_NOT_FOUND))
+     {
+         oldChilds = oldChildValue->Value.MVbin;
+         newChilds.cValues=oldChilds.cValues - 1;
+         mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+         newChilds.lpbin = bins;
+         for (oldIndex=0;oldIndex<oldChilds.cValues;oldIndex++)
+         {
+             if (oldIndex != lDeleteEntry)
+             {
+                 newChilds.lpbin[newIndex].lpb = oldChilds.lpbin[oldIndex].lpb;
+                 newChilds.lpbin[newIndex].cb = oldChilds.lpbin[oldIndex].cb;
+                 newIndex++;
+             }
+         }
+     }
+     else
+     {
+         newChilds.cValues = 1;
+         mMAPIAllocateBuffer(sizeof(SBinary) * newChilds.cValues,(void**)& bins);
+         newChilds.lpbin = bins;
+     }
  
  
+     
+     if (newChilds.cValues == 0)
+     {
+         SPropTagArray delTags;
+         delTags.cValues = 1;
+         delTags.aulPropTag[0] = listTag;
+ 
+         mLastError = container->DeleteProps(&delTags, &problems) ;
+     }
+     else
+     {
+         childs.ulPropTag = listTag;
+         childs.Value.MVbin = newChilds;
+         mLastError = container->SetProps(1, &childs, &problems) ;
+     }
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot set childs %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     mMAPIFreeBuffer(bins);
+ 
+     mLastError = container->SaveChanges(KEEP_OPEN_READONLY) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot commit new entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     return TRUE ;
+ }
+ 
+ BOOL nsMapiAddressBook::GetEntryParent(const nsMapiEntry& aParent, nsMapiEntry& aParentEntry)
+ {
+     nsMapiInterfaceWrapper<LPMAPIPROP> object ;
+     ULONG objType = 0 ;
+     mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                          (IUnknown **)&object) ;
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     SPropValue *parentID=GetMapiProperty(*(LPMAPIPROP*)&object, PR_PARENT_ENTRYID);
+ 
+     if (parentID->Value.l == MAPI_E_NOT_FOUND)
+         return FALSE;
+     aParentEntry.Assign(parentID->Value.bin.cb, NS_REINTERPRET_CAST(LPENTRYID, parentID->Value.bin.lpb));
+     return TRUE;
+ }
+ BOOL nsMapiAddressBook::CreateEntryInList(const nsMapiEntry& aDistlist, nsMapiEntry& aNewEntry)
+ {
+     nsMapiInterfaceWrapper<LPMAPIPROP> container ;
+     ULONG objType = 0 ;
+ 
+     nsMapiEntry parentEntry;
+     if (!GetEntryParent(aDistlist,parentEntry))
+     {
+         return FALSE;
+     }
+     nsMapiInterfaceWrapper<LPMESSAGE> newEntry ;
+     if (!CreateEntry(parentEntry,aNewEntry)) //Create a entry in parent folder
+         return FALSE;
+ 
+     return AddEntryToList(aDistlist,aNewEntry);
+ }
+ 
+ BOOL nsMapiAddressBook::CreateEntry(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry)
+ {
+     nsMapiInterfaceWrapper<LPMAPIFOLDER> container ;
+     ULONG objType = 0 ;
+ 
+     nsMapiInterfaceWrapper<LPMAPIPROP> object;
+     mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                          object) ;
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return NULL ;
+     }
+     LPSPropValue msgClass=GetMapiProperty(*(LPMAPIPROP*)&object,PR_MESSAGE_CLASS);
+ 
+     if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+         return CreateEntryInList(aParent,aNewEntry);        //Create entry in DistList
+     
+     LPMDB lpMsgStore=GetMsgStore(aParent);
+     
+     if (!lpMsgStore)
+         return FALSE;
+     
+     mLastError = lpMsgStore->OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                          &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType,
+                                          container) ;
+     lpMsgStore->Release();
+ 
+     if (HR_FAILED(mLastError))
+         return FALSE;
+     
+     nsMapiInterfaceWrapper<LPMESSAGE> newEntry ;
+ 
+     mLastError = container->CreateMessage(&IID_IMessage,
+                                         0,
+                                         newEntry) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot create new entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     SPropValue messageclass ;
+     LPSPropProblemArray problems = NULL ;
+     nsCString tempName ;
+ 
+     messageclass.ulPropTag = PR_MESSAGE_CLASS_A ;
+     tempName.Assign("IPM.Contact") ;
+     messageclass.Value.lpszA = NS_CONST_CAST(char *, tempName.get()) ;
+     mLastError = newEntry->SetProps(1, &messageclass, &problems) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot set temporary name %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     mLastError = newEntry->SaveChanges(KEEP_OPEN_READONLY) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot commit new entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     SPropTagArray property ;
+     LPSPropValue value = NULL ;
+     ULONG valueCount = 0 ;
+ 
+     property.cValues = 1 ;
+     property.aulPropTag [0] = PR_ENTRYID ;
+     mLastError = newEntry->GetProps(&property, 0, &valueCount, &value) ;
+     if (HR_FAILED(mLastError) || valueCount != 1) {
+         PRINTF(("Cannot get entry id %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     aNewEntry.Assign(value->Value.bin.cb, NS_REINTERPRET_CAST(LPENTRYID, value->Value.bin.lpb)) ;
+     FreeBuffer(value) ;
+     return TRUE ;
+ }
+ 
+ BOOL nsMapiAddressBook::CreateDistList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry)
+ {
+     nsMapiInterfaceWrapper<LPMAPIFOLDER> container ;
+     ULONG objType = 0 ;
+ 
+     LPMDB lpMsgStore=GetMsgStore(aParent);
+     if (!lpMsgStore)
+         return FALSE;
+     mLastError = lpMsgStore->OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                          &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType,
+                                          container) ;
+     lpMsgStore->Release();
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open container %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     nsMapiInterfaceWrapper<LPMESSAGE> newEntry ;
+     mLastError = container->CreateMessage(&IID_IMAPIProp,
+                                         0,
+                                         newEntry) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot create new entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     SPropValue messageclass ;
+     LPSPropProblemArray problems = NULL ;
+     nsCString tempName ;
+ 
+     messageclass.ulPropTag = PR_MESSAGE_CLASS_A ;
+     tempName.Assign("IPM.DistList") ;
+     messageclass.Value.lpszA = NS_CONST_CAST(char *, tempName.get()) ;
+     mLastError = newEntry->SetProps(1, &messageclass, &problems) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot set PR_MESSAGE_CLASS_A %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     mLastError = newEntry->SaveChanges(KEEP_OPEN_READONLY) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot commit new entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     ULONG valueCount = 0 ;
+     SPropTagArray property ;
+     LPSPropValue value = NULL ;
+ 
+     property.cValues = 1 ;
+     property.aulPropTag [0] = PR_ENTRYID ;
+     mLastError = newEntry->GetProps(&property, 0, &valueCount, &value) ;
+     if (HR_FAILED(mLastError) || valueCount != 1) {
+         PRINTF(("Cannot get entry id %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     aNewEntry.Assign(value->Value.bin.cb, NS_REINTERPRET_CAST(LPENTRYID, value->Value.bin.lpb)) ;
+ 
+     FreeBuffer(value) ;
+     return TRUE ;
+ }
+ 
+ 
+ BOOL nsMapiAddressBook::CopyEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aSource,
+                               nsMapiEntry& aTarget)
+ {
+     nsMapiInterfaceWrapper<LPMAPIFOLDER> container ;
+     nsMapiInterfaceWrapper<LPMAPIFOLDER> targetFolder ;
+     ULONG objType = 0 ;
+     nsMapiInterfaceWrapper<LPMAPIPROP> object;
+     mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                          object) ;
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     LPSPropValue msgClass=GetMapiProperty(*(LPMAPIPROP*)&object,PR_MESSAGE_CLASS);
+ 
+     if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+     {
+         //Add Entry To DistList
+         if (!AddEntryToList(aContainer,aSource))
+             return FALSE;
+         aTarget.Assign(aSource.mByteCount,aSource.mEntryId);
+         return TRUE;
+     }
+ 
+     SBinary entry ;
+     SBinaryArray entryArray ;
+ 
+     entry.cb = aSource.mByteCount ;
+     entry.lpb = NS_REINTERPRET_CAST(LPBYTE, aSource.mEntryId) ;
+     entryArray.cValues = 1 ;
+     entryArray.lpbin = &entry ;
+  
+     mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+                                          &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType,
+                                          container) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open container %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     mLastError = OpenEntry(aTarget.mByteCount, aTarget.mEntryId,
+                                          &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType,
+                                          targetFolder) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open Target folder %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+ 
+     nsMapiInterfaceWrapper<LPMAPIPROP> newEntry ;
+ 
+     mLastError = container->CopyMessages(&entryArray,
+                                         &IID_IMessage,
+                                         (void*)&targetFolder,
+                                         0,
+                                         NULL,
+                                         NULL) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot create new entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     return TRUE ;
+ }
+ 
+ BOOL nsMapiAddressBook::DeleteEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry)
+ {
+     nsMapiInterfaceWrapper<LPMAPIFOLDER> container ;
+     ULONG objType = 0 ;
+     SBinary entry ;
+     SBinaryArray entryArray ;
+ 
+     
+     nsMapiInterfaceWrapper<LPMAPIPROP> object;
+     mLastError = OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS, &objType,
+                                          object) ;
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     LPSPropValue msgClass=GetMapiProperty(*(LPMAPIPROP*)&object,PR_MESSAGE_CLASS);
+ 
+     if (msgClass && strcmp("IPM.DistList",msgClass->Value.lpszA) == 0)
+         return DeleteEntryFromList(aContainer,aEntry);      //Delete Entry from DistList
+ 
+     LPMDB lpMsgStore=GetMsgStore(aContainer);
+     if (!lpMsgStore)
+         return FALSE;
+ 
+     mLastError = lpMsgStore->OpenEntry(aContainer.mByteCount, aContainer.mEntryId,
+                                          &IID_IMAPIFolder, MAPI_BEST_ACCESS, &objType, 
+                                          container) ;
+     lpMsgStore->Release();
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open container %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     entry.cb = aEntry.mByteCount ;
+     entry.lpb = NS_REINTERPRET_CAST(LPBYTE, aEntry.mEntryId) ;
+     entryArray.cValues = 1 ;
+     entryArray.lpbin = &entry ;
+     mLastError = container->DeleteMessages(&entryArray, 0,0,0) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot delete entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     return TRUE ;
+ }
+ 
+ //Use to open message store in write mode
+ LPMDB nsMapiAddressBook::GetMsgStore(const nsMapiEntry& aEntry)
+ {
+     nsMapiInterfaceWrapper<LPMAPIPROP> object;
+     ULONG objType=0;
+ 
+     mLastError = OpenEntry(aEntry.mByteCount, aEntry.mEntryId,
+                                          &IID_IMAPIProp, MAPI_BEST_ACCESS  , &objType, 
+                                          object) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return NULL ;
+     }
+     SPropValue *svMsgSore=GetMapiProperty( *(LPMAPIPROP*)&object, PR_STORE_ENTRYID);;
+ 
+     LPMDB  lpMsgStore=NULL;
+     mLastError=mRootSession->OpenMsgStore(0,
+                               svMsgSore->Value.bin.cb,
+                               (ENTRYID*)svMsgSore->Value.bin.lpb,
+                               &IID_IMsgStore,
+                               MAPI_BEST_ACCESS  ,
+                               &lpMsgStore);
+ 
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open MsgStore %08x.\n", mLastError)) ;
+         return NULL ;
+     }
+     
+     return lpMsgStore;
+ }
*** misc/mozilla/mailnews/addrbook/src/nsMapiAddressBook.h	2001-09-28 22:06:25.000000000 +0200
--- misc/build/mozilla/mailnews/addrbook/src/nsMapiAddressBook.h	2005-07-13 17:26:54.000000000 +0200
***************
*** 40,51 ****
--- 40,81 ----
  
  #include "nsAbWinHelper.h"
   
+ struct TagMap
+ {
+     ULONG AddressTag;
+     ULONG NameID;
+     ULONG TypeMask;
+ };
  class nsMapiAddressBook : public nsAbWinHelper
  {
  public :
      nsMapiAddressBook(void) ;
      virtual ~nsMapiAddressBook(void) ;
  
+     // Get the top address books
+     virtual BOOL GetFolders(nsMapiEntryArray& aFolders);
+ 
+     // Get a default address book container
+     virtual BOOL GetDefaultContainer(nsMapiEntry& aContainer);
+     // Is the helper correctly initialised?
+     virtual BOOL IsOK(void);
+     virtual BOOL GetPropertyLong(const nsMapiEntry& aObject,
+                                     ULONG aPropertyTag,
+                                     ULONG& aValue);
+     // Get the value of a MAPI property of type SYSTIME
+     virtual BOOL GetPropertyDate(const nsMapiEntry& aObject, ULONG aPropertyTag,
+                          WORD& aYear, WORD& aMonth, WORD& aDay);
+     // Create entry in the address book
+     virtual BOOL CreateEntry(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
+     // Delete an entry in the address book
+     virtual BOOL DeleteEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aEntry) ;
+     // Create a distribution list in the address book
+     virtual BOOL CreateDistList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry) ;
+     // Copy an existing entry in the address book
+     virtual BOOL CopyEntry(const nsMapiEntry& aContainer, const nsMapiEntry& aSource, nsMapiEntry& aTarget) ;
+ 
+     static void FreeMapiLibrary(void) ;
+ 
  protected :
      // Class members to handle the library/entry points
      static HMODULE mLibrary ;
***************
*** 67,85 ****
      static BOOL mInitialized ;
      static BOOL mLogonDone ;
      static LPMAPISESSION mRootSession ;
!     static LPADRBOOK mRootBook ;
  
      // Load the MAPI environment
      BOOL Initialize(void) ;
      // Allocation of a buffer for transmission to interfaces
      virtual void AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer) ;
      // Destruction of a buffer provided by the interfaces
      virtual void FreeBuffer(LPVOID aBuffer) ;
      // Library management 
      static BOOL LoadMapiLibrary(void) ;
!     static void FreeMapiLibrary(void) ;
  
  private :
  } ;
  
  #endif // nsMapiAddressBook_h___
--- 97,173 ----
      static BOOL mInitialized ;
      static BOOL mLogonDone ;
      static LPMAPISESSION mRootSession ;
! 
  
      // Load the MAPI environment
      BOOL Initialize(void) ;
+ 
+     virtual HRESULT OpenEntry(ULONG cbEntryID,
+                     LPENTRYID lpEntryID,
+                     LPCIID lpInterface,
+                     ULONG ulFlags,
+                     ULONG FAR * lpulObjType,
+                     LPUNKNOWN FAR * lppUnk
+                     );
+  
+ 
+     // Retrieve the contents of a container, with an optional restriction
+     virtual BOOL GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
+                      nsMapiEntryArray *aList, ULONG aMapiType) ;
+     // Retrieve the values of a set of properties on a MAPI object
+     virtual BOOL GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
+                            ULONG aNbProperties,
+                            LPSPropValue& aValues, ULONG& aValueCount) ;
+     // Set the values of a set of properties on a MAPI object
+     virtual BOOL SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                            LPSPropValue& aValues);
+ 
+ 
      // Allocation of a buffer for transmission to interfaces
      virtual void AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer) ;
      // Destruction of a buffer provided by the interfaces
      virtual void FreeBuffer(LPVOID aBuffer) ;
      // Library management 
      static BOOL LoadMapiLibrary(void) ;
! 
!     BOOL HandleContentsItem(ULONG oType, ULONG cb, LPENTRYID pEntry,nsMapiEntryArray& aFolders);
!     LPSPropValue GetMapiProperty( LPMAPIPROP pProp, ULONG tag);
!     BOOL GetEntryIdFromProp( LPSPropValue pVal, ULONG& cbEntryId, LPENTRYID& lpEntryId, BOOL delVal=FALSE);
!     BOOL HandleHierarchyItem( ULONG oType, ULONG cb, LPENTRYID pEntry,nsMapiEntryArray& aFolders);
!     BOOL IterateHierarchy(IMAPIContainer * pFolder, nsMapiEntryArray& aFolders,ULONG flags=0);
!     ULONG GetEmailPropertyTag(LPMAPIPROP lpProp, LONG nameID);
!     ULONG GetRealMapiPropertyTag(LPMAPIPROP lpProp, LONG aPropertyTag,BOOL aTest=FALSE);
!     LPMDB GetMsgStore(const nsMapiEntry& aEntry);
!     BOOL CreateEntryInList(const nsMapiEntry& aParent, nsMapiEntry& aNewEntry);
!     BOOL AddEntryToList(const nsMapiEntry& aParent,const nsMapiEntry& aNewEntry);
!     BOOL DeleteEntryFromList(const nsMapiEntry& aDistlist, const nsMapiEntry& aNewEntry);
!     BOOL GetEntryParent(const nsMapiEntry& aParent, nsMapiEntry& aParentEntry);
!     BOOL CorrectRestriction(const LPMAPIPROP aMapiProp,ULONG aRestrictionNum, LPSRestriction aRestriction);
! 
!     //filter
!     BOOL Filter( LPSRestriction aRestriction,nsMapiEntryArray * aList);
!     BOOL FilterOnOneRow(nsMapiEntry *aEntry,LPSRestriction aRestriction);
!     BOOL AtomyFilter(LPSRestriction aRestriction,LPSPropValue aRealValue,LPSPropValue aFilterValue);
! 
!     void AddToMDBArray(LPMDB aMDB)
!     {
!         m_MDBArray.AppendElement(aMDB);
!     }
!     void CleanUpMDB()
!     {
!         LPMDB mdb;
!         for (int i = 0; i < m_MDBArray.Count(); i++)
!         {
!             mdb = (LPMDB)m_MDBArray.ElementAt(i);
!             mdb->Release();
!         }
!         m_MDBArray.Clear();
!     }
  
  private :
+     //use to keep all openned MsgStore,if we not open a message store,we can't open any thing on it
+     //so we have to kill message stores openned
+     nsVoidArray        m_MDBArray; 
  } ;
  
  #endif // nsMapiAddressBook_h___
*** misc/mozilla/mailnews/addrbook/src/nsWabAddressBook.cpp	2001-10-30 08:59:16.000000000 +0100
--- misc/build/mozilla/mailnews/addrbook/src/nsWabAddressBook.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 47,52 ****
--- 47,68 ----
  
  #define PRINTF(args) PR_LOG(gWabAddressBookLog, PR_LOG_DEBUG, args)
  
+ enum
+ {
+     ContentsColumnEntryId = 0,
+     ContentsColumnObjectType,
+     ContentsColumnsSize
+ } ;
+ 
+ static const SizedSPropTagArray(ContentsColumnsSize, ContentsColumns) =
+ {
+     ContentsColumnsSize,
+     {
+         PR_ENTRYID,
+         PR_OBJECT_TYPE
+     }
+ } ;
+ 
  HMODULE nsWabAddressBook::mLibrary = NULL ;
  PRInt32 nsWabAddressBook::mLibUsage = 0 ;
  LPWABOPEN nsWabAddressBook::mWABOpen = NULL ;
***************
*** 95,101 ****
  MOZ_DECL_CTOR_COUNTER(nsWabAddressBook)
  
  nsWabAddressBook::nsWabAddressBook(void)
! : nsAbWinHelper()
  {
      BOOL result = Initialize() ;
  
--- 111,117 ----
  MOZ_DECL_CTOR_COUNTER(nsWabAddressBook)
  
  nsWabAddressBook::nsWabAddressBook(void)
! : nsAbWinHelper(),mAddressBook(NULL)
  {
      BOOL result = Initialize() ;
  
***************
*** 110,118 ****
      MOZ_COUNT_DTOR(nsWabAddressBook) ;
  }
  
  BOOL nsWabAddressBook::Initialize(void)
  {
-     if (mAddressBook) { return TRUE ; }
      nsAutoLock guard(mMutex) ;
  
      if (!LoadWabLibrary()) {
--- 126,379 ----
      MOZ_COUNT_DTOR(nsWabAddressBook) ;
  }
  
+ BOOL nsWabAddressBook::GetFolders(nsMapiEntryArray& aFolders)
+ {
+     aFolders.CleanUp() ;
+     nsMapiInterfaceWrapper<LPABCONT> rootFolder ;
+     nsMapiInterfaceWrapper<LPMAPITABLE> folders ;
+     ULONG objType = 0 ;
+     ULONG rowCount = 0 ;
+     SRestriction restriction ;
+     SPropTagArray folderColumns ;
+ 
+     mLastError = OpenEntry(0, NULL, NULL, 0, &objType,
+                                          rootFolder);
+     if (HR_FAILED(mLastError)){
+         PRINTF(("Cannot open root %08x.\n", mLastError));
+         return FALSE;
+     }
+     mLastError = rootFolder->GetHierarchyTable(0, folders);
+     if (HR_FAILED(mLastError)){
+         PRINTF(("Cannot get hierarchy %08x.\n", mLastError));
+         return FALSE;
+     }
+     // We only take into account modifiable containers,
+     // otherwise, we end up with all the directory services...
+     restriction.rt = RES_BITMASK ;
+     restriction.res.resBitMask.ulPropTag = PR_CONTAINER_FLAGS ;
+     restriction.res.resBitMask.relBMR = BMR_NEZ ;
+     restriction.res.resBitMask.ulMask = AB_MODIFIABLE ;
+     mLastError = folders->Restrict(&restriction, 0) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot restrict table %08x.\n", mLastError)) ;
+     }
+     folderColumns.cValues = 1 ;
+     folderColumns.aulPropTag [0] = PR_ENTRYID ;
+     mLastError = folders->SetColumns(&folderColumns, 0) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     mLastError = folders->GetRowCount(0, &rowCount) ;
+     if (HR_SUCCEEDED(mLastError)) {
+         do {
+             LPSRowSet rowSet = NULL ;
+ 
+             rowCount = 0 ;
+             mLastError = folders->QueryRows(1, 0, &rowSet) ;
+             if (HR_SUCCEEDED(mLastError)) {
+                 rowCount = rowSet->cRows ;
+                 if (rowCount > 0) {
+                     SPropValue& currentValue = rowSet->aRow->lpProps [0] ;
+                     
+                     aFolders.AddItem(currentValue.Value.bin.cb,
+                                    NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+                 }
+                 MyFreeProws(rowSet) ;
+             }
+             else {
+                 PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
+             }
+         } while (rowCount > 0) ;
+     }
+     return HR_SUCCEEDED(mLastError) ;
+ }
+ BOOL nsWabAddressBook::GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction,
+                                 nsMapiEntryArray *aList, ULONG aMapiType)
+ {
+     if (aList) { aList->CleanUp(); }
+     nsMapiInterfaceWrapper<LPMAPICONTAINER> parent ;
+     nsMapiInterfaceWrapper<LPMAPITABLE> contents ;
+     ULONG objType = 0 ;
+     ULONG rowCount = 0 ;
+ 
+     mLastError = OpenEntry(aParent.mByteCount, aParent.mEntryId,
+                                          &IID_IMAPIContainer, 0, &objType,
+                                          parent) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open parent %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     // Here, flags for WAB and MAPI could be different, so this works
+     // only as long as we don't want to use any flag in GetContentsTable
+     mLastError = parent->GetContentsTable(0, contents) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot get contents %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     if (aRestriction) {
+         mLastError = contents->Restrict(aRestriction, 0) ;
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot set restriction %08x.\n", mLastError)) ;
+             return FALSE ;
+         }
+     }
+     int entryId = ContentsColumnEntryId ;
+     int objectType = ContentsColumnObjectType ;
+ 
+     if (aRestriction) 
+     {
+         LPSPropTagArray allColumns = NULL ;
+ 
+         mLastError = contents->QueryColumns(TBL_ALL_COLUMNS, &allColumns) ;
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot query columns %08x.\n", mLastError)) ;
+             return FALSE ;
+         }
+ 
+         for (unsigned int j = 0 ; j < allColumns->cValues ; ++ j) {
+             if (allColumns->aulPropTag [j] == PR_ENTRYID) { 
+                 entryId = j ; 
+             }
+             else if (allColumns->aulPropTag [j] == PR_OBJECT_TYPE) { 
+                 objectType = j ; 
+             }
+         }
+         mLastError = contents->SetColumns(allColumns, 0) ;
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
+             return FALSE ;
+         }
+         FreeBuffer(allColumns) ;
+     }
+     else
+     {
+ 
+         mLastError = contents->SetColumns((LPSPropTagArray) &ContentsColumns, 0) ;
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot set columns %08x.\n", mLastError)) ;
+             return FALSE ;
+         }
+      }    
+     
+     mLastError = contents->GetRowCount(0, &rowCount) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot get result count %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     do {
+         LPSRowSet rowSet = NULL ;
+         
+         rowCount = 0 ;
+         mLastError = contents->QueryRows(1, 0, &rowSet) ;
+         if (HR_FAILED(mLastError)) {
+             PRINTF(("Cannot query rows %08x.\n", mLastError)) ;
+             return FALSE ;
+         }
+         rowCount = rowSet->cRows ;
+         if (rowCount > 0 &&
+             (aMapiType == 0 ||
+             rowSet->aRow->lpProps[objectType].Value.ul == aMapiType)) {
+             if (aList) {
+                 SPropValue& currentValue = rowSet->aRow->lpProps[entryId] ;
+                 
+                 aList->AddItem(currentValue.Value.bin.cb,
+                     NS_REINTERPRET_CAST(LPENTRYID, currentValue.Value.bin.lpb)) ;
+                 
+             }
+         }
+         MyFreeProws(rowSet) ;
+     } while (rowCount > 0) ;
+     return TRUE ;
+ }
+ 
+ BOOL nsWabAddressBook::GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
+                                       ULONG aNbProperties, LPSPropValue& aValue, 
+                                       ULONG& aValueCount)
+ {
+     nsMapiInterfaceWrapper<LPMAPIPROP> object ;
+     IMsgStore * mdb=NULL;
+     ULONG objType = 0 ;
+     LPSPropTagArray properties = NULL ;
+     ULONG i = 0 ;
+     
+     mLastError = OpenEntry(aObject.mByteCount, aObject.mEntryId,
+                                          &IID_IMAPIProp, 0, &objType, 
+                                          object) ;
+ 
+     if (HR_FAILED(mLastError)){
+         PRINTF(("Cannot open entry %08x.\n", mLastError));
+         return FALSE;
+     }
+     AllocateBuffer(CbNewSPropTagArray(aNbProperties),
+                    NS_REINTERPRET_CAST(void **, &properties));
+     properties->cValues = aNbProperties;
+     for (i = 0 ; i < aNbProperties ; ++ i) {
+         properties->aulPropTag [i] = aPropertyTags [i];
+     }
+     mLastError = object->GetProps(properties, 0, &aValueCount, &aValue);
+     FreeBuffer(properties);
+     if (HR_FAILED(mLastError)){
+         PRINTF(("Cannot get props %08x.\n", mLastError));
+     }
+     return HR_SUCCEEDED(mLastError) ;
+ }
+ 
+ BOOL nsWabAddressBook::SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                                       LPSPropValue& aValues)
+ {
+     nsMapiInterfaceWrapper<LPMAPIPROP> object ;
+     ULONG objType = 0 ;
+     LPSPropProblemArray problems = NULL ;
+ 
+     mLastError = OpenEntry(aObject.mByteCount, aObject.mEntryId,
+                                          &IID_IMAPIProp, MAPI_MODIFY, &objType, 
+                                          object) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot open entry %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     mLastError = object->SetProps(aNbProperties, aValues, &problems) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot update the object %08x.\n", mLastError)) ;
+         return FALSE ;
+     }
+     if (problems) {
+         for (ULONG i = 0 ; i < problems->cProblem ; ++ i) {
+             PRINTF(("Problem %d: index %d code %08x.\n", i,
+                 problems->aProblem [i].ulIndex,
+                 problems->aProblem [i].scode));
+         }
+     }
+     mLastError = object->SaveChanges(0) ;
+     if (HR_FAILED(mLastError)) {
+         PRINTF(("Cannot commit changes %08x.\n", mLastError)) ;
+     }
+     return HR_SUCCEEDED(mLastError) ;
+ }
+ 
+ BOOL nsWabAddressBook::GetDefaultContainer(nsMapiEntry& aContainer)
+ {
+     LPENTRYID entryId = NULL;
+     ULONG byteCount = 0;
+ 
+     mLastError = mAddressBook->GetPAB(&byteCount, &entryId);
+     if (HR_FAILED(mLastError)){
+         PRINTF(("Cannot get PAB %08x.\n", mLastError));
+         return FALSE;
+     }
+     aContainer.Assign(byteCount, entryId);
+     FreeBuffer(entryId) ;
+     return TRUE ;
+ }
+ 
+ BOOL nsWabAddressBook::IsOK(void)
+ {
+     return mAddressBook != NULL ;
+ }
+ 
  BOOL nsWabAddressBook::Initialize(void)
  {
      nsAutoLock guard(mMutex) ;
  
      if (!LoadWabLibrary()) {
*** misc/mozilla/mailnews/addrbook/src/nsWabAddressBook.h	2001-09-28 22:06:25.000000000 +0200
--- misc/build/mozilla/mailnews/addrbook/src/nsWabAddressBook.h	2005-07-13 17:26:54.000000000 +0200
***************
*** 47,52 ****
--- 47,61 ----
      nsWabAddressBook(void) ;
      virtual ~nsWabAddressBook(void) ;
  
+     // Get the top address books
+     virtual BOOL GetFolders(nsMapiEntryArray& aFolders);
+ 
+     // Get a default address book container
+     virtual BOOL GetDefaultContainer(nsMapiEntry& aContainer);
+     // Is the helper correctly initialised?
+     virtual BOOL IsOK(void);
+     static void FreeWabLibrary(void) ;
+ 
  protected :
      // Session and address book that will be shared by all instances
      // (see nsMapiAddressBook.h for details)
***************
*** 57,71 ****
      static HMODULE mLibrary ;
      static LPWABOPEN mWABOpen ;
  
      // Load the WAB environment
      BOOL Initialize(void) ;
      // Allocation of a buffer for transmission to interfaces
      virtual void AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer) ;
      // Destruction of a buffer provided by the interfaces
      virtual void FreeBuffer(LPVOID aBuffer) ;
      // Manage the library
      static BOOL LoadWabLibrary(void) ;
-     static void FreeWabLibrary(void) ;
  
  private :
  } ;
--- 66,111 ----
      static HMODULE mLibrary ;
      static LPWABOPEN mWABOpen ;
  
+     LPADRBOOK mAddressBook ;
+ 
      // Load the WAB environment
      BOOL Initialize(void) ;
+ 
+     virtual HRESULT OpenEntry(ULONG cbEntryID,
+                     LPENTRYID lpEntryID,
+                     LPCIID lpInterface,
+                     ULONG ulFlags,
+                     ULONG FAR * lpulObjType,
+                     LPUNKNOWN FAR * lppUnk
+                     )
+     {
+         return mAddressBook->OpenEntry(cbEntryID,
+                     lpEntryID,
+                     lpInterface,
+                     ulFlags,
+                     lpulObjType,
+                     lppUnk
+                     );
+     }
+  
+ 
+     // Retrieve the contents of a container, with an optional restriction
+     virtual BOOL GetContents(const nsMapiEntry& aParent, LPSRestriction aRestriction, 
+                      nsMapiEntryArray *aList, ULONG aMapiType) ;
+     // Retrieve the values of a set of properties on a MAPI object
+     virtual BOOL GetMAPIProperties(const nsMapiEntry& aObject, const ULONG *aPropertyTags, 
+                            ULONG aNbProperties,
+                            LPSPropValue& aValues, ULONG& aValueCount) ;
+     // Set the values of a set of properties on a MAPI object
+     virtual BOOL SetMAPIProperties(const nsMapiEntry& aObject, ULONG aNbProperties, 
+                            LPSPropValue& aValues) ;
+ 
      // Allocation of a buffer for transmission to interfaces
      virtual void AllocateBuffer(ULONG aByteCount, LPVOID *aBuffer) ;
      // Destruction of a buffer provided by the interfaces
      virtual void FreeBuffer(LPVOID aBuffer) ;
      // Manage the library
      static BOOL LoadWabLibrary(void) ;
  
  private :
  } ;
*** misc/mozilla/modules/libpref/src/Makefile.in	2004-01-16 20:22:37.000000000 +0100
--- misc/build/mozilla/modules/libpref/src/Makefile.in	2005-07-13 17:26:54.000000000 +0200
***************
*** 78,84 ****
  PREF_JS_EXPORTS	+= $(srcdir)/init/non-shared.txt
  endif
  
! EXTRA_DSO_LDOPTS = \
  		$(LIBS_DIR) \
  		$(MOZ_JS_LIBS) \
  		$(MOZ_COMPONENT_LIBS) \
--- 78,84 ----
  PREF_JS_EXPORTS	+= $(srcdir)/init/non-shared.txt
  endif
  
! EXTRA_DSO_LDOPTS += \
  		$(LIBS_DIR) \
  		$(MOZ_JS_LIBS) \
  		$(MOZ_COMPONENT_LIBS) \
***************
*** 89,91 ****
--- 89,92 ----
  GARBAGE		+= $(addprefix $(DIST)/bin/defaults/pref/, \
  			all.js mailnews.js editor.js \
  			aix.js beos.js unix.js winpref.js os2prefs.js openvms.js photon.js)
+ 
*** misc/mozilla/nsprpub/lib/ds/Makefile.in	2003-04-09 23:49:32.000000000 +0200
--- misc/build/mozilla/nsprpub/lib/ds/Makefile.in	2005-07-13 17:26:54.000000000 +0200
***************
*** 80,97 ****
  OS_LIBS = -lc
  endif
  
  ifeq ($(OS_ARCH),SunOS)
  OS_LIBS = -lc
  MAPFILE = $(OBJDIR)/pldsmap.sun
  GARBAGE += $(MAPFILE)
  ifdef NS_USE_GCC
  ifdef GCC_USE_GNU_LD
! MKSHLIB += -Wl,--version-script,$(MAPFILE)
  else
! MKSHLIB += -Wl,-M,$(MAPFILE)
  endif
  else
! MKSHLIB += -M $(MAPFILE)
  endif
  endif
  
--- 80,101 ----
  OS_LIBS = -lc
  endif
  
+ ifeq ($(OS_ARCH),Linux)
+ MKSHLIB += -Wl,-rpath,\$$ORIGIN
+ endif
+ 
  ifeq ($(OS_ARCH),SunOS)
  OS_LIBS = -lc
  MAPFILE = $(OBJDIR)/pldsmap.sun
  GARBAGE += $(MAPFILE)
  ifdef NS_USE_GCC
  ifdef GCC_USE_GNU_LD
! MKSHLIB += -Wl,--version-script,$(MAPFILE) -Wl,-rpath,\$$ORIGIN
  else
! MKSHLIB += -Wl,-M,$(MAPFILE) -Wl,-R,'$$ORIGIN'
  endif
  else
! MKSHLIB += -M $(MAPFILE) -Wl,-R,'$$ORIGIN'
  endif
  endif
  
*** misc/mozilla/nsprpub/lib/libc/src/Makefile.in	2003-04-09 23:49:35.000000000 +0200
--- misc/build/mozilla/nsprpub/lib/libc/src/Makefile.in	2005-07-13 17:26:54.000000000 +0200
***************
*** 90,107 ****
  OS_LIBS = -lc
  endif
  
  ifeq ($(OS_ARCH),SunOS)
  OS_LIBS = -lc
  MAPFILE = $(OBJDIR)/plcmap.sun
  GARBAGE += $(MAPFILE)
  ifdef NS_USE_GCC
  ifdef GCC_USE_GNU_LD
! MKSHLIB += -Wl,--version-script,$(MAPFILE)
  else
! MKSHLIB += -Wl,-M,$(MAPFILE)
  endif
  else
! MKSHLIB += -M $(MAPFILE)
  endif
  endif
  
--- 90,111 ----
  OS_LIBS = -lc
  endif
  
+ ifeq ($(OS_ARCH),Linux)
+ MKSHLIB += -Wl,-rpath,\$$ORIGIN
+ endif
+ 
  ifeq ($(OS_ARCH),SunOS)
  OS_LIBS = -lc
  MAPFILE = $(OBJDIR)/plcmap.sun
  GARBAGE += $(MAPFILE)
  ifdef NS_USE_GCC
  ifdef GCC_USE_GNU_LD
! MKSHLIB += -Wl,--version-script,$(MAPFILE) -Wl,-rpath,\$$ORIGIN
  else
! MKSHLIB += -Wl,-M,$(MAPFILE) -Wl,-R,'$$ORIGIN'
  endif
  else
! MKSHLIB += -M $(MAPFILE) -Wl,-R,'$$ORIGIN'
  endif
  endif
  
*** misc/mozilla/profile/src/nsProfile.cpp	2004-04-24 19:15:40.000000000 +0200
--- misc/build/mozilla/profile/src/nsProfile.cpp	2005-07-13 17:26:54.000000000 +0200
***************
*** 37,43 ****
--- 37,45 ----
  
  #include "nscore.h" 
  #include "nsProfile.h"
+ #ifdef MOZ_PROFILELOCKING
  #include "nsProfileLock.h"
+ #endif
  #include "nsIPrefService.h"
  #include "nsIPrefBranch.h"
  
***************
*** 499,510 ****
--- 501,514 ----
                  profileURLStr = PROFILE_MANAGER_URL; 
              if (exists)
              {
+ #ifdef MOZ_PROFILELOCKING
                  // If the profile is locked, we need the UI
                  nsCOMPtr<nsILocalFile> localFile(do_QueryInterface(curProfileDir));
                  nsProfileLock tempLock;
                  rv = tempLock.Lock(localFile);
                  if (NS_FAILED(rv))
                      profileURLStr = PROFILE_MANAGER_URL;
+ #endif
              } 
          }
          else
***************
*** 1173,1179 ****
      }
      else
          isSwitch = PR_FALSE;
!     
      nsProfileLock localLock;
      nsCOMPtr<nsILocalFile> localProfileDir(do_QueryInterface(profileDir, &rv));
      if (NS_FAILED(rv)) return rv;
--- 1177,1183 ----
      }
      else
          isSwitch = PR_FALSE;
! #ifdef MOZ_PROFILELOCKING    
      nsProfileLock localLock;
      nsCOMPtr<nsILocalFile> localProfileDir(do_QueryInterface(profileDir, &rv));
      if (NS_FAILED(rv)) return rv;
***************
*** 1183,1189 ****
          NS_ERROR("Could not get profile directory lock.");
          return rv;
      }
! 
      nsCOMPtr<nsIObserverService> observerService = 
               do_GetService("@mozilla.org/observer-service;1", &rv);
      NS_ENSURE_TRUE(observerService, NS_ERROR_FAILURE);
--- 1187,1193 ----
          NS_ERROR("Could not get profile directory lock.");
          return rv;
      }
! #endif
      nsCOMPtr<nsIObserverService> observerService = 
               do_GetService("@mozilla.org/observer-service;1", &rv);
      NS_ENSURE_TRUE(observerService, NS_ERROR_FAILURE);
***************
*** 1237,1244 ****
--- 1241,1250 ----
          UpdateCurrentProfileModTime(PR_FALSE);        
      }
  
+ #ifdef MOZ_PROFILELOCKING    
      // Do the profile switch
      localLock.Unlock(); // gDirServiceProvider will get and hold its own lock
+ #endif
      gDirServiceProvider->SetProfileDir(profileDir);  
      mCurrentProfileName.Assign(aCurrentProfile);    
      gProfileDataAccess->SetCurrentProfile(aCurrentProfile);
*** misc/mozilla/security/coreconf/command.mk	2002-02-15 23:53:12.000000000 +0100
--- misc/build/mozilla/security/coreconf/command.mk	2005-07-13 17:26:54.000000000 +0200
***************
*** 42,48 ****
  LINK_DLL      = $(LINK) $(OS_DLLFLAGS) $(DLLFLAGS)
  LINK_EXE      = $(LINK) $(OS_LFLAGS) $(LFLAGS)
  NFSPWD        = $(NSINSTALL_DIR)/nfspwd
! CFLAGS        = $(OPTIMIZER) $(OS_CFLAGS) $(XP_DEFINE) $(DEFINES) $(INCLUDES) \
  		$(XCFLAGS)
  RANLIB        = echo
  TAR           = /bin/tar
--- 42,48 ----
  LINK_DLL      = $(LINK) $(OS_DLLFLAGS) $(DLLFLAGS)
  LINK_EXE      = $(LINK) $(OS_LFLAGS) $(LFLAGS)
  NFSPWD        = $(NSINSTALL_DIR)/nfspwd
! CFLAGS        += $(OPTIMIZER) $(OS_CFLAGS) $(XP_DEFINE) $(DEFINES) $(INCLUDES) \
  		$(XCFLAGS)
  RANLIB        = echo
  TAR           = /bin/tar
*** misc/mozilla/security/coreconf/Linux2.1.mk	2001-11-07 21:58:09.000000000 +0100
--- misc/build/mozilla/security/coreconf/Linux2.1.mk	2005-07-13 17:26:54.000000000 +0200
***************
*** 36,42 ****
  include $(CORE_DEPTH)/coreconf/Linux.mk
  ifeq ($(OS_RELEASE),2.1)
          OS_REL_CFLAGS   += -DLINUX2_1
!         MKSHLIB         = $(CC) -shared -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
          ifdef BUILD_OPT
                  OPTIMIZER       = -O2
          endif
--- 36,42 ----
  include $(CORE_DEPTH)/coreconf/Linux.mk
  ifeq ($(OS_RELEASE),2.1)
          OS_REL_CFLAGS   += -DLINUX2_1
!         MKSHLIB         = $(CC) $(DSO_LDOPTS) -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
          ifdef BUILD_OPT
                  OPTIMIZER       = -O2
          endif
*** misc/mozilla/security/coreconf/Linux2.2.mk	2001-11-07 21:56:18.000000000 +0100
--- misc/build/mozilla/security/coreconf/Linux2.2.mk	2005-07-13 17:26:54.000000000 +0200
***************
*** 36,42 ****
  include $(CORE_DEPTH)/coreconf/Linux.mk
  
  OS_REL_CFLAGS   += -DLINUX2_1
! MKSHLIB         = $(CC) -shared -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  ifdef BUILD_OPT
              OPTIMIZER       = -O2
  endif
--- 36,42 ----
  include $(CORE_DEPTH)/coreconf/Linux.mk
  
  OS_REL_CFLAGS   += -DLINUX2_1
! MKSHLIB         = $(CC) $(DSO_LDOPTS) -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  ifdef BUILD_OPT
              OPTIMIZER       = -O2
  endif
*** misc/mozilla/security/coreconf/Linux2.4.mk	2001-11-07 21:56:18.000000000 +0100
--- misc/build/mozilla/security/coreconf/Linux2.4.mk	2005-07-13 17:26:54.000000000 +0200
***************
*** 36,42 ****
  include $(CORE_DEPTH)/coreconf/Linux.mk
  
  OS_REL_CFLAGS   += -DLINUX2_1
! MKSHLIB         = $(CC) -shared -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  ifdef BUILD_OPT
              OPTIMIZER       = -O2
  endif
--- 36,42 ----
  include $(CORE_DEPTH)/coreconf/Linux.mk
  
  OS_REL_CFLAGS   += -DLINUX2_1
! MKSHLIB         = $(CC) $(DSO_LDOPTS) -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  ifdef BUILD_OPT
              OPTIMIZER       = -O2
  endif
*** misc/mozilla/security/coreconf/Linux2.5.mk	2002-01-27 01:45:37.000000000 +0100
--- misc/build/mozilla/security/coreconf/Linux2.5.mk	2005-07-13 17:26:54.000000000 +0200
***************
*** 36,42 ****
  include $(CORE_DEPTH)/coreconf/Linux.mk
  
  OS_REL_CFLAGS   += -DLINUX2_1
! MKSHLIB         = $(CC) -shared -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  ifdef BUILD_OPT
              OPTIMIZER       = -O2
  endif
--- 36,42 ----
  include $(CORE_DEPTH)/coreconf/Linux.mk
  
  OS_REL_CFLAGS   += -DLINUX2_1
! MKSHLIB         = $(CC) $(DSO_LDOPTS) -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  ifdef BUILD_OPT
              OPTIMIZER       = -O2
  endif
*** misc/mozilla/security/coreconf/Linux2.6.mk	2003-07-19 23:21:50.000000000 +0200
--- misc/build/mozilla/security/coreconf/Linux2.6.mk	2005-07-13 17:26:54.000000000 +0200
***************
*** 36,42 ****
  include $(CORE_DEPTH)/coreconf/Linux.mk
  
  OS_REL_CFLAGS   += -DLINUX2_1
! MKSHLIB         = $(CC) -shared -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  ifdef BUILD_OPT
              OPTIMIZER       = -O2
  endif
--- 36,42 ----
  include $(CORE_DEPTH)/coreconf/Linux.mk
  
  OS_REL_CFLAGS   += -DLINUX2_1
! MKSHLIB         = $(CC) $(DSO_LDOPTS) -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  ifdef BUILD_OPT
              OPTIMIZER       = -O2
  endif
*** misc/mozilla/security/coreconf/Linux.mk	2004-02-11 03:33:51.000000000 +0100
--- misc/build/mozilla/security/coreconf/Linux.mk	2005-07-13 17:26:54.000000000 +0200
***************
*** 123,129 ****
  
  ifeq ($(OS_RELEASE),2.0)
  	OS_REL_CFLAGS	+= -DLINUX2_0
! 	MKSHLIB		= $(CC) -shared -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  	ifdef BUILD_OPT
  		OPTIMIZER	= -O2
  	endif
--- 123,129 ----
  
  ifeq ($(OS_RELEASE),2.0)
  	OS_REL_CFLAGS	+= -DLINUX2_0
! 	MKSHLIB		= $(CC) $(DSO_LDOPTS) -Wl,-soname -Wl,$(@:$(OBJDIR)/%.so=%.so)
  	ifdef BUILD_OPT
  		OPTIMIZER	= -O2
  	endif
***************
*** 149,154 ****
--- 149,155 ----
  
  DSO_CFLAGS		= -fPIC
  DSO_LDOPTS		= -shared
+ DSO_LDOPTS		+= -Wl,-rpath,\$$ORIGIN
  DSO_LDFLAGS		=
  
  # INCLUDES += -I/usr/include -Y/usr/include/linux
*** misc/mozilla/security/coreconf/SunOS5.mk	2004-10-16 01:52:29.000000000 +0200
--- misc/build/mozilla/security/coreconf/SunOS5.mk	2005-07-13 17:26:54.000000000 +0200
***************
*** 164,175 ****
--- 164,177 ----
  
  # ld options:
  # -G: produce a shared object
+ # -R '$ORIGIN': search for dependencies in same directory
  # -z defs: no unresolved symbols allowed
  ifdef NS_USE_GCC
  ifeq ($(USE_64), 1)
  	DSO_LDOPTS += -m64
  endif
  	DSO_LDOPTS += -shared -h $(notdir $@)
+     DSO_LDOPTS += -Wl,-rpath,\$$ORIGIN
  else
  ifeq ($(USE_64), 1)
  	ifeq ($(OS_TEST),i86pc)
***************
*** 179,184 ****
--- 181,187 ----
  	endif
  endif
  	DSO_LDOPTS += -G -h $(notdir $@)
+     DSO_LDOPTS += -R '\$$ORIGIN'
  endif
  
  # -KPIC generates position independent code for use in shared libraries.
*** misc/mozilla/security/nss/lib/ckfw/builtins/config.mk	2004-10-16 01:52:32.000000000 +0200
--- misc/build/mozilla/security/nss/lib/ckfw/builtins/config.mk	2005-07-13 17:26:54.000000000 +0200
***************
*** 59,67 ****
  DSO_LDOPTS = -bundle
  endif
  
- ifeq ($(OS_TARGET),SunOS)
- # The -R '$ORIGIN' linker option instructs this library to search for its
- # dependencies in the same directory where it resides.
- MKSHLIB += -R '$$ORIGIN'
- endif
  
--- 59,62 ----
*** misc/mozilla/security/nss/lib/freebl/Makefile	2004-10-16 01:52:33.000000000 +0200
--- misc/build/mozilla/security/nss/lib/freebl/Makefile	2005-07-13 17:26:54.000000000 +0200
***************
*** 179,189 ****
  
  # Note: -xarch=v8 or v9 is now done in coreconf
  ifeq ($(OS_TARGET),SunOS)
- 
- # The -R '$ORIGIN' linker option instructs this library to search for its
- # dependencies in the same directory where it resides.
- MKSHLIB += -R '$$ORIGIN'
- 
  ifeq ($(CPU_ARCH),sparc)
  ifndef NS_USE_GCC
  ifdef USE_HYBRID
--- 179,184 ----
***************
*** 199,205 ****
  MKSHLIB += -Wl,-B,symbolic,-z,defs,-z,now,-z,text,-M,mapfile.Solaris
  endif # GCC_USE_GNU_LD
  else
! MKSHLIB += -B symbolic -z defs -z now -z text -M mapfile.Solaris
  endif # NS_USE_GCC
  ifdef USE_PURE_32
  # this builds for Sparc v8 pure 32-bit architecture
--- 194,200 ----
  MKSHLIB += -Wl,-B,symbolic,-z,defs,-z,now,-z,text,-M,mapfile.Solaris
  endif # GCC_USE_GNU_LD
  else
! MKSHLIB += -z defs -z now -z text -M mapfile.Solaris
  endif # NS_USE_GCC
  ifdef USE_PURE_32
  # this builds for Sparc v8 pure 32-bit architecture
*** misc/mozilla/security/nss/lib/nss/config.mk	2004-10-16 01:52:33.000000000 +0200
--- misc/build/mozilla/security/nss/lib/nss/config.mk	2005-07-13 17:26:54.000000000 +0200
***************
*** 107,120 ****
  # The -R '$ORIGIN' linker option instructs this library to search for its
  # dependencies in the same directory where it resides.
  ifeq ($(USE_64), 1)
! MKSHLIB += -R '$$ORIGIN:/usr/lib/mps/secv1/sparcv9:/usr/lib/mps/sparcv9'
  else
! MKSHLIB += -R '$$ORIGIN:/usr/lib/mps/secv1:/usr/lib/mps'
! endif
! else
! MKSHLIB += -R '$$ORIGIN'
! endif
! endif
  
  
  ifeq (,$(filter-out WINNT WIN95,$(OS_TARGET)))
--- 107,118 ----
  # The -R '$ORIGIN' linker option instructs this library to search for its
  # dependencies in the same directory where it resides.
  ifeq ($(USE_64), 1)
! DSO_LDOPTS += -R /usr/lib/mps/secv1/sparcv9:/usr/lib/mps/sparcv9
  else
! DSO_LDOPTS += -R /usr/lib/mps/secv1:/usr/lib/mps
! endif # USE_64
! endif # BUILD_SUN_PKG
! endif # SunOS
  
  
  ifeq (,$(filter-out WINNT WIN95,$(OS_TARGET)))
*** misc/mozilla/security/nss/lib/nss/nss.def	2004-10-16 01:52:33.000000000 +0200
--- misc/build/mozilla/security/nss/lib/nss/nss.def	2005-07-13 17:26:54.000000000 +0200
***************
*** 60,65 ****
--- 60,66 ----
  CERT_CheckCertValidTimes;
  CERT_CreateCertificateRequest;
  CERT_ChangeCertTrust;
+ CERT_DecodeDERCertificate;
  CERT_DecodeDERCrl;
  CERT_DestroyCertificateRequest;
  CERT_DestroyCertList;
*** misc/mozilla/security/nss/lib/smime/config.mk	2004-10-16 01:52:34.000000000 +0200
--- misc/build/mozilla/security/nss/lib/smime/config.mk	2005-07-13 17:26:54.000000000 +0200
***************
*** 85,94 ****
  	../pkcs12 \
  	../pkcs7 \
  	$(NULL)
- 
- ifeq ($(OS_TARGET),SunOS)
- # The -R '$ORIGIN' linker option instructs this library to search for its
- # dependencies in the same directory where it resides.
- MKSHLIB += -R '$$ORIGIN'
- endif
- 
--- 85,87 ----
*** misc/mozilla/security/nss/lib/softoken/config.mk	2004-10-16 01:52:35.000000000 +0200
--- misc/build/mozilla/security/nss/lib/softoken/config.mk	2005-07-13 17:26:54.000000000 +0200
***************
*** 83,94 ****
  	$(NULL)
  endif
  
- ifeq ($(OS_TARGET),SunOS)
- # The -R '$ORIGIN' linker option instructs this library to search for its
- # dependencies in the same directory where it resides.
- MKSHLIB += -R '$$ORIGIN'
- endif
- 
  ifeq ($(OS_TARGET),WINCE)
  DEFINES += -DDBM_USING_NSPR
  endif
--- 83,88 ----
*** misc/mozilla/security/nss/lib/ssl/config.mk	2004-10-16 01:52:35.000000000 +0200
--- misc/build/mozilla/security/nss/lib/ssl/config.mk	2005-07-13 17:26:54.000000000 +0200
***************
*** 78,87 ****
  EXTRA_SHARED_LIBS += -dylib_file @executable_path/libsoftokn3.dylib:$(DIST)/lib/libsoftokn3.dylib
  endif
  
- ifeq ($(OS_TARGET),SunOS)
- # The -R '$ORIGIN' linker option instructs this library to search for its
- # dependencies in the same directory where it resides.
- MKSHLIB += -R '$$ORIGIN'
- endif
- 
  endif
--- 78,81 ----
*** misc/mozilla/xpfe/bootstrap/Makefile.in	2004-06-24 20:58:48.000000000 +0200
--- misc/build/mozilla/xpfe/bootstrap/Makefile.in	2005-07-14 12:34:56.000000000 +0200
***************
*** 84,94 ****
--- 84,97 ----
  
  include $(topsrcdir)/config/config.mk
  
+ # reduce prerequisites by disabling mozilla binary
+ ifndef DISABLE_MOZ_EXECUTABLE
  ifeq ($(USE_SHORT_LIBNAME),1)
  PROGRAM		= mozilla$(BIN_SUFFIX)
  else
  PROGRAM		= mozilla-bin$(BIN_SUFFIX)
  endif
+ endif
  
  # Force applications to be built non-statically
  # when building the mozcomps meta component
