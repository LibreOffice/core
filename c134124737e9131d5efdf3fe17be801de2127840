{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "65ef2a5f_67ca8304",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000789
      },
      "writtenOn": "2022-07-27T10:26:54Z",
      "side": 1,
      "message": "Looks reasonable in general:\nJust wondering: Are there valid scenarios where the functions are called with invalid values in the first place?\nOtherwise, would it make sense to instead (or in addition) assert when that \"unknown\" code path is triggered?\n\nI just looked a little closer at `AccessibilityTools::getRelationTypeName`: Values are initialized to -1 in `AccessibleRelationSet::contents_flows_to_and_from`, but it looks to me like that could just as well use AccessibleRelationType::INVALID instead of -1.",
      "revId": "c134124737e9131d5efdf3fe17be801de2127840",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ebbe8b7a_9d81cf4f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001582
      },
      "writtenOn": "2022-07-27T10:43:43Z",
      "side": 1,
      "message": "\u003e Just wondering: Are there valid scenarios where the functions are called with invalid values in the first place?\n\u003e Otherwise, would it make sense to instead (or in addition) assert when that \"unknown\" code path is triggered?\n\nMy reasoning was more that as these name mappings are not automatically generated at build time (which they possibly should), they could possibly get out of sync and we\u0027d be better off with more info than less.\nBut then maybe asserting is indeed a good idea as it could catch that case as well, although indirectly.\n\n\u003e I just looked a little closer at `AccessibilityTools::getRelationTypeName`: Values are initialized to -1 in `AccessibleRelationSet::contents_flows_to_and_from`, but it looks to me like that could just as well use AccessibleRelationType::INVALID instead of -1.\n\nThey could, but I\u0027m not sure if they should: API-wise there is nothing preventing a relation actually being set to INVALID (although I fail to see the use), so using a value outside the actual range allows to discriminate the case where it is not set, and where it is set to INVALID.  It\u0027s kind of abusing `AccessibilityTools::getRelationTypeName()` (and the fact it\u0027s basically an enum, just presented as separate values) indeed though, and for the test itself it\u0027d be the same.\n\nSo I\u0027m actually not entirely sure what\u0027s best, and I\u0027d be happy to go either direction if you have an opinion on this.",
      "parentUuid": "65ef2a5f_67ca8304",
      "revId": "c134124737e9131d5efdf3fe17be801de2127840",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64a054a6_3d7202d8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000789
      },
      "writtenOn": "2022-07-27T12:05:47Z",
      "side": 1,
      "message": "\u003e My reasoning was more that as these name mappings are not automatically generated at build time (which they possibly should), they could possibly get out of sync and we\u0027d be better off with more info than less.\n\u003e But then maybe asserting is indeed a good idea as it could catch that case as well, although indirectly.\n\nThat also sounds, reasonable, I don\u0027t have a strong opinion here either way. (I\u0027d personally go with asserts at least in non-test code, so it just fails and it becomes clear that something needs to be handled at this place if new constants etc. are added later, or it\u0027s clear where invalid values are passed, so what caller needs to be observed further,... Probably it doesn\u0027t make much of a difference for the tests, since the test already fails if something goes wrong anyway and it\u0027s clear this needs to be looked into.)\n\n\u003e They could, but I\u0027m not sure if they should: API-wise there is nothing preventing a relation actually being set to INVALID (although I fail to see the use), so using a value outside the actual range allows to discriminate the case where it is not set, and where it is set to INVALID.  It\u0027s kind of abusing AccessibilityTools::getRelationTypeName()  (and the fact it\u0027s basically an enum, just presented as separate values) indeed though, and for the test itself it\u0027d be the same.\n\nTrue. I\u0027d personally tend to lean towards the \"Logically, this is like an enum class.\" argument (and I also don\u0027t so far see any real use case where we\u0027d want INVALID for a real relation), but don\u0027t have a strong opinion here either.\n\n\u003e So I\u0027m actually not entirely sure what\u0027s best, and I\u0027d be happy to go either direction if you have an opinion on this.\n\nSimilar here, no strong opinion either way, just some thoughts I had. Please feel free to choose whatever you prefer. ðŸ˜Š",
      "parentUuid": "ebbe8b7a_9d81cf4f",
      "revId": "c134124737e9131d5efdf3fe17be801de2127840",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b7d0dc54_87afb779",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001582
      },
      "writtenOn": "2022-07-27T14:38:45Z",
      "side": 1,
      "message": "\u003e (I\u0027d personally go with asserts at least in non-test code, so it just fails and it becomes clear that something needs to be handled at this place if new constants etc. are added later, or it\u0027s clear where invalid values are passed, so what caller needs to be observed further,... Probably it doesn\u0027t make much of a difference for the tests, since the test already fails if something goes wrong anyway and it\u0027s clear this needs to be looked into.)\n\nOK I think I\u0027d just keep it like this for now.  I could do something like\n static OUString unknownName(std::string_view name, const sal_Int64 value)\n {\n     CPPUNIT_ASSERT_MESSAGE(OString(OString::number(value) + \" is not a valid \" + name).getStr(),\n                            false);\n     return \"unknown (\" + OUString::number(value) + \")\";\n }\n\nbut somehow I\u0027m not particularly fond of it.  If you like it, I\u0027ll add it because it\u0027s not bad per se, but I\u0027m not particularly sure a cppunit assert makes much sense here, and a plain assert() won\u0027t convey what the value actually was, which is inconvenient.\n\n\u003e \u003e They could, but I\u0027m not sure if they should: API-wise there is nothing preventing a relation actually being set to INVALID (although I fail to see the use), so using a value outside the actual range allows to discriminate the case where it is not set, and where it is set to INVALID.  It\u0027s kind of abusing AccessibilityTools::getRelationTypeName()  (and the fact it\u0027s basically an enum, just presented as separate values) indeed though, and for the test itself it\u0027d be the same.\n\u003e \n\u003e True. I\u0027d personally tend to lean towards the \"Logically, this is like an enum class.\" argument (and I also don\u0027t so far see any real use case where we\u0027d want INVALID for a real relation), but don\u0027t have a strong opinion here either.\n\nOK so I went ahead and submitted https://gerrit.libreoffice.org/c/core/+/137505 to fix this particular issue (but you already saw that, as I was slow to tackle this one ðŸ˜Š).  And FWIW code before my usage of `AccessibilityTools::getRelationTypeName()` would have crashed (hopefullyâ€¦) indexing an array at `-1` if those relations were not actually populated, so it\u0027s probably better whether using INVALID or -1 anyway.",
      "parentUuid": "64a054a6_3d7202d8",
      "revId": "c134124737e9131d5efdf3fe17be801de2127840",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f8e284f5_3e0870fc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000789
      },
      "writtenOn": "2022-07-27T15:34:55Z",
      "side": 1,
      "message": "\u003e OK I think I\u0027d just keep it like this for now. (...)\n\nFine.\n\n\u003e OK so I went ahead and submitted https://gerrit.libreoffice.org/c/core/+/137505 to fix this particular issue (...)\n\nThanks again. ðŸ˜Š",
      "parentUuid": "b7d0dc54_87afb779",
      "revId": "c134124737e9131d5efdf3fe17be801de2127840",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    }
  ]
}