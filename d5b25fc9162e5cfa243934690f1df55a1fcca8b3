{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0b5abdab_fca38691",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000994
      },
      "writtenOn": "2021-10-22T06:28:47Z",
      "side": 1,
      "message": "By the way: I think that generally, your change is going into the right direction, and it should be not export-time change, but something executed at format application stage.",
      "revId": "d5b25fc9162e5cfa243934690f1df55a1fcca8b3",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7303ff8e_4647925e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000804
      },
      "writtenOn": "2021-10-22T08:46:27Z",
      "side": 1,
      "message": "Thanks for taking the time to look at this Mike.",
      "revId": "d5b25fc9162e5cfa243934690f1df55a1fcca8b3",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d126c1f8_39f47e80",
        "filename": "svl/source/numbers/zforlist.cxx",
        "patchSetId": 3
      },
      "lineNbr": 3356,
      "author": {
        "id": 1000994
      },
      "writtenOn": "2021-10-22T06:26:21Z",
      "side": 1,
      "message": "I am not sure if my concern is justified, but please consider creating some \"impl\" without the locking (for use in properly locked IsUserDefined variants). I suggest this because I\u0027m afraid that this code might be used in busy loops, so if nested locking has measurable overhead, we better avoid it - so SvNumberFormatter::IsUserDefined(std::u16string_view, LanguageType) does not execute locking twice.",
      "revId": "d5b25fc9162e5cfa243934690f1df55a1fcca8b3",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "11a80a8e_dbfdacb4",
        "filename": "svl/source/numbers/zforlist.cxx",
        "patchSetId": 3
      },
      "lineNbr": 3356,
      "author": {
        "id": 1000804
      },
      "writtenOn": "2021-10-22T08:46:27Z",
      "side": 1,
      "message": "I was a bit concerned about that myself - but I also didn\u0027t know. In that case not changing the original function seems the best - and just duplicating the small two lines that are the same.",
      "parentUuid": "d126c1f8_39f47e80",
      "revId": "d5b25fc9162e5cfa243934690f1df55a1fcca8b3",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "69127979_aa899533",
        "filename": "sw/source/core/table/swtable.cxx",
        "patchSetId": 3
      },
      "lineNbr": 2345,
      "author": {
        "id": 1000994
      },
      "writtenOn": "2021-10-22T06:26:21Z",
      "side": 1,
      "message": "Do I understand it correctly, that this check relies on the previous *format*, not on *content*? (I might misread, please excuse if I do.)\n\nIf I\u0027m correct, then I\u0027m afraid this is not quite OK: this would disallow to change text to any numeric format other than user-defined format. I suppose that we should decide on by-cell *value* basis, considering if the value could be parsed as number (taking the new format into consideration), and reject the application of the new format *cell-by-cell* based on that test. So that one could change text \"123\" to number, but not \"abc\" to number.\n\nWhat do you think?",
      "revId": "d5b25fc9162e5cfa243934690f1df55a1fcca8b3",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66817fc9_06869cad",
        "filename": "sw/source/core/table/swtable.cxx",
        "patchSetId": 3
      },
      "lineNbr": 2345,
      "author": {
        "id": 1000804
      },
      "writtenOn": "2021-10-22T08:46:27Z",
      "side": 1,
      "message": "It relies on BOTH previous format and current content. The bIsNumFormat clause just above this code change has already evaluated the content to see if it can be classified as a number. So the only time we even reach this block is when a new format specifies a number format, and the content doesn\u0027t fit that classification.\n\nWhat I have here should be correct.  I am checking if there is content (bChgText), that the format was previously text format, and the new number format (which by definition is number at this point in the code) is not a user-defined function - which could be intending to do anything as suggested by Eike\u0027s comments in the code block above.\n\nSo what this will do is prevent ANY attempt to set a built-in number format on existing content THAT IS NOT CONSIDERED TO BE A NUMBER. (Yes, that is rather heavy handed.)\n\nBecause every user-defined format is considered a number, I thought I had better make an exception for brain-powered, exotic formatting attempts.",
      "parentUuid": "69127979_aa899533",
      "revId": "d5b25fc9162e5cfa243934690f1df55a1fcca8b3",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    }
  ]
}