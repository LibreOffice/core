// autogenerated file with codegen.pl

#include <math.h>
#include <stdio.h>

#include <algorithm> // STL

#include <cppunit/simpleheader.hxx>
#include "stringhelper.hxx"
#include "valueequal.hxx"

namespace rtl_OUString
{


class valueOf : public CppUnit::TestFixture
{
    void valueOf_float_test_impl(float _nValue)
        {
            rtl::OUString suValue;
            suValue = rtl::OUString::valueOf( _nValue );
            rtl::OString sValue;
            sValue <<= suValue;
            printf("# nFloat := %.9f  sValue := %s\n", _nValue, sValue.getStr());

            float nValueATOF = atof( sValue.getStr() );

            bool bEqualResult = is_float_equal(_nValue, nValueATOF);
            CPPUNIT_ASSERT_MESSAGE("Values are not equal.", bEqualResult == true);
        }

    void valueOf_float_test(float _nValue)
        {
            valueOf_float_test_impl(_nValue);

            // test also the negative part.
            float nNegativeValue = -_nValue;
            valueOf_float_test_impl(nNegativeValue);
        }

public:
    // initialise your test code values here.
    void setUp()
    {
    }

    void tearDown()
    {
    }

    // insert your test code here.
    void valueOf_float_test_001()
    {
        // this is demonstration code
        // CPPUNIT_ASSERT_MESSAGE("a message", 1 == 1);
        float nValue = 3.0f;
        valueOf_float_test(nValue);
    }

    void valueOf_float_test_002()
    {
        float nValue = 3.5f;
        valueOf_float_test(nValue);
    }

    void valueOf_float_test_003()
    {
        float nValue = 3.0625f;
        valueOf_float_test(nValue);
    }

    void valueOf_float_test_004()
    {
        float nValue = 3.502525f;
        valueOf_float_test(nValue);
    }

    void valueOf_float_test_005()
    {
        float nValue = 3.141592f;
        valueOf_float_test(nValue);
    }

    void valueOf_float_test_006()
    {
        float nValue = 3.5025255f;
        valueOf_float_test(nValue);
    }

    void valueOf_float_test_007()
    {
        float nValue = 3.0039062f;
        valueOf_float_test(nValue);
    }

private:

    void valueOf_double_test_impl(double _nValue)
        {
            rtl::OUString suValue;
            suValue = rtl::OUString::valueOf( _nValue );
            rtl::OString sValue;
            sValue <<= suValue;
            printf("# nDouble := %.20f  sValue := %s\n", _nValue, sValue.getStr());

            double nValueATOF = atof( sValue.getStr() );

            bool bEqualResult = is_double_equal(_nValue, nValueATOF);
            CPPUNIT_ASSERT_MESSAGE("Values are not equal.", bEqualResult == true);
        }

    void valueOf_double_test(double _nValue)
        {
            valueOf_double_test_impl(_nValue);

            // test also the negative part.
            double nNegativeValue = -_nValue;
            valueOf_double_test_impl(nNegativeValue);
        }
public:

    // valueOf double
    void valueOf_double_test_001()
        {
            double nValue = 3.0;
            valueOf_double_test(nValue);
        }
    void valueOf_double_test_002()
        {
            double nValue = 3.5;
            valueOf_double_test(nValue);
        }
    void valueOf_double_test_003()
        {
            double nValue = 3.0625;
            valueOf_double_test(nValue);
        }
    void valueOf_double_test_004()
        {
            double nValue = 3.1415926535;
            valueOf_double_test(nValue);
        }
    void valueOf_double_test_005()
        {
            double nValue = 3.141592653589793;
            valueOf_double_test(nValue);
        }
    void valueOf_double_test_006()
        {
            double nValue = 3.1415926535897932;
            valueOf_double_test(nValue);
        }
    void valueOf_double_test_007()
        {
            double nValue = 3.14159265358979323;
            valueOf_double_test(nValue);
        }
    void valueOf_double_test_008()
        {
            double nValue = 3.141592653589793238462643;
            valueOf_double_test(nValue);
        }


    // Change the following lines only, if you add, remove or rename
    // member functions of the current class,
    // because these macros are need by auto register mechanism.

    CPPUNIT_TEST_SUITE(valueOf);
    CPPUNIT_TEST(valueOf_float_test_001);
    CPPUNIT_TEST(valueOf_float_test_002);
    CPPUNIT_TEST(valueOf_float_test_003);
    CPPUNIT_TEST(valueOf_float_test_004);
    CPPUNIT_TEST(valueOf_float_test_005);
    CPPUNIT_TEST(valueOf_float_test_006);
    CPPUNIT_TEST(valueOf_float_test_007);

    CPPUNIT_TEST(valueOf_double_test_001);
    CPPUNIT_TEST(valueOf_double_test_002);
    CPPUNIT_TEST(valueOf_double_test_003);
    CPPUNIT_TEST(valueOf_double_test_004);
    CPPUNIT_TEST(valueOf_double_test_005);
    CPPUNIT_TEST(valueOf_double_test_006);
    CPPUNIT_TEST(valueOf_double_test_007);
    CPPUNIT_TEST(valueOf_double_test_008);
    CPPUNIT_TEST_SUITE_END();
}; // class valueOf

//------------------------------------------------------------------------
// testing the method toDouble()
//------------------------------------------------------------------------
template<class T>
sal_Int16 SAL_CALL checkPrecisionSize()
{
    sal_Int16 nSize = sizeof(T);
    volatile T nCalcValue = 1.0;


    // (i + 1) is the current precision
    // numerical series
    // 1.1
    // 10.1
    // 100.1
    // ...
    // 1000...0.1

    sal_Int16 i = 0;
    for (i=0;i<50;i++)
    {
        nCalcValue *= 10;
        volatile T nValue = nCalcValue + 0.1;
        volatile T dSub = nValue - nCalcValue;
        // ----- 0.11 ---- 0.1 ---- 0.09 -----
        if (0.11 > dSub && dSub < 0.09)
        {
            // due to the fact, that the value is break down we sub 1 from the precision value
            // but to suppress this, we start at zero, precision is i+1 till here --i;
            break;
        }
    }

    sal_Int16 j= 0;
    nCalcValue = 1.0;

    // numerical series
    // 1.1
    // 1.01
    // 1.001
    // ...
    // 1.000...001

    for (j=0;j<50;j++)
    {
        nCalcValue /= 10;
        volatile T nValue = nCalcValue + 1.0;
        volatile T dSub = nValue - 1.0;
        // ---- 0.02 ----- 0.01 ---- 0 --- -0.99 ---- -0.98 ----
        volatile T dSubAbsolut = fabs(dSub);
        // ---- 0.02 ----- 0.01 ---- 0 (cut)
        if ( dSub == 0)
            break;
    }
    if (i != j)
    {
            // hmmm....
            // imho i +- 1 == j is a good value
            int n = i - j;
            if (n < 0) n = -n;
            if (n <= 1)
            {
                return std::min(i,j);
            }
            else
            {
                printf("# warning: presision differs more than 1!\n");
            }
        }

    return i;
}

// -----------------------------------------------------------------------------

    class testPrecision
    {
    public:
        testPrecision()
            {
                sal_Int16 nPrecision;
                nPrecision = checkPrecisionSize<float>();
                printf("# precision of float: %d sizeof()=%d \n", nPrecision, sizeof(float));

                nPrecision = checkPrecisionSize<double>();
                printf("# precision of double: %d sizeof()=%d \n", nPrecision, sizeof(double));

                nPrecision = checkPrecisionSize<long double>();
                printf("# precision of long double: %d sizeof()=%d \n", nPrecision, sizeof(long double));

            }

    };


// -----------------------------------------------------------------------------
// - toDouble (tests)
// -----------------------------------------------------------------------------
    class toDouble : public CppUnit::TestFixture
    {

    public:

        toDouble()
            {
                // testPrecision a;
            }



        // initialise your test code values here.
        void setUp()
            {
            }

        void tearDown()
            {
            }

        void toDouble_test_impl(rtl::OString const& _sValue)
            {
                double nValueATOF = atof( _sValue.getStr() );

                rtl::OUString suValue = rtl::OUString::createFromAscii( _sValue.getStr() );
                double nValueToDouble = suValue.toDouble();

                bool bEqualResult = is_double_equal(nValueToDouble, nValueATOF);
                CPPUNIT_ASSERT_MESSAGE("Values are not equal.", bEqualResult == true);
            }

        void toDouble_test(rtl::OString const& _sValue)
            {
                toDouble_test_impl(_sValue);

                // test also the negativ part.
                rtl::OString sNegativValue("-");
                sNegativValue += _sValue;
                toDouble_test_impl(sNegativValue);
            }

        // insert your test code here.
        void toDouble_selftest()
            {
                printf("# Start selftest:\n");
                CPPUNIT_ASSERT (is_double_equal(1.0, 1.01) == false);
                CPPUNIT_ASSERT (is_double_equal(1.0, 1.001) == false);
                CPPUNIT_ASSERT (is_double_equal(1.0, 1.0001) == false);
                CPPUNIT_ASSERT (is_double_equal(1.0, 1.00001) == false);
                CPPUNIT_ASSERT (is_double_equal(1.0, 1.000001) == false);
                CPPUNIT_ASSERT (is_double_equal(1.0, 1.0000001) == false);
                CPPUNIT_ASSERT (is_double_equal(1.0, 1.00000001) == false);
                CPPUNIT_ASSERT (is_double_equal(1.0, 1.000000001) == false);
                CPPUNIT_ASSERT (is_double_equal(1.0, 1.0000000001) == false);
                CPPUNIT_ASSERT (is_double_equal(1.0, 1.00000000001) == false);
                CPPUNIT_ASSERT (is_double_equal(1.0, 1.000000000001) == false);
                CPPUNIT_ASSERT (is_double_equal(1.0, 1.0000000000001) == false);
                // we check til 15 values after comma
                CPPUNIT_ASSERT (is_double_equal(1.0, 1.00000000000001) == true);
                CPPUNIT_ASSERT (is_double_equal(1.0, 1.000000000000001) == true);
                CPPUNIT_ASSERT (is_double_equal(1.0, 1.0000000000000001) == true);
                printf("# Selftest done.\n");
            }

        void toDouble_test_3()
            {
                rtl::OString sValue("3");
                toDouble_test(sValue);
            }
        void toDouble_test_3_5()
            {
                rtl::OString sValue("3.5");
                toDouble_test(sValue);
            }
        void toDouble_test_3_0625()
            {
                rtl::OString sValue("3.0625");
                toDouble_test(sValue);
            }
        void toDouble_test_pi()
            {
                // value from http://www.angio.net/pi/digits/50.txt
                rtl::OString sValue("3.141592653589793238462643383279502884197169399375");
                toDouble_test(sValue);
            }

        void toDouble_test_1()
            {
                rtl::OString sValue("1");
                toDouble_test(sValue);
            }
        void toDouble_test_10()
            {
                rtl::OString sValue("10");
                toDouble_test(sValue);
            }
        void toDouble_test_100()
            {
                rtl::OString sValue("100");
                toDouble_test(sValue);
            }
        void toDouble_test_1000()
            {
                rtl::OString sValue("1000");
                toDouble_test(sValue);
            }
        void toDouble_test_10000()
            {
                rtl::OString sValue("10000");
                toDouble_test(sValue);
            }
        void toDouble_test_1e99()
            {
                rtl::OString sValue("1e99");
                toDouble_test(sValue);
            }
        void toDouble_test_1e_n99()
            {
                rtl::OString sValue("1e-99");
                toDouble_test(sValue);
            }
        void toDouble_test_1e308()
            {
                rtl::OString sValue("1e308");
                toDouble_test(sValue);
            }

        // Change the following lines only, if you add, remove or rename
        // member functions of the current class,
        // because these macros are need by auto register mechanism.

        CPPUNIT_TEST_SUITE(toDouble);
        CPPUNIT_TEST(toDouble_selftest);

        CPPUNIT_TEST(toDouble_test_3);
        CPPUNIT_TEST(toDouble_test_3_5);
        CPPUNIT_TEST(toDouble_test_3_0625);
        CPPUNIT_TEST(toDouble_test_pi);
        CPPUNIT_TEST(toDouble_test_1);
        CPPUNIT_TEST(toDouble_test_10);
        CPPUNIT_TEST(toDouble_test_100);
        CPPUNIT_TEST(toDouble_test_1000);
        CPPUNIT_TEST(toDouble_test_10000);
        CPPUNIT_TEST(toDouble_test_1e99);
        CPPUNIT_TEST(toDouble_test_1e_n99);
        CPPUNIT_TEST(toDouble_test_1e308);
        CPPUNIT_TEST_SUITE_END();
    }; // class toDouble

// -----------------------------------------------------------------------------
// - lastIndexOf (tests)
// -----------------------------------------------------------------------------
class lastIndexOf : public CppUnit::TestFixture
{

public:

    // initialise your test code values here.
    void setUp()
        {
        }

    void tearDown()
        {
        }

    // -----------------------------------------------------------------------------

    void lastIndexOf_oustring(rtl::OUString const& _suStr, rtl::OUString const& _suSearchStr, sal_Int32 _nExpectedResultPos)
        {
            // Algorithm
            // search the string _suSearchStr (rtl::OUString) in the string _suStr.
            // check if the _nExpectedResultPos occurs.

            sal_Int32 nPos = _suStr.lastIndexOf(_suSearchStr);
            CPPUNIT_ASSERT_MESSAGE("expected position is wrong", nPos == _nExpectedResultPos);
        }

    void lastIndexOf_salunicode(rtl::OUString const& _suStr, sal_Unicode _cuSearchChar, sal_Int32 _nExpectedResultPos)
        {
            // Algorithm
            // search the unicode char _suSearchChar (sal_Unicode) in the string _suStr.
            // check if the _nExpectedResultPos occurs.

            sal_Int32 nPos = _suStr.lastIndexOf(_cuSearchChar);
            CPPUNIT_ASSERT_MESSAGE("expected position is wrong", nPos == _nExpectedResultPos);
        }

    void lastIndexOf_oustring_offset(rtl::OUString const& _suStr, rtl::OUString const& _suSearchStr, sal_Int32 _nExpectedResultPos, sal_Int32 _nStartOffset)
        {
            sal_Int32 nPos = _suStr.lastIndexOf(_suSearchStr, _nStartOffset);
            CPPUNIT_ASSERT_MESSAGE("expected position is wrong", nPos == _nExpectedResultPos);
        }

    void lastIndexOf_salunicode_offset(rtl::OUString const& _suStr, sal_Unicode _cuSearchChar, sal_Int32 _nExpectedResultPos, sal_Int32 _nStartOffset)
        {
            sal_Int32 nPos = _suStr.lastIndexOf(_cuSearchChar, _nStartOffset);
            CPPUNIT_ASSERT_MESSAGE("expected position is wrong", nPos == _nExpectedResultPos);
        }

    // -----------------------------------------------------------------------------

    void lastIndexOf_test_oustring_offset_001()
        {
            // search for sun, start at the end, found (pos==0)
            rtl::OUString aStr = rtl::OUString::createFromAscii("sun java system");
            rtl::OUString aSearchStr = rtl::OUString::createFromAscii("sun");
            lastIndexOf_oustring_offset(aStr, aSearchStr, 0, aStr.getLength());
        }

    void lastIndexOf_test_oustring_offset_002()
        {
            // search for sun, start at pos = 3, found (pos==0)
            rtl::OUString aStr = rtl::OUString::createFromAscii("sun java system");
            rtl::OUString aSearchStr = rtl::OUString::createFromAscii("sun");
            lastIndexOf_oustring_offset(aStr, aSearchStr, 0, 3);
        }

    void lastIndexOf_test_oustring_offset_003()
        {
            // search for sun, start at pos = 2, found (pos==-1)
            rtl::OUString aStr = rtl::OUString::createFromAscii("sun java system");
            rtl::OUString aSearchStr = rtl::OUString::createFromAscii("sun");
            lastIndexOf_oustring_offset(aStr, aSearchStr, -1, 2);
        }

    void lastIndexOf_test_oustring_offset_004()
        {
            // search for sun, start at the end, found (pos==0)
            rtl::OUString aStr = rtl::OUString::createFromAscii("sun java system");
            rtl::OUString aSearchStr = rtl::OUString::createFromAscii("sun");
            lastIndexOf_oustring_offset(aStr, aSearchStr, -1, -1);
        }

    void lastIndexOf_test_oustring_001()
        {
            // search for sun, found (pos==0)
            rtl::OUString aStr = rtl::OUString::createFromAscii("sun java system");
            rtl::OUString aSearchStr = rtl::OUString::createFromAscii("sun");
            lastIndexOf_oustring(aStr, aSearchStr, 0);
        }

    void lastIndexOf_test_oustring_002()
        {
            // search for sun, found (pos==4)
            rtl::OUString aStr = rtl::OUString::createFromAscii("the sun java system");
            rtl::OUString aSearchStr = rtl::OUString::createFromAscii("sun");
            lastIndexOf_oustring(aStr, aSearchStr, 4);
        }

    void lastIndexOf_test_oustring_003()
        {
            // search for sun, found (pos==8)
            rtl::OUString aStr = rtl::OUString::createFromAscii("the sun sun java system");
            rtl::OUString aSearchStr = rtl::OUString::createFromAscii("sun");
            lastIndexOf_oustring(aStr, aSearchStr, 8);
        }

    void lastIndexOf_test_oustring_004()
        {
            // search for sun, found (pos==8)
            rtl::OUString aStr = rtl::OUString::createFromAscii("the sun sun");
            rtl::OUString aSearchStr = rtl::OUString::createFromAscii("sun");
            lastIndexOf_oustring(aStr, aSearchStr, 8);
        }

    void lastIndexOf_test_oustring_005()
        {
            // search for sun, found (pos==4)
            rtl::OUString aStr = rtl::OUString::createFromAscii("the sun su");
            rtl::OUString aSearchStr = rtl::OUString::createFromAscii("sun");
            lastIndexOf_oustring(aStr, aSearchStr, 4);
        }

    void lastIndexOf_test_oustring_006()
        {
            // search for sun, found (pos==-1)
            rtl::OUString aStr = rtl::OUString::createFromAscii("the su su");
            rtl::OUString aSearchStr = rtl::OUString::createFromAscii("sun");
            lastIndexOf_oustring(aStr, aSearchStr, -1);
        }

    void lastIndexOf_test_oustring_007()
        {
            // search for earth, not found (-1)
            rtl::OUString aStr = rtl::OUString::createFromAscii("the su su");
            rtl::OUString aSearchStr = rtl::OUString::createFromAscii("earth");
            lastIndexOf_oustring(aStr, aSearchStr, -1);
        }

    void lastIndexOf_test_oustring_008()
        {
            // search for earth, not found (-1)
            rtl::OUString aStr = rtl::OUString();
            rtl::OUString aSearchStr = rtl::OUString::createFromAscii("earth");
            lastIndexOf_oustring(aStr, aSearchStr, -1);
        }

    void lastIndexOf_test_oustring_009()
        {
            // search for earth, not found (-1)
            rtl::OUString aStr = rtl::OUString();
            rtl::OUString aSearchStr = rtl::OUString();
            lastIndexOf_oustring(aStr, aSearchStr, -1);

        }

    void lastIndexOf_test_salunicode_001()
        {
            // search for 's', found (19)
            rtl::OUString aStr = rtl::OUString::createFromAscii("the sun sun java system");
            sal_Unicode suChar = L's';
            lastIndexOf_salunicode(aStr, suChar, 19);
        }

    void lastIndexOf_test_salunicode_002()
        {
            // search for 'x', not found (-1)
            rtl::OUString aStr = rtl::OUString::createFromAscii("the sun sun java system");
            sal_Unicode suChar = L'x';
            lastIndexOf_salunicode(aStr, suChar, -1);
        }

    void lastIndexOf_test_salunicode_offset_001()
        {
            // search for 's', start from pos last char, found (19)
            rtl::OUString aStr = rtl::OUString::createFromAscii("the sun sun java system");
            sal_Unicode cuChar = L's';
            lastIndexOf_salunicode_offset(aStr, cuChar, 19, aStr.getLength());
        }
    void lastIndexOf_test_salunicode_offset_002()
        {
            // search for 's', start pos is last occur from search behind, found (17)
            rtl::OUString aStr = rtl::OUString::createFromAscii("the sun sun java system");
            sal_Unicode cuChar = L's';
            lastIndexOf_salunicode_offset(aStr, cuChar, 17, 19);
        }
    void lastIndexOf_test_salunicode_offset_003()
        {
            // search for 't', start pos is 1, found (0)
            rtl::OUString aStr = rtl::OUString::createFromAscii("the sun sun java system");
            sal_Unicode cuChar = L't';
            lastIndexOf_salunicode_offset(aStr, cuChar, 0, 1);
        }

    // Change the following lines only, if you add, remove or rename
    // member functions of the current class,
    // because these macros are need by auto register mechanism.

    CPPUNIT_TEST_SUITE(lastIndexOf);
    CPPUNIT_TEST(lastIndexOf_test_oustring_001);
    CPPUNIT_TEST(lastIndexOf_test_oustring_002);
    CPPUNIT_TEST(lastIndexOf_test_oustring_003);
    CPPUNIT_TEST(lastIndexOf_test_oustring_004);
    CPPUNIT_TEST(lastIndexOf_test_oustring_005);
    CPPUNIT_TEST(lastIndexOf_test_oustring_006);
    CPPUNIT_TEST(lastIndexOf_test_oustring_007);
    CPPUNIT_TEST(lastIndexOf_test_oustring_008);
    CPPUNIT_TEST(lastIndexOf_test_oustring_009);

    CPPUNIT_TEST(lastIndexOf_test_oustring_offset_001);
    CPPUNIT_TEST(lastIndexOf_test_oustring_offset_002);
    CPPUNIT_TEST(lastIndexOf_test_oustring_offset_003);
    CPPUNIT_TEST(lastIndexOf_test_oustring_offset_004);

    CPPUNIT_TEST(lastIndexOf_test_salunicode_001);
    CPPUNIT_TEST(lastIndexOf_test_salunicode_002);

    CPPUNIT_TEST(lastIndexOf_test_salunicode_offset_001);
    CPPUNIT_TEST(lastIndexOf_test_salunicode_offset_002);
    CPPUNIT_TEST(lastIndexOf_test_salunicode_offset_003);

    CPPUNIT_TEST_SUITE_END();
}; // class lastIndexOf
// -----------------------------------------------------------------------------
// - valueOf (tests)
// -----------------------------------------------------------------------------

//LLA: this is old test code, maybe we can use it later, so first let it in.

// LLA: old code: class valueOf : public CppUnit::TestFixture
// LLA: old code: {
// LLA: old code: public:
// LLA: old code:     // initialise your test code values here.
// LLA: old code:     void setUp()
// LLA: old code:     {
// LLA: old code:     }
// LLA: old code:
// LLA: old code:     void tearDown()
// LLA: old code:     {
// LLA: old code:     }
// LLA: old code:
// LLA: old code:     template <class T>
// LLA: old code:     void checkATOFPrecision()
// LLA: old code:         {
// LLA: old code:             int nCount = 1;
// LLA: old code:             sal_Int32 nAdd = 1;
// LLA: old code:             T nValue = 3;
// LLA: old code:             rtl::OString sValue("3.");
// LLA: old code:             while (nCount < 25)
// LLA: old code:             {
// LLA: old code:                 sValue += rtl::OString::valueOf( nAdd );
// LLA: old code:                 T nATOFValue = atof(sValue.getStr());
// LLA: old code:
// LLA: old code:                 T nAddValue = pow(10.0, -nCount) * nAdd;
// LLA: old code:                 nValue = nValue + nAddValue;
// LLA: old code:
// LLA: old code:                 T nATOFDelta = fabs(nValue - nATOFValue);
// LLA: old code:
// LLA: old code:
// LLA: old code:                 // rtl::OUString suOUStringValue = rtl::OUString::valueOf( nValue );
// LLA: old code:                 // double nOUStringValue = suOUStringValue.toDouble();
// LLA: old code:
// LLA: old code:                 // double nOUStringDelta = fabs(nATOFValue - nOUStringDelta);
// LLA: old code:                 // printf("# Value: %.20f   DeltaATOF: %e   DeltaOUStr: %e   String: %s   \n", nValue, nATOFDelta, nOUStringDelta, sValue.getStr());
// LLA: old code:                 printf("# Value: %.20lf   DeltaATOF: %e   String: %s   \n", nValue, nATOFDelta, sValue.getStr());
// LLA: old code:
// LLA: old code:                 // we wan'na use digits between 1 and 9
// LLA: old code:                 nAdd ++;
// LLA: old code:                 if (nAdd >= 10) nAdd = 1;
// LLA: old code:
// LLA: old code:                 nCount++;
// LLA: old code:             }
// LLA: old code:         }
// LLA: old code:
// LLA: old code:     // insert your test code here.
// LLA: old code:     void valueOf_double_001()
// LLA: old code:     {
// LLA: old code:         // this is demonstration code
// LLA: old code:         // CPPUNIT_ASSERT_MESSAGE("a message", 1 == 1);
// LLA: old code:
// LLA: old code:         rtl::OString sValue("3.0");
// LLA: old code:         double nValue = atof(sValue.getStr());
// LLA: old code:
// LLA: old code:         // check here, how many precisions are in.
// LLA: old code:         rtl::OUString suStr;
// LLA: old code:         suStr = rtl::OUString::valueOf( nValue );
// LLA: old code:
// LLA: old code:         // LLA: Due to the fact, that we can't handle values in strings right
// LLA: old code:         // we have to convert it back to double values
// LLA: old code:
// LLA: old code:         rtl::OString sStr;
// LLA: old code:         sStr <<= suStr;
// LLA: old code:         double nValue2 = sStr.toDouble();
// LLA: old code:
// LLA: old code:         printf("# OUString::valueOf(3.0) = %s\n", sStr.getStr());
// LLA: old code:         double nDelta = fabs(nValue - nValue2);
// LLA: old code:         printf("# nDelta = %f\n", nDelta);
// LLA: old code:         bool bCondition = true;
// LLA: old code:         CPPUNIT_ASSERT_MESSAGE("valueOf(double(3.0)) failed.", bCondition);
// LLA: old code:     }
// LLA: old code:
// LLA: old code:     void valueOf_double_002();
// LLA: old code:     // {
// LLA: old code:     //     CPPUNIT_ASSERT_STUB();
// LLA: old code:     // }
// LLA: old code: private:
// LLA: old code:     void double_equal(double x, double y)
// LLA: old code:         {
// LLA: old code:             // due to the fact that this check looks only if both values are equal
// LLA: old code:             // we only need to look on one value
// LLA: old code:
// LLA: old code:             // LLA: 4 stellen hinter dem komma
// LLA: old code:             sal_Int32 nPrecOfN = -4 + sal_Int32( log10(x) );
// LLA: old code:
// LLA: old code:             printf("# prec: %d\n", nPrecOfN);
// LLA: old code:             double nPrec = pow(10, nPrecOfN) * 1;
// LLA: old code:
// LLA: old code:             printf("# prec: %.25f\n", nPrec);
// LLA: old code:
// LLA: old code:             double nDelta = fabs( x - y);
// LLA: old code:             if (nDelta > nPrec)
// LLA: old code:             {
// LLA: old code:                 printf("# values are not equal! ndelta:%.20f\n", nDelta);
// LLA: old code:             }
// LLA: old code:             else
// LLA: old code:             {
// LLA: old code:                 printf("# values are equal.     ndelta:%.20f\n", nDelta);
// LLA: old code:             }
// LLA: old code:         }
// LLA: old code:
// LLA: old code:     void valueOf_double_004()
// LLA: old code:     {
// LLA: old code:         // CPPUNIT_ASSERT_STUB();
// LLA: old code:         // double n;
// LLA: old code:         // n = log10(100);
// LLA: old code:         // printf("# log10(100) %f\n", n);
// LLA: old code:         // n = log10(10);
// LLA: old code:         // printf("# log10(10) %f\n", n);
// LLA: old code:         // n = log10(1);
// LLA: old code:         // printf("# log10(1) %f\n", n);
// LLA: old code:         //
// LLA: old code:         // n = log10(0.1);
// LLA: old code:         // printf("# log10(0.1) %f\n", n);
// LLA: old code:         // n = log10(0.01);
// LLA: old code:         // printf("# log10(0.01) %f\n", n);
// LLA: old code:         // n = log10(0.001);
// LLA: old code:         // printf("# log10(0.001) %f\n", n);
// LLA: old code:
// LLA: old code:         double_equal(1,1);
// LLA: old code:         double_equal(3.1415926, 3.1415);
// LLA: old code:         double_equal(10,10);
// LLA: old code:         double_equal(100,100);
// LLA: old code:         double_equal(1000,1000);
// LLA: old code:         double_equal(10000,10000);
// LLA: old code:         double_equal(100000,100000);
// LLA: old code:         double_equal(1000000,1000000);
// LLA: old code:         double_equal(10000000,10000000);
// LLA: old code:         double_equal(100000000,100000000);
// LLA: old code:     }
// LLA: old code:
// LLA: old code:     void doubleequal_prec(double _x, double _y, double _prec)
// LLA: old code:         {
// LLA: old code:             double nDelta = fabs(_x - _y);
// LLA: old code:             if (nDelta > _prec)
// LLA: old code:             {
// LLA: old code:                 printf("# x and y are not equal, delta:%.19f prec:%.19f\n", nDelta, _prec);
// LLA: old code:             }
// LLA: old code:             else
// LLA: old code:             {
// LLA: old code:                 printf("# x and y are equal.     delta:%.19f prec:%.19f\n", nDelta, _prec);
// LLA: old code:             }
// LLA: old code:         }
// LLA: old code:
// LLA: old code:     void valueOf_double(double _nFactor)
// LLA: old code:     {
// LLA: old code:         double x = _nFactor *  1.001;
// LLA: old code:         double y = _nFactor *  1.002;
// LLA: old code:         doubleequal_prec(x, y, _nFactor * 0.001);
// LLA: old code:
// LLA: old code:         x = _nFactor *  1.0001;
// LLA: old code:         y = _nFactor *  1.0002;
// LLA: old code:         doubleequal_prec(x, y, 0.0001);
// LLA: old code:
// LLA: old code:         x = _nFactor *  1.00001;
// LLA: old code:         y = _nFactor *  1.00002;
// LLA: old code:         doubleequal_prec(x, y, 0.00001);
// LLA: old code:
// LLA: old code:         x = _nFactor *  1.000001;
// LLA: old code:         y = _nFactor *  1.000002;
// LLA: old code:         doubleequal_prec(x, y, 0.000001);
// LLA: old code:
// LLA: old code:         x = _nFactor *  1.0000001;
// LLA: old code:         y = _nFactor *  1.0000002;
// LLA: old code:         doubleequal_prec(x, y, 0.0000001);
// LLA: old code:
// LLA: old code:         x = _nFactor *  1.00000001;
// LLA: old code:         y = _nFactor *  1.00000002;
// LLA: old code:         doubleequal_prec(x, y, 0.00000001);
// LLA: old code:
// LLA: old code:         x = _nFactor *  1.000000001;
// LLA: old code:         y = _nFactor *  1.000000002;
// LLA: old code:         doubleequal_prec(x, y, 0.000000001);
// LLA: old code:
// LLA: old code:         x = _nFactor *  1.0000000001;
// LLA: old code:         y = _nFactor *  1.0000000002;
// LLA: old code:         doubleequal_prec(x, y, 0.0000000001);
// LLA: old code:
// LLA: old code:         x = _nFactor *  1.00000000001;
// LLA: old code:         y = _nFactor *  1.00000000002;
// LLA: old code:         doubleequal_prec(x, y, 0.00000000001);
// LLA: old code:
// LLA: old code:         x = _nFactor *  1.000000000001;
// LLA: old code:         y = _nFactor *  1.000000000002;
// LLA: old code:         doubleequal_prec(x, y, 0.000000000001);
// LLA: old code:
// LLA: old code:         x = _nFactor *  1.0000000000001;
// LLA: old code:         y = _nFactor *  1.0000000000002;
// LLA: old code:         doubleequal_prec(x, y, 0.0000000000001);
// LLA: old code:
// LLA: old code:         x = _nFactor *  1.00000000000001;
// LLA: old code:         y = _nFactor *  1.00000000000002;
// LLA: old code:         doubleequal_prec(x, y, 0.00000000000001);
// LLA: old code:
// LLA: old code:         x = _nFactor *  1.000000000000001;
// LLA: old code:         y = _nFactor *  1.000000000000002;
// LLA: old code:         doubleequal_prec(x, y, 0.000000000000001);
// LLA: old code:
// LLA: old code:         // this is out of double precision
// LLA: old code:         x = _nFactor *  1.0000000000000001;
// LLA: old code:         y = _nFactor *  1.0000000000000002;
// LLA: old code:         doubleequal_prec(x, y, 0.0000000000000001);
// LLA: old code:
// LLA: old code:         x = _nFactor *  1.00000000000000001;
// LLA: old code:         y = _nFactor *  1.00000000000000002;
// LLA: old code:         doubleequal_prec(x, y, 0.00000000000000001);
// LLA: old code:
// LLA: old code:         x = _nFactor *  1.000000000000000001;
// LLA: old code:         y = _nFactor *  1.000000000000000002;
// LLA: old code:         doubleequal_prec(x, y, 0.000000000000000001);
// LLA: old code:
// LLA: old code:         printf("# ---------- \n");
// LLA: old code:         // CPPUNIT_ASSERT_STUB();
// LLA: old code:     }
// LLA: old code:
// LLA: old code:     void valueOf_double_003()
// LLA: old code:         {
// LLA: old code:
// LLA: old code:             // valueOf_double(1);
// LLA: old code:             // valueOf_double(10);
// LLA: old code:             // valueOf_double(100);
// LLA: old code:             // valueOf_double(1000);
// LLA: old code:             // valueOf_double(10000);
// LLA: old code:             // valueOf_double(100000);
// LLA: old code:             // valueOf_double(1000000);
// LLA: old code:             // valueOf_double(10000000);
// LLA: old code:             // valueOf_double(100000000);
// LLA: old code:             double n = log10(1);
// LLA: old code:             printf("# log10 (1) = %f \n", n);
// LLA: old code:             n = log10(10);
// LLA: old code:             printf("# log10 (10) = %f \n", n);
// LLA: old code:             n = log10(100);
// LLA: old code:             printf("# log10 (100) = %f \n", n);
// LLA: old code:             n = log10(1000);
// LLA: old code:             printf("# log10 (1000) = %f \n", n);
// LLA: old code:             n = log10(30000);
// LLA: old code:             printf("# log10 (30000) = %f \n", n);
// LLA: old code:
// LLA: old code:         }
// LLA: old code:
// LLA: old code:     // void valueOf_double_004()
// LLA: old code:     // {
// LLA: old code:     //     CPPUNIT_ASSERT_STUB();
// LLA: old code:     // }
// LLA: old code:
// LLA: old code:     void valueOf_double_005()
// LLA: old code:     {
// LLA: old code:         CPPUNIT_ASSERT_STUB();
// LLA: old code:     }
// LLA: old code:
// LLA: old code:     void valueOf_double_006()
// LLA: old code:     {
// LLA: old code:         CPPUNIT_ASSERT_STUB();
// LLA: old code:     }
// LLA: old code:
// LLA: old code:     void valueOf_double_007()
// LLA: old code:     {
// LLA: old code:         CPPUNIT_ASSERT_STUB();
// LLA: old code:     }
// LLA: old code:
// LLA: old code:     // Change the following lines only, if you add, remove or rename
// LLA: old code:     // member functions of the current class,
// LLA: old code:     // because these macros are need by auto register mechanism.
// LLA: old code:
// LLA: old code:     CPPUNIT_TEST_SUITE(valueOf);
// LLA: old code: //    CPPUNIT_TEST(checkATOFPrecision<float>);
// LLA: old code: //    CPPUNIT_TEST(checkATOFPrecision<double>);
// LLA: old code: //    CPPUNIT_TEST(checkATOFPrecision<long double>);
// LLA: old code: //    CPPUNIT_TEST(valueOf_double_001);
// LLA: old code: //    CPPUNIT_TEST(valueOf_double_002);
// LLA: old code: // LLA:    CPPUNIT_TEST(valueOf_double_003);
// LLA: old code:     CPPUNIT_TEST(valueOf_double_004);
// LLA: old code:     CPPUNIT_TEST(valueOf_double_005);
// LLA: old code:     CPPUNIT_TEST(valueOf_double_006);
// LLA: old code:     CPPUNIT_TEST(valueOf_double_007);
// LLA: old code:     CPPUNIT_TEST_SUITE_END();
// LLA: old code: }; // class valueOf

// -----------------------------------------------------------------------------
CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(rtl_OUString::valueOf, "rtl_OUString");
CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(rtl_OUString::toDouble, "rtl_OUString");
CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(rtl_OUString::lastIndexOf, "rtl_OUString");


// LLA: old code:     // insert your test code here.
// LLA: old code:     void valueOf::valueOf_double_002()
// LLA: old code:     {
// LLA: old code:         // this is demonstration code
// LLA: old code:         // CPPUNIT_ASSERT_MESSAGE("a message", 1 == 1);
// LLA: old code:
// LLA: old code:         rtl::OString sValue("3.0");
// LLA: old code:         double nValue = atof(sValue.getStr());
// LLA: old code:
// LLA: old code:         // check here, how many precisions are in.
// LLA: old code:         rtl::OUString suStr;
// LLA: old code:         suStr = rtl::OUString::valueOf( nValue );
// LLA: old code:
// LLA: old code:         rtl::OString sStr;
// LLA: old code:         sStr <<= suStr;
// LLA: old code:         printf("# valueOf(3.0) = %s\n", sStr.getStr());
// LLA: old code:         bool bCondition = false;
// LLA: old code:         CPPUNIT_ASSERT_MESSAGE("valueOf(double(3.0)) failed.", bCondition);
// LLA: old code:     }

} // namespace rtl_OUString


// -----------------------------------------------------------------------------

// this macro creates an empty function, which will called by the RegisterAllFunctions()
// to let the user the possibility to also register some functions by hand.
NOADDITIONAL;

