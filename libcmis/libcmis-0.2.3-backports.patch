--- src/cmis-client.cxx	2012-06-01 15:50:49.000000000 +0200
+++ src/cmis-client.cxx	2012-07-05 11:21:22.316674741 +0200
@@ -163,16 +163,13 @@
             if ( "list-repos" == command )
             {
                 map< int, string > params = getSessionParams( );
-                list< string > ids = libcmis::SessionFactory::getRepositories( params );
+                list< libcmis::RepositoryPtr > repos = libcmis::SessionFactory::getRepositories( params );
             
                 cout << "Repositories: ";
-                for ( list< string >::iterator it = ids.begin(); it != ids.end(); it++ )
+                for ( list< libcmis::RepositoryPtr >::iterator it = repos.begin(); it != repos.end(); it++ )
                 {
-                    if ( it != ids.begin() )
-                        cout << ", ";
-                    cout << *it;
+                    cout << "\t" <<  ( *it )->getName() << " (" << ( *it )->getId( ) << ")" << endl;
                 }
-                cout << endl;
             }
             else if ( "show-root" == command )
             {
--- src/libcmis/allowable-actions.cxx	2012-02-01 12:02:56.000000000 +0100
+++ src/libcmis/allowable-actions.cxx	2012-07-05 11:21:22.314674740 +0200
@@ -28,14 +28,122 @@
 
 #include "allowable-actions.hxx"
 #include "object.hxx"
+#include "xml-utils.hxx"
 
 using namespace std;
 
 namespace libcmis
 {
-    AllowableActions::AllowableActions( ) :
+    ObjectAction::ObjectAction( xmlNodePtr node ) :
+        m_type( ObjectAction::DeleteObject ),
+        m_enabled( false ),
+        m_valid( false )
+    {
+        try
+        {
+            m_type = parseType( string( ( char* ) node->name ) );
+            m_valid = true;
+        }
+        catch ( const Exception& )
+        {
+            m_valid = false;
+        }
+
+        // Invalid xsd:bool will be mean false... not sure what the spec says
+        try
+        {
+            xmlChar* content = xmlNodeGetContent( node );
+            m_enabled = parseBool( string( ( char* )content ) );
+            xmlFree( content );
+        }
+        catch ( const Exception& )
+        {
+            m_enabled = false;
+        }
+    }
+
+    ObjectAction::Type ObjectAction::parseType( string type ) throw ( Exception )
+    {
+        Type value = DeleteObject;
+        if ( type == "canDeleteObject" )
+            value = DeleteObject;
+        else if ( type == "canUpdateProperties" )
+            value = UpdateProperties;
+        else if ( type == "canGetFolderTree" )
+            value = GetFolderTree;
+        else if ( type == "canGetProperties" )
+            value = GetProperties;
+        else if ( type == "canGetObjectRelationships" )
+            value = GetObjectRelationships;
+        else if ( type == "canGetObjectParents" )
+            value = GetObjectParents;
+        else if ( type == "canGetFolderParent" )
+            value = GetFolderParent;
+        else if ( type == "canGetDescendants" )
+            value = GetDescendants;
+        else if ( type == "canMoveObject" )
+            value = MoveObject;
+        else if ( type == "canDeleteContentStream" )
+            value = DeleteContentStream;
+        else if ( type == "canCheckOut" )
+            value = CheckOut;
+        else if ( type == "canCancelCheckOut" )
+            value = CancelCheckOut;
+        else if ( type == "canCheckIn" )
+            value = CheckIn;
+        else if ( type == "canSetContentStream" )
+            value = SetContentStream;
+        else if ( type == "canGetAllVersions" )
+            value = GetAllVersions;
+        else if ( type == "canAddObjectToFolder" )
+            value = AddObjectToFolder;
+        else if ( type == "canRemoveObjectFromFolder" )
+            value = RemoveObjectFromFolder;
+        else if ( type == "canGetContentStream" )
+            value = GetContentStream;
+        else if ( type == "canApplyPolicy" )
+            value = ApplyPolicy;
+        else if ( type == "canGetAppliedPolicies" )
+            value = GetAppliedPolicies;
+        else if ( type == "canRemovePolicy" )
+            value = RemovePolicy;
+        else if ( type == "canGetChildren" )
+            value = GetChildren;
+        else if ( type == "canCreateDocument" )
+            value = CreateDocument;
+        else if ( type == "canCreateFolder" )
+            value = CreateFolder;
+        else if ( type == "canCreateRelationship" )
+            value = CreateRelationship;
+        else if ( type == "canDeleteTree" )
+            value = DeleteTree;
+        else if ( type == "canGetRenditions" )
+            value = GetRenditions;
+        else if ( type == "canGetACL" )
+            value = GetACL;
+        else if ( type == "canApplyACL" )
+            value = ApplyACL;
+        else
+            throw Exception( "Invalid AllowableAction type: " + type );
+        
+        return value;
+    }
+
+    AllowableActions::AllowableActions( xmlNodePtr node ) :
         m_states( )
     {
+        for ( xmlNodePtr child = node->children; child; child = child->next )
+        {
+            // Check for non text children... "\n" is also a node ;)
+            if ( !xmlNodeIsText( child ) )
+            {
+                ObjectAction action( child );
+                if ( action.isValid( ) )
+                    m_states.insert( pair< libcmis::ObjectAction::Type, bool >(
+                                action.getType( ),
+                                action.isEnabled() ) );
+            }
+        }
     }
 
     AllowableActions::AllowableActions( const AllowableActions& copy ) :
--- src/libcmis/allowable-actions.hxx	2012-02-01 12:02:56.000000000 +0100
+++ src/libcmis/allowable-actions.hxx	2012-07-05 11:21:22.314674740 +0200
@@ -29,6 +29,11 @@
 #define _ALLOWABLE_ACTIONS_HXX_
 
 #include <map>
+#include <string>
+
+#include <libxml/tree.h>
+
+#include "exception.hxx"
 
 namespace libcmis
 {
@@ -37,8 +42,6 @@
     class ObjectAction
     {
         public:
-            virtual ~ObjectAction( ){ }
-
             enum Type
             {
                 DeleteObject,
@@ -71,6 +74,25 @@
                 GetACL,
                 ApplyACL
             };
+
+        private:
+            Type m_type;
+            bool m_enabled;
+            bool m_valid;
+
+        public:
+            ObjectAction( xmlNodePtr node );
+            virtual ~ObjectAction( ){ }
+
+            Type getType( ) { return m_type; }
+            bool isEnabled( ) { return m_enabled; }
+            bool isValid( ) { return m_valid; }
+
+            /** Parses the permission name into one of the enum values or throws
+                an exception for invalid input strings.
+              */
+            static Type parseType( std::string type ) throw ( Exception );
+
     };
 
     /** Class providing access to the allowed actions on an object.
@@ -81,7 +103,7 @@
             std::map< ObjectAction::Type, bool > m_states;
 
         public:
-            AllowableActions( );
+            AllowableActions( xmlNodePtr node );
             AllowableActions( const AllowableActions& copy );
             virtual ~AllowableActions( );
 
--- src/libcmis/atom-allowable-actions.cxx	2012-05-29 10:50:50.000000000 +0200
+++ src/libcmis/atom-allowable-actions.cxx	1970-01-01 01:00:00.000000000 +0100
@@ -1,237 +0,0 @@
-/* libcmis
- * Version: MPL 1.1 / GPLv2+ / LGPLv2+
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License or as specified alternatively below. You may obtain a copy of
- * the License at http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * Major Contributor(s):
- * Copyright (C) 2011 SUSE <cbosdonnat@suse.com>
- *
- *
- * All Rights Reserved.
- *
- * For minor contributions see the git repository.
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPLv2+"), or
- * the GNU Lesser General Public License Version 2 or later (the "LGPLv2+"),
- * in which case the provisions of the GPLv2+ or the LGPLv2+ are applicable
- * instead of those above.
- */
-
-#include <libxml/xpathInternals.h>
-
-#include "atom-allowable-actions.hxx"
-#include "atom-utils.hxx"
-#include "xml-utils.hxx"
-
-using namespace std;
-
-namespace atom
-{
-    class ObjectAction : libcmis::ObjectAction
-    {
-        private:
-            libcmis::ObjectAction::Type m_type;
-            bool m_enabled;
-            bool m_valid;
-
-        public:
-            ObjectAction( xmlNodePtr node );
-
-            libcmis::ObjectAction::Type getType( ) { return m_type; }
-            bool isEnabled( ) { return m_enabled; }
-            bool isValid( ) { return m_valid; }
-
-            /** Parses the atom permission name into one of the enum values or throws
-                an exception for invalid input strings.
-              */
-            static libcmis::ObjectAction::Type parseType( string type ) throw ( libcmis::Exception );
-    };
-
-    ObjectAction::ObjectAction( xmlNodePtr node ) :
-        m_type( libcmis::ObjectAction::DeleteObject ),
-        m_enabled( false ),
-        m_valid( false )
-    {
-        try
-        {
-            m_type = parseType( string( ( char* ) node->name ) );
-            m_valid = true;
-        }
-        catch ( const libcmis::Exception& e )
-        {
-            m_valid = false;
-        }
-
-        // Invalid xsd:bool will be mean false... not sure what the spec says
-        try
-        {
-            xmlChar* content = xmlNodeGetContent( node );
-            m_enabled = libcmis::parseBool( string( ( char* )content ) );
-            xmlFree( content );
-        }
-        catch ( const libcmis::Exception& e )
-        {
-            m_enabled = false;
-        }
-    }
-
-    libcmis::ObjectAction::Type ObjectAction::parseType( string type ) throw ( libcmis::Exception )
-    {
-        libcmis::ObjectAction::Type value = libcmis::ObjectAction::DeleteObject;
-        if ( type == "canDeleteObject" )
-            value = libcmis::ObjectAction::DeleteObject;
-        else if ( type == "canUpdateProperties" )
-            value = libcmis::ObjectAction::UpdateProperties;
-        else if ( type == "canGetFolderTree" )
-            value = libcmis::ObjectAction::GetFolderTree;
-        else if ( type == "canGetProperties" )
-            value = libcmis::ObjectAction::GetProperties;
-        else if ( type == "canGetObjectRelationships" )
-            value = libcmis::ObjectAction::GetObjectRelationships;
-        else if ( type == "canGetObjectParents" )
-            value = libcmis::ObjectAction::GetObjectParents;
-        else if ( type == "canGetFolderParent" )
-            value = libcmis::ObjectAction::GetFolderParent;
-        else if ( type == "canGetDescendants" )
-            value = libcmis::ObjectAction::GetDescendants;
-        else if ( type == "canMoveObject" )
-            value = libcmis::ObjectAction::MoveObject;
-        else if ( type == "canDeleteContentStream" )
-            value = libcmis::ObjectAction::DeleteContentStream;
-        else if ( type == "canCheckOut" )
-            value = libcmis::ObjectAction::CheckOut;
-        else if ( type == "canCancelCheckOut" )
-            value = libcmis::ObjectAction::CancelCheckOut;
-        else if ( type == "canCheckIn" )
-            value = libcmis::ObjectAction::CheckIn;
-        else if ( type == "canSetContentStream" )
-            value = libcmis::ObjectAction::SetContentStream;
-        else if ( type == "canGetAllVersions" )
-            value = libcmis::ObjectAction::GetAllVersions;
-        else if ( type == "canAddObjectToFolder" )
-            value = libcmis::ObjectAction::AddObjectToFolder;
-        else if ( type == "canRemoveObjectFromFolder" )
-            value = libcmis::ObjectAction::RemoveObjectFromFolder;
-        else if ( type == "canGetContentStream" )
-            value = libcmis::ObjectAction::GetContentStream;
-        else if ( type == "canApplyPolicy" )
-            value = libcmis::ObjectAction::ApplyPolicy;
-        else if ( type == "canGetAppliedPolicies" )
-            value = libcmis::ObjectAction::GetAppliedPolicies;
-        else if ( type == "canRemovePolicy" )
-            value = libcmis::ObjectAction::RemovePolicy;
-        else if ( type == "canGetChildren" )
-            value = libcmis::ObjectAction::GetChildren;
-        else if ( type == "canCreateDocument" )
-            value = libcmis::ObjectAction::CreateDocument;
-        else if ( type == "canCreateFolder" )
-            value = libcmis::ObjectAction::CreateFolder;
-        else if ( type == "canCreateRelationship" )
-            value = libcmis::ObjectAction::CreateRelationship;
-        else if ( type == "canDeleteTree" )
-            value = libcmis::ObjectAction::DeleteTree;
-        else if ( type == "canGetRenditions" )
-            value = libcmis::ObjectAction::GetRenditions;
-        else if ( type == "canGetACL" )
-            value = libcmis::ObjectAction::GetACL;
-        else if ( type == "canApplyACL" )
-            value = libcmis::ObjectAction::ApplyACL;
-        else
-            throw libcmis::Exception( "Invalid AllowableAction type: " + type );
-        
-        return value;
-    }
-}
-
-AtomAllowableActions::AtomAllowableActions( AtomPubSession* session ) :
-    libcmis::AllowableActions( ),
-    m_url( ),
-    m_session( session )
-{
-}
-
-AtomAllowableActions::AtomAllowableActions( AtomPubSession* session, string url ) :
-    libcmis::AllowableActions( ),
-    m_url( url ),
-    m_session( session )
-{
-    refresh();
-}
-
-AtomAllowableActions::AtomAllowableActions( const AtomAllowableActions& copy ) :
-    libcmis::AllowableActions( copy ),
-    m_url( copy.m_url ),
-    m_session( copy.m_session )
-{
-}
-
-const AtomAllowableActions& AtomAllowableActions::operator=( const AtomAllowableActions& copy )
-{
-    AllowableActions::operator=( copy );
-    m_url = copy.m_url;
-    m_session = copy.m_session;
-
-    return *this;
-}
-
-void AtomAllowableActions::refresh( ) throw ( libcmis::Exception )
-{
-    m_states.clear( );
-    
-    if ( !m_url.empty( ) )
-    {
-        string buf;
-        try
-        {
-            buf  = m_session->httpGetRequest( m_url )->str( );
-        }
-        catch ( const atom::CurlException& e )
-        {
-            throw e.getCmisException( );
-        }
-        xmlDocPtr doc = xmlReadMemory( buf.c_str(), buf.size(), m_url.c_str(), NULL, 0 );
-
-        if ( NULL == doc )
-            throw libcmis::Exception( "Failed to parse object infos" );
-
-        // Populate the m_states map
-        xmlXPathContextPtr xpathCtx = xmlXPathNewContext( doc );
-
-        atom::registerNamespaces( xpathCtx );
-
-        if ( NULL != xpathCtx )
-        {
-            xmlXPathObjectPtr xpathObj = xmlXPathEvalExpression( BAD_CAST( "//cmis:allowableActions" ), xpathCtx );
-            if ( xpathObj && xpathObj->nodesetval && xpathObj->nodesetval->nodeNr > 0 )
-            {
-                xmlNodePtr node = xpathObj->nodesetval->nodeTab[0];
-                for ( xmlNodePtr child = node->children; child; child = child->next )
-                {
-                    // Check for non text children... "\n" is also a node ;)
-                    if ( !xmlNodeIsText( child ) )
-                    {
-                        atom::ObjectAction action( child );
-                        if ( action.isValid( ) )
-                            m_states.insert( pair< libcmis::ObjectAction::Type, bool >(
-                                        action.getType( ),
-                                        action.isEnabled() ) );
-                    }
-                }
-            }
-            xmlXPathFreeObject( xpathObj );
-        }
-
-        xmlXPathFreeContext( xpathCtx );
-
-        xmlFreeDoc( doc );
-    }
-}
--- src/libcmis/atom-allowable-actions.hxx	2012-01-19 17:26:32.000000000 +0100
+++ src/libcmis/atom-allowable-actions.hxx	1970-01-01 01:00:00.000000000 +0100
@@ -1,56 +0,0 @@
-/* libcmis
- * Version: MPL 1.1 / GPLv2+ / LGPLv2+
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License or as specified alternatively below. You may obtain a copy of
- * the License at http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * Major Contributor(s):
- * Copyright (C) 2011 SUSE <cbosdonnat@suse.com>
- *
- *
- * All Rights Reserved.
- *
- * For minor contributions see the git repository.
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPLv2+"), or
- * the GNU Lesser General Public License Version 2 or later (the "LGPLv2+"),
- * in which case the provisions of the GPLv2+ or the LGPLv2+ are applicable
- * instead of those above.
- */
-#ifndef _ATOM_ALLOWABLE_ACTIONS_HXX_
-#define _ATOM_ALLOWABLE_ACTIONS_HXX_
-
-#include <string>
-
-#include "atom-session.hxx"
-#include "allowable-actions.hxx"
-#include "exception.hxx"
-
-class AtomAllowableActions : public libcmis::AllowableActions
-{
-    private:
-        std::string m_url;
-        AtomPubSession* m_session;
-
-    public:
-        AtomAllowableActions( AtomPubSession* session );
-        AtomAllowableActions( AtomPubSession* session, std::string url );
-        AtomAllowableActions( const AtomAllowableActions& copy );
-        ~AtomAllowableActions( ) { };
-
-        const AtomAllowableActions& operator=( const AtomAllowableActions& copy );
-
-        void setUrl( std::string url ) { m_url = url; }
-
-        void refresh( ) throw ( libcmis::Exception );
-};
-
-#endif
--- src/libcmis/atom-document.hxx	2012-06-01 15:47:01.000000000 +0200
+++ src/libcmis/atom-document.hxx	2012-07-05 11:21:22.314674740 +0200
@@ -35,6 +35,7 @@
 
 #include "document.hxx"
 #include "exception.hxx"
+#include "folder.hxx"
 #include "atom-object.hxx"
 
 class AtomDocument : public libcmis::Document, public AtomObject
--- src/libcmis/atom-object.cxx	2012-06-08 13:43:05.000000000 +0200
+++ src/libcmis/atom-object.cxx	2012-07-05 11:21:22.315674740 +0200
@@ -435,12 +435,14 @@
         // Get the infos URL as we may not have it
         m_infosUrl = getLink( "self", "application/atom+xml;type=entry" )->getHref( );
 
-        // Get the URL to the allowableActions
-        AtomLink* allowableActionsLink = getLink( "http://docs.oasis-open.org/ns/cmis/link/200908/allowableactions", "application/cmisallowableactions+xml" );
-        if ( NULL != allowableActionsLink )
+        // Get the allowableActions
+        xpathObj = xmlXPathEvalExpression( BAD_CAST( "//cmis:allowableActions" ), xpathCtx );
+        if ( xpathObj && xpathObj->nodesetval && xpathObj->nodesetval->nodeNr > 0 )
         {
-            m_allowableActions.reset( new AtomAllowableActions( m_session, allowableActionsLink->getHref( ) ) );
+            xmlNodePtr node = xpathObj->nodesetval->nodeTab[0];
+            m_allowableActions.reset( new libcmis::AllowableActions( node ) );
         }
+        xmlXPathFreeObject( xpathObj );
 
         // First get the type id as it will give us the property definitions
         string typeIdReq( "//cmis:propertyId[@propertyDefinitionId='cmis:objectTypeId']/cmis:value/text()" );
--- src/libcmis/atom-object.hxx	2012-06-01 15:43:27.000000000 +0200
+++ src/libcmis/atom-object.hxx	2012-07-05 11:21:22.315674740 +0200
@@ -30,7 +30,7 @@
 
 #include <libxml/tree.h>
 
-#include "atom-allowable-actions.hxx"
+#include "allowable-actions.hxx"
 #include "object.hxx"
 
 class AtomPubSession;
@@ -64,7 +64,7 @@
         libcmis::ObjectTypePtr m_typeDescription;
 
         std::map< std::string, libcmis::PropertyPtr > m_properties;
-        boost::shared_ptr< AtomAllowableActions > m_allowableActions;
+        boost::shared_ptr< libcmis::AllowableActions > m_allowableActions;
 
         std::vector< AtomLink > m_links;
 
--- src/libcmis/atom-object-type.cxx	2012-05-29 10:50:50.000000000 +0200
+++ src/libcmis/atom-object-type.cxx	2012-07-05 11:21:22.317674741 +0200
@@ -255,7 +255,7 @@
     bool createdDoc = ( NULL == doc );
     if ( createdDoc )
     {
-        string pattern = m_session->getWorkspace().getUriTemplate( atom::UriTemplate::TypeById );
+        string pattern = m_session->getAtomRepository()->getUriTemplate( UriTemplate::TypeById );
         map< string, string > vars;
         vars[URI_TEMPLATE_VAR_ID] = getId( );
         string url = m_session->createUrl( pattern, vars );
--- src/libcmis/atom-session.cxx	2012-06-08 13:43:05.000000000 +0200
+++ src/libcmis/atom-session.cxx	2012-07-05 11:21:22.317674741 +0200
@@ -126,8 +126,8 @@
     m_username( username ),
     m_password( password ),
     m_authProvided( false ),
-    m_workspace( ),
-    m_repositoriesIds( ),
+    m_repository( ),
+    m_repositories( ),
     m_verbose( verbose ),
     m_authProvider( ),
     m_curlHandle( NULL )
@@ -143,8 +143,8 @@
     m_username( copy.m_username ),
     m_password( copy.m_password ),
     m_authProvided( copy.m_authProvided ),
-    m_workspace( copy.m_workspace ),
-    m_repositoriesIds( copy.m_repositoriesIds ),
+    m_repository( copy.m_repository ),
+    m_repositories( copy.m_repositories ),
     m_verbose( copy.m_verbose ),
     m_authProvider( copy.m_authProvider ),
     m_curlHandle( NULL )
@@ -162,8 +162,8 @@
     m_username = copy.m_username;
     m_password = copy.m_password;
     m_authProvided = copy.m_authProvided;
-    m_workspace = copy.m_workspace;
-    m_repositoriesIds = copy.m_repositoriesIds;
+    m_repository = copy.m_repository;
+    m_repositories = copy.m_repositories;
     m_verbose = copy.m_verbose;
     m_authProvider = copy.m_authProvider;
     m_curlHandle = NULL;
@@ -183,7 +183,7 @@
 
 void AtomPubSession::initialize( ) throw ( libcmis::Exception )
 {
-    if ( m_repositoriesIds.empty() )
+    if ( m_repositories.empty() )
     {
         // Pull the content from sAtomPubUrl
         string buf;
@@ -221,13 +221,13 @@
                     {
                         try
                         {
-                            atom::Workspace ws( xpathObj->nodesetval->nodeTab[i] );
+                            AtomRepositoryPtr ws( new AtomRepository( xpathObj->nodesetval->nodeTab[i] ) );
 
                             // SharePoint is case insensitive for the id...
-                            if ( lcl_tolower( ws.getId( ) ) == lcl_tolower( m_sRepository ) )
-                                m_workspace = ws;
+                            if ( lcl_tolower( ws->getId( ) ) == lcl_tolower( m_sRepository ) )
+                                m_repository = ws;
 
-                            m_repositoriesIds.push_back( ws.getId() );
+                            m_repositories.push_back( ws );
                         }
                         catch ( const libcmis::Exception& e )
                         {
@@ -246,22 +246,22 @@
 
 }
 
-list< string > AtomPubSession::getRepositories( string url, string username, string password, bool verbose ) throw ( libcmis::Exception )
+list< libcmis::RepositoryPtr > AtomPubSession::getRepositories( string url, string username, string password, bool verbose ) throw ( libcmis::Exception )
 {
     AtomPubSession session( url, string(), username, password, verbose );
     session.initialize( );
-    return session.m_repositoriesIds;
+    return session.m_repositories;
 }
 
-atom::Workspace& AtomPubSession::getWorkspace( ) throw ( libcmis::Exception )
+AtomRepositoryPtr AtomPubSession::getAtomRepository( ) throw ( libcmis::Exception )
 {
     initialize( );
-    return m_workspace;
+    return m_repository;
 }
 
-libcmis::FolderPtr AtomPubSession::getRootFolder() throw ( libcmis::Exception )
+libcmis::RepositoryPtr AtomPubSession::getRepository( ) throw ( libcmis::Exception )
 {
-    return getFolder( getWorkspace().getRootId() );
+    return getAtomRepository( );
 }
 
 libcmis::ObjectPtr AtomPubSession::createObjectFromEntryDoc( xmlDocPtr doc )
@@ -306,11 +306,17 @@
     return cmisObject;
 }
 
+libcmis::FolderPtr AtomPubSession::getRootFolder( ) throw ( libcmis::Exception )
+{
+    return getFolder( getRootId( ) );
+}
+
 libcmis::ObjectPtr AtomPubSession::getObject( string id ) throw ( libcmis::Exception )
 {
-    string pattern = getWorkspace().getUriTemplate( atom::UriTemplate::ObjectById );
+    string pattern = getAtomRepository()->getUriTemplate( UriTemplate::ObjectById );
     map< string, string > vars;
     vars[URI_TEMPLATE_VAR_ID] = id;
+    vars[string( "includeAllowableActions" )] = string( "true" );
     string url = createUrl( pattern, vars );
 
     try
@@ -337,9 +343,10 @@
 
 libcmis::ObjectPtr AtomPubSession::getObjectByPath( string path ) throw ( libcmis::Exception )
 {
-    string pattern = getWorkspace().getUriTemplate( atom::UriTemplate::ObjectByPath );
+    string pattern = getAtomRepository()->getUriTemplate( UriTemplate::ObjectByPath );
     map< string, string > vars;
     vars[URI_TEMPLATE_VAR_PATH] = path;
+    vars[string( "includeAllowableActions" )] = string( "true" );
     string url = createUrl( pattern, vars );
 
     try
--- src/libcmis/atom-session.hxx	2012-06-08 13:43:05.000000000 +0200
+++ src/libcmis/atom-session.hxx	2012-07-05 11:21:22.360674743 +0200
@@ -95,9 +95,9 @@
         std::string m_username;
         std::string m_password;
         bool m_authProvided;
-        atom::Workspace m_workspace;
+        AtomRepositoryPtr m_repository;
 
-        std::list< std::string > m_repositoriesIds;
+        std::list< libcmis::RepositoryPtr > m_repositories;
 
         bool m_verbose;
         libcmis::AuthProviderPtr m_authProvider;
@@ -113,17 +113,17 @@
 
         AtomPubSession& operator=( const AtomPubSession& copy );
 
-        static std::list< std::string > getRepositories( std::string url,
+        static std::list< libcmis::RepositoryPtr > getRepositories( std::string url,
                         std::string username, std::string password,
                         bool verbose = false ) throw ( libcmis::Exception );
 
-        std::string getRootId( ) throw ( libcmis::Exception ) { return getWorkspace().getRootId( ); }
+        std::string getRootId( ) throw ( libcmis::Exception ) { return getRepository()->getRootId( ); }
 
         std::string getUsername( ) { return m_username; }
 
         std::string getPassword( ) { return m_password; }
 
-        atom::Workspace& getWorkspace( ) throw ( libcmis::Exception );
+        AtomRepositoryPtr getAtomRepository( ) throw ( libcmis::Exception );
 
         // Utility methods
 
@@ -142,6 +142,8 @@
 
         // Override session methods
 
+        virtual libcmis::RepositoryPtr getRepository( ) throw ( libcmis::Exception );
+
         virtual libcmis::FolderPtr getRootFolder() throw ( libcmis::Exception );
 
         virtual libcmis::ObjectPtr getObject( std::string id ) throw ( libcmis::Exception );
--- src/libcmis/atom-workspace.cxx	2011-12-06 14:12:19.000000000 +0100
+++ src/libcmis/atom-workspace.cxx	2012-07-05 11:21:22.360674743 +0200
@@ -31,204 +31,207 @@
 
 using namespace std;
 
-namespace atom
+AtomRepository::AtomRepository( xmlNodePtr wsNode ) throw ( libcmis::Exception ):
+    m_id( ),
+    m_rootId( ),
+    m_name( ),
+    m_collections( ),
+    m_uriTemplates( )
 {
-    Workspace::Workspace( xmlNodePtr wsNode ) throw ( libcmis::Exception ):
-        m_id( ),
-        m_rootId( ),
-        m_collections( ),
-        m_uriTemplates( )
+    if ( wsNode != NULL )
     {
-        if ( wsNode != NULL )
-        {
-            xmlDocPtr doc = wrapInDoc( wsNode );
-            xmlXPathContextPtr xpathCtx = xmlXPathNewContext( doc );
-            atom::registerNamespaces( xpathCtx );
+        xmlDocPtr doc = atom::wrapInDoc( wsNode );
+        xmlXPathContextPtr xpathCtx = xmlXPathNewContext( doc );
+        atom::registerNamespaces( xpathCtx );
 
-            if ( NULL != xpathCtx )
-            {
-                // Get the collections
-                xmlXPathObjectPtr xpathObj = xmlXPathEvalExpression( BAD_CAST( "//app:collection" ), xpathCtx );
-                if ( NULL != xpathObj )
-                    readCollections( xpathObj->nodesetval );
-                xmlXPathFreeObject( xpathObj );
-
-                // Get the URI templates
-                xpathObj = xmlXPathEvalExpression( BAD_CAST( "//cmisra:uritemplate" ), xpathCtx );
-                if ( NULL != xpathObj )
-                    readUriTemplates( xpathObj->nodesetval );
-                xmlXPathFreeObject( xpathObj );
-                
-                // Get the root node id
-                string rootIdXPath( "//cmisra:repositoryInfo/cmis:rootFolderId/text()" );
-                m_rootId = atom::getXPathValue( xpathCtx, rootIdXPath );
-                
-                // Get the repository id
-                string repoIdXPath( "//cmisra:repositoryInfo/cmis:repositoryId/text()" );
-                m_id = atom::getXPathValue( xpathCtx, repoIdXPath );
+        if ( NULL != xpathCtx )
+        {
+            // Get the collections
+            xmlXPathObjectPtr xpathObj = xmlXPathEvalExpression( BAD_CAST( "//app:collection" ), xpathCtx );
+            if ( NULL != xpathObj )
+                readCollections( xpathObj->nodesetval );
+            xmlXPathFreeObject( xpathObj );
+
+            // Get the URI templates
+            xpathObj = xmlXPathEvalExpression( BAD_CAST( "//cmisra:uritemplate" ), xpathCtx );
+            if ( NULL != xpathObj )
+                readUriTemplates( xpathObj->nodesetval );
+            xmlXPathFreeObject( xpathObj );
+            
+            // Get the root node id
+            string rootIdXPath( "//cmisra:repositoryInfo/cmis:rootFolderId/text()" );
+            m_rootId = atom::getXPathValue( xpathCtx, rootIdXPath );
+            
+            // Get the repository id
+            string repoIdXPath( "//cmisra:repositoryInfo/cmis:repositoryId/text()" );
+            m_id = atom::getXPathValue( xpathCtx, repoIdXPath );
+
+            // Get the repository name
+            string repoNameXPath( "//cmisra:repositoryInfo/cmis:repositoryName/text()" );
+            m_name = atom::getXPathValue( xpathCtx, repoNameXPath );
 
-                // TODO Extract other useful stuffs
-            }
-            xmlXPathFreeContext( xpathCtx );
-            xmlFreeDoc( doc );
+            // TODO Extract other useful stuffs
         }
+        xmlXPathFreeContext( xpathCtx );
+        xmlFreeDoc( doc );
     }
+}
 
-    Workspace::Workspace( const Workspace& rCopy ) :
-        m_id ( rCopy.m_id ),
-        m_rootId( rCopy.m_rootId ),
-        m_collections( rCopy.m_collections ),
-        m_uriTemplates( rCopy.m_uriTemplates )
-    {
-    }
-
-    Workspace::~Workspace( )
-    {
-        m_collections.clear( );
-        m_uriTemplates.clear( );
-    }
-
-    Workspace& Workspace::operator= ( const Workspace& rCopy )
-    {
-        m_id = rCopy.m_id;
-        m_rootId = rCopy.m_rootId;
-        m_collections = rCopy.m_collections;
-        m_uriTemplates = rCopy.m_uriTemplates;
-
-        return *this;
-    }
-
-    string Workspace::getCollectionUrl( Collection::Type type )
-    {
-        return m_collections[ type ];
-    }
-
-    string Workspace::getUriTemplate( UriTemplate::Type type )
-    {
-        return m_uriTemplates[ type ];
-    }
+AtomRepository::AtomRepository( const AtomRepository& rCopy ) :
+    m_id ( rCopy.m_id ),
+    m_rootId( rCopy.m_rootId ),
+    m_name( rCopy.m_name ),
+    m_collections( rCopy.m_collections ),
+    m_uriTemplates( rCopy.m_uriTemplates )
+{
+}
 
-    void Workspace::readCollections( xmlNodeSetPtr nodeSet )
-    {
-        int size = 0;
-        if ( nodeSet )
-            size = nodeSet->nodeNr;
+AtomRepository::~AtomRepository( )
+{
+    m_collections.clear( );
+    m_uriTemplates.clear( );
+}
 
-        for ( int i = 0; i < size; i++ )
-        {
-            xmlNodePtr node = nodeSet->nodeTab[i];
+AtomRepository& AtomRepository::operator= ( const AtomRepository& rCopy )
+{
+    m_id = rCopy.m_id;
+    m_rootId = rCopy.m_rootId;
+    m_name = rCopy.m_name;
+    m_collections = rCopy.m_collections;
+    m_uriTemplates = rCopy.m_uriTemplates;
 
-            // Look for the href property
-            xmlChar* href = xmlGetProp( node, BAD_CAST( "href" ) );
-            if ( href )
-            {
-                string collectionRef( ( char* )href );
-                xmlFree( href );
+    return *this;
+}
 
-                // Look for the cmisra:collectionType child
-                for ( xmlNodePtr child = node->children; child; child = child->next )
-                {
-                    // SharePoint CMIS implementation doesn't follow the spec:
-                    // the cmisra namespace is omitted
-                    bool isCollectionType = xmlStrEqual( child->name, BAD_CAST( "collectionType" ) );
-                    if ( isCollectionType )
-                    {
-                        xmlChar* content = xmlNodeGetContent( child );
-                        Collection::Type type = Collection::Root;
-                        bool typeDefined = false;
-
-                        if ( xmlStrEqual( content, BAD_CAST( "root" ) ) )
-                        {
-                            type = Collection::Root;
-                            typeDefined = true;
-                        }
-                        else if ( xmlStrEqual( content, BAD_CAST( "types" ) ) )
-                        {
-                            type = Collection::Types;
-                            typeDefined = true;
-                        }
-                        else if ( xmlStrEqual( content, BAD_CAST( "query" ) ) )
-                        {
-                            type = Collection::Query;
-                            typeDefined = true;
-                        }
-                        else if ( xmlStrEqual( content, BAD_CAST( "checkedout" ) ) )
-                        {
-                            type = Collection::CheckedOut;
-                            typeDefined = true;
-                        }
-                        else if ( xmlStrEqual( content, BAD_CAST( "unfiled" ) ) )
-                        {
-                            type = Collection::Unfiled;
-                            typeDefined = true;
-                        }
+string AtomRepository::getCollectionUrl( Collection::Type type )
+{
+    return m_collections[ type ];
+}
 
-                        if ( typeDefined )
-                            m_collections[ type ] = collectionRef;
+string AtomRepository::getUriTemplate( UriTemplate::Type type )
+{
+    return m_uriTemplates[ type ];
+}
 
-                        xmlFree( content );
-                    }
-                }
-            }
-        }
-    }
+void AtomRepository::readCollections( xmlNodeSetPtr nodeSet )
+{
+    int size = 0;
+    if ( nodeSet )
+        size = nodeSet->nodeNr;
 
-    void Workspace::readUriTemplates( xmlNodeSetPtr nodeSet )
+    for ( int i = 0; i < size; i++ )
     {
-        int size = 0;
-        if ( nodeSet )
-            size = nodeSet->nodeNr;
+        xmlNodePtr node = nodeSet->nodeTab[i];
 
-        for ( int i = 0; i < size; i++ )
+        // Look for the href property
+        xmlChar* href = xmlGetProp( node, BAD_CAST( "href" ) );
+        if ( href )
         {
-            xmlNodePtr node = nodeSet->nodeTab[i];
-
-            string templateUri;
-            UriTemplate::Type type = UriTemplate::ObjectById;
-            bool typeDefined = false;
+            string collectionRef( ( char* )href );
+            xmlFree( href );
 
-            // Look for the cmisra:template and cmisra:type children
+            // Look for the cmisra:collectionType child
             for ( xmlNodePtr child = node->children; child; child = child->next )
             {
-                bool isTemplate = xmlStrEqual( child->name, BAD_CAST( "template" ) );
-                bool isType = xmlStrEqual( child->name, BAD_CAST( "type" ) );
-
-                if ( isTemplate )
-                {
-                    xmlChar* content = xmlNodeGetContent( child );
-                    templateUri = string( ( char * )content );
-                    xmlFree( content );
-                }
-                else if ( isType )
+                // SharePoint CMIS implementation doesn't follow the spec:
+                // the cmisra namespace is omitted
+                bool isCollectionType = xmlStrEqual( child->name, BAD_CAST( "collectionType" ) );
+                if ( isCollectionType )
                 {
                     xmlChar* content = xmlNodeGetContent( child );
-                    if ( xmlStrEqual( content, BAD_CAST( "objectbyid" ) ) )
+                    Collection::Type type = Collection::Root;
+                    bool typeDefined = false;
+
+                    if ( xmlStrEqual( content, BAD_CAST( "root" ) ) )
                     {
-                        type = UriTemplate::ObjectById;
+                        type = Collection::Root;
                         typeDefined = true;
                     }
-                    else if ( xmlStrEqual( content, BAD_CAST( "objectbypath" ) ) )
+                    else if ( xmlStrEqual( content, BAD_CAST( "types" ) ) )
                     {
-                        type = UriTemplate::ObjectByPath;
+                        type = Collection::Types;
                         typeDefined = true;
                     }
                     else if ( xmlStrEqual( content, BAD_CAST( "query" ) ) )
                     {
-                        type = UriTemplate::Query;
+                        type = Collection::Query;
                         typeDefined = true;
                     }
-                    else if ( xmlStrEqual( content, BAD_CAST( "typebyid" ) ) )
+                    else if ( xmlStrEqual( content, BAD_CAST( "checkedout" ) ) )
                     {
-                        type = UriTemplate::TypeById;
+                        type = Collection::CheckedOut;
                         typeDefined = true;
                     }
+                    else if ( xmlStrEqual( content, BAD_CAST( "unfiled" ) ) )
+                    {
+                        type = Collection::Unfiled;
+                        typeDefined = true;
+                    }
+
+                    if ( typeDefined )
+                        m_collections[ type ] = collectionRef;
+
                     xmlFree( content );
                 }
             }
-
-            if ( !templateUri.empty() && typeDefined )
-                m_uriTemplates[ type ] = templateUri;
         }
     }
+}
+
+void AtomRepository::readUriTemplates( xmlNodeSetPtr nodeSet )
+{
+    int size = 0;
+    if ( nodeSet )
+        size = nodeSet->nodeNr;
+
+    for ( int i = 0; i < size; i++ )
+    {
+        xmlNodePtr node = nodeSet->nodeTab[i];
+
+        string templateUri;
+        UriTemplate::Type type = UriTemplate::ObjectById;
+        bool typeDefined = false;
 
+        // Look for the cmisra:template and cmisra:type children
+        for ( xmlNodePtr child = node->children; child; child = child->next )
+        {
+            bool isTemplate = xmlStrEqual( child->name, BAD_CAST( "template" ) );
+            bool isType = xmlStrEqual( child->name, BAD_CAST( "type" ) );
+
+            if ( isTemplate )
+            {
+                xmlChar* content = xmlNodeGetContent( child );
+                templateUri = string( ( char * )content );
+                xmlFree( content );
+            }
+            else if ( isType )
+            {
+                xmlChar* content = xmlNodeGetContent( child );
+                if ( xmlStrEqual( content, BAD_CAST( "objectbyid" ) ) )
+                {
+                    type = UriTemplate::ObjectById;
+                    typeDefined = true;
+                }
+                else if ( xmlStrEqual( content, BAD_CAST( "objectbypath" ) ) )
+                {
+                    type = UriTemplate::ObjectByPath;
+                    typeDefined = true;
+                }
+                else if ( xmlStrEqual( content, BAD_CAST( "query" ) ) )
+                {
+                    type = UriTemplate::Query;
+                    typeDefined = true;
+                }
+                else if ( xmlStrEqual( content, BAD_CAST( "typebyid" ) ) )
+                {
+                    type = UriTemplate::TypeById;
+                    typeDefined = true;
+                }
+                xmlFree( content );
+            }
+        }
+
+        if ( !templateUri.empty() && typeDefined )
+            m_uriTemplates[ type ] = templateUri;
+    }
 }
--- src/libcmis/atom-workspace.hxx	2012-05-29 10:50:50.000000000 +0200
+++ src/libcmis/atom-workspace.hxx	2012-07-05 11:21:22.361674743 +0200
@@ -31,65 +31,71 @@
 #include <map>
 #include <string>
 
+#include <boost/shared_ptr.hpp>
 #include <curl/curl.h>
 #include <libxml/xpath.h>
 
 #include "exception.hxx"
+#include "repository.hxx"
 
 #define URI_TEMPLATE_VAR_ID std::string( "id" )
 #define URI_TEMPLATE_VAR_PATH std::string( "path" )
 
-namespace atom
-{
-    struct Collection {
-        enum Type
-        {
-            Root,
-            Types,
-            Query,
-            CheckedOut,
-            Unfiled
-        };
-    };
-
-    struct UriTemplate {
-        enum Type
-        {
-            ObjectById,
-            ObjectByPath,
-            TypeById,
-            Query
-        };
+struct Collection {
+    enum Type
+    {
+        Root,
+        Types,
+        Query,
+        CheckedOut,
+        Unfiled
     };
+};
 
-    class Workspace
+struct UriTemplate {
+    enum Type
     {
-        private:
-            std::string m_id;
-            std::string m_rootId;
-
-            /// Collections URLs
-            std::map< Collection::Type, std::string > m_collections;
-
-            /// URI templates
-            std::map< UriTemplate::Type, std::string > m_uriTemplates;
-
-        public:
-            Workspace( xmlNodePtr wsNode = NULL ) throw ( libcmis::Exception );
-            Workspace( const Workspace& rCopy );
-            ~Workspace( );
-
-            Workspace& operator= ( const Workspace& rCopy );
-
-            std::string getCollectionUrl( atom::Collection::Type );
-            std::string getUriTemplate( atom::UriTemplate::Type );
-            std::string getRootId( ) { return m_rootId; }
-            std::string getId( ) { return m_id; }
-
-        private:
-            void readCollections( xmlNodeSetPtr pNodeSet );
-            void readUriTemplates( xmlNodeSetPtr pNodeSet );
+        ObjectById,
+        ObjectByPath,
+        TypeById,
+        Query
     };
-}
+};
+
+class AtomRepository : public libcmis::Repository
+{
+    private:
+        std::string m_id;
+        std::string m_rootId;
+        std::string m_name;
+
+        /// Collections URLs
+        std::map< Collection::Type, std::string > m_collections;
+
+        /// URI templates
+        std::map< UriTemplate::Type, std::string > m_uriTemplates;
+
+    public:
+        AtomRepository( xmlNodePtr wsNode = NULL ) throw ( libcmis::Exception );
+        AtomRepository( const AtomRepository& rCopy );
+        ~AtomRepository( );
+
+        AtomRepository& operator= ( const AtomRepository& rCopy );
+
+        std::string getCollectionUrl( Collection::Type );
+        std::string getUriTemplate( UriTemplate::Type );
+
+        // Repository methods
+
+        virtual std::string getRootId( ) { return m_rootId; }
+        virtual std::string getId( ) { return m_id; }
+        virtual std::string getName( ) { return m_name; }
+
+    private:
+        void readCollections( xmlNodeSetPtr pNodeSet );
+        void readUriTemplates( xmlNodeSetPtr pNodeSet );
+};
+
+typedef boost::shared_ptr< AtomRepository > AtomRepositoryPtr;
 
 #endif
--- src/libcmis/Makefile.am	2012-06-08 13:51:36.000000000 +0200
+++ src/libcmis/Makefile.am	2012-07-05 11:21:22.361674743 +0200
@@ -9,6 +9,7 @@
 	object.hxx \
 	property-type.hxx \
 	property.hxx \
+	repository.hxx \
 	session-factory.hxx \
 	session.hxx \
 	xml-utils.hxx \
@@ -32,8 +33,6 @@
 	atom-utils.cxx \
 	atom-workspace.hxx \
 	atom-workspace.cxx \
-	atom-allowable-actions.hxx \
-	atom-allowable-actions.cxx \
 	allowable-actions.cxx \
 	property.cxx \
 	property-type.cxx \
--- src/libcmis/Makefile.in	2012-06-08 14:17:01.000000000 +0200
+++ src/libcmis/Makefile.in	2012-07-05 11:21:22.361674743 +0200
@@ -80,7 +80,7 @@
 am_libcmis_@LIBCMIS_API_VERSION@_la_OBJECTS = atom-object-type.lo \
 	session-factory.lo atom-document.lo atom-folder.lo \
 	atom-object.lo atom-session.lo atom-utils.lo atom-workspace.lo \
-	atom-allowable-actions.lo allowable-actions.lo property.lo \
+	allowable-actions.lo property.lo \
 	property-type.lo xml-utils.lo
 libcmis_@LIBCMIS_API_VERSION@_la_OBJECTS =  \
 	$(am_libcmis_@LIBCMIS_API_VERSION@_la_OBJECTS)
@@ -278,6 +278,7 @@
 	object.hxx \
 	property-type.hxx \
 	property.hxx \
+	repository.hxx \
 	session-factory.hxx \
 	session.hxx \
 	xml-utils.hxx \
@@ -301,8 +302,6 @@
 	atom-utils.cxx \
 	atom-workspace.hxx \
 	atom-workspace.cxx \
-	atom-allowable-actions.hxx \
-	atom-allowable-actions.cxx \
 	allowable-actions.cxx \
 	property.cxx \
 	property-type.cxx \
@@ -417,7 +416,6 @@
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/allowable-actions.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/atom-allowable-actions.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/atom-document.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/atom-folder.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/atom-object-type.Plo@am__quote@
--- src/libcmis/makefile.mk	2012-05-09 12:14:57.000000000 +0200
+++ src/libcmis/makefile.mk	2012-07-05 11:21:22.315674740 +0200
@@ -25,7 +25,6 @@
 
 SLOFILES= \
     $(SLO)$/allowable-actions.obj \
-	$(SLO)$/atom-allowable-actions.obj \
 	$(SLO)$/atom-document.obj \
 	$(SLO)$/atom-folder.obj \
 	$(SLO)$/atom-object-type.obj \
--- src/libcmis/repository.hxx	1970-01-01 01:00:00.000000000 +0100
+++ src/libcmis/repository.hxx	2012-07-05 11:21:22.361674743 +0200
@@ -0,0 +1,54 @@
+/* libcmis
+ * Version: MPL 1.1 / GPLv2+ / LGPLv2+
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License or as specified alternatively below. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * Major Contributor(s):
+ * Copyright (C) 2011 CÃ©dric Bosdonnat <cbosdo@users.sourceforge.net>
+ *
+ *
+ * All Rights Reserved.
+ *
+ * For minor contributions see the git repository.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPLv2+"), or
+ * the GNU Lesser General Public License Version 2 or later (the "LGPLv2+"),
+ * in which case the provisions of the GPLv2+ or the LGPLv2+ are applicable
+ * instead of those above.
+ */
+#ifndef _REPOSITORY_HXX_
+#define _REPOSITORY_HXX_
+
+#include <string>
+
+#include <boost/shared_ptr.hpp>
+
+namespace libcmis
+{
+    /** Class representing a repository and its infos.
+
+        \sa 2.2.2.2 section of the CMIS specifications
+      */
+    class Repository
+    {
+        public:
+            virtual ~Repository( ) { };
+
+            virtual std::string getRootId( ) = 0;
+            virtual std::string getId( ) = 0;
+            virtual std::string getName( ) = 0;
+    };
+    
+    typedef ::boost::shared_ptr< Repository > RepositoryPtr;
+}
+
+#endif
--- src/libcmis/session-factory.cxx	2012-05-10 15:36:32.000000000 +0200
+++ src/libcmis/session-factory.cxx	2012-07-05 11:21:22.362674743 +0200
@@ -74,9 +74,9 @@
         return session;
     }
 
-    list< string > SessionFactory::getRepositories( map< int, string > params ) throw ( Exception )
+    list< RepositoryPtr > SessionFactory::getRepositories( map< int, string > params ) throw ( Exception )
     {
-        list< string > repos;
+        list< RepositoryPtr > repos;
 
         map< int, string >::iterator pIt = params.find( ATOMPUB_URL );
         if ( pIt != params.end( ) )
--- src/libcmis/session-factory.hxx	2012-05-10 15:37:03.000000000 +0200
+++ src/libcmis/session-factory.hxx	2012-07-05 11:21:22.362674743 +0200
@@ -33,6 +33,7 @@
 #include <string>
 
 #include "exception.hxx"
+#include "repository.hxx"
 #include "session.hxx"
 
 #define ATOMPUB_URL         0
@@ -63,7 +64,7 @@
               */
             static Session* createSession( std::map< int, std::string > params ) throw ( Exception );
 
-            static std::list< std::string > getRepositories( std::map< int, std::string > params ) throw ( Exception );
+            static std::list< RepositoryPtr > getRepositories( std::map< int, std::string > params ) throw ( Exception );
     };
 }
 
--- src/libcmis/session.hxx	2012-05-31 16:49:18.000000000 +0200
+++ src/libcmis/session.hxx	2012-07-05 11:21:22.362674743 +0200
@@ -34,6 +34,7 @@
 #include "object-type.hxx"
 #include "object.hxx"
 #include "folder.hxx"
+#include "repository.hxx"
 
 namespace libcmis
 {
@@ -56,6 +57,10 @@
 
             virtual ~Session() { };
 
+            /** Get the current repository.
+              */
+            virtual RepositoryPtr getRepository( ) throw ( Exception ) = 0;
+
             /** Get the Root folder of the repository
               */
             virtual FolderPtr getRootFolder() throw ( Exception )= 0;
--- src/libcmis/test-atom.cxx	2012-05-30 16:17:44.000000000 +0200
+++ src/libcmis/test-atom.cxx	2012-07-05 11:21:22.362674743 +0200
@@ -34,7 +34,6 @@
 #include "atom-document.hxx"
 #include "atom-folder.hxx"
 #include "atom-session.hxx"
-#include "atom-utils.hxx"
 
 // InMemory local test server data
 #define SERVER_ATOM_URL string( "http://localhost:8080/inmemory/atom" )
@@ -81,7 +80,7 @@
 #define TEST_UPDATED_PROPERTY_NAME string( "cmis:name" )
 #define TEST_UPDATED_PROPERTY_VALUE string( "New name" )
 
-using namespace boost;
+using boost::shared_ptr;
 using namespace std;
 
 class AtomTest : public CppUnit::TestFixture
@@ -153,9 +152,9 @@
 
 void AtomTest::getRepositoriesTest()
 {
-    list< string > ids = AtomPubSession::getRepositories( SERVER_ATOM_URL, SERVER_USERNAME, SERVER_PASSWORD );
-    CPPUNIT_ASSERT_EQUAL_MESSAGE( "One repository should be found", SERVER_REPOSITORIES_COUNT, ids.size() );
-    CPPUNIT_ASSERT_EQUAL_MESSAGE( "Wrong repository found", SERVER_REPOSITORY, ids.front() );
+    list< libcmis::RepositoryPtr > repos = AtomPubSession::getRepositories( SERVER_ATOM_URL, SERVER_USERNAME, SERVER_PASSWORD );
+    CPPUNIT_ASSERT_EQUAL_MESSAGE( "One repository should be found", SERVER_REPOSITORIES_COUNT, repos.size() );
+    CPPUNIT_ASSERT_EQUAL_MESSAGE( "Wrong repository found", SERVER_REPOSITORY, repos.front()->getId() );
 }
 
 void AtomTest::sessionCreationTest( )
@@ -164,29 +163,29 @@
 
     // Check for the mandatory collection URLs
     CPPUNIT_ASSERT_MESSAGE( "root collection URL missing",
-            !session.getWorkspace().getCollectionUrl( atom::Collection::Root ).empty() );
+            !session.getAtomRepository()->getCollectionUrl( Collection::Root ).empty() );
     CPPUNIT_ASSERT_MESSAGE( "types collection URL missing",
-            !session.getWorkspace().getCollectionUrl( atom::Collection::Types ).empty() );
+            !session.getAtomRepository()->getCollectionUrl( Collection::Types ).empty() );
     CPPUNIT_ASSERT_MESSAGE( "query collection URL missing",
-            !session.getWorkspace().getCollectionUrl( atom::Collection::Query ).empty() );
+            !session.getAtomRepository()->getCollectionUrl( Collection::Query ).empty() );
 
     // The optional collection URLs are present on InMemory, so check them
     CPPUNIT_ASSERT_MESSAGE( "checkedout collection URL missing",
-            !session.getWorkspace().getCollectionUrl( atom::Collection::CheckedOut ).empty() );
+            !session.getAtomRepository()->getCollectionUrl( Collection::CheckedOut ).empty() );
     CPPUNIT_ASSERT_MESSAGE( "unfiled collection URL missing",
-            !session.getWorkspace().getCollectionUrl( atom::Collection::Unfiled ).empty() );
+            !session.getAtomRepository()->getCollectionUrl( Collection::Unfiled ).empty() );
 
     // Check for the mandatory URI template URLs
     CPPUNIT_ASSERT_MESSAGE( "objectbyid URI template URL missing",
-            !session.getWorkspace().getUriTemplate( atom::UriTemplate::ObjectById ).empty() );
+            !session.getAtomRepository()->getUriTemplate( UriTemplate::ObjectById ).empty() );
     CPPUNIT_ASSERT_MESSAGE( "objectbypath URI template URL missing",
-            !session.getWorkspace().getUriTemplate( atom::UriTemplate::ObjectByPath ).empty() );
+            !session.getAtomRepository()->getUriTemplate( UriTemplate::ObjectByPath ).empty() );
     CPPUNIT_ASSERT_MESSAGE( "typebyid URI template URL missing",
-            !session.getWorkspace().getUriTemplate( atom::UriTemplate::TypeById ).empty() );
+            !session.getAtomRepository()->getUriTemplate( UriTemplate::TypeById ).empty() );
     
     // The optional URI template URL is present on InMemory, so check it
     CPPUNIT_ASSERT_MESSAGE( "query URI template URL missing",
-            !session.getWorkspace().getUriTemplate( atom::UriTemplate::Query ).empty() );
+            !session.getAtomRepository()->getUriTemplate( UriTemplate::Query ).empty() );
 
     // Check that the root id is defined
     CPPUNIT_ASSERT_MESSAGE( "Root node ID is missing",
