{
  "comments": [
    {
      "key": {
        "uuid": "AAAAVH///zc\u003d",
        "filename": "sc/source/ui/view/cellsh1.cxx",
        "patchSetId": 1
      },
      "lineNbr": 1287,
      "author": {
        "id": 1000065
      },
      "writtenOn": "2013-02-05T20:34:53Z",
      "side": 1,
      "message": "have to admit, I don\u0027t understand the check here to disable shift :-/ maybe if you could explain the rationale in more detail for me ( who is probably just being stupid )",
      "revId": "756e56600d7af1028960225ca19743d8b06bf650",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAAVH///x4\u003d",
        "filename": "sc/source/ui/view/cellsh1.cxx",
        "patchSetId": 1
      },
      "lineNbr": 1287,
      "author": {
        "id": 1000057
      },
      "writtenOn": "2013-02-06T07:55:07Z",
      "side": 1,
      "message": "(It took me a month to understand what this code was supposed to do, so who is being stupid here?:).\nFirst, I find out if the destination is 1 cell or a range, and if the source area is large than the selected destination area [1271-1279]. The largest area of these is taken for the comparisons [1282-1283], as this will be the actual destination area (copy/paste some blocks and you will see what I mean if my text is not clear).\nThe first comparison is whether source and destination area overlap [1284-1288]. When the source area contains references, these probably will go wrong when there is an overlap. As this may produce data loss (e.g. formulas that get wrong references), it _must_ be avoided. This code was there from the beginning, but with errors, disabling the wrong options. My first patch fixed only a part of that.\nThe second comparison [1294-1327] handles something else, the question whether shifting the cells in the destination area will fit on the sheet. This comparison is not necessary for integrity, but for user friendliness. Without the comparison, the user will get a message that the result will not fit and no harm is done. Rainer Bielefeld wanted the possibilty of fitting on the sheet reflected in the en/disabling of the shift options.\nI do this check by going from the MAXCOL/MAXROW position back for the width/height of the destination area and checking if the cells are empty. If not, paste+shift will not fit and the appropiate shit option is disabled.\nI feared a performance penalty with this method, but I tested it on an old. slow machine (complete build of Libreofiice takes 24hrs) with a destination area almost MAXROW high and that gave no noticeable delay.\nBut because of this performance penalty danger, i want you to have a good look at the code. Perhaps it will be safer to leave it out, perhaps there are more efficient ways to check the fitting.\n\nI hope my proze give you the explanation you want.\nPerhaps I should put some of it in the code as comment?",
      "parentUuid": "AAAAVH///zc\u003d",
      "revId": "756e56600d7af1028960225ca19743d8b06bf650",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAAVH///xE\u003d",
        "filename": "sc/source/ui/view/cellsh1.cxx",
        "patchSetId": 1
      },
      "lineNbr": 1287,
      "author": {
        "id": 1000065
      },
      "writtenOn": "2013-02-06T10:56:22Z",
      "side": 1,
      "message": "it was the [1284-1288] test that was causing me confusion.\nOk I can\u0027t comment on whether that rationale for preventing the shift is sensible or not ( and yes I can see the old code does similar ) but now at least I understand what you are trying to do :-) How about though we make the intention even clearer by replacing  [1284-1288] with some range manipulation and some comments e.g.\n\n/* When the source and destination areas intersect things may go wrong especially if the area contains references. This may produce data loss (e.g. formulas that get wrong references), this scenario _must_ be avoided.*/\n\n     ScRange aSource( nStartX, nStartY, nStartTab, nStartX + nRangeSizeX, nStartY + nRangeSizeY, nEndTab );\n    ScRange aDest( nClipStartX, nClipStartY, nStartTab, nClipStartX + nRangeSizeX, nClipStartY + nRangeSizeY, nEndTab );\n    if ( aSource.Intersects( aDest ) )\n        pDlg-\u003eSetCellShiftDisabled( SC_CELL_SHIFT_DISABLE_DOWN | SC_CELL_SHIFT_DISABLE_RIGHT );",
      "parentUuid": "AAAAVH///x4\u003d",
      "revId": "756e56600d7af1028960225ca19743d8b06bf650",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAAVH///zQ\u003d",
        "filename": "sc/source/ui/view/cellsh1.cxx",
        "patchSetId": 1
      },
      "lineNbr": 1297,
      "author": {
        "id": 1000065
      },
      "writtenOn": "2013-02-05T20:34:53Z",
      "side": 1,
      "message": "I don\u0027t like the following loops :-) I don\u0027t think they are performance killers per se but there are already such loops already in the code, you should use those instead, take a look at ScDocument::FindAreaPos, you can use that to find the next cell with content ( in any direction ) from any start point.",
      "revId": "756e56600d7af1028960225ca19743d8b06bf650",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAAVH///x0\u003d",
        "filename": "sc/source/ui/view/cellsh1.cxx",
        "patchSetId": 1
      },
      "lineNbr": 1297,
      "author": {
        "id": 1000057
      },
      "writtenOn": "2013-02-06T07:55:07Z",
      "side": 1,
      "message": "I agree, I don\u0027t like the loops either. But I see no alternative. To check if opy+paste will fit, I must check that every cell that will be shifted off the sheet is empty. \nI looked at your suggestion, and possibly ScTable::FindAreaPos will make the code easier to read (but a row-loop must be maintained when checking the cols and vice versa). It will not make the code more efficient, but probably more robust.\nI don\u0027t have a strong preference for one of the other (perhaps a slight preference for FindAreaPos because of the extra robustness).",
      "parentUuid": "AAAAVH///zQ\u003d",
      "revId": "756e56600d7af1028960225ca19743d8b06bf650",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAAVH///xM\u003d",
        "filename": "sc/source/ui/view/cellsh1.cxx",
        "patchSetId": 1
      },
      "lineNbr": 1297,
      "author": {
        "id": 1000065
      },
      "writtenOn": "2013-02-06T10:56:22Z",
      "side": 1,
      "message": "Well I did realise that your loop does possibly exit earlier than ScTable::FindAreaPos does but really it shouldn\u0027t matter. ScTable::FindAreaPos should be performant enough. Afterall, it is used when you do cntrl-[up|down|left|right] to navigate to next non-empty cell. If that operation already is apparenly slow to the user ( even when used at the extremes of the sheet ranges ) then imho it should be tweaked. The beauty of code reuse is that any users of that method will benefit from any changes. Also afaik the code here to detect the range limitation is only called from this paste special cntx menu right? I mean its nothing called thousands of times as part of some calculation code or whatever",
      "parentUuid": "AAAAVH///x0\u003d",
      "revId": "756e56600d7af1028960225ca19743d8b06bf650",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615",
      "unresolved": false
    }
  ]
}