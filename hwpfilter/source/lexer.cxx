/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
 * This file is part of the LibreOffice project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * This file incorporates work covered by the following license notice:
 *
 *   Licensed to the Apache Software Foundation (ASF) under one or more
 *   contributor license agreements. See the NOTICE file distributed
 *   with this work for additional information regarding copyright
 *   ownership. The ASF licenses this file to you under the Apache
 *   License, Version 2.0 (the "License"); you may not use this file
 *   except in compliance with the License. You may obtain a copy of
 *   the License at http://www.apache.org/licenses/LICENSE-2.0 .
 */

/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 */
#ifndef YY_STACK_USED
#define YY_STACK_USED 0
#endif
#ifndef YY_ALWAYS_INTERACTIVE
#define YY_ALWAYS_INTERACTIVE 0
#endif
#ifndef YY_NEVER_INTERACTIVE
#define YY_NEVER_INTERACTIVE 0
#endif
#ifndef YY_MAIN
#define YY_MAIN 0
#endif

#include <stdio.h>

#include <stdlib.h>
#ifndef _WIN32
#include <unistd.h>
#else
#include <io.h>
#endif


/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) (static_cast<unsigned int>(static_cast<unsigned char>(c)))

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.
 */
#define YY_START ((yy_start - 1) / 2)

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 16384

namespace {

typedef struct yy_buffer_state *YY_BUFFER_STATE;

}

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

//#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;

namespace {

struct yy_buffer_state
    {
    FILE *yy_input_file;

    char *yy_ch_buf;        /* input buffer */
    char *yy_buf_pos;       /* current position in input buffer */

    /* Size of input buffer in bytes, not including room for EOB
     * characters.
     */
    yy_size_t yy_buf_size;

    /* Number of characters read into yy_ch_buf, not including EOB
     * characters.
     */
    int yy_n_chars;

    /* Whether we "own" the buffer - i.e., we know we created it,
     * and can realloc() it to grow it, and should free() it to
     * delete it.
     */
    int yy_is_our_buffer;

    /* Whether this is an "interactive" input source; if so, and
     * if we're using stdio for input, then we want to use getc()
     * instead of fread(), to make sure we stop fetching input after
     * each newline.
     */
    bool yy_is_interactive;

    /* Whether we're considered to be at the beginning of a line.
     * If so, '^' rules will be active on the next match, otherwise
     * not.
     */
    int yy_at_bol;

    /* Whether to try to fill the input buffer when we reach the
     * end of it.
     */
    int yy_fill_buffer;

    int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
    /* When an EOF's been seen but there's still some text to process
     * then we mark the buffer as YY_EOF_PENDING, to indicate that we
     * shouldn't try reading from the input source any more.  We might
     * still have a bunch of tokens to match, though, because of
     * possible backing-up.
     *
     * When we actually see the EOF, we change the status to "new"
     * (via yyrestart()), so that the user can continue scanning by
     * just pointing yyin at a new input file.
     */
#define YY_BUFFER_EOF_PENDING 2
    };

}

static YY_BUFFER_STATE yy_current_buffer = nullptr;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars;      /* number of characters read into yy_ch_buf */


static int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = nullptr;
static int yy_init = 1;     /* whether we need to initialize */
static int yy_start = 0;    /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

static void yyrestart YY_PROTO(( FILE *input_file ));

static void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
static void yy_load_buffer_state YY_PROTO(( ));
static YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
static void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
static void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
static void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));

static YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
static YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
static YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));

static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

typedef unsigned char YY_CHAR;
static FILE *yyin = nullptr, *yyout = nullptr;
typedef int yy_state_type;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state YY_PROTO(( ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
static int yy_get_next_buffer YY_PROTO(( ));
[[noreturn]] static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
    yytext_ptr = yy_bp; \
    yyleng = static_cast<int>(yy_cp - yy_bp); \
    yy_hold_char = *yy_cp; \
    *yy_cp = '\0'; \
    yy_c_buf_p = yy_cp;

#define YY_END_OF_BUFFER 46
yyconst short int yy_accept[994] =
    {   0,
        0,    0,   46,   44,   41,   41,   44,   42,   39,   37,
       37,   36,   39,   39,   44,   44,   38,   40,   35,   43,
       13,   21,   36,   36,   22,   16,   17,    0,   34,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   24,    0,   24,    0,    0,    0,    0,    0,
        7,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   42,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    4,   31,    5,   43,
       36,   20,   14,   15,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,   24,    0,    0,    0,

        0,    0,    0,   10,    0,    0,   27,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,   12,   12,    0,    0,
        0,    0,    0,    0,    0,   12,    0,    0,    0,    0,
        0,    0,    0,    0,   12,    0,   27,    0,    0,    0,
        0,    0,    0,    0,    0,   11,    0,    9,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   23,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,   19,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   18,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    8,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   27,
       27,    0,    0,    0,    0,   12,    0,    0,    8,    0,

        0,    0,    2,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,   27,   26,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   27,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,   12,   27,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   27,
        0,    0,   27,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,   11,    0,    0,    0,    0,    0,    0,    8,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   29,
        0,    0,    0,    0,    0,    0,   24,    0,    0,    0,
        0,    0,    0,    0,    0,    3,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,   30,    0,    0,
       12,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   28,    0,    0,   12,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
       19,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        1,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,   25,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    6,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,   32,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,   12,    0,   12,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,   11,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,   33,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,   19,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   12,   12,    0,   24,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   19,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0

    } ;

yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    4,    1,    1,    1,    1,    5,    1,    6,
        7,    8,    8,    9,   10,   11,    8,   12,   12,   12,
       12,   12,   12,   12,   12,   12,   12,   13,   14,   15,
       16,   17,    1,    1,   18,   19,   20,   21,   22,    1,
       23,    1,   24,   25,   26,   27,   28,   29,   30,   31,
        1,   32,   33,   34,   35,   36,    1,   37,    1,   38,
       39,   40,   41,   42,   42,    1,   43,   44,   45,   46,

       47,   48,   49,   50,   51,   52,   53,   54,   55,   56,
       57,   58,   59,   60,   61,   62,   63,   64,   65,   66,
       67,   68,   69,   70,   71,   72,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,

       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,    1
    } ;

yyconst int yy_meta[74] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1
    } ;

yyconst short int yy_base[995] =
    {   0,
        0,   72, 1314, 1315, 1315, 1315, 1297, 1315, 1315, 1315,
     1295,    2,    8, 1294, 1281,  142, 1315, 1315, 1315, 1236,
     1315, 1315, 1296,    8, 1290, 1291, 1288, 1274, 1315,    0,
        0, 1253,    1,    1, 1259,    7, 1244, 1257,    8, 1236,
     1235, 1242,   35,   43, 1245,    0, 1237, 1251, 1242, 1245,
     1315,   46,   72,  171,   79,   62,   77,  184,  192,   92,
     1236,    2,  207,  216,  225,  234,  250,   46,  269,  278,
      295,   10,  111,  255,   10, 1243, 1315, 1315, 1315, 1216,
     1276, 1315, 1315, 1315, 1253, 1228, 1225, 1222, 1217, 1231,
     1227, 1237, 1214, 1217, 1234, 1221, 1315, 1213, 1223, 1215,

     1217, 1223, 1214, 1315,  168, 1218, 1315, 1217, 1210, 1217,
     1216, 1201, 1216,  177, 1202, 1199, 1197,   34, 1216, 1209,
     1199,  181,   36,  164,  198, 1207,  119,  199, 1201, 1196,
     1196,  218, 1192, 1188,  225, 1205, 1191,   78,   40,  245,
      280, 1197,  175, 1184, 1192, 1187, 1198, 1182, 1179, 1198,
      101, 1197, 1179,  227, 1183, 1191, 1177, 1315, 1192, 1172,
     1190, 1189,   53, 1184, 1187,  260, 1167, 1171, 1184, 1168,
     1165,  248, 1177, 1166,  291, 1168, 1161, 1174, 1164, 1161,
      222,  268, 1160,    0, 1170, 1315, 1172, 1315,  247,  299,
     1152, 1170, 1155, 1155,  300, 1156, 1155, 1157, 1160, 1146,

     1145, 1153,  302, 1152, 1139, 1158, 1144, 1152, 1147, 1143,
     1136,  308, 1146, 1137, 1150, 1136,  317, 1148,  308,  318,
     1147,  311, 1146,  322, 1145,  312, 1140,  319, 1128, 1134,
      324,  340, 1124,  333,  340, 1137, 1136, 1121, 1118, 1315,
     1129, 1121, 1134, 1114, 1120, 1118, 1122, 1117, 1128, 1114,
     1111, 1124, 1105, 1117, 1116, 1119, 1113, 1107, 1099, 1100,
     1102, 1107,  344, 1114, 1094, 1097, 1104, 1099,  327, 1092,
      347, 1094, 1095, 1096, 1315, 1105, 1096, 1103,  350, 1083,
     1099, 1079, 1088, 1079, 1095, 1094, 1094, 1088, 1076, 1085,
     1084, 1084, 1082, 1082, 1068, 1067, 1073, 1071, 1079, 1069,

     1069, 1061, 1315, 1071, 1070, 1059, 1057, 1075, 1072, 1051,
     1060, 1050, 1053, 1052, 1058, 1054,  348, 1047, 1315, 1065,
     1045, 1048, 1061, 1055, 1052, 1040, 1039, 1043, 1042,  338,
     1035, 1048, 1035, 1048, 1038, 1039, 1029, 1031,  276, 1030,
     1027, 1026, 1038,  371, 1023, 1042, 1029, 1023,  355, 1024,
     1036, 1025,  372, 1036, 1032, 1028, 1025, 1020, 1017, 1016,
     1022, 1008, 1014, 1020, 1008, 1012, 1006, 1010, 1017, 1013,
     1008, 1007, 1014,  360,  997,  995,  997,  995, 1010,  372,
     1008,  993, 1002,  156, 1005, 1003, 1006, 1001,  997,  996,
      985,  987,  980,  991,  374,  980,  978,  977,  989,  990,

      993,  992,  969,  990,  975,  988,  976,  986,  985,  981,
      379,  191,  983,  965,  962,  980,  979,  961,  955,  965,
      960,  374,  967,  965,  965,  967,  963,  969,  962,  963,
      947,  951,  950,  955,  962,  939,  945,  941,  938,  944,
      377,  383,  940,  938,  939,  949,  948,  943,  946,  945,
      944,  929,  936,  927,  930,  939,  921,  935,  922,  939,
      924,  933,  920,  935,  910,  922,  911,  912,  919, 1315,
      916,  928,  923,  907,  388,  906,  920,  916,  898,  914,
      920,  916,  907,  906,  898,  400,  901,  894,  900,  892,
      893,  392,  891,  898,  902,  907,  889,  888,  891,  895,

      885,  901,  883,  879,  880,  879,  892,  405,  884,  886,
      889,  888,  872,  887,  878,  877,  887,  872,  865,  865,
      865,  876,  870,  863,  871,  863,  877,  860,  864,  870,
      869,  857,  856, 1315,  400,  866,  865,  851,  863,  849,
      861,  864,  859,  844,  848,  843,  856,  855,  840,  834,
      837,  843,  838,  403,  845,  843,  843,  834,  841,  829,
     1315,  842,  401,  824,  831,  826,  828,  841,  823,  831,
      834,  829,  822,  835,  820,  820,  818,  813,  822,  815,
      822,  823,  809,  802,  806,  810,  809,  800,  809,  801,
     1315,  803,  800,  801,  404,  807,  803,  805,  810,  803,

      799,  805,  805,  803,  785,  786, 1315,  784,  800,  785,
      797,  787,  782,  780,  783,  778,  784,  776,  789,  784,
      783,  790,  785,  771,  787,  778,  768,  769,  778,  767,
      762,  776,  779,  770,  763,  758,  764,  774,  759,   93,
      126,  187,  225,  269,  333,  415,  345,  372,  388,  397,
      400,  417,  418,  408,  411,  427,  409,  418,  426,  417,
      419,  415,  417,  418,  419,  419,  423,  422,  422,  428,
      438,  438,  444,  432,  434,  434,  431,  442,  437,  446,
      449,  436,  456,  449,  454,  456,  443,  448,  445,  457,
      459,  459,  453,  450,  446,  469,  457,  463,  460,  454,

      460,  471,  476,  473,  476,  458,  461,  468,  462,  471,
      484,  485,  466,  481,  484,  481,  473,  488,  475,  489,
      481,  475,  491,  491,  496,  482,  483,  495, 1315,  502,
      498,  490,  500,  503,  497,  487,  488,  498,  512,  508,
      501,  509,  512,  506,  514,  502,  520,  521,  518,  501,
      504,  505,  506,  523,  524,  525,  526,  527,  510,  519,
      523,  518,  528,  515,  538,  526,  532,  529,  523,  535,
      525,  534,  529,  533,  534,  542,  531,  544,  535,  536,
      543,  555,  556,  545,  541,  541,  540,  543,  558,  548,
      549,  552,  548,  563,  551,  550,  552,  557,  553,  565,

      555,  568,  576,  563,  563,  572,  578,  562,  564,  576,
      582,  566,  582,  580,  577,  572,  573,  589,  574,  581,
      586,  576,  577,  581,  579,  583,  583,  597,  602,  590,
      587,  594,  606,  607,  597, 1315,  606,  591,  589,  590,
      594,  614,  596,  602,  600,  604,  600,  613,  603,  604,
      617,  605,  605,  604,  608,  628,  610,  619,  610,  619,
      615,  628,  636,  618,  619,  635,  640,  622,  628,  628,
      637,  626,  642,  643,  644,  646,  648,  647,  635,  640,
      641,  652,  658,  642,  652,  661,  640,  650,  652,  655,
      659,  651,  669,  656,  671,  668,  656,  666,  661,  676,

      660,  678,  657,  666,  677,  666,  667,  680,  677,  682,
      673,  675,  676,  673,  674,  686,  676,  672,  691,  677,
      680,  681,  686,  683,  684,  696,  686,  687,  688,  692,
      702,  702,  687,  693,  697,  705,  696,  711,  701,  699,
      714,  701,  705,  713,  704,  708,  706,  711,  706,  719,
      713,  706,  710,  716,  718,  718,  713,  722,  723,  723,
      725,  718,  722,  728,  721,  730,  742,  727,  725,  748,
      727,  728,  729,  730,  731,  754,  733,  734,  743,  743,
      742,  747,  748,  746,  742,  748,  749,  754,  754,  755,
      748,  749, 1315,  814

    } ;

yyconst short int yy_def[995] =
    {   0,
      994,  994,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,

      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,

      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,

      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,

      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,

      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,

      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,

      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,

      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,

      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,    0,  993

    } ;

yyconst short int yy_nxt[1389] =
    {   0,
      993,    5,    6,    7,    8,    9,    9,   10,  993,   11,
      993,   12,   23,   24,   13,   10,   14,   25,   23,   24,
      993,  993,   26,  993,  993,  993,   15,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,    9,   16,
        9,   17,  112,  993,  170,  158,   88,   91,  171,  113,
      101,   92,  993,   86,  102,  107,   89,   93,   94,   87,
      188,   97,   95,   98,  103,  231,  238,  232,    9,   18,
        9,   19,   20,    5,    6,    7,    8,    9,    9,   10,
      266,   11,  294,   12,  106,  104,   13,   10,   14,   97,
      117,  267,  109,  110,  107,  108,  295,  186,   15,  118,

      119,  120,  273,  121,  205,  122,  123,  107,  206,  315,
        9,   16,    9,   17,  124,  145,  146,  147,  125,  148,
      149,  138,  126,  150,  139,  140,  292,  151,  127,  141,
      152,  128,  142,  153,  129,  143,  154,  164,  293,  144,
        9,   18,    9,   19,   20,   29,  165,  166,  167,  737,
       29,  306,  168,  233,   29,   29,  234,  235,  107,   30,
       31,   32,   33,   34,   35,   36,   37,   38,   39,   40,
       41,   42,   43,   44,   45,   46,   47,   48,   49,   50,
       97,   51,  738,  280,   52,   53,   54,   55,   56,   57,
       58,   59,   60,   61,   62,   63,   64,   65,   66,   67,

       68,   69,   70,   71,   72,   73,   74,   75,  274,   76,
       77,   78,   79,  130,  255,  541,  131,  542,  256,  260,
      132,  133,  261,  275,  134,  271,  155,  135,  156,  107,
      157,  136,  158,  137,  160,  161,  299,  262,  162,  300,
      272,  281,  276,  159,  571,  282,  277,  186,  163,  172,
      572,  173,  174,  175,  176,  177,  178,  179,  182,  278,
      158,  180,  107,  181,  285,  183,  184,  189,  188,  309,
      107,  190,  185,  186,  186,  158,  187,  332,  188,  193,
      288,  191,  289,  310,  194,  290,  291,  188,  195,  192,
      336,  196,  200,  107,  197,  198,  201,  199,  296,  202,

      188,  236,  323,  324,  186,  237,  107,  318,  337,  203,
      204,  207,   97,  208,  186,  209,  210,  211,  212,  213,
      216,  319,  297,  214,  217,  333,  499,  218,  219,  186,
      215,  500,  220,  107,  107,  221,  222,  226,  327,  223,
      224,  338,  225,  186,  227,  228,  343,   97,  351,  158,
      344,  229,  352,  186,  230,  374,  368,  158,  353,  365,
      371,  107,  369,  370,  188,  378,  379,  383,  372,  388,
      375,  376,  385,  386,  188,  396,  319,  389,  366,  380,
      430,  381,  391,  390,  275,  392,  186,  431,  489,  397,
      421,  433,  739,  393,  441,  742,  477,  509,  490,  398,

      394,  422,  532,  423,  424,  425,  442,  434,  435,  478,
      443,  444,  445,  446,  447,  503,  510,  319,  538,  592,
      553,  569,  533,  579,  104,  743,  504,  593,  595,  513,
      744,  554,  539,  555,  556,  557,  558,  596,  570,  594,
      597,  619,  624,  664,  598,  632,  633,  620,  645,  625,
      683,  634,  678,  188,  706,  158,  158,  665,  646,  626,
      707,  740,  684,   79,  647,  741,  745,   79,  729,  746,
      748,  749,   97,  750,  751,  752,  747,  753,  754,  755,
      756,  158,  757,  758,  759,  760,  761,  762,  764,  765,
      766,  767,  188,  188,  768,  769,  770,  763,  771,  772,

      773,   97,  774,  104,  775,  776,  777,  778,  104,  779,
      561,  780,  104,  781,  782,  783,  784,  785,  786,  158,
      186,  319,  319,  787,  788,  789,  790,  792,  793,  794,
      795,  796,  186,  797,  798,  799,  188,  800,  801,  802,
      803,  804,  805,  806,  807,  808,  791,  809,  810,   97,
       97,  561,  561,  188,  811,  812,  813,  814,  815,   97,
      158,  816,  817,  818,   97,  561,  819,  820,  821,  822,
      823,  824,  825,  826,  561,  827,  828,  829,  830,  561,
      831,  188,  832,  833,  834,  835,  836,  837,  838,  839,
      840,  841,  842,  843,  844,  845,  846,  104,  104,   97,

      847,  848,  849,  319,  850,  319,  319,  851,  319,  319,
      852,   97,  853,  854,   97,  855,  856,  857,  858,  859,
      860,  861,  862,  863,  864,  865,  866,  867,  836,  868,
      158,  869,  870,  871,  186,  319,  872,  873,  874,  158,
      158,  158,  875,  876,  877,  878,  879,  880,  188,  188,
      881,  882,  729,  561,  561,  883,  884,  886,  887,  888,
      889,  729,   78,  319,  319,  890,  729,  891,  561,   97,
      892,  893,  158,  885,  561,  894,  895,  896,  897,  899,
      900,  836,  901,  902,  903,  904,  905,   97,  906,  907,
      158,   97,  910,  836,  911,  898,  912,  913,  836,  908,

      914,  915,  916,  917,  561,  909,  918,  104,  919,  920,
      921,  922,  923,  924,  729,  925,  926,  561,  927,  928,
      929,  561,  930,  729,  158,  158,  931,  932,  836,  933,
      188,  188,  934,  935,  936,  937,  561,  938,   97,  939,
      940,  941,  942,  943,  944,  945,  946,  947,  948,  949,
      950,  561,  951,  952,  953,  954,  955,  957,  958,  959,
      961,  962,  963,  964,  965,  966,  967,  186,  968,  969,
      561,  970,  971,  956,  972,  186,  960,  561,  973,  974,
      561,  975,  561,  976,  977,  836,  978,  979,  186,  561,
      981,  561,  982,  561,  983,  561,  984,  561,  836,  985,

      561,  986,  186,  561,  980,  987,  988,  989,  990,  561,
      991,  992,  561,  561,    4,  736,  735,  734,  158,  561,
      733,  732,  731,  730,  107,  107,  729,   77,  728,  727,
      726,   77,  188,  725,  724,  723,  722,   97,   97,  721,
      720,  719,  718,  717,  186,  319,  716,  186,  715,  158,
      714,  319,  713,  712,  711,  710,  709,  708,  319,  705,
      319,  704,  703,  702,  107,  107,  107,  158,  701,  700,
      699,  104,  104,  698,  697,  696,  695,  694,  693,  692,
      691,  690,  689,  104,  688,  687,  686,  685,  186,  607,
      158,  682,  681,  680,  679,  677,  676,  186,  675,  674,

      186,  186,  673,  672,  186,  275,  188,  671,  670,  669,
      668,  667,  666,  186,  186,  663,  158,  662,  158,  188,
       97,  661,  660,  659,  658,  657,  656,  655,  654,  653,
       79,  652,   29,  651,   97,  650,  649,  648,  644,  643,
      186,  642,  641,  188,  640,  158,  158,  639,  638,   97,
      637,  636,  635,  631,  630,  629,  628,  627,  607,   77,
      623,  622,  188,   97,  607,   97,  158,  621,  618,  275,
      188,  158,  617,  616,  158,  615,  614,  613,  158,  561,
      612,  188,  607,  611,  158,  610,  609,  608,  275,  607,
      606,  275,  605,  604,  603,  602,  601,  600,  599,  591,

      590,  589,  158,  588,  587,  586,  585,  584,  583,   97,
      186,  188,   97,  275,  582,  581,  580,  578,  577,  576,
      575,  104,  104,  574,  573,  104,  568,  104,  104,  567,
      566,  565,  104,  564,  104,  188,  563,  562,  561,  560,
      559,  552,  551,  550,  549,  548,  547,  546,  545,  544,
      543,  107,  540,   97,  537,  536,  186,  535,  534,  531,
      530,  529,  107,  528,  527,  526,  525,  524,  523,  522,
      521,  520,  519,  518,  517,  516,  515,   29,  514,  512,
      511,  158,  508,  507,  506,  505,  502,  319,  186,  501,
      498,  497,  496,  495,  494,  493,  492,  491,  488,  487,

      486,  485,  484,  483,  482,  481,  480,  188,  479,  476,
      475,  474,   97,  473,  472,  471,  470,  469,   97,  468,
      467,  466,  465,  186,  464,  463,  462,  461,  460,  459,
      458,  457,  456,  107,  107,  455,  158,  454,  186,  453,
      452,  451,  450,  449,  448,  188,  440,  439,  438,  437,
      436,  432,  429,  428,  427,  426,  104,  420,  419,  418,
      417,  416,  415,  414,  413,  412,  411,  410,  409,  158,
      104,  408,  407,  406,  405,  404,  104,  403,  402,  401,
      158,  400,  399,  395,  387,   97,  384,  382,  377,  373,
      367,  364,  363,  362,  361,  360,  359,  358,  357,  356,

      355,  354,  188,  188,  350,  349,  348,  347,  346,  345,
      342,  341,  340,  339,  335,  334,   97,  331,  330,  186,
      329,  328,  326,  325,  107,  322,  321,  158,  320,  317,
      316,  314,  313,  275,  312,  158,  107,  311,  308,  307,
      188,  305,  304,  303,  302,   97,  301,  298,  186,  107,
      287,  286,  284,  186,  283,  279,  270,  269,  268,  265,
      264,  263,  259,  104,  258,  257,  104,  104,  104,  254,
      253,  252,  251,  250,  249,  248,  104,  247,  246,  245,
      244,  104,   97,  243,  242,  241,  240,   81,   80,  239,
      169,  116,  104,  115,  114,  111,  105,  104,  104,  100,

       99,   96,   90,   85,   84,   83,   82,   81,   80,   28,
       27,   22,   21,  993,    3,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993
    } ;

yyconst short int yy_chk[1389] =
    {   0,
        0,    1,    1,    1,    1,    1,    1,    1,    0,    1,
        0,    1,   12,   12,    1,    1,    1,   13,   24,   24,
        0,    0,   13,    0,    0,    0,    1,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    1,    1,
        1,    1,   46,    0,   62,  184,   31,   33,   62,   46,
       39,   33,    0,   30,   39,  184,   31,   33,   34,   30,
       75,   36,   34,   36,   39,   72,   75,   72,    1,    1,
        1,    1,    1,    2,    2,    2,    2,    2,    2,    2,
      118,    2,  139,    2,   43,   43,    2,    2,    2,   44,
       52,  118,   44,   44,   43,   43,  139,  123,    2,   52,

       52,   52,  123,   52,   68,   52,   52,  163,   68,  163,
        2,    2,    2,    2,   53,   56,   56,   56,   53,   56,
       56,   55,   53,   56,   55,   55,  138,   56,   53,   55,
       57,   53,   55,   57,   53,   55,   57,   60,  138,   55,
        2,    2,    2,    2,    2,   16,   60,   60,   60,  640,
       16,  151,   60,   73,   16,   16,   73,   73,  151,   16,
       16,   16,   16,   16,   16,   16,   16,   16,   16,   16,
       16,   16,   16,   16,   16,   16,   16,   16,   16,   16,
      127,   16,  641,  127,   16,   16,   16,   16,   16,   16,
       16,   16,   16,   16,   16,   16,   16,   16,   16,   16,

       16,   16,   16,   16,   16,   16,   16,   16,  124,   16,
       16,   16,   16,   54,  105,  384,   54,  384,  105,  114,
       54,   54,  114,  124,   54,  122,   58,   54,   58,  122,
       58,   54,   58,   54,   59,   59,  143,  114,   59,  143,
      122,  128,  125,   58,  412,  128,  125,  642,   59,   63,
      412,   63,   63,   63,   63,   63,   63,   63,   64,  125,
       63,   63,   63,   63,  132,   64,   64,   65,  132,  154,
      181,   65,   64,   64,  643,   65,   64,  181,   64,   66,
      135,   65,  135,  154,   66,  135,  135,   65,   66,   65,
      189,   66,   67,  140,   66,   66,   67,   66,  140,   67,

       67,   74,  172,  172,   67,   74,  140,  166,  189,   67,
       67,   69,   74,   69,   74,   69,   69,   69,   69,   69,
       70,  166,  141,   69,   70,  182,  339,   70,   70,  644,
       69,  339,   70,  182,  141,   70,   70,   71,  175,   70,
       70,  190,   70,  141,   71,   71,  195,  190,  203,  175,
      195,   71,  203,  212,   71,  222,  219,  190,  203,  217,
      220,  217,  219,  219,  212,  224,  224,  226,  220,  231,
      222,  222,  228,  228,  226,  234,  224,  231,  217,  224,
      269,  224,  232,  231,  235,  232,  235,  269,  330,  234,
      263,  271,  645,  232,  279,  647,  317,  349,  330,  235,

      232,  263,  374,  263,  263,  263,  279,  271,  271,  317,
      279,  279,  279,  279,  279,  344,  349,  353,  380,  441,
      395,  411,  374,  422,  422,  648,  344,  441,  442,  353,
      649,  395,  380,  395,  395,  395,  395,  442,  411,  441,
      442,  475,  486,  535,  442,  492,  492,  475,  508,  486,
      563,  492,  554,  554,  595,  650,  651,  535,  508,  486,
      595,  646,  563,  652,  508,  646,  653,  654,  655,  656,
      657,  658,  659,  660,  661,  662,  656,  663,  664,  665,
      666,  667,  668,  669,  670,  671,  672,  673,  674,  675,
      676,  677,  678,  679,  680,  681,  682,  673,  683,  684,

      685,  686,  687,  688,  689,  690,  691,  692,  693,  694,
      695,  696,  697,  698,  699,  700,  701,  702,  703,  704,
      705,  706,  707,  708,  709,  710,  711,  712,  713,  714,
      715,  716,  717,  718,  719,  720,  721,  722,  723,  724,
      725,  726,  727,  728,  730,  731,  711,  732,  733,  734,
      735,  736,  737,  738,  739,  740,  741,  742,  743,  744,
      745,  746,  747,  748,  749,  750,  751,  752,  753,  754,
      755,  756,  757,  758,  759,  760,  761,  762,  763,  764,
      765,  766,  767,  768,  769,  770,  771,  772,  773,  774,
      775,  776,  777,  778,  779,  780,  781,  782,  783,  784,

      785,  786,  787,  788,  789,  790,  791,  792,  793,  794,
      795,  796,  797,  798,  799,  800,  801,  802,  803,  804,
      805,  806,  807,  808,  809,  810,  811,  812,  813,  814,
      815,  816,  817,  818,  819,  820,  821,  822,  823,  824,
      825,  826,  827,  828,  829,  830,  831,  832,  833,  834,
      835,  837,  838,  839,  840,  841,  842,  843,  844,  845,
      846,  847,  848,  849,  850,  851,  852,  853,  854,  855,
      856,  857,  858,  842,  859,  860,  861,  862,  863,  864,
      865,  866,  867,  868,  869,  870,  871,  872,  873,  874,
      875,  876,  877,  878,  879,  863,  880,  881,  882,  876,

      883,  884,  885,  886,  887,  876,  888,  889,  890,  891,
      892,  893,  894,  895,  896,  897,  898,  899,  900,  901,
      902,  903,  904,  905,  906,  907,  908,  909,  910,  911,
      912,  913,  914,  915,  916,  917,  918,  919,  920,  921,
      922,  923,  924,  925,  926,  927,  928,  929,  930,  931,
      932,  933,  934,  935,  936,  937,  938,  939,  940,  941,
      942,  943,  944,  945,  946,  947,  948,  949,  950,  951,
      952,  953,  954,  938,  955,  956,  941,  957,  958,  959,
      960,  961,  962,  963,  964,  965,  966,  967,  968,  969,
      970,  971,  972,  973,  974,  975,  976,  977,  978,  979,

      980,  981,  982,  983,  967,  984,  985,  986,  987,  988,
      989,  990,  991,  992,  994,  639,  638,  637,  636,  635,
      634,  633,  632,  631,  630,  629,  628,  627,  626,  625,
      624,  623,  622,  621,  620,  619,  618,  617,  616,  615,
      614,  613,  612,  611,  610,  609,  608,  606,  605,  604,
      603,  602,  601,  600,  599,  598,  597,  596,  594,  593,
      592,  590,  589,  588,  587,  586,  585,  584,  583,  582,
      581,  580,  579,  578,  577,  576,  575,  574,  573,  572,
      571,  570,  569,  568,  567,  566,  565,  564,  562,  560,
      559,  558,  557,  556,  555,  553,  552,  551,  550,  549,

      548,  547,  546,  545,  544,  543,  542,  541,  540,  539,
      538,  537,  536,  533,  532,  531,  530,  529,  528,  527,
      526,  525,  524,  523,  522,  521,  520,  519,  518,  517,
      516,  515,  514,  513,  512,  511,  510,  509,  507,  506,
      505,  504,  503,  502,  501,  500,  499,  498,  497,  496,
      495,  494,  493,  491,  490,  489,  488,  487,  485,  484,
      483,  482,  481,  480,  479,  478,  477,  476,  474,  473,
      472,  471,  469,  468,  467,  466,  465,  464,  463,  462,
      461,  460,  459,  458,  457,  456,  455,  454,  453,  452,
      451,  450,  449,  448,  447,  446,  445,  444,  443,  440,

      439,  438,  437,  436,  435,  434,  433,  432,  431,  430,
      429,  428,  427,  426,  425,  424,  423,  421,  420,  419,
      418,  417,  416,  415,  414,  413,  410,  409,  408,  407,
      406,  405,  404,  403,  402,  401,  400,  399,  398,  397,
      396,  394,  393,  392,  391,  390,  389,  388,  387,  386,
      385,  383,  382,  381,  379,  378,  377,  376,  375,  373,
      372,  371,  370,  369,  368,  367,  366,  365,  364,  363,
      362,  361,  360,  359,  358,  357,  356,  355,  354,  352,
      351,  350,  348,  347,  346,  345,  343,  342,  341,  340,
      338,  337,  336,  335,  334,  333,  332,  331,  329,  328,

      327,  326,  325,  324,  323,  322,  321,  320,  318,  316,
      315,  314,  313,  312,  311,  310,  309,  308,  307,  306,
      305,  304,  302,  301,  300,  299,  298,  297,  296,  295,
      294,  293,  292,  291,  290,  289,  288,  287,  286,  285,
      284,  283,  282,  281,  280,  278,  277,  276,  274,  273,
      272,  270,  268,  267,  266,  265,  264,  262,  261,  260,
      259,  258,  257,  256,  255,  254,  253,  252,  251,  250,
      249,  248,  247,  246,  245,  244,  243,  242,  241,  239,
      238,  237,  236,  233,  230,  229,  227,  225,  223,  221,
      218,  216,  215,  214,  213,  211,  210,  209,  208,  207,

      206,  205,  204,  202,  201,  200,  199,  198,  197,  196,
      194,  193,  192,  191,  187,  185,  183,  180,  179,  178,
      177,  176,  174,  173,  171,  170,  169,  168,  167,  165,
      164,  162,  161,  160,  159,  157,  156,  155,  153,  152,
      150,  149,  148,  147,  146,  145,  144,  142,  137,  136,
      134,  133,  131,  130,  129,  126,  121,  120,  119,  117,
      116,  115,  113,  112,  111,  110,  109,  108,  106,  103,
      102,  101,  100,   99,   98,   96,   95,   94,   93,   92,
       91,   90,   89,   88,   87,   86,   85,   81,   80,   76,
       61,   50,   49,   48,   47,   45,   42,   41,   40,   38,

       37,   35,   32,   28,   27,   26,   25,   23,   20,   15,
       14,   11,    7,    3,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993,  993,  993,
      993,  993,  993,  993,  993,  993,  993,  993
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
static char *yytext;
#define INITIAL 0
#include <string.h>
#include "nodes.h"

#ifdef _WIN32
#define fileno _fileno
#define isatty _isatty
#endif

extern "C" {
#include "grammar.h"
static int yywrap();
}

#ifdef TOKEN_DEBUG
#define token_debug printf
#else
static int token_debug(const char *format, ...);
#endif

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_NO_UNPUT
//static void yyunput YY_PROTO(( int c, char *buf_ptr ));
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen YY_PROTO(( yyconst char * ));
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO(( int new_state ));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO(( void ));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if !(defined __STDC__ && __STDC__)
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

#include "lexer.hxx"

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { fwrite( yytext, yyleng, 1, yyout ); } while (false)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
    if ( yy_current_buffer->yy_is_interactive ) \
        { \
        int c = '*', n; \
        for ( n = 0; n < max_size && \
                 (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
            buf[n] = static_cast<char>(c); \
        if ( c == '\n' ) \
            buf[n++] = static_cast<char>(c); \
        if ( c == EOF && ferror( yyin ) ) \
            YY_FATAL_ERROR( "input in flex scanner failed" ); \
        result = n; \
        } \
    else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
          && ferror( yyin ) ) \
        YY_FATAL_ERROR( "input in flex scanner failed" );
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int yylex YY_PROTO(( void ))
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
    YY_USER_ACTION

YY_DECL
    {
    yy_state_type yy_current_state;
    char *yy_cp, *yy_bp;
    int yy_act;

    if ( yy_init )
    {
        yy_init = 0;

#ifdef YY_USER_INIT
        YY_USER_INIT;
#endif

        if ( ! yy_start )
            yy_start = 1;   /* first start state */

        if ( ! yyin )
            yyin = stdin;

        if ( ! yyout )
            yyout = stdout;

        if ( ! yy_current_buffer )
            yy_current_buffer =
                yy_create_buffer( yyin, YY_BUF_SIZE );

        yy_load_buffer_state();
    }

    while ( true )     /* loops until end-of-file is reached */
    {
        yy_cp = yy_c_buf_p;

        /* Support of yytext. */
        *yy_cp = yy_hold_char;

        /* yy_bp points to the position in yy_ch_buf of the start of
         * the current run.
         */
        yy_bp = yy_cp;

        yy_current_state = yy_start;
yy_match:
        do
        {
            YY_CHAR yy_c = sal::static_int_cast<YY_CHAR>(yy_ec[YY_SC_TO_UI(*yy_cp)]);
            if ( yy_accept[yy_current_state] )
            {
                yy_last_accepting_state = yy_current_state;
                yy_last_accepting_cpos = yy_cp;
            }
            while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
            {
                yy_current_state = static_cast<int>(yy_def[yy_current_state]);
                if ( yy_current_state >= 994 )
                    yy_c = sal::static_int_cast<YY_CHAR>(yy_meta[static_cast<unsigned int>(yy_c)]);
            }
            yy_current_state = yy_nxt[yy_base[yy_current_state] + static_cast<unsigned int>(yy_c)];
            ++yy_cp;
        }
        while ( yy_base[yy_current_state] != 1315 );

yy_find_action:
        yy_act = yy_accept[yy_current_state];
        if ( yy_act == 0 )
        { /* have to back up */
            yy_cp = yy_last_accepting_cpos;
            yy_current_state = yy_last_accepting_state;
            yy_act = yy_accept[yy_current_state];
        }

        YY_DO_BEFORE_ACTION;


do_action:  /* This label is used only to access EOF actions. */


        switch ( yy_act )
    { /* beginning of action switch */
            case 0: /* must back up */
            /* undo the effects of YY_DO_BEFORE_ACTION */
            *yy_cp = yy_hold_char;
            yy_cp = yy_last_accepting_cpos;
            yy_current_state = yy_last_accepting_state;
            goto yy_find_action;

case 1:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Begin[%s]\n",yytext+1); return Grammar::EQBEGIN; }
    //YY_BREAK
case 2:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>End[%s]\n",yytext+1); return Grammar::EQEND; }
    //YY_BREAK
case 3:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Left[%s]\n",yytext+1); return Grammar::EQLEFT; }
    //YY_BREAK
case 4:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>LeftDelim[%s]\n",yytext+1); return Grammar::LEFT_DELIM; }
    //YY_BREAK
case 5:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>RightDelim[%s]\n",yytext+1); return Grammar::RIGHT_DELIM; }
    //YY_BREAK
case 6:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Right[%s]\n",yytext+1); return Grammar::EQRIGHT; }
    //YY_BREAK
case 7:
YY_RULE_SETUP
{ yylval.str = yytext;   token_debug("  ==>NewLine[%s]\n",yytext); return Grammar::NEWLINE; }
    //YY_BREAK
case 8:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Accent[%s]\n",yytext+1); return Grammar::ACCENT; }
    //YY_BREAK
case 9:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Small_Greek[%s]\n",yytext+1); return Grammar::SMALL_GREEK; }
    //YY_BREAK
case 10:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Capital_Greek[%s]\n",yytext+1); return Grammar::CAPITAL_GREEK; }
    //YY_BREAK
case 11:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Binary_Operator[%s]\n",yytext+1); return Grammar::BINARY_OPERATOR; }
    //YY_BREAK
case 12:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Relation_Symbol[%s]\n",yytext+1); return Grammar::RELATION_OPERATOR; }
    //YY_BREAK
case 13:
YY_RULE_SETUP
{ yylval.str = "neq"; token_debug(" ==>Relation_Symbol[neq]\n"); return Grammar::RELATION_OPERATOR; }
    //YY_BREAK
case 14:
YY_RULE_SETUP
{ yylval.str = "vmlt"; token_debug(" ==>Relation_Symbol[neq]\n"); return Grammar::RELATION_OPERATOR; }
    //YY_BREAK
case 15:
YY_RULE_SETUP
{ yylval.str = "vmgt"; token_debug(" ==>Relation_Symbol[neq]\n"); return Grammar::RELATION_OPERATOR; }
    //YY_BREAK
case 16:
YY_RULE_SETUP
{ yylval.str = "mlt"; token_debug(" ==>Relation_Symbol[neq]\n"); return Grammar::RELATION_OPERATOR; }
    //YY_BREAK
case 17:
YY_RULE_SETUP
{ yylval.str = "mgt"; token_debug(" ==>Relation_Symbol[neq]\n"); return Grammar::RELATION_OPERATOR; }
    //YY_BREAK
case 18:
YY_RULE_SETUP
{ yylval.str = yytext; token_debug(" ==>Relation_Symbol[neq]\n"); return Grammar::RELATION_OPERATOR; }
    //YY_BREAK
case 19:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Arrow[%s]\n",yytext+1); return Grammar::ARROW; }
    //YY_BREAK
case 20:
YY_RULE_SETUP
{ yylval.str = "leftrightarrow"; token_debug("  ==>Arrow[leftrightarrow]\n"); return Grammar::ARROW; }
    //YY_BREAK
case 21:
YY_RULE_SETUP
{ yylval.str = "rightarrow"; token_debug("  ==>Arrow[rightarrow]\n"); return Grammar::ARROW; }
    //YY_BREAK
case 22:
YY_RULE_SETUP
{ yylval.str = "leftarrow"; token_debug("   ==>Arrow[leftarrow]\n"); return Grammar::ARROW; }
    //YY_BREAK

case 23:
YY_RULE_SETUP
{ token_debug(" ==>Ignore[\\rm]\n"); }
    //YY_BREAK
[[fallthrough]];
case 24:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>General_Iden[%s]\n",yytext+1); return Grammar::GENERAL_IDEN; }
    //YY_BREAK
case 25:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>General_Oper[%s]\n",yytext+1); return Grammar::GENERAL_OPER; }
    //YY_BREAK
case 26:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Big_Symbol[%s]\n",yytext+1); return Grammar::BIG_SYMBOL; }
    //YY_BREAK
case 27:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Function[%s]\n",yytext+1); return Grammar::FUNCTION; }
    //YY_BREAK
case 28:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Root[%s]\n",yytext+1); return Grammar::ROOT; }
    //YY_BREAK
case 29:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Fraction[%s]\n",yytext+1); return Grammar::FRACTION; }
    //YY_BREAK
case 30:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Over[%s]\n",yytext+1); return Grammar::EQOVER; }
    //YY_BREAK
case 31:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Delimeter[%s]\n",yytext+1); return Grammar::DELIMETER; }
    //YY_BREAK
case 32:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Large_Delim[%s]\n",yytext+1); return Grammar::LARGE_DELIM; }
    //YY_BREAK
case 33:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Decoration[%s]\n",yytext+1); return Grammar::DECORATION; }
    //YY_BREAK
case 34:
YY_RULE_SETUP
{ yylval.str = yytext+1; token_debug("  ==>Space_Symbol[%s]\n",yytext+1); /*return Grammar::SPACE_SYMBOL;*/ }
    //YY_BREAK
[[fallthrough]];
case 35:
YY_RULE_SETUP
{ yylval.str = "quad"; token_debug("    ==>Space_Symbol[quad]\n"); /* return Grammar::SPACE_SYMBOL;*/ }
    //YY_BREAK
[[fallthrough]];
case 36:
YY_RULE_SETUP
{ yylval.dval = yytext;  token_debug("  ==>Digit[%s]\n",yytext); return Grammar::DIGIT; }
    //YY_BREAK
case 37:
YY_RULE_SETUP
{ yylval.str = yytext;   token_debug("  ==>Operator[%s]\n",yytext); return Grammar::OPERATOR; }
    //YY_BREAK
case 38:
YY_RULE_SETUP
{ token_debug(" ==>SubSup[%s]\n",yytext); return yytext[0]; }
    //YY_BREAK
case 39:
YY_RULE_SETUP
{ token_debug(" ==>Paren[%s]\n",yytext); return yytext[0];}
    //YY_BREAK
case 40:
YY_RULE_SETUP
{ token_debug(" ==>Abs[%s]\n",yytext); return yytext[0];}
    //YY_BREAK
case 41:
YY_RULE_SETUP
{ token_debug("   ==>Space[0x%2x]\n",yytext[0]); }
    YY_BREAK
case 42:
YY_RULE_SETUP
{ token_debug("   ==>Ignore[0x%2x]\n",yytext[0]); }
    YY_BREAK
case 43:
YY_RULE_SETUP
{ yylval.str = yytext;  token_debug("   ==>String[%s]\n",yytext); return Grammar::STRING; }
    //YY_BREAK
case 44:
YY_RULE_SETUP
{ yylval.str = yytext;  token_debug("   ==>Else[%s]\n",yytext); return Grammar::CHARACTER; }
    //YY_BREAK
case 45:
YY_RULE_SETUP
ECHO;
    YY_BREAK
case YY_STATE_EOF(INITIAL):
    yyterminate();

    case YY_END_OF_BUFFER:
        {
        /* Amount of text matched not including the EOB char. */
        int yy_amount_of_matched_text = static_cast<int>(yy_cp - yytext_ptr) - 1;

        /* Undo the effects of YY_DO_BEFORE_ACTION. */
        *yy_cp = yy_hold_char;
        YY_RESTORE_YY_MORE_OFFSET

        if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
        {
            /* We're scanning a new file or input source.  It's
             * possible that this happened because the user
             * just pointed yyin at a new source and called
             * yylex().  If so, then we have to assure
             * consistency between yy_current_buffer and our
             * globals.  Here is the right place to do so, because
             * this is the first action (other than possibly a
             * back-up) that will match for the new input source.
             */
            yy_n_chars = yy_current_buffer->yy_n_chars;
            yy_current_buffer->yy_input_file = yyin;
            yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
        }

        /* Note that here we test for yy_c_buf_p "<=" to the position
         * of the first EOB in the buffer, since yy_c_buf_p will
         * already have been incremented past the NUL character
         * (since all states make transitions on EOB to the
         * end-of-buffer state).  Contrast this with the test
         * in input().
         */
        if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
        { /* This was really a NUL. */
            yy_state_type yy_next_state;

            yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

            yy_current_state = yy_get_previous_state();

            /* Okay, we're now positioned to make the NUL
             * transition.  We couldn't have
             * yy_get_previous_state() go ahead and do it
             * for us because it doesn't know how to deal
             * with the possibility of jamming (and we don't
             * want to build jamming into it because then it
             * will run more slowly).
             */

            yy_next_state = yy_try_NUL_trans( yy_current_state );

            yy_bp = yytext_ptr + YY_MORE_ADJ;

            if ( yy_next_state )
            {
                /* Consume the NUL. */
                yy_cp = ++yy_c_buf_p;
                yy_current_state = yy_next_state;
                goto yy_match;
            }

            else
            {
                yy_cp = yy_c_buf_p;
                goto yy_find_action;
            }
        }

        else switch ( yy_get_next_buffer() )
            {
            case EOB_ACT_END_OF_FILE:
                {
                yy_did_buffer_switch_on_eof = 0;

                if ( yywrap() )
                {
                    /* Note: because we've taken care in
                     * yy_get_next_buffer() to have set up
                     * yytext, we can now set up
                     * yy_c_buf_p so that if some total
                     * hoser (like flex itself) wants to
                     * call the scanner after we return the
                     * YY_NULL, it'll still work - another
                     * YY_NULL will get returned.
                     */
                    yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

                    yy_act = YY_STATE_EOF(YY_START);
                    goto do_action;
                }

                else
                {
                    if ( ! yy_did_buffer_switch_on_eof )
                        YY_NEW_FILE;
                }
                }
                break;

            case EOB_ACT_CONTINUE_SCAN:
                yy_c_buf_p =
                    yytext_ptr + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state();

                yy_cp = yy_c_buf_p;
                yy_bp = yytext_ptr + YY_MORE_ADJ;
                goto yy_match;
                break;

            case EOB_ACT_LAST_MATCH:
                yy_c_buf_p =
                &yy_current_buffer->yy_ch_buf[yy_n_chars];

                yy_current_state = yy_get_previous_state();

                yy_cp = yy_c_buf_p;
                yy_bp = yytext_ptr + YY_MORE_ADJ;
                goto yy_find_action;
                break;
            }
        break;
        }

    default:
        YY_FATAL_ERROR(
            "fatal flex scanner internal error--no action found" );
    } /* end of action switch */
    } /* end of scanning one token */
    } /* end of yylex */


/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()
    {
    char *dest = yy_current_buffer->yy_ch_buf;
    char *source = yytext_ptr;
    int number_to_move, i;
    int ret_val;

    if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
        YY_FATAL_ERROR(
        "fatal flex scanner internal error--end of buffer missed" );

    if ( yy_current_buffer->yy_fill_buffer == 0 )
    { /* Don't try to fill the buffer, so this is an EOF. */
        if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
        {
            /* We matched a single character, the EOB, so
             * treat this as a final EOF.
             */
            return EOB_ACT_END_OF_FILE;
        }

        else
        {
            /* We matched some text prior to the EOB, first
             * process it.
             */
            return EOB_ACT_LAST_MATCH;
        }
    }

    /* Try to read more data. */

    /* First move last chars to start of buffer. */
    number_to_move = static_cast<int>(yy_c_buf_p - yytext_ptr) - 1;

    for ( i = 0; i < number_to_move; ++i )
        *(dest++) = *(source++);

    if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
        /* don't do the read, it's not guaranteed to return an EOF,
         * just force an EOF
         */
        yy_current_buffer->yy_n_chars = yy_n_chars = 0;

    else
    {
        int num_to_read =
            yy_current_buffer->yy_buf_size - number_to_move - 1;

        while ( num_to_read <= 0 )
        { /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
            YY_FATAL_ERROR(
"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
#else

            /* just a shorter name for the current buffer */
            YY_BUFFER_STATE b = yy_current_buffer;

            int yy_c_buf_p_offset =
                static_cast<int>(yy_c_buf_p - b->yy_ch_buf);

            if ( b->yy_is_our_buffer )
            {
                int new_size = b->yy_buf_size * 2;

                if ( new_size <= 0 )
                    b->yy_buf_size += b->yy_buf_size / 8;
                else
                    b->yy_buf_size *= 2;

                b->yy_ch_buf = static_cast<char *>(
                    /* Include room in for 2 EOB chars. */
                    yy_flex_realloc( static_cast<void *>(b->yy_ch_buf),
                             b->yy_buf_size + 2 ));
            }
            else
                /* Can't grow it, we don't own it. */
                b->yy_ch_buf = nullptr;

            if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR(
                "fatal error - scanner input buffer overflow" );

            yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

            num_to_read = yy_current_buffer->yy_buf_size -
                        number_to_move - 1;
#endif
        }

        if ( num_to_read > YY_READ_BUF_SIZE )
            num_to_read = YY_READ_BUF_SIZE;

        /* Read in more data. */
        YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
            yy_n_chars, num_to_read );

        yy_current_buffer->yy_n_chars = yy_n_chars;
    }

    if ( yy_n_chars == 0 )
    {
        if ( number_to_move == YY_MORE_ADJ )
        {
            ret_val = EOB_ACT_END_OF_FILE;
            yyrestart( yyin );
        }

        else
        {
            ret_val = EOB_ACT_LAST_MATCH;
            yy_current_buffer->yy_buffer_status =
                YY_BUFFER_EOF_PENDING;
        }
    }

    else
        ret_val = EOB_ACT_CONTINUE_SCAN;

    yy_n_chars += number_to_move;
    yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
    yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

    yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

    return ret_val;
    }


/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state()
    {
    yy_state_type yy_current_state;
    char *yy_cp;

    yy_current_state = yy_start;

    for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
    {
        YY_CHAR yy_c = sal::static_int_cast<YY_CHAR>(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
        if ( yy_accept[yy_current_state] )
        {
            yy_last_accepting_state = yy_current_state;
            yy_last_accepting_cpos = yy_cp;
        }
        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        {
            yy_current_state = static_cast<int>(yy_def[yy_current_state]);
            if ( yy_current_state >= 994 )
                yy_c = sal::static_int_cast<YY_CHAR>(yy_meta[static_cast<unsigned int>(yy_c)]);
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + static_cast<unsigned int>(yy_c)];
    }

    return yy_current_state;
    }


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
yy_state_type yy_current_state;
#endif
    {
    bool yy_is_jam;
    char *yy_cp = yy_c_buf_p;

    YY_CHAR yy_c = 1;
    if ( yy_accept[yy_current_state] )
    {
        yy_last_accepting_state = yy_current_state;
        yy_last_accepting_cpos = yy_cp;
    }
    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
    {
        yy_current_state = static_cast<int>(yy_def[yy_current_state]);
        if ( yy_current_state >= 994 )
            yy_c = sal::static_int_cast<YY_CHAR>(yy_meta[static_cast<unsigned int>(yy_c)]);
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + static_cast<unsigned int>(yy_c)];
    yy_is_jam = (yy_current_state == 993);

    return yy_is_jam ? 0 : yy_current_state;
    }

#ifdef YY_USE_PROTOS
void yyrestart( FILE *input_file )
#else
void yyrestart( input_file )
FILE *input_file;
#endif
    {
    if ( ! yy_current_buffer )
        yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );

    yy_init_buffer( yy_current_buffer, input_file );
    yy_load_buffer_state();
    }


#ifdef YY_USE_PROTOS
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
#else
void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif
    {
    if ( yy_current_buffer == new_buffer )
        return;

    if ( yy_current_buffer )
    {
        /* Flush out information for old buffer. */
        *yy_c_buf_p = yy_hold_char;
        yy_current_buffer->yy_buf_pos = yy_c_buf_p;
        yy_current_buffer->yy_n_chars = yy_n_chars;
    }

    yy_current_buffer = new_buffer;
    yy_load_buffer_state();

    /* We don't actually know whether we did this switch during
     * EOF (yywrap()) processing, but the only time this flag
     * is looked at is after yywrap() is called, so it's safe
     * to go ahead and always set it.
     */
    yy_did_buffer_switch_on_eof = 1;
    }


#ifdef YY_USE_PROTOS
void yy_load_buffer_state()
#else
void yy_load_buffer_state()
#endif
    {
    yy_n_chars = yy_current_buffer->yy_n_chars;
    yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
    yyin = yy_current_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
    }


#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
#else
YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
#endif
    {
    YY_BUFFER_STATE b;

    b = static_cast<YY_BUFFER_STATE>(yy_flex_alloc( sizeof( struct yy_buffer_state ) ));
    if ( ! b )
        YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

    b->yy_buf_size = size;

    /* yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = static_cast<char *>(yy_flex_alloc( b->yy_buf_size + 2 ));
    if ( ! b->yy_ch_buf )
        YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

    b->yy_is_our_buffer = 1;

    yy_init_buffer( b, file );

    return b;
    }


#ifdef YY_USE_PROTOS
void yy_delete_buffer( YY_BUFFER_STATE b )
#else
void yy_delete_buffer( b )
YY_BUFFER_STATE b;
#endif
    {
    if ( ! b )
        return;

    if ( b == yy_current_buffer )
        yy_current_buffer = nullptr;

    if ( b->yy_is_our_buffer )
        yy_flex_free( static_cast<void *>(b->yy_ch_buf) );

    yy_flex_free( static_cast<void *>(b) );
    }


#ifndef YY_ALWAYS_INTERACTIVE
#ifndef YY_NEVER_INTERACTIVE
extern int isatty YY_PROTO(( int ));
#endif
#endif

#ifdef YY_USE_PROTOS
void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
#else
void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;
#endif


    {
    yy_flush_buffer( b );

    b->yy_input_file = file;
    b->yy_fill_buffer = 1;

#if YY_ALWAYS_INTERACTIVE
    b->yy_is_interactive = true;
#else
#if YY_NEVER_INTERACTIVE
    b->yy_is_interactive = false;
#else
    b->yy_is_interactive = file && isatty( fileno(file) ) > 0;
#endif
#endif
    }


#ifdef YY_USE_PROTOS
void yy_flush_buffer( YY_BUFFER_STATE b )
#else
void yy_flush_buffer( b )
YY_BUFFER_STATE b;
#endif

    {
    if ( ! b )
        return;

    b->yy_n_chars = 0;

    /* We always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[0];

    b->yy_at_bol = 1;
    b->yy_buffer_status = YY_BUFFER_NEW;

    if ( b == yy_current_buffer )
        yy_load_buffer_state();
    }


#ifndef YY_NO_SCAN_BUFFER
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
#else
YY_BUFFER_STATE yy_scan_buffer( base, size )
char *base;
yy_size_t size;
#endif
    {
    YY_BUFFER_STATE b;

    if ( size < 2 ||
         base[size-2] != YY_END_OF_BUFFER_CHAR ||
         base[size-1] != YY_END_OF_BUFFER_CHAR )
        /* They forgot to leave room for the EOB's. */
        return nullptr;

    b = static_cast<YY_BUFFER_STATE>(yy_flex_alloc( sizeof( struct yy_buffer_state ) ));
    if ( ! b )
        YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

    b->yy_buf_size = size - 2;  /* "- 2" to take care of EOB's */
    b->yy_buf_pos = b->yy_ch_buf = base;
    b->yy_is_our_buffer = 0;
    b->yy_input_file = nullptr;
    b->yy_n_chars = b->yy_buf_size;
    b->yy_is_interactive = false;
    b->yy_at_bol = 1;
    b->yy_fill_buffer = 0;
    b->yy_buffer_status = YY_BUFFER_NEW;

    yy_switch_to_buffer( b );

    return b;
    }
#endif


#ifndef YY_NO_SCAN_STRING
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
#else
YY_BUFFER_STATE yy_scan_string( yy_str )
yyconst char *yy_str;
#endif
    {
    int len;
    for ( len = 0; yy_str[len]; ++len )
        ;

    return yy_scan_bytes( yy_str, len );
    }
#endif


#ifndef YY_NO_SCAN_BYTES
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
#else
YY_BUFFER_STATE yy_scan_bytes( bytes, len )
yyconst char *bytes;
int len;
#endif
    {
    YY_BUFFER_STATE b;
    char *buf;
    yy_size_t n;
    int i;

    /* Get memory for full buffer, including space for trailing EOB's. */
    n = len + 2;
    buf = static_cast<char *>(yy_flex_alloc( n ));
    if ( ! buf )
        YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

    for ( i = 0; i < len; ++i )
        buf[i] = bytes[i];

    buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

    b = yy_scan_buffer( buf, n );
    if ( ! b )
        YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

    /* It's okay to grow etc. this buffer, and we should throw it
     * away when we're done.
     */
    b->yy_is_our_buffer = 1;

    return b;
    }
#endif


#ifndef YY_NO_PUSH_STATE
#ifdef YY_USE_PROTOS
static void yy_push_state( int new_state )
#else
static void yy_push_state( new_state )
int new_state;
#endif
    {
    if ( yy_start_stack_ptr >= yy_start_stack_depth )
        {
        yy_size_t new_size;

        yy_start_stack_depth += YY_START_STACK_INCR;
        new_size = yy_start_stack_depth * sizeof( int );

        if ( ! yy_start_stack )
            yy_start_stack = (int *) yy_flex_alloc( new_size );

        else
            yy_start_stack = (int *) yy_flex_realloc(
                    (void *) yy_start_stack, new_size );

        if ( ! yy_start_stack )
            YY_FATAL_ERROR(
            "out of memory expanding start-condition stack" );
        }

    yy_start_stack[yy_start_stack_ptr++] = YY_START;

    BEGIN(new_state);
    }
#endif


#ifndef YY_NO_POP_STATE
static void yy_pop_state()
    {
    if ( --yy_start_stack_ptr < 0 )
        YY_FATAL_ERROR( "start-condition stack underflow" );

    BEGIN(yy_start_stack[yy_start_stack_ptr]);
    }
#endif


#ifndef YY_NO_TOP_STATE
static int yy_top_state()
    {
    return yy_start_stack[yy_start_stack_ptr - 1];
    }
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

#ifdef YY_USE_PROTOS
static void yy_fatal_error( yyconst char msg[] )
#else
static void yy_fatal_error( msg )
char msg[];
#endif
    {
    (void) fprintf( stderr, "%s\n", msg );
    exit( YY_EXIT_FAILURE );
    }


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
char *s1;
yyconst char *s2;
int n;
#endif
    {
    int i;
    for ( i = 0; i < n; ++i )
        s1[i] = s2[i];
    }
#endif

#ifdef YY_NEED_STRLEN
#ifdef YY_USE_PROTOS
static int yy_flex_strlen( yyconst char *s )
#else
static int yy_flex_strlen( s )
yyconst char *s;
#endif
    {
    int n;
    for ( n = 0; s[n]; ++n )
        ;

    return n;
    }
#endif


#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
    {
    return malloc( size );
    }

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t size )
#else
static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
#endif
    {
    /* The cast to (char *) in the following accommodates both
     * implementations that use char* generic pointers, and those
     * that use void* generic pointers.  It works with the latter
     * because both ANSI C and C++ allow castless assignment from
     * any pointer type to void*, and deal with argument conversions
     * as though doing an assignment.
     */
    return realloc( ptr, size );
    }

#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
    {
    free( ptr );
    }

#if YY_MAIN
int main()
    {
    yylex();
    return 0;
    }
#endif


void initFlex(const char *_code )
{
    yy_switch_to_buffer( yy_scan_string(_code) );
}

void deinitFlex()
{
    // flex faq-memory-leak
    yy_delete_buffer(YY_CURRENT_BUFFER);
    yy_init = 1;
}

int yywrap()
{
    yy_delete_buffer( YY_CURRENT_BUFFER );
    return 1;
}

#ifndef TOKEN_DEBUG
int token_debug(const char * /*format*/, ...)
{
   return 0;
}
#endif

/* vim:set shiftwidth=4 softtabstop=4 expandtab: */
