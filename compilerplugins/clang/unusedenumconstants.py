#!/usr/bin/python

import sys
import re
import io

definitionSet = set()
definitionToSourceLocationMap = dict()
readSet = set()
writeSet = set()
sourceLocationSet = set()

# clang does not always use exactly the same numbers in the type-parameter vars it generates
# so I need to substitute them to ensure we can match correctly.
normalizeTypeParamsRegex = re.compile(r"type-parameter-\d+-\d+")
def normalizeTypeParams( line ):
    return normalizeTypeParamsRegex.sub("type-parameter-?-?", line)

def parseFieldInfo( tokens ):
    if len(tokens) == 3:
        return (normalizeTypeParams(tokens[1]), tokens[2])
    else:
        return (normalizeTypeParams(tokens[1]), "")

# The parsing here is designed to avoid grabbing stuff which is mixed in from gbuild.
# I have not yet found a way of suppressing the gbuild output.
with io.open("loplugin.unusedenumconstants.log", "rb", buffering=1024*1024) as txt:
    for line in txt:
        tokens = line.strip().split("\t")
        if tokens[0] == "definition:":
            fieldInfo = (normalizeTypeParams(tokens[1]), tokens[2])
            srcLoc = tokens[3]
            # ignore external source code
            if (srcLoc.startswith("external/")):
                continue
            # ignore build folder
            if (srcLoc.startswith("workdir/")):
                continue
            definitionSet.add(fieldInfo)
            definitionToSourceLocationMap[fieldInfo] = srcLoc
        elif tokens[0] == "read:":
            readSet.add(parseFieldInfo(tokens))
        elif tokens[0] == "write:":
            writeSet.add(parseFieldInfo(tokens))
        else:
            print( "unknown line: " + line)

# Invert the definitionToSourceLocationMap
# If we see more than one method at the same sourceLocation, it's being autogenerated as part of a template
# and we should just ignore
sourceLocationToDefinitionMap = {}
for k, v in definitionToSourceLocationMap.iteritems():
    sourceLocationToDefinitionMap[v] = sourceLocationToDefinitionMap.get(v, [])
    sourceLocationToDefinitionMap[v].append(k)
for k, definitions in sourceLocationToDefinitionMap.iteritems():
    if len(definitions) > 1:
        for d in definitions:
            definitionSet.remove(d)

untouchedSet = set()
for d in definitionSet:
    if d in readSet or d in writeSet:
        continue
    # this is all representations of on-disk data structures
    if srcLoc.startswith("basic/source/inc/filefmt.hxx"):
    "basic/source/sbx/sbxscan.cxx"
        continue
    srcLoc = definitionToSourceLocationMap[d];
    untouchedSet.add((d[0] + " " + d[1], srcLoc))

writeonlySet = set()
for d in writeSet:
    if d in readSet:
        continue
    srcLoc = definitionToSourceLocationMap[d];
    writeonlySet.add((d[0] + " " + d[1], srcLoc))

readonlySet = set()
for d in readSet:
    if d in writeSet:
        continue
    srcLoc = definitionToSourceLocationMap[d];
    readonlySet.add((d[0] + " " + d[1], srcLoc))

# sort the results using a "natural order" so sequences like [item1,item2,item10] sort nicely
def natural_sort_key(s, _nsre=re.compile('([0-9]+)')):
    return [int(text) if text.isdigit() else text.lower()
            for text in re.split(_nsre, s)]

# sort results by name and line number
tmp1list = sorted(untouchedSet, key=lambda v: natural_sort_key(v[1]))
tmp2list = sorted(writeonlySet, key=lambda v: natural_sort_key(v[1]))
tmp3list = sorted(readonlySet, key=lambda v: natural_sort_key(v[1]))

# print out the results
with open("loplugin.unusedenumconstants.report-untouched", "wt") as f:
    for t in tmp1list:
        f.write( t[1] + "\n" )
        f.write( "    " + t[0] + "\n" )
with open("loplugin.unusedenumconstants.report-writeonly", "wt") as f:
    for t in tmp2list:
        f.write( t[1] + "\n" )
        f.write( "    " + t[0] + "\n" )
with open("loplugin.unusedenumconstants.report-readonly", "wt") as f:
    for t in tmp3list:
        f.write( t[1] + "\n" )
        f.write( "    " + t[0] + "\n" )


