{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "21e7606c_91d0f564",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000179
      },
      "writtenOn": "2022-08-11T09:14:35Z",
      "side": 1,
      "message": "Hi Caol√°n,\nAnother blind fix for a crash that needs review",
      "revId": "ad1f0fa11fa8fb90783be2aa54d3a90f05f72ff5",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f12f4f5e_ae49d2a3",
        "filename": "connectivity/source/cpool/ZConnectionPool.cxx",
        "patchSetId": 2
      },
      "lineNbr": 300,
      "author": {
        "id": 1000135
      },
      "writtenOn": "2022-08-11T11:00:09Z",
      "side": 1,
      "message": "I dunno, its a divide by zero so it must be that m_nTimeOut is 0 at line 300 here (because it can\u0027t be the divide by nTimeOutCorrection on line 299 which is 10 or 20).\n\nIf m_nALiveCount was 0, and was set to 1 on line 297 the 1/10 or 1/20 on line 299 gives a m_nTimeOut of 0 and this would still div-by-zero at line 300",
      "revId": "ad1f0fa11fa8fb90783be2aa54d3a90f05f72ff5",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "705d47c5_12bf9275",
        "filename": "connectivity/source/cpool/ZConnectionPool.cxx",
        "patchSetId": 2
      },
      "lineNbr": 300,
      "author": {
        "id": 1000179
      },
      "writtenOn": "2022-08-11T11:34:30Z",
      "side": 1,
      "message": "meh, you are right. stupid mistake",
      "parentUuid": "f12f4f5e_ae49d2a3",
      "revId": "ad1f0fa11fa8fb90783be2aa54d3a90f05f72ff5",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f45614d_bc300d3b",
        "filename": "connectivity/source/cpool/ZConnectionPool.cxx",
        "patchSetId": 2
      },
      "lineNbr": 300,
      "author": {
        "id": 1000135
      },
      "writtenOn": "2022-08-11T12:25:06Z",
      "side": 1,
      "message": "To reproduce this, blow away your config and start writer, visit tools, options, base, connections and enable connection pooling enabled, find com.sun.star.sdbcx.comp.hdqldb.Driver and \"enable pooling for this driver\" and \"apply\" with the default 120 seconds, ok and exit\n\nthen open a database (based on hsqldb) and click on \"tables\" (to start a connection)\nthat default 120 seconds is the input for calculateTimeOuts (this becomes a final m_nALiveCount of 10 by the divide by 20), now visit the options again and change the 120 to something else and ok and the input for calculateTimeOuts is the old \"10\" calculated before and not the new expected value.\n\nThe reason appears to be in OConnectionPool::propertyChange, it expects to get the new value of the property from evt.NewValue but it gets an empty Any so the m_nALiveCount is not actually changed, so the assumption it was set and will be \u003e\u003d 20 and sanely divisible by 20 doesn\u0027t hold.\n\ncaolan-\u003esberg: should the new value of this property have arrived in ::propertyChange or did this never work as the original author expected.",
      "parentUuid": "705d47c5_12bf9275",
      "revId": "ad1f0fa11fa8fb90783be2aa54d3a90f05f72ff5",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eb95a43a_796e9af0",
        "filename": "connectivity/source/cpool/ZConnectionPool.cxx",
        "patchSetId": 2
      },
      "lineNbr": 300,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2022-08-16T14:02:50Z",
      "side": 1,
      "message": "\u003e caolan-\u003esberg: should the new value of this property have arrived in ::propertyChange or did this never work as the original author expected.\n\nThe css.beans.PropertyChangeEvent OldValue and NewValue members have always been broken by design, as such event notifications need to be sent among UNO objects with no mutexes locked, so they can seemingly arrive out of order, so the receiver could never know from the OldValue and NewValue data what the last-set value is anyway.  (I remember doing a lengthy write-up about that sometime in the early 2000s, with a proof based on some domino tiling analogy, but which is unfortunately lost to history...)  PropertyChangeEvent has always allowed that \"Void values may be provided for the old and new values if their true values are not known\", so when I reimplemented configmgr around 2009 I happily left those useless members void in configmgr/source/acces.cxx.  They likely had non-void values in the old configmgr implementation, and the code relying on non-void values here dates back to \u003chttps://git.libreoffice.org/core/+/278c3b2660b2cd11f446312b82dbd370088b81bb%5E!/\u003e \"#87724# driver pooling enabled\" from 2001, so it likely originally happened to work as expected and only silently broke with the new configmgr implementation around 2009.",
      "parentUuid": "7f45614d_bc300d3b",
      "revId": "ad1f0fa11fa8fb90783be2aa54d3a90f05f72ff5",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    }
  ]
}