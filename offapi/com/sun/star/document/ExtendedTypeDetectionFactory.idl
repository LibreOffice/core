/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*************************************************************************
 *
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Copyright 2000, 2010 Oracle and/or its affiliates.
 *
 * OpenOffice.org - a multi-platform office productivity suite
 *
 * This file is part of OpenOffice.org.
 *
 * OpenOffice.org is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 3
 * only, as published by the Free Software Foundation.
 *
 * OpenOffice.org is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License version 3 for more details
 * (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU Lesser General Public License
 * version 3 along with OpenOffice.org.  If not, see
 * <http://www.openoffice.org/license.html>
 * for a copy of the LGPLv3 License.
 *
 ************************************************************************/
#ifndef __com_sun_star_document_ExtendedTypeDetectionFactory_idl__
#define __com_sun_star_document_ExtendedTypeDetectionFactory_idl__

#include <com/sun/star/lang/XMultiServiceFactory.idl>
#include <com/sun/star/container/XNameContainer.idl>
#include <com/sun/star/container/XContainerQuery.idl>
#include <com/sun/star/util/XFlushable.idl>


module com { module sun { module star { module document {

/** factory to create extended type detection components.

    <p>
    This factory implements read/write access on the underlying configuration set.
    and further a validate and flush mechanism for more performance and a special query mode
    can be used here too.
    </p>

    @since OOo 1.1.2
 */
published service ExtendedTypeDetectionFactory
{
    /** factory interface to create and initialize extended type detection components.

        <p>
        A detection component must be specified by it's UNO implementation name and will be crated then.
        Every new created component can be initialized with it's own configuration data
        and may given optional arguments of the corresponding createInstanceWithArguments() request. To do so the
        service must support the optional interface <type scope="com::sun::star::lang">XInitialization</type>.
        The arguments parameter will have the following structure:
        <ul>
            <li>sequence< Any >[0] contains a sequence< <type scope="com::sun::star::beans">PropertyValue</type> >,
                which represent the configuration data set of this detector component. The used properties are the same, as
                they are available at the container interface of this factory service. (see below)</li>
            <li>Every following item of the argument list sequence< Any >[1..n] contains the copied argument of the
                corresponding createInstanceWithArguments() call. That means: Item 0 or the original list was copied as
                item 1 of the destination list ... etc.
        </ul>
        </p>
     */
    interface com::sun::star::lang::XMultiServiceFactory;

    /** provides read access to the complete set of configuration data.

        <p>
        Every container item is specified as a set of properties and will be
        represented by a sequence< <type scope="com::sun::star::beans">PropertyValue</type> > structure.
        Follow properties are supported:
        (But note: not all of them must be present every time!)
        </p>
        <table border=1>
            <tr>
                <td><strong>Property Name</strong></td>
                <td><strong>Value Type</strong></td>
                <td><strong>Description</strong></td>
            </tr>
            <tr>
                <td><em>Name</em></td>
                <td>[string]</td>
                <td>It means the UNO implementation name of the detector component.
                    Note: It means the really the implementation instead of the UNO service name.
                    Because it's not possible to distinguish between more then one components; if all of them
                    uses a generic service identifier!</td>
            </tr>
            <tr>
                <td><em>Types</em></td>
                <td>[sequence< string >]</td>
                <td>It's a list of all types, which can be detected by this extended detection component.
                    All items of this list must match an item of the <type>TypeDetection</type> container service.</td>
            </tr>
        </table>
        </p>
     */
    interface com::sun::star::container::XNameAccess;

    /** provides a write access to the configuration data.
     */
    [optional] interface com::sun::star::container::XNameContainer;

    /** provides search on the configuration data set.

        <p>
        Against simple property search it provides some complex algorithms too.
        For further informations please read the SDK documentation.
        </p>
     */
    [optional] interface com::sun::star::container::XContainerQuery;

    /** can be used to perform container changes.

        <p>
        Because the complexness of such configuration set can be very high,
        it seams not very useful to update the underlying configuration layer
        on every container change request immediately. Another strategy can be to
        make all changes (adding/changing/removing of items) and call flush at the end.
        That will validate the whole container and reject inconsistent data sets.
        Only in case all made changes was correct, they will be written back to the
        configuration. Further this interface provides the possibility, that interested
        changes listener can be registered too.
        </p>
     */
    [optional] interface com::sun::star::util::XFlushable;
};


}; }; }; };

#endif

/* vim:set shiftwidth=4 softtabstop=4 expandtab: */
