/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
 * This file is part of the LibreOffice project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * This file incorporates work covered by the following license notice:
 *
 *   Licensed to the Apache Software Foundation (ASF) under one or more
 *   contributor license agreements. See the NOTICE file distributed
 *   with this work for additional information regarding copyright
 *   ownership. The ASF licenses this file to you under the Apache
 *   License, Version 2.0 (the "License"); you may not use this file
 *   except in compliance with the License. You may obtain a copy of
 *   the License at http://www.apache.org/licenses/LICENSE-2.0 .
 */
#ifndef __com_sun_star_sdbc_XDatabaseMetaData_idl__
#define __com_sun_star_sdbc_XDatabaseMetaData_idl__

#include <com/sun/star/uno/XInterface.idl>

#include <com/sun/star/sdbc/SQLException.idl>


 module com {  module sun {  module star {  module sdbc {

 published interface XResultSet;
 published interface XConnection;

/** provides comprehensive information about the database as a whole.


    <p>Many of the methods here return lists of information in
    the form of
    com::sun::star::sdbc::XResultSet
    objects.
    You can use the normal com::sun::star::sdbc::XRow
    (or com::sun::star::sdb::XColumn)
    methods such as
    com::sun::star::sdbc::XRow::getString()
    and
    com::sun::star::sdbc::XRow::getInt()
    to retrieve the data from these XResultSets. If a given form of
    metadata is not available, these methods should throw a
    com::sun::star::sdbc::SQLException.
    After calling one of the getXXX() methods,
    one can check whether that value is `NULL`
    with the method com::sun::star::sdbc::XRow::wasNull().
    In the text only "(may be `NULL`)" is mentioned for this case.
    </p>
    <p>Some of these methods take arguments that are String patterns. These
    arguments all have names such as fooPattern. Within a pattern String, "%"
    means match any substring of 0 or more characters, and "_" means match
    any one character. Only metadata entries matching the search pattern
    are returned. If a search pattern argument is set to `VOID`,
    that argument's criteria will be dropped from the search.
    </p>
    <p>
    A
    com::sun::star::sdbc::SQLException
    will be thrown if a driver does not support
    a metadata method. In the case of methods that return an XResultSet,
    either an XResultSet (which may be empty) is returned or a
    SQLException is thrown.</p>
 */
published interface XDatabaseMetaData: com::sun::star::uno::XInterface
{

    /** Can all the procedures returned by getProcedures be called by the
        current user?

        @return
        `TRUE`
        if the user is allowed to call all procedures returned by getProcedures
        otherwise `FALSE`.
        @throws SQLException
            if a database access error occurs.
     */
    boolean allProceduresAreCallable() raises (SQLException);

    /** Can all the tables returned by getTable be SELECTed by the
        current user?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean allTablesAreSelectable() raises (SQLException);

    /** returns the URL for the database connection
     */
    string getURL() raises (SQLException);

    /** returns the user name from this database connection.
     */
    string getUserName() raises (SQLException);

    /** checks if the database in read-only mode.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean isReadOnly() raises (SQLException);

    /** Are NULL values sorted high?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
    */
    boolean nullsAreSortedHigh() raises (SQLException);

    /** Are NULL values sorted low?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
    */
    boolean nullsAreSortedLow() raises (SQLException);

    /** Are NULL values sorted at the start regardless of sort order?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean nullsAreSortedAtStart() raises (SQLException);

    /**  Are NULL values sorted at the end, regardless of sort order?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean nullsAreSortedAtEnd() raises (SQLException);

    /** returns the name of the database product.
     */
    string getDatabaseProductName() raises (SQLException);

    /** returns the version of the database product.
     */
    string getDatabaseProductVersion() raises (SQLException);

    /** returns the name of the SDBC driver.
     */
    string getDriverName() raises (SQLException);

    /** returns the version number of the SDBC driver.
     */
    string getDriverVersion() raises (SQLException);

    /** returns the SDBC driver major version number.
     */
    long getDriverMajorVersion();

    /** returns the SDBC driver minor version number.
     */
    long getDriverMinorVersion();

    /** use the database local files to save the tables.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean usesLocalFiles() raises (SQLException);

    /** use the database one local file to save for each table.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean usesLocalFilePerTable() raises (SQLException);

    /** use the database "mixed case unquoted SQL identifiers" case sensitive.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsMixedCaseIdentifiers() raises (SQLException);

    /** Does the database treat mixed case unquoted SQL identifiers as
        case insensitive and store them in upper case?
            @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean storesUpperCaseIdentifiers() raises (SQLException);

    /** Does the database treat mixed case unquoted SQL identifiers as
        case insensitive and store them in lower case?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean storesLowerCaseIdentifiers() raises (SQLException);

    /** Does the database treat mixed case unquoted SQL identifiers as
        case insensitive and store them in mixed case?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean storesMixedCaseIdentifiers() raises (SQLException);

    /** Does the database treat mixed case quoted SQL identifiers as
        case sensitive and as a result store them in mixed case?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsMixedCaseQuotedIdentifiers() raises (SQLException);

    /** Does the database treat mixed case quoted SQL identifiers as
        case insensitive and store them in upper case?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean storesUpperCaseQuotedIdentifiers() raises (SQLException);

    /** Does the database treat mixed case quoted SQL identifiers as
        case insensitive and store them in lower case?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean storesLowerCaseQuotedIdentifiers() raises (SQLException);

    /** Does the database treat mixed case quoted SQL identifiers as
        case insensitive and store them in mixed case?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean storesMixedCaseQuotedIdentifiers() raises (SQLException);

    /** What's the string used to quote SQL identifiers?
        This returns a space " " if identifier quoting is not supported.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    string getIdentifierQuoteString() raises (SQLException);

    /** gets a comma-separated list of all a database's SQL keywords
        that are NOT also SQL92 keywords.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    string getSQLKeywords() raises (SQLException);

    /** gets a comma-separated list of math functions. These are the
        X/Open CLI math function names used in the SDBC function escape
        clause.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    string getNumericFunctions() raises (SQLException);

    /** gets a comma-separated list of string functions. These are the
        X/Open CLI string function names used in the SDBC function escape
        clause.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    string getStringFunctions() raises (SQLException);

    /** gets a comma-separated list of system functions. These are the
        X/Open CLI system function names used in the SDBC function escape
        clause.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    string getSystemFunctions() raises (SQLException);

    /** gets a comma-separated list of time and date functions.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    string getTimeDateFunctions() raises (SQLException);

    /** gets the string that can be used to escape wildcard characters.
        This is the string that can be used to escape "_" or "%" in
        the string pattern style catalog search parameters.


        <p>
        The "_" character represents any single character.
        </p>
        <p>
        The "%" character represents any sequence of zero or
        more characters.
        </p>
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    string getSearchStringEscape() raises (SQLException);

    /** gets all the "extra" characters that can be used in unquoted
        identifier names (those beyond a-z, A-Z, 0-9 and _).
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    string getExtraNameCharacters() raises (SQLException);

    /** support the Database "ALTER TABLE" with add column?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsAlterTableWithAddColumn() raises (SQLException);

    /** support the Database  "ALTER TABLE" with drop column?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsAlterTableWithDropColumn() raises (SQLException);

    /** support the Database column aliasing?


        <p>
        The SQL AS clause can be used to provide names for
        computed columns or to provide alias names for columns as required.
        </p>
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsColumnAliasing() raises (SQLException);

    /** are concatenations between NULL and non-NULL values NULL?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean nullPlusNonNullIsNull() raises (SQLException);

    /** `TRUE`
            , if the Database supports the CONVERT function between SQL types,
            otherwise `FALSE`.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsTypeConversion() raises (SQLException);

    /**     `TRUE`
            , if the Database supports the CONVERT between the given SQL types
            otherwise `FALSE`.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsConvert([in]long fromType, [in]long toType)
        raises (SQLException);

    /** Are table correlation names supported?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsTableCorrelationNames() raises (SQLException);

    /** If table correlation names are supported, are they restricted
        to be different from the names of the tables?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsDifferentTableCorrelationNames()
        raises (SQLException);

    /** Are expressions in "ORDER BY" lists supported?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsExpressionsInOrderBy() raises (SQLException);

    /** Can an "ORDER BY" clause use columns not in the SELECT statement?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsOrderByUnrelated() raises (SQLException);

    /** Is some form of "GROUP BY" clause supported?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsGroupBy() raises (SQLException);

    /** Can a "GROUP BY" clause use columns not in the SELECT?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsGroupByUnrelated() raises (SQLException);

    /** Can a "GROUP BY" clause add columns not in the SELECT
        provided it specifies all the columns in the SELECT?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsGroupByBeyondSelect() raises (SQLException);

    /** Is the escape character in "LIKE" clauses supported?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsLikeEscapeClause() raises (SQLException);

    /** Are multiple XResultSets from a single execute supported?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsMultipleResultSets() raises (SQLException);

    /** Can we have multiple transactions open at once (on different
        connections)?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsMultipleTransactions() raises (SQLException);

    /** Can columns be defined as non-nullable?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsNonNullableColumns() raises (SQLException);

    /**     `TRUE`, if the database supports ODBC Minimum SQL grammar,
            otherwise `FALSE`.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsMinimumSQLGrammar() raises (SQLException);

    /** `TRUE`, if the database supports ODBC Core SQL grammar,
            otherwise `FALSE`.
            @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsCoreSQLGrammar() raises (SQLException);

    /**
            `TRUE`, if the database supports ODBC Extended SQL grammar,
            otherwise `FALSE`.
            @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsExtendedSQLGrammar() raises (SQLException);

    /** @returns
            `TRUE`, if the database supports ANSI92 entry level SQL grammar,
            otherwise `FALSE`.
            @throws SQLException
            if a database access error occurs.
     */
    boolean supportsANSI92EntryLevelSQL() raises (SQLException);

    /** @returns
            `TRUE`, if the database supports ANSI92 intermediate SQL grammar,
            otherwise `FALSE`.
            @throws SQLException
            if a database access error occurs.
     */
    boolean supportsANSI92IntermediateSQL() raises (SQLException);

    /** @returns
            `TRUE`, if the database supports ANSI92 full SQL grammar,
            otherwise `FALSE`.
            @throws SQLException
            if a database access error occurs.
     */
    boolean supportsANSI92FullSQL() raises (SQLException);

    /** returns
            `TRUE`, if the Database supports SQL Integrity Enhancement Facility,
            otherwise `FALSE`.
            @throws SQLException
            if a database access error occurs.
     */
    boolean supportsIntegrityEnhancementFacility() raises (SQLException);

    /** @returns
            `TRUE`, if some form of outer join is supported,
            otherwise `FALSE`.
            @throws SQLException
            if a database access error occurs.
     */
    boolean supportsOuterJoins() raises (SQLException);

    /** @returns
            `TRUE`, if full nested outer joins are supported,
            otherwise `FALSE`.
            @throws SQLException
            if a database access error occurs.
     */
    boolean supportsFullOuterJoins() raises (SQLException);

    /** @returns
            `TRUE`, if there is limited support for outer joins.
            (This will be `TRUE` if supportFullOuterJoins is `TRUE`.)
            `FALSE` is returned otherwise.
            @throws SQLException
            if a database access error occurs.
     */
    boolean supportsLimitedOuterJoins() raises (SQLException);

    /** return the database vendor's preferred term for "schema"
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    string getSchemaTerm() raises (SQLException);

    /** return the database vendor's preferred term for "procedure"
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    string getProcedureTerm() raises (SQLException);

    /** return the database vendor's preferred term for "catalog"
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    string getCatalogTerm() raises (SQLException);

    /** Does a catalog appear at the start of a qualified table name?
        (Otherwise it appears at the end)
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean isCatalogAtStart() raises (SQLException);

    /** return the separator between catalog and table name
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    string getCatalogSeparator() raises (SQLException);

    /** Can a schema name be used in a data manipulation statement?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsSchemasInDataManipulation() raises (SQLException);

    /** Can a schema name be used in a procedure call statement?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsSchemasInProcedureCalls() raises (SQLException);

    /** Can a schema name be used in a table definition statement?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsSchemasInTableDefinitions() raises (SQLException);

    /** Can a schema name be used in an index definition statement?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsSchemasInIndexDefinitions() raises (SQLException);

    /** Can a schema name be used in a privilege definition statement?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsSchemasInPrivilegeDefinitions()
        raises (SQLException);

    /** Can a catalog name be used in a data manipulation statement?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsCatalogsInDataManipulation() raises (SQLException);

    /** Can a catalog name be used in a procedure call statement?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsCatalogsInProcedureCalls() raises (SQLException);

    /** Can a catalog name be used in a table definition statement?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsCatalogsInTableDefinitions() raises (SQLException);

    /** Can a catalog name be used in an index definition statement?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsCatalogsInIndexDefinitions() raises (SQLException);

    /** Can a catalog name be used in a privilege definition statement?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsCatalogsInPrivilegeDefinitions()
        raises (SQLException);

    /** Is positioned DELETE supported?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsPositionedDelete() raises (SQLException);

    /** Is positioned UPDATE supported?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsPositionedUpdate() raises (SQLException);

    /** Is SELECT for UPDATE supported?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsSelectForUpdate() raises (SQLException);

    /** Are stored procedure calls using the stored procedure escape
        syntax supported?
            @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsStoredProcedures() raises (SQLException);

    /** Are subqueries in comparison expressions supported?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsSubqueriesInComparisons() raises (SQLException);

    /** Are subqueries in "exists" expressions supported?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsSubqueriesInExists() raises (SQLException);

    /** Are subqueries in "in" statements supported?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsSubqueriesInIns() raises (SQLException);

    /** Are subqueries in quantified expressions supported?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsSubqueriesInQuantifieds() raises (SQLException);

    /** Are correlated subqueries supported?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsCorrelatedSubqueries() raises (SQLException);

    /** Is SQL UNION supported?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsUnion() raises (SQLException);

    /** Is SQL UNION ALL supported?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsUnionAll() raises (SQLException);

    /** Can cursors remain open across commits?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsOpenCursorsAcrossCommit() raises (SQLException);

    /** Can cursors remain open across rollbacks?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsOpenCursorsAcrossRollback() raises (SQLException);

    /** Can statements remain open across commits?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsOpenStatementsAcrossCommit() raises (SQLException);

    /** Can statements remain open across rollbacks?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsOpenStatementsAcrossRollback()
        raises (SQLException);

    /** return the maximal number of hex characters in an inline binary literal
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxBinaryLiteralLength() raises (SQLException);

    /** return the max length for a character literal
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxCharLiteralLength() raises (SQLException);

    /** return the limit on column name length
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxColumnNameLength() raises (SQLException);

    /** return the maximum number of columns in a "GROUP BY" clause
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxColumnsInGroupBy() raises (SQLException);

    /** return the maximum number of columns allowed in an index
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxColumnsInIndex() raises (SQLException);

    /** return the maximum number of columns in an "ORDER BY" clause
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxColumnsInOrderBy() raises (SQLException);

    /** return the maximum number of columns in a "SELECT" list
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxColumnsInSelect() raises (SQLException);

    /** return the maximum number of columns in a table
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxColumnsInTable() raises (SQLException);

    /** return the number of active connections at a time to this database.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxConnections() raises (SQLException);

    /** return the maximum cursor name length
    @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxCursorNameLength() raises (SQLException);

    /** return the maximum length of an index (in bytes)
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxIndexLength() raises (SQLException);

    /** return the maximum length allowed for a schema name
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxSchemaNameLength() raises (SQLException);

    /** return the maximum length of a procedure name
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxProcedureNameLength() raises (SQLException);

    /** return the maximum length of a catalog name
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxCatalogNameLength() raises (SQLException);

    /** return the maximum length of a single row.
    @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxRowSize() raises (SQLException);

    /** Did getMaxRowSize() include LONGVARCHAR and LONGVARBINARY
        blobs?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean doesMaxRowSizeIncludeBlobs() raises (SQLException);

    /** return the maximum length of a SQL statement
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxStatementLength() raises (SQLException);

    /** return the maximal number of open active statements at one time to this database
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxStatements() raises (SQLException);

    /** return the maximum length of a table name
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxTableNameLength() raises (SQLException);

    /** return the maximum number of tables in a SELECT statement
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxTablesInSelect() raises (SQLException);

    /** return the maximum length of a user name
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    long getMaxUserNameLength() raises (SQLException);

    /** return the database default transaction isolation level.
        The values are defined in
        com::sun::star::sdbc::TransactionIsolation.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
        @see com::sun::star::sdbc::XConnection
     */
    long getDefaultTransactionIsolation() raises (SQLException);

    /** support the Database transactions?
        If not, invoking the method
        com::sun::star::sdbc::XConnection::commit()
        is a noop and the
        isolation level is TransactionIsolation_NONE.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsTransactions() raises (SQLException);

    /** Does this database support the given transaction isolation level?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
 @see com::sun::star::sdbc::Connection
     */
    boolean supportsTransactionIsolationLevel([in]long level)
                            raises (SQLException);

    /** support the Database both data definition and data manipulation statements
        within a transaction?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
<!-- JRH: Unclear on the intent of these many support questions.
        If asking, it should state, "Does the Database support both ....?
        If declaring, it should state something like the following:

        metadata:   supportsDataDefinitionAndDataManipulationTransactions

    "provides support for both data definition and data manipulation statements within a transaction."
 -->     */
    boolean supportsDataDefinitionAndDataManipulationTransactions()
                             raises (SQLException);

    /** are only data manipulation statements within a transaction
        supported?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsDataManipulationTransactionsOnly()
                            raises (SQLException);

    /** does a data definition statement within a transaction force the
        transaction to commit?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean dataDefinitionCausesTransactionCommit()
                            raises (SQLException);

    /** is a data definition statement within a transaction ignored?
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean dataDefinitionIgnoredInTransactions()
                            raises (SQLException);

    /** Gets a description of the stored procedures available in a
        catalog.


        <p>
        Only procedure descriptions matching the schema and
        procedure name criteria are returned. They are ordered by
        PROCEDURE_SCHEM, and PROCEDURE_NAME.
        </p>
        <p>
        Each procedure description has the following columns:
        </p>
        <ol>
        <li>
        <b>PROCEDURE_CAT</b> string => procedure catalog (may be `NULL`)
        </li>
        <li>
        <b>PROCEDURE_SCHEM</b> string => procedure schema (may be `NULL`)
        </li>
        <li>
        <b>PROCEDURE_NAME</b> string => procedure name
        </li>
        <li> reserved for future use
        </li>
        <li> reserved for future use
        </li>
        <li> reserved for future use
        </li>
        <li>
        <b>REMARKS</b> string => explanatory comment on the procedure
        </li>
        <li>
        <b>PROCEDURE_TYPE</b> short => kind of procedure:
        <ul>
        <li> UNKNOWN - May return a result
        </li>
        <li> NO - Does not return a result
        </li>
        <li> RETURN - Returns a result
        </li>
        </ul>
        </li>
        </ol>
        @param catalog
            a catalog name; "" retrieves those without a catalog; `VOID` means drop catalog name from the selection criteria
        @param schemaPattern
            a schema name pattern; "" retrieves those without a schema
        @param procedureNamePattern
            a procedure name pattern
        @returns
            each row is a procedure description
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getProcedures([in]any catalog, [in]string schemaPattern,
                    [in]string procedureNamePattern) raises (SQLException);

    /** gets a description of a catalog's stored procedure parameters
        and result columns.


        <p>
        Only descriptions matching the schema, procedure and
        parameter name criteria are returned. They are ordered by
        PROCEDURE_SCHEM and PROCEDURE_NAME. Within this, the return value,
        if any, is first. Next are the parameter descriptions in call
        order. The column descriptions follow in column number order.
        </p>
        <p>Each row in the XResultSet is a parameter description or
        column description with the following fields:
        </p>
        <ol>
        <li>
        <b>PROCEDURE_CAT</b> string => procedure catalog (may be `NULL`)
        </li>
        <li>
        <b>PROCEDURE_SCHEM</b> string => procedure schema (may be `NULL`)
        </li>
        <li>
        <b>PROCEDURE_NAME</b> string => procedure name
        </li>
        <li>
        <b>COLUMN_NAME</b> string => column/parameter name
        </li>
        <li>
        <b>COLUMN_TYPE</b> Short => kind of column/parameter:
        <ul>
        <li> UNKNOWN - nobody knows
        </li>
        <li> IN - IN parameter
        </li>
        <li> INOUT - INOUT parameter
        </li>
        <li> OUT - OUT parameter
        </li>
        <li> RETURN - procedure return value
        </li>
        <li> RESULT - result column in XResultSet
        </li>
        </ul>
        </li>
        <li>
        <b>DATA_TYPE</b> short => SQL type from java.sql.Types
        </li>
        <li>
        <b>TYPE_NAME</b> string => SQL type name, for a UDT type the
        type name is fully qualified
        </li>
        <li>
        <b>PRECISION</b> long => precision
        </li>
        <li>
        <b>LENGTH</b> long => length in bytes of data
        </li>
        <li>
        <b>SCALE</b> short => scale
        </li>
        <li>
        <b>RADIX</b> short => radix
        </li>
        <li>
        <b>NULLABLE</b> short => can it contain NULL?
        <ul>
        <li> NO_NULLS - does not allow NULL values
        </li>
        <li> NULLABLE - allows NULL values
        </li>
        <li> NULLABLE_UNKNOWN - nullability unknown
        </li>
        </ul>
        </li>
        <li>
        <b>REMARKS</b> string => comment describing parameter/column
        </li>
        </ol>
        <p>
        <b>Note:</b> Some databases may not return the column
        descriptions for a procedure. Additional columns beyond
        REMARKS can be defined by the database.
        </p>
        @param catalog
            a catalog name; "" retrieves those without a catalog; `VOID` means drop catalog name from the selection criteria
        @param schemaPattern
            a schema name pattern; "" retrieves those without a schema
        @param procedureNamePattern
            a procedure name pattern
        @param columnNamePattern
            a column name pattern
        @returns
            each row describes a stored procedure parameter or column
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getProcedureColumns([in]any catalog, [in]string schemaPattern,
                                   [in]string procedureNamePattern,
                                   [in]string columnNamePattern)
                        raises (SQLException);

    /** gets a description of tables available in a catalog.


        <p>Only table descriptions matching the catalog, schema, table
        name, and type criteria are returned. They are ordered by
        TABLE_TYPE, TABLE_SCHEM, and TABLE_NAME.
        </p>
        <p>Each table description has the following columns:
        </p>
        <ol>
        <li>
        <b>TABLE_CAT</b> string => table catalog (may be `NULL`)
        </li>
        <li>
        <b>TABLE_SCHEM</b> string => table schema (may be `NULL`)
        </li>
        <li>
        <b>TABLE_NAME</b> string => table name
        </li>
        <li>
        <b>TABLE_TYPE</b> string => table type. Typical types are "TABLE",
        "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
        "LOCAL TEMPORARY", "ALIAS", "SYNONYM".
        </li>
        <li>
        <b>REMARKS</b> string => explanatory comment on the table
        </li>
        </ol>
        <p>
        <b>Note:</b> Some databases may not return information for
        all tables.
        </p>
        @param catalog
            a catalog name; "" retrieves those without a catalog; `VOID` means drop catalog name from the selection criteria
        @param schemaPattern
            a schema name pattern; "" retrieves those without a schema
        @param tableNamePattern
            a table name pattern
        @param types
            a list of table types to include
        @returns
            each row is a table description
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getTables([in]any catalog, [in]string schemaPattern,
        [in]string tableNamePattern, [in]sequence<string> types)
        raises (SQLException);

    /** Gets the schema names available in this database. The results
        are ordered by schema name.


        <p>The schema column is:
        </p>
        <ol>
        <li>
        <b>TABLE_SCHEM</b> string => schema name
        </li>
        </ol>
        @returns
            each row has a single String column that is a schema name
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getSchemas() raises (SQLException);

    /** gets the catalog names available in this database. The results
        are ordered by catalog name.


        <p>The catalog column is:
        </p>
        <ol>
        <li>
        <b>TABLE_CAT</b> string => catalog name
        </li>
        </ol>
        @returns
            each row has a single String column that is a catalog name
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getCatalogs() raises (SQLException);

    /** gets the table types available in this database. The results
        are ordered by table type.


        <p>The table type is:
        </p>
        <ol>
        <li>
        <b>TABLE_TYPE</b> string => table type. Typical types are "TABLE",
        "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY",
        "LOCAL TEMPORARY", "ALIAS", "SYNONYM".
        </li>
        </ol>
        @returns
            each row has a single String column that is a table type
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getTableTypes() raises (SQLException);

    /** gets a description of table columns available in
        the specified catalog.


        <p>Only column descriptions matching the catalog, schema, table
        and column name criteria are returned. They are ordered by
        TABLE_SCHEM, TABLE_NAME, and ORDINAL_POSITION.
        </p>
        <p>Each column description has the following columns:
        </p>
        <ol>
        <li>
        <b>TABLE_CAT</b> string => table catalog (may be `NULL`)
        </li>
        <li>
        <b>TABLE_SCHEM</b> string => table schema (may be `NULL`)
        </li>
        <li>
        <b>TABLE_NAME</b> string => table name
        </li>
        <li>
        <b>COLUMN_NAME</b> string => column name
        </li>
        <li>
        <b>DATA_TYPE</b> short => SQL type from java.sql.Types
        </li>
        <li>
        <b>TYPE_NAME</b> string => Data source dependent type name,
        for a UDT the type name is fully qualified
        </li>
        <li>
        <b>COLUMN_SIZE</b> long => column size. For char or date
        types this is the maximum number of characters, for numeric or
        decimal types this is precision.
        </li>
        <li>
        <b>BUFFER_LENGTH</b> is not used.
        </li>
        <li>
        <b>DECIMAL_DIGITS</b> long => the number of fractional digits
        </li>
        <li>
        <b>NUM_PREC_RADIX</b> long => Radix (typically either 10 or 2)
        </li>
        <li>
        <b>NULLABLE</b> long => is NULL allowed?
        <ul>
        <li> NO_NULLS - might not allow NULL values
        </li>
        <li> NULLABLE - definitely allows NULL values
        </li>
        <li> NULLABLE_UNKNOWN - nullability unknown
        </li>
        </ul>
        </li>
        <li>
        <b>REMARKS</b> string => comment describing column (may be `NULL`)
        </li>
        <li>
        <b>COLUMN_DEF</b> string => default value (may be `NULL`)
        </li>
        <li>
        <b>SQL_DATA_TYPE</b> long => unused
        </li>
        <li>
        <b>SQL_DATETIME_SUB</b> long => unused
        </li>
        <li>
        <b>CHAR_OCTET_LENGTH</b> long => for char types the
        maximum number of bytes in the column
        </li>
        <li>
        <b>ORDINAL_POSITION</b> int => index of column in table
        (starting at 1)
        </li>
        <li>
        <b>IS_NULLABLE</b> string => "NO" means column definitely
        does not allow NULL values; "YES" means the column might
        allow NULL values. An empty string means nobody knows.
        </li>
        </ol>
        @param catalog
            a catalog name; "" retrieves those without a catalog; `VOID` means drop catalog name from the selection criteria
        @param schemaPattern
            a schema name pattern; "" retrieves those without a schema
        @param tableNamePattern
            a table name pattern
        @param columnNamePattern
            a column name pattern
        @returns
            each row is a column description
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getColumns([in]any catalog, [in]string schemaPattern,
        [in]string tableNamePattern, [in]string columnNamePattern)
                    raises (SQLException);

    /** gets a description of the access rights for a table's columns.


        <p>
        Only privileges matching the column name criteria are
        returned. They are ordered by COLUMN_NAME and PRIVILEGE.
        </p>
        <p>Each privilege description has the following columns:
        </p>
        <ol>
        <li>
        <b>TABLE_CAT</b> string => table catalog (may be `NULL`)
        </li>
        <li>
        <b>TABLE_SCHEM</b> string => table schema (may be `NULL`)
        </li>
        <li>
        <b>TABLE_NAME</b> string => table name
        </li>
        <li>
        <b>COLUMN_NAME</b> string => column name
        </li>
        <li>
        <b>GRANTOR</b> => granter of access (may be `NULL`)
        </li>
        <li>
        <b>GRANTEE</b> string => grantee of access
        </li>
        <li>
        <b>PRIVILEGE</b> string => name of access (SELECT,
        INSERT, UPDATE, REFERENCES, ...)
        </li>
        <li>
        <b>IS_GRANTABLE</b> string => "YES" if grantee is permitted
        to grant to others; "NO" if not; `NULL` if unknown
        </li>
        </ol>
        @param catalog
            a catalog name; "" retrieves those without a catalog; `VOID` means drop catalog name from the selection criteria
        @param schema
            a schema name ; "" retrieves those without a schema
        @param table
            a table name
        @param columnNamePattern
            a column name pattern
        @returns
            each row is a column privilege description
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getColumnPrivileges([in]any catalog, [in]string schema,
        [in]string table, [in]string columnNamePattern) raises (SQLException);

    /** gets a description of the access rights for each table available
        in a catalog. Note that a table privilege applies to one or
        more columns in the table. It would be wrong to assume that
        this privilege applies to all columns (this may be `TRUE` for
        some systems but is not `TRUE` for all.)


        <p>Only privileges matching the schema and table name
        criteria are returned. They are ordered by TABLE_SCHEM,
        TABLE_NAME, and PRIVILEGE.
        </p>
        <p>Each privilege description has the following columns:
        </p>
        <ol>
        <li>
        <b>TABLE_CAT</b> string => table catalog (may be `NULL`)
        </li>
        <li>
        <b>TABLE_SCHEM</b> string => table schema (may be `NULL`)
        </li>
        <li>
        <b>TABLE_NAME</b> string => table name
        </li>
        <li>
        <b>GRANTOR</b> => granter of access (may be `NULL`)
        </li>
        <li>
        <b>GRANTEE</b> string => grantee of access
        </li>
        <li>
        <b>PRIVILEGE</b> string => name of access (SELECT,
        INSERT, UPDATE, REFERENCES, ...)
        </li>
        <li>
        <b>IS_GRANTABLE</b> string => "YES" if grantee is permitted
        to grant to others; "NO" if not; `NULL` if unknown
        </li>
        </ol>
        @param catalog
            a catalog name; "" retrieves those without a catalog; `VOID` means drop catalog name from the selection criteria
        @param schemaPattern
            a schema name pattern; "" retrieves those without a schema
        @param tableNamePattern
            a table name pattern
        @returns
            each row is a table privilege description
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getTablePrivileges([in]any catalog, [in]string schemaPattern,
                [in]string tableNamePattern) raises (SQLException);

    /** gets a description of a table's optimal set of columns that
        uniquely identifies a row. They are ordered by SCOPE.


        <p>Each column description has the following columns:
        </p>
        <ol>
        <li>
        <b>SCOPE</b> short => actual scope of result
        <ul>
        <li> TEMPORARY - very temporary, while using row
        </li>
        <li> TRANSACTION - valid for remainder of current transaction
        </li>
        <li> SESSION - valid for remainder of current session
        </li>
        </ul>
        </li>
        <li>
        <b>COLUMN_NAME</b> string => column name
        </li>
        <li>
        <b>DATA_TYPE</b> short => SQL data type from java.sql.Types
        </li>
        <li>
        <b>TYPE_NAME</b> string => Data source dependent type name,
        for a UDT the type name is fully qualified
        </li>
        <li>
        <b>COLUMN_SIZE</b> long => precision
        </li>
        <li>
        <b>BUFFER_LENGTH</b> long => not used
        </li>
        <li>
        <b>DECIMAL_DIGITS</b> short  => scale
        </li>
        <li>
        <b>PSEUDO_COLUMN</b> short => is this a pseudo column
        like an Oracle ROWID
        <ul>
        <li> UNKNOWN - may or may not be pseudo column
        </li>
        <li> NOT_PSEUDO - is NOT a pseudo column
        </li>
        <li> PSEUDO - is a pseudo column
        </li>
        </ul>
        </li>
        </ol>
        @param catalog
            a catalog name; "" retrieves those without a catalog; `VOID` means drop catalog name from the selection criteria
        @param schema
            a schema name; "" retrieves those without a schema
        @param table
            a table name
        @param scope
            the scope of interest; use same values as SCOPE
        @param nullable
            include columns that are nullable?
        @returns
            each row is a column description
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getBestRowIdentifier([in]any catalog, [in]string schema,
        [in]string table, [in]long scope, [in] boolean nullable)
        raises (SQLException);

    /** gets a description of a table's columns that are automatically
        updated when any value in a row is updated. They are
        unordered.


        <p>Each column description has the following columns:
        </p>
        <ol>
        <li>
        <b>SCOPE</b> short => is not used
        </li>
        <li>
        <b>COLUMN_NAME</b> string => column name
        </li>
        <li>
        <b>DATA_TYPE</b> short => SQL data type from java.sql.Types
        </li>
        <li>
        <b>TYPE_NAME</b> string => Data source dependent type name
        </li>
        <li>
        <b>COLUMN_SIZE</b> long => precision
        </li>
        <li>
        <b>BUFFER_LENGTH</b> long => length of column value in bytes
        </li>
        <li>
        <b>DECIMAL_DIGITS</b> short  => scale
        </li>
        <li>
        <b>PSEUDO_COLUMN</b> short => is this a pseudo column
        like an Oracle ROWID
        <ul>
        <li> UNKNOWN - may or may not be pseudo column
        </li>
        <li> NOT_PSEUDO - is NOT a pseudo column
        </li>
        <li> PSEUDO - is a pseudo column
        </li>
        </ul>
        </li>
        </ol>
        @param catalog
            a catalog name; "" retrieves those without a catalog; `VOID` means drop catalog name from the selection criteria
        @param schema
            a schema name; "" retrieves those without a schema
        @param table
            a table name
        @returns
            each row is a column description
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getVersionColumns([in]any catalog, [in]string schema,
                [in]string table) raises (SQLException);

    /** gets a description of a table's primary key columns. They
        are ordered by COLUMN_NAME.


        <p>Each primary key column description has the following columns:
        </p>
        <ol>
        <li>
        <b>TABLE_CAT</b> string => table catalog (may be `NULL`)
        </li>
        <li>
        <b>TABLE_SCHEM</b> string => table schema (may be `NULL`)
        </li>
        <li>
        <b>TABLE_NAME</b> string => table name
        </li>
        <li>
        <b>COLUMN_NAME</b> string => column name
        </li>
        <li>
        <b>KEY_SEQ</b> short => sequence number within primary key
        </li>
        <li>
        <b>PK_NAME</b> string => primary key name (may be `NULL`)
        </li>
        </ol>
        @param catalog
            a catalog name; "" retrieves those without a catalog; `VOID` means drop catalog name from the selection criteria
        @param schema
            a schema name; "" retrieves those without a schema
        @param table
            a table name
        @returns
            each row is a primary key column description
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getPrimaryKeys([in]any catalog, [in]string schema,
                [in]string table) raises (SQLException);

    /** gets a description of the primary key columns that are
        referenced by a table's foreign key columns (the primary keys
        imported by a table). They are ordered by PKTABLE_CAT,
        PKTABLE_SCHEM, PKTABLE_NAME, and KEY_SEQ.


        <p>Each primary key column description has the following columns:
        </p>
        <ol>
        <li>
        <b>PKTABLE_CAT</b> string => primary key table catalog
        being imported (may be `NULL`)
        </li>
        <li>
        <b>PKTABLE_SCHEM</b> string => primary key table schema
        being imported (may be `NULL`)
        </li>
        <li>
        <b>PKTABLE_NAME</b> string => primary key table name
        being imported
        </li>
        <li>
        <b>PKCOLUMN_NAME</b> string => primary key column name
        being imported
        </li>
        <li>
        <b>FKTABLE_CAT</b> string => foreign key table catalog (may be `NULL`)
        </li>
        <li>
        <b>FKTABLE_SCHEM</b> string => foreign key table schema (may be `NULL`)
        </li>
        <li>
        <b>FKTABLE_NAME</b> string => foreign key table name
        </li>
        <li>
        <b>FKCOLUMN_NAME</b> string => foreign key column name
        </li>
        <li>
        <b>KEY_SEQ</b> short => sequence number within foreign key
        </li>
        <li>
        <b>UPDATE_RULE</b> short => What happens to
        foreign key when primary is updated:
        <ul>
        <li> importedNoAction - do not allow update of primary
        key if it has been imported
        </li>
        <li> importedKeyCascade - change imported key to agree
        with primary key update
        </li>
        <li> importedKeySetNull - change imported key to NULL if
        its primary key has been updated
        </li>
        <li> importedKeySetDefault - change imported key to default values
        if its primary key has been updated
        </li>
        <li> importedKeyRestrict - same as importedKeyNoAction
        (for ODBC 2.x compatibility)
        </li>
        </ul>
        </li>
        <li>
        <b>DELETE_RULE</b> short => What happens to
        the foreign key when primary is deleted.
        <ul>
        <li> importedKeyNoAction - do not allow delete of primary
        key if it has been imported
        </li>
        <li> importedKeyCascade - delete rows that import a deleted key
        </li>
        <li> importedKeySetNull - change imported key to NULL if
        its primary key has been deleted
        </li>
        <li> importedKeyRestrict - same as importedKeyNoAction
        (for ODBC 2.x compatibility)
        </li>
        <li> importedKeySetDefault - change imported key to default if
        its primary key has been deleted
        </li>
        </ul>
        </li>
        <li>
        <b>FK_NAME</b> string => foreign key name (may be `NULL`)
        </li>
        <li>
        <b>PK_NAME</b> string => primary key name (may be `NULL`)
        </li>
        <li>
        <b>DEFERRABILITY</b> short => can the evaluation of foreign key
        constraints be deferred until commit
        <ul>
        <li> importedKeyInitiallyDeferred - see SQL92 for definition
        </li>
        <li> importedKeyInitiallyImmediate - see SQL92 for definition
        </li>
        <li> importedKeyNotDeferrable - see SQL92 for definition
        </li>
        </ul>
        </li>
        </ol>
        @param catalog
            a catalog name; "" retrieves those without a catalog; `VOID` means drop catalog name from the selection criteria
        @param schema
            a schema name; "" retrieves those without a schema
        @param table
            a table name
        @returns
            each row is a primary key column description
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getImportedKeys([in]any catalog, [in]string schema,
                [in]string table) raises (SQLException);

    /** gets a description of the foreign key columns that reference a
        table's primary key columns (the foreign keys exported by a
        table). They are ordered by FKTABLE_CAT, FKTABLE_SCHEM,
        FKTABLE_NAME, and KEY_SEQ.


        <p>Each foreign key column description has the following columns:
        </p>
        <ol>
        <li>
        <b>PKTABLE_CAT</b> string => primary key table catalog (may be `NULL`)
        </li>
        <li>
        <b>PKTABLE_SCHEM</b> string => primary key table schema (may be `NULL`)
        </li>
        <li>
        <b>PKTABLE_NAME</b> string => primary key table name
        </li>
        <li>
        <b>PKCOLUMN_NAME</b> string => primary key column name
        </li>
        <li>
        <b>FKTABLE_CAT</b> string => foreign key table catalog (may be `NULL`)
        being exported (may be `NULL`)
        </li>
        <li>
        <b>FKTABLE_SCHEM</b> string => foreign key table schema (may be `NULL`)
        being exported (may be `NULL`)
        </li>
        <li>
        <b>FKTABLE_NAME</b> string => foreign key table name
        being exported
        </li>
        <li>
        <b>FKCOLUMN_NAME</b> string => foreign key column name
        being exported
        </li>
        <li>
        <b>KEY_SEQ</b> short => sequence number within foreign key
        </li>
        <li>
        <b>UPDATE_RULE</b> short => What happens to
        foreign key when primary is updated:
        <ul>
        <li> NO_ACTION - do not allow update of primary
        key if it has been imported
        </li>
        <li> CASCADE - change imported key to agree
        with primary key update
        </li>
        <li> SET_NULL - change imported key to NULL if
        its primary key has been updated
        </li>
        <li> SET_DEFAULT - change imported key to default values
        if its primary key has been updated
        </li>
        <li> RESTRICT - same as importedKeyNoAction
        (for ODBC 2.x compatibility)
        </li>
        </ul>
        </li>
        <li>
        <b>DELETE_RULE</b> short => What happens to
        the foreign key when primary is deleted.
        <ul>
        <li> NO_ACTION - do not allow delete of primary
        key if it has been imported
        </li>
        <li> CASCADE - delete rows that import a deleted key
        </li>
        <li> SET_NULL - change imported key to NULL if
        its primary key has been deleted
        </li>
        <li> RESTRICT - same as importedKeyNoAction
        (for ODBC 2.x compatibility)
        </li>
        <li> SET_DEFAULT - change imported key to default if
        its primary key has been deleted
        </li>
        </ul>
        </li>
        <li>
        <b>FK_NAME</b> string => foreign key name (may be `NULL`)
        </li>
        <li>
        <b>PK_NAME</b> string => primary key name (may be `NULL`)
        </li>
        <li>
        <b>DEFERRABILITY</b> short => can the evaluation of foreign key
        constraints be deferred until commit
        <ul>
        <li> INITIALLY_DEFERRED - see SQL92 for definition
        </li>
        <li> INITIALLY_IMMEDIATE - see SQL92 for definition
        </li>
        <li> NONE - see SQL92 for definition
        </li>
        </ul>
        </li>
        </ol>
        @param catalog
            a catalog name; "" retrieves those without a catalog; `VOID` means drop catalog name from the selection criteria
        @param schema
            a schema name; "" retrieves those without a schema
        @param table
            a table name
        @returns
            each row is a foreign key column description
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getExportedKeys([in]any catalog, [in]string schema,
                [in]string table) raises (SQLException);

    /** gets a description of the foreign key columns in the foreign key
        table that reference the primary key columns of the primary key
        table (describe how one table imports another's key.) This
        should normally return a single foreign key/primary key pair
        (most tables only import a foreign key from a table once.). They
        are ordered by FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, and
        KEY_SEQ.


        <p>Each foreign key column description has the following columns:
        </p>
        <ol>
        <li>
        <b>PKTABLE_CAT</b> string => primary key table catalog (may be `NULL`)
        </li>
        <li>
        <b>PKTABLE_SCHEM</b> string => primary key table schema (may be `NULL`)
        </li>
        <li>
        <b>PKTABLE_NAME</b> string => primary key table name
        </li>
        <li>
        <b>PKCOLUMN_NAME</b> string => primary key column name
        </li>
        <li>
        <b>FKTABLE_CAT</b> string => foreign key table catalog (may be `NULL`)
        being exported (may be `NULL`)
        </li>
        <li>
        <b>FKTABLE_SCHEM</b> string => foreign key table schema (may be `NULL`)
        being exported (may be `NULL`)
        </li>
        <li>
        <b>FKTABLE_NAME</b> string => foreign key table name
        being exported
        </li>
        <li>
        <b>FKCOLUMN_NAME</b> string => foreign key column name
        being exported
        </li>
        <li>
        <b>KEY_SEQ</b> short => sequence number within foreign key
        </li>
        <li>
        <b>UPDATE_RULE</b> short => What happens to
        foreign key when primary is updated:
        <ul>
        <li> NO_ACTION - do not allow update of primary
        key if it has been imported
        </li>
        <li> CASCADE - change imported key to agree
        with primary key update
        </li>
        <li> SET_NULL - change imported key to NULL if
        its primary key has been updated
        </li>
        <li> SET_DEFAULT - change imported key to default values
        if its primary key has been updated
        </li>
        <li> RESTRICT - same as importedKeyNoAction
        (for ODBC 2.x compatibility)
        </li>
        </ul>
        </li>
        <li>
        <b>DELETE_RULE</b> short => What happens to
        the foreign key when primary is deleted.
        <ul>
        <li> NO_ACTION - do not allow delete of primary
        key if it has been imported
        </li>
        <li> CASCADE - delete rows that import a deleted key
        </li>
        <li> SET_NULL - change imported key to NULL if
        its primary key has been deleted
        </li>
        <li> RESTRICT - same as importedKeyNoAction
        (for ODBC 2.x compatibility)
        </li>
        <li> SET_DEFAULT - change imported key to default if
        its primary key has been deleted
        </li>
        </ul>
        </li>
        <li>
        <b>FK_NAME</b> string => foreign key name (may be `NULL`)
        </li>
        <li>
        <b>PK_NAME</b> string => primary key name (may be `NULL`)
        </li>
        <li>
        <b>DEFERRABILITY</b> short => can the evaluation of foreign key
        constraints be deferred until commit
        <ul>
        <li> INITIALLY_DEFERRED - see SQL92 for definition
        </li>
        <li> INITIALLY_IMMEDIATE - see SQL92 for definition
        </li>
        <li> NONE - see SQL92 for definition
        </li>
        </ul>
        </li>
        </ol>
        @param primaryCatalog
            a catalog name; "" retrieves those without a catalog; `VOID` means drop catalog name from the selection criteria
        @param primarySchema
            a schema name; "" retrieves those without a schema
        @param primaryTable
            the table name that exports the key
        @param foreignCatalog
            a catalog name; "" retrieves those without a catalog; `VOID` means drop catalog name from the selection criteria
        @param foreignSchema
            a schema name; "" retrieves those without a schema
        @param foreignTable
            the table name that imports the key
        @returns
            each row is a foreign key column description
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getCrossReference(
        [in]any primaryCatalog, [in]string primarySchema,
        [in]string primaryTable,
        [in]any foreignCatalog, [in]string foreignSchema,
        [in]string foreignTable) raises (SQLException);

    /** gets a description of all the standard SQL types supported by
        this database. They are ordered by DATA_TYPE and then by how
        closely the data type maps to the corresponding SDBC SQL type.



        <p>Each type description has the following columns:
        </p>
        <ol>
        <li>
        <b>TYPE_NAME</b> string => Type name
        </li>
        <li>
        <b>DATA_TYPE</b> short => SQL data type from java.sql.Types
        </li>
        <li>
        <b>PRECISION</b> long => maximum precision
        </li>
        <li>
        <b>LITERAL_PREFIX</b> string => prefix used to quote a literal
        (may be `NULL`)
        </li>
        <li>
        <b>LITERAL_SUFFIX</b> string => suffix used to quote a literal
        (may be `NULL`)
        </li>
        <li>
        <b>CREATE_PARAMS</b> string => parameters used in creating
        the type (may be `NULL`)
        </li>
        <li>
        <b>NULLABLE</b> short => can you use NULL for this type?
        <ul>
        <li> NO_NULLS - does not allow NULL values
        </li>
        <li> NULLABLE - allows NULL values
        </li>
        <li> NULLABLE_UNKNOWN - nullability unknown
        </li>
        </ul>
        </li>
        <li>
        <b>CASE_SENSITIVE</b> boolean=> is it case sensitive?
        </li>
        <li>
        <b>SEARCHABLE</b> short => can you use "WHERE" based on this type:
        <ul>
        <li> NONE - No support
        </li>
        <li> CHAR - Only supported with WHERE .. LIKE
        </li>
        <li> BASIC - Supported except for WHERE .. LIKE
        </li>
        <li> FULL - Supported for all WHERE ..
        </li>
        </ul>
        </li>
        <li>
        <b>UNSIGNED_ATTRIBUTE</b> boolean => is it unsigned?
        </li>
        <li>
        <b>FIXED_PREC_SCALE</b> boolean => can it be a money value?
        </li>
        <li>
        <b>AUTO_INCREMENT</b> boolean => can it be used for an
        auto-increment value?
        </li>
        <li>
        <b>LOCAL_TYPE_NAME</b> string => localized version of type name
        (may be `NULL`)
        </li>
        <li>
        <b>MINIMUM_SCALE</b> short => minimum scale supported
        </li>
        <li>
        <b>MAXIMUM_SCALE</b> short => maximum scale supported
        </li>
        <li>
        <b>SQL_DATA_TYPE</b> long => unused
        </li>
        <li>
        <b>SQL_DATETIME_SUB</b> long => unused
        </li>
        <li>
        <b>NUM_PREC_RADIX</b> long => usually 2 or 10
        </li>
        </ol>
        @returns
            each row is a SQL type description
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getTypeInfo() raises (SQLException);

    /** gets a description of a table's indices and statistics. They are
        ordered by NON_UNIQUE, TYPE, INDEX_NAME, and ORDINAL_POSITION.


        <p>Each index column description has the following columns:
        </p>
        <ol>
        <li>
        <b>TABLE_CAT</b> string => table catalog (may be `NULL`)
        </li>
        <li>
        <b>TABLE_SCHEM</b> string => table schema (may be `NULL`)
        </li>
        <li>
        <b>TABLE_NAME</b> string => table name
        </li>
        <li>
        <b>NON_UNIQUE</b> boolean => Can index values be non-unique?
        `FALSE` when TYPE is tableIndexStatistic
        </li>
        <li>
        <b>INDEX_QUALIFIER</b> string => index catalog (may be `NULL`);
        `NULL` when TYPE is tableIndexStatistic
        </li>
        <li>
        <b>INDEX_NAME</b> string => index name; `NULL` when TYPE is
        tableIndexStatistic
        </li>
        <li>
        <b>TYPE</b> short => index type:
        <ul>
        <li> 0 - this identifies table statistics that are
        returned in conjunction with a table's index descriptions
        </li>
        <li> CLUSTERED - this is a clustered index
        </li>
        <li> HASHED - this is a hashed index
        </li>
        <li> OTHER - this is some other style of index
        </li>
        </ul>
        </li>
        <li>
        <b>ORDINAL_POSITION</b> short => column sequence number
        within index; zero when TYPE is tableIndexStatistic
        </li>
        <li>
        <b>COLUMN_NAME</b> string => column name; `NULL` when TYPE is
        tableIndexStatistic
        </li>
        <li>
        <b>ASC_OR_DESC</b> string => column sort sequence, "A" => ascending,
        "D" => descending, may be `NULL` if sort sequence is not supported;
        `NULL` when TYPE is tableIndexStatistic
        </li>
        <li>
        <b>CARDINALITY</b> long => When TYPE is tableIndexStatistic, then
        this is the number of rows in the table; otherwise, it is the
        number of unique values in the index.
        </li>
        <li>
        <b>PAGES</b> long => When TYPE is  tableIndexStatisic then
        this is the number of pages used for the table, otherwise it
        is the number of pages used for the current index.
        </li>
        <li>
        <b>FILTER_CONDITION</b> string => Filter condition, if any.
        (may be `NULL`)
        </li>
        </ol>
        @param catalog
            a catalog name; "" retrieves those without a catalog; `VOID` means drop catalog name from the selection criteria
        @param schema
            a schema name; "" retrieves those without a schema
        @param table
            the table name that exports the key
        @param unique
            when `TRUE`, return only indices for unique values; when `FALSE`, return indices regardless of whether unique or not
        @param approximate
            when `TRUE`, result is allowed to reflect approximate or out of data values; when `FALSE`, results are requested to be accurate
        @returns
            each row is an index column description
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getIndexInfo([in]any catalog, [in]string schema, [in]string table,
            [in]boolean unique, [in]boolean approximate)
                    raises (SQLException);

    /** Does the database support the given result set type?
        @param setType
            defined in
            com::sun::star::sdbc::ResultSetType
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsResultSetType([in]long setType) raises (SQLException);

    /** Does the database support the concurrency type in combination
        with the given result set type?
        @param setType
            defined in
            com::sun::star::sdbc::ResultSetType
        @param concurrency
            defined in
            com::sun::star::sdbc::ResultSetConcurrency
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsResultSetConcurrency([in]long setType,
                                                  [in]long concurrency)
      raises (SQLException);

    /** indicates whether a result set's own updates are visible.
        @param setType
            defined in
            com::sun::star::sdbc::ResultSetType
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean ownUpdatesAreVisible([in]long setType) raises (SQLException);

    /** indicates whether a result set's own deletes are visible.
        @param setType
            defined in
            com::sun::star::sdbc::ResultSetType
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean ownDeletesAreVisible([in]long setType) raises (SQLException);

    /** indicates whether a result set's own inserts are visible.
        @param setType
            defined in
            com::sun::star::sdbc::ResultSetType
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean ownInsertsAreVisible([in]long setType) raises (SQLException);

    /** indicates whether updates made by others are visible.
        @param setType
            defined in
            com::sun::star::sdbc::ResultSetType
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean othersUpdatesAreVisible([in]long setType) raises (SQLException);

    /** indicates whether deletes made by others are visible.
        @param setType
            defined in
            com::sun::star::sdbc::ResultSetType
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean othersDeletesAreVisible([in]long setType) raises (SQLException);

    /** indicates whether inserts made by others are visible.
        @param setType
            defined in
            com::sun::star::sdbc::ResultSetType
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean othersInsertsAreVisible([in]long setType) raises (SQLException);

    /** indicates whether or not a visible row update can be detected by
        calling the method
        <code>XResultSet.rowUpdated</code>.
        @param setType
            defined in
            com::sun::star::sdbc::ResultSetType
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean updatesAreDetected([in]long setType) raises (SQLException);

    /** indicates whether or not a visible row delete can be detected by
        calling com::sun::star::sdbc::XResultSet::rowDeleted().
        If deletesAreDetected()
        returns `FALSE`, then deleted rows are removed from the result set.
        @param setType
            defined in
            com::sun::star::sdbc::ResultSetType
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean deletesAreDetected([in]long setType) raises (SQLException);

    /** indicates whether or not a visible row insert can be detected
        by calling
        com::sun::star::sdbc::XResultSet::rowInserted().()
        @param setType
            defined in
            com::sun::star::sdbc::ResultSetType
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean insertsAreDetected([in]long setType) raises (SQLException);

    /** indicates whether the driver supports batch updates.
        @returns
            `TRUE` if so
        @throws SQLException
            if a database access error occurs.
     */
    boolean supportsBatchUpdates() raises (SQLException);

    /** Gets a description of the user-defined types defined in a particular
        schema. Schema-specific UDTs may have type OBJECT, STRUCT,
        or DISTINCT.


        <p>Only types matching the catalog, schema, type name, and type
        criteria are returned. They are ordered by DATA_TYPE, TYPE_SCHEM,
        and TYPE_NAME. The type name parameter may be a fully-qualified
        name. In this case, the catalog and schemaPattern parameters are
        ignored.
        </p>
        <p>Each type description has the following columns:
        </p>
        <ol>
        <li>
        <b>TYPE_CAT</b> string => the type's catalog (may be `NULL`)
        </li>
        <li>
        <b>TYPE_SCHEM</b> string => type's schema (may be `NULL`)
        </li>
        <li>
        <b>TYPE_NAME</b> string => type name
        </li>
        <li>
        <b>CLASS_NAME</b> string => Java class name or service name
        </li>
        <li>
        <b>DATA_TYPE</b> string => type value.
        One of OBJECT, STRUCT, or DISTINCT
        </li>
        <li>
        <b>REMARKS</b> string => explanatory comment on the type
        </li>
        </ol>
        <p>
        <b>Note:</b> If the driver does not support UDTs, an empty
        result set is returned.
        </p>
        @param catalog
            a catalog name; "" retrieves those without a catalog; `VOID` means drop catalog name from the selection criteria
        @param schemaPattern
            a schema name pattern; "" retrieves those without a schema
        @param typeNamePattern
            a type name pattern; may be a fully-qualified name
        @param types
            a list of user-named types to include (OBJECT, STRUCT, or DISTINCT)
        @returns
            each row is a type description
        @throws SQLException
            if a database access error occurs.
     */
    XResultSet getUDTs([in]any catalog, [in]string schemaPattern,
              [in]string typeNamePattern, [in]sequence<long> types)
      raises (SQLException);

    /** retrieves the connection that produced this metadata object.
        @returns
            the Connection object
        @throws SQLException
            if a database access error occurs.
     */
    XConnection getConnection() raises (SQLException);
};


}; }; }; };

#endif

/* vim:set shiftwidth=4 softtabstop=4 expandtab: */
