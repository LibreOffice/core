--- misc/cppunit-1.8.0/AUTHORS	2002-03-26 09:29:58.000000000 +0100
+++ misc/build/cppunit-1.8.0/AUTHORS	2008-12-09 08:01:30.000000000 +0100
@@ -5,3 +5,4 @@
 Baptiste Lepilleur <gaiacrtn@free.fr> <blep@sourceforge.net>
 Bastiaan Bakker <bastiaan.bakker@lifeline.nl>
 Steve Robbins <smr99@sourceforge.net>
+Lars Langhans <lla@openoffice.org>
--- misc/cppunit-1.8.0/ChangeLog	2002-04-11 11:53:02.000000000 +0200
+++ misc/build/cppunit-1.8.0/ChangeLog	2008-12-09 08:08:42.000000000 +0100
@@ -1,3 +1,9 @@
+2008-12-09 Lars Langhans <lla@openoffice.org>
+	* create with some source files a new library
+	* lot of source changes to build it within OOo environment.
+	* lot of additional code to build within OOo environment.
+	* Configure is no longer supported.
+	
 2002-04-11 Baptiste Lepilleur <gaiacrtn@free.fr>
 
 	* doc/FAQ: removed question about the Exception::operator =() problem.
--- misc/cppunit-1.8.0/INSTALL	2001-07-06 19:48:28.000000000 +0200
+++ misc/build/cppunit-1.8.0/INSTALL	2008-12-09 09:39:09.000000000 +0100
@@ -1,6 +1,12 @@
 Basic Installation
 ==================
 
+<IMPORTANT>
+This is a patched Version of CppUnit and works only in a OpenOffice.org
+environment.
+All other information here are expired.
+</IMPORTANT>
+
    These are generic installation instructions.
 
    The `configure' shell script attempts to guess correct values for
--- misc/cppunit-1.8.0/include/cppunit/Asserter.h	2002-03-28 16:47:07.000000000 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/Asserter.h	2008-02-27 17:09:30.000000000 +0100
@@ -4,6 +4,7 @@
 #include <cppunit/Portability.h>
 #include <cppunit/SourceLine.h>
 #include <string>
+#include <rtl/ustring.hxx>
 
 namespace CppUnit
 {
@@ -44,8 +45,8 @@
 
   /*! Throws a Exception with the specified message and location.
    */
-  void CPPUNIT_API fail( std::string message, 
-                         SourceLine sourceLine = SourceLine() );
+  void CPPUNIT_API fail( std::string const& message, 
+                         SourceLine const& sourceLine = SourceLine() );
 
   /*! Throws a Exception with the specified message and location.
    * \param shouldFail if \c true then the exception is thrown. Otherwise
@@ -54,8 +55,14 @@
    * \param sourceLine Location of the assertion.
    */
   void CPPUNIT_API failIf( bool shouldFail, 
-                           std::string message, 
-                           SourceLine sourceLine = SourceLine() );
+                           std::string const& message, 
+                           SourceLine const& sourceLine = SourceLine() );
+
+
+    // LLA: test, if it's possible to use a DEFINE twice ;-)
+  void CPPUNIT_API failIf( bool shouldFail, 
+                           rtl::OUString const& message, 
+                           SourceLine const& sourceLine = SourceLine() );
 
   /*! Throws a NotEqualException with the specified message and location.
    * \param expected Text describing the expected value.
@@ -64,10 +71,10 @@
    *                          where the "difference" is located.
    * \param sourceLine Location of the assertion.
    */
-  void CPPUNIT_API failNotEqual( std::string expected, 
-                                 std::string actual, 
-                                 SourceLine sourceLine = SourceLine(),
-                                 std::string additionalMessage ="" );
+  void CPPUNIT_API failNotEqual( std::string const& expected, 
+                                 std::string const& actual, 
+                                 SourceLine const& sourceLine = SourceLine(),
+                                 std::string const& additionalMessage ="" );
 
   /*! Throws a NotEqualException with the specified message and location.
    * \param shouldFail if \c true then the exception is thrown. Otherwise
@@ -79,10 +86,18 @@
    * \param sourceLine Location of the assertion.
    */
   void CPPUNIT_API failNotEqualIf( bool shouldFail,
-                                   std::string expected, 
-                                   std::string actual, 
-                                   SourceLine sourceLine = SourceLine(),
-                                   std::string additionalMessage ="" );
+                                   std::string const& expected, 
+                                   std::string const& actual, 
+                                   SourceLine const& sourceLine = SourceLine(),
+                                   std::string const& additionalMessage ="" );
+
+
+  /*! Throws an Exception with the specified message and location.
+   * \param message Message explaining the assertion failure.
+   * \param sourceLine Location of the assertion.
+   */
+  void CPPUNIT_API failStub( std::string const& message, 
+							 SourceLine const& sourceLine = SourceLine() );
 
 } // namespace Asserter
 } // namespace CppUnit
--- misc/cppunit-1.8.0/include/cppunit/Exception.h	2002-03-28 16:47:07.000000000 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/Exception.h	2008-02-27 17:10:36.000000000 +0100
@@ -21,7 +21,7 @@
     class Type
     {
     public:
-        Type( std::string type ) : m_type ( type ) {}
+        Type( std::string const& _type ) : m_type ( _type ) {}
 
         bool operator ==( const Type &other ) const
         {
@@ -32,13 +32,13 @@
     };
 
 
-    Exception( std::string  message = "", 
-	       SourceLine sourceLine = SourceLine() );
+    Exception( std::string  const& message = "", 
+	       SourceLine const& sourceLine = SourceLine() );
 
 #ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
-    Exception( std::string  message, 
+    Exception( std::string  const& message, 
 	       long lineNumber, 
-	       std::string fileName );
+	       std::string const& fileName );
 #endif
 
     Exception (const Exception& other);
@@ -74,6 +74,41 @@
     SourceLine m_sourceLine;
 };
 
+// -----------------------------------------------------------------------------
+
+class StubException : public Exception
+{
+public:
+	StubException( std::string const&  _message = "", 
+				   SourceLine const& _sourceLine = SourceLine() )
+			:Exception(_message, _sourceLine) {}
+	
+	
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+    StubException( std::string const& message, 
+				   long lineNumber, 
+				   std::string const& fileName )
+			:Exception(message, lineNumber, fileName) {}
+#endif
+};
+
+// -----------------------------------------------------------------------------
+
+class SignalException : public Exception
+{
+public:
+	SignalException( std::string const& _message = "", 
+                     SourceLine const& _sourceLine = SourceLine() )
+			:Exception(_message, _sourceLine) {}
+	
+	
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+    SignalException( std::string const& message, 
+				   long lineNumber, 
+				   std::string const& fileName )
+			:Exception(message, lineNumber, fileName) {}
+#endif
+};
 
 } // namespace CppUnit
 
--- misc/cppunit-1.8.0/include/cppunit/NotEqualException.h	2002-03-28 16:47:07.000000000 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/NotEqualException.h	2008-02-27 17:11:12.000000000 +0100
@@ -19,16 +19,16 @@
    * \param additionalMessage Additionnal information provided to further qualify
    *                          the inequality.
    */
-  NotEqualException( std::string expected,
-                     std::string actual, 
-                     SourceLine sourceLine = SourceLine(),
-                     std::string additionalMessage = "" );
+  NotEqualException( std::string const& expected,
+                     std::string const& actual, 
+                     SourceLine const& sourceLine = SourceLine(),
+                     std::string const& additionalMessage = "" );
 
 #ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
-  NotEqualException( std::string expected,
-                     std::string actual, 
+  NotEqualException( std::string const& expected,
+                     std::string const& actual, 
                      long lineNumber, 
-                     std::string fileName );
+                     std::string const& fileName );
 #endif
 
   NotEqualException( const NotEqualException &other );
--- misc/cppunit-1.8.0/include/cppunit/Portability.h	2002-03-25 19:41:39.000000000 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/Portability.h	2008-02-27 17:12:24.000000000 +0100
@@ -3,11 +3,11 @@
 
 /* include platform specific config */
 #if defined(__BORLANDC__)
-#    include <cppunit/config-bcb5.h>
+#    include <cppunit/portability/config-bcb5.h>
 #elif defined (_MSC_VER)
-#    include <cppunit/config-msvc6.h>
+#    include <cppunit/portability/config-msvc6.h>
 #else
-#    include <cppunit/config-auto.h>
+#    include <cppunit/portability/config-auto.h>
 #endif
 
 
--- misc/cppunit-1.8.0/include/cppunit/Test.h	2002-03-28 16:47:07.000000000 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/Test.h	2008-02-27 17:09:20.000000000 +0100
@@ -3,14 +3,15 @@
 
 #include <cppunit/Portability.h>
 #include <string>
+#include <cppunit/autoregister/htestresult.h>
 
 namespace CppUnit {
 
-class TestResult;
+//# class TestResult;
 
 /*! \brief Base class for all test objects.
  * \ingroup BrowsingCollectedTestResult
- *
+ *l-
  * All test objects should be a subclass of Test.  Some test objects,
  * TestCase for example, represent one individual test.  Other test
  * objects, such as TestSuite, are comprised of several tests.  
@@ -27,7 +28,7 @@
 
     /*! \brief Run the test, collecting results.
      */
-    virtual void                  run (TestResult *result)    = 0;
+    virtual void                  run (hTestResult pResult)    = 0;
 
     /*! \brief Return the number of test cases invoked by run().
      *
--- misc/cppunit-1.8.0/include/cppunit/TestAssert.h	2002-04-04 17:39:37.000000000 +0200
+++ misc/build/cppunit-1.8.0/include/cppunit/TestAssert.h	2008-02-27 17:12:12.000000000 +0100
@@ -5,9 +5,12 @@
 #include <cppunit/Exception.h>
 #include <cppunit/Asserter.h>
 
+#include <cppunit/checkboom.hxx>
 
 namespace CppUnit {
 
+
+
   /*! \brief Traits used by CPPUNIT_ASSERT_EQUAL().
    *
    * Here is an example of specialization of that traits:
@@ -31,83 +34,83 @@
    * };
    * \endcode
    */
-  template <class T>
-  struct assertion_traits 
-  {  
-      static bool equal( const T& x, const T& y )
-      {
-          return x == y;
-      }
-
-      static std::string toString( const T& x )
-      {
-          OStringStream ost;
-          ost << x;
-          return ost.str();
-      }
-  };
 
 
-  namespace TestAssert
-  {
+template <class T>
+struct assertion_traits 
+{  
+	static bool equal( const T& x, const T& y )
+	{
+		return x == y;
+	}
+
+	static std::string toString( const T& x )
+	{
+		OStringStream ost;
+		ost << x;
+		return ost.str();
+	}
+};
+
+namespace TestAssert
+{
 #ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
-    void CPPUNIT_API assertImplementation( bool         condition, 
-                                           std::string  conditionExpression = "",
-                                           long lineNumber,
-                                           std::string  fileName );
-
-    void CPPUNIT_API assertNotEqualImplementation( std::string expected,
-                                                   std::string actual,
-                                                   long lineNumber,
-                                                   std::string fileName );
-      
-
-    template <class T>
-    void assertEquals( const T& expected,
-                       const T& actual,
-                       long lineNumber,
-                       std::string fileName )
-    {
-      if ( !assertion_traits<T>::equal(expected,actual) ) // lazy toString conversion...
-      {
-        assertNotEqualImplementation( assertion_traits<T>::toString(expected),
-                                      assertion_traits<T>::toString(actual),
-                                      lineNumber, 
-                                      fileName );
-      }
-    }
-
-    void CPPUNIT_API assertEquals( double expected, 
-                                   double actual, 
-                                   double delta, 
-                                   long lineNumber,
-                                   std::string fileName );
+	  void CPPUNIT_API assertImplementation( bool         condition, 
+											 std::string  conditionExpression = "",
+											 long lineNumber,
+											 std::string  fileName );
+
+	  void CPPUNIT_API assertNotEqualImplementation( std::string expected,
+													 std::string actual,
+													 long lineNumber,
+													 std::string fileName );
+		
+
+	  template <class T>
+	  void assertEquals( const T& expected,
+						 const T& actual,
+						 long lineNumber,
+						 std::string fileName )
+	  {
+		if ( !assertion_traits<T>::equal(expected,actual) ) // lazy toString conversion...
+		{
+		  assertNotEqualImplementation( assertion_traits<T>::toString(expected),
+										assertion_traits<T>::toString(actual),
+										lineNumber, 
+										fileName );
+		}
+	  }
+
+	  void CPPUNIT_API assertEquals( double expected, 
+									 double actual, 
+									 double delta, 
+									 long lineNumber,
+									 std::string fileName );
 
 #else   //                  using SourceLine
 
-    template <class T>
-    void assertEquals( const T& expected,
-                       const T& actual,
-                       SourceLine sourceLine,
-                       const std::string &message ="" )
-    {
-      if ( !assertion_traits<T>::equal(expected,actual) ) // lazy toString conversion...
-      {
-        Asserter::failNotEqual( assertion_traits<T>::toString(expected),
-                                assertion_traits<T>::toString(actual),
-                                sourceLine,
-                                message );
-      }
-    }
-
-    void CPPUNIT_API assertDoubleEquals( double expected,
-                                         double actual,
-                                         double delta,
-                                         SourceLine sourceLine );
+	  template <class T>
+	  void assertEquals( const T& expected,
+						 const T& actual,
+						 SourceLine sourceLine,
+						 const std::string &message ="" )
+	  {
+		if ( !assertion_traits<T>::equal(expected,actual) ) // lazy toString conversion...
+		{
+		  Asserter::failNotEqual( assertion_traits<T>::toString(expected),
+								  assertion_traits<T>::toString(actual),
+								  sourceLine,
+								  message );
+		}
+	  }
+
+  void CPPUNIT_API assertDoubleEquals( double expected,
+  									 double actual,
+  									 double delta,
+  									 SourceLine sourceLine );
 
 #endif
-  }
-
+}
 
 /* A set of macros which allow us to get the line number
  * and file name at the point of an error.
@@ -118,15 +121,22 @@
 /** Assertions that a condition is \c true.
  * \ingroup Assertions
  */
-#define CPPUNIT_ASSERT(condition)                          \
-  ( ::CppUnit::Asserter::failIf( !(condition),             \
-                                 (#condition),             \
-                                 CPPUNIT_SOURCELINE() ) )
+    // LLA: due to the fact, that side effects are not wished, we create a local scope, 
+    //      assign the condition to a local variable and check this variable again and again.
+
+#define CPPUNIT_ASSERT(condition)                       \
+   {   bool __bLocalCondition = condition;                     \
+       CheckBoom((__bLocalCondition), (#condition));           \
+       (::CppUnit::Asserter::failIf( !(__bLocalCondition),     \
+                                    (#condition),       \
+                                    CPPUNIT_SOURCELINE() ) ); }
 #else
-#define CPPUNIT_ASSERT(condition)                          \
-  ( ::CppUnit::Asserter::failIf( !(condition),             \
-                                 "",                       \
-                                 CPPUNIT_SOURCELINE() ) )
+#define CPPUNIT_ASSERT(condition)                       \
+   { bool __bLocalCondition = condition;                       \
+   CheckBoom((__bLocalCondition), "");                         \
+    (::CppUnit::Asserter::failIf( !(__bLocalCondition),        \
+                                 "",                    \
+                                 CPPUNIT_SOURCELINE() ) ); }
 #endif
 
 /** Assertion with a user specified message.
@@ -136,25 +146,33 @@
  * \param condition If this condition evaluates to \c false then the
  *                  test failed.
  */
-#define CPPUNIT_ASSERT_MESSAGE(message,condition)          \
-  ( ::CppUnit::Asserter::failIf( !(condition),             \
-                                 (message),                \
-                                 CPPUNIT_SOURCELINE() ) )
+#define CPPUNIT_ASSERT_MESSAGE(message,condition)       \
+   { bool __bLocalCondition = (condition);                     \
+   CheckBoom((__bLocalCondition), (message));                  \
+    (::CppUnit::Asserter::failIf( !(__bLocalCondition),        \
+                                 (message),             \
+                                 CPPUNIT_SOURCELINE() ) ); }
+
+#define CPPUNIT_ASSERT_STUB() \
+   CheckBoom((1 == 0), ("This is only a stub."));          \
+   (::CppUnit::Asserter::failStub("This is only a stub.",  \
+								  CPPUNIT_SOURCELINE() ) )
+
 
 /** Fails with the specified message.
  * \ingroup Assertions
  * \param message Message reported in diagnostic.
  */
 #define CPPUNIT_FAIL( message )                            \
-  ( ::CppUnit::Asserter::fail( message,                    \
-                               CPPUNIT_SOURCELINE() ) )
+	( ::CppUnit::Asserter::fail( message,                    \
+								 CPPUNIT_SOURCELINE() ) )
 
 #ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
 /// Generalized macro for primitive value comparisons
 #define CPPUNIT_ASSERT_EQUAL(expected,actual)                    \
-  ( ::CppUnit::TestAssert::assertEquals( (expected),             \
-                                         (actual),               \
-                                         __LINE__, __FILE__ ) )
+	( ::CppUnit::TestAssert::assertEquals( (expected),             \
+										   (actual),               \
+										   __LINE__, __FILE__ ) )
 #else
 /** Asserts that two values are equals.
  * \ingroup Assertions
@@ -173,9 +191,9 @@
  * removed by specializing the CppUnit::assertion_traits.
  */
 #define CPPUNIT_ASSERT_EQUAL(expected,actual)                     \
-  ( ::CppUnit::TestAssert::assertEquals( (expected),              \
-                                         (actual),                \
-                                         CPPUNIT_SOURCELINE() ) )
+	( ::CppUnit::TestAssert::assertEquals( (expected),              \
+										   (actual),                \
+										   CPPUNIT_SOURCELINE() ) )
 
 /** Asserts that two values are equals, provides additional messafe on failure.
  * \ingroup Assertions
@@ -196,20 +214,20 @@
  * removed by specializing the CppUnit::assertion_traits.
  */
 #define CPPUNIT_ASSERT_EQUAL_MESSAGE(message,expected,actual)     \
-  ( ::CppUnit::TestAssert::assertEquals( (expected),              \
-                                         (actual),                \
-                                         CPPUNIT_SOURCELINE(),    \
-                                         (message) ) )
+	( ::CppUnit::TestAssert::assertEquals( (expected),              \
+										   (actual),                \
+										   CPPUNIT_SOURCELINE(),    \
+										   (message) ) )
 #endif
 
 /*! \brief Macro for primitive value comparisons
  * \ingroup Assertions
  */
 #define CPPUNIT_ASSERT_DOUBLES_EQUAL(expected,actual,delta)       \
-  ( ::CppUnit::TestAssert::assertDoubleEquals( (expected),        \
-                                               (actual),          \
-                                               (delta),           \
-                                               CPPUNIT_SOURCELINE() ) )
+	( ::CppUnit::TestAssert::assertDoubleEquals( (expected),        \
+												 (actual),          \
+												 (delta),           \
+												 CPPUNIT_SOURCELINE() ) )
 
 // Backwards compatibility
 
@@ -223,7 +241,6 @@
 
 #endif
 
-
 } // namespace CppUnit
 
 #endif  // CPPUNIT_TESTASSERT_H
--- misc/cppunit-1.8.0/include/cppunit/TestCaller.h	2002-03-28 16:47:07.000000000 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/TestCaller.h	2008-02-27 17:09:40.000000000 +0100
@@ -111,7 +111,7 @@
    * \param name name of this TestCaller
    * \param test the method this TestCaller calls in runTest()
    */
-  TestCaller( std::string name, TestMethod test ) :
+  TestCaller( std::string const& name, TestMethod test ) :
 	    TestCase( name ), 
 	    m_ownFixture( true ),
 	    m_fixture( new Fixture() ),
@@ -128,7 +128,7 @@
    * \param test the method this TestCaller calls in runTest()
    * \param fixture the Fixture to invoke the test method on.
    */
-  TestCaller(std::string name, TestMethod test, Fixture& fixture) :
+  TestCaller(std::string const& name, TestMethod test, Fixture& fixture) :
 	    TestCase( name ), 
 	    m_ownFixture( false ),
 	    m_fixture( &fixture ),
@@ -145,7 +145,7 @@
    * \param test the method this TestCaller calls in runTest()
    * \param fixture the Fixture to invoke the test method on.
    */
-  TestCaller(std::string name, TestMethod test, Fixture* fixture) :
+  TestCaller(std::string const& name, TestMethod test, Fixture* fixture) :
 	    TestCase( name ), 
 	    m_ownFixture( true ),
 	    m_fixture( fixture ),
--- misc/cppunit-1.8.0/include/cppunit/TestCase.h	2002-03-27 18:56:45.000000000 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/TestCase.h	2008-02-27 17:11:00.000000000 +0100
@@ -3,15 +3,13 @@
 
 #include <cppunit/Portability.h>
 #include <cppunit/Test.h>
-#include <cppunit/TestAssert.h>
 #include <cppunit/TestFixture.h>
 #include <string>
-
+#include <cppunit/autoregister/htestresult.h>
 
 namespace CppUnit {
 
-class TestResult;
-
+//# class TestResult;
 
 /*! \brief A single test object.
  *
@@ -28,25 +26,25 @@
 {
 public:
 
-    TestCase( std::string Name );
+    TestCase( std::string const& Name );
     //! \internal
     TestCase();
     ~TestCase();
     
-    virtual void run(TestResult *result);
+    virtual void run(hTestResult pResult);
     virtual int countTestCases() const;
     std::string getName() const;
     std::string toString() const;
 
     //! FIXME: what is this for?
-    virtual TestResult *run();
+    //# virtual TestResult *run();
     
 protected:
     //! FIXME: this should probably be pure virtual.
     virtual void runTest();
 
     //! Create TestResult for the run(void) method.
-    TestResult *defaultResult();
+    //# TestResult *defaultResult();
     
 private:
     TestCase( const TestCase &other ); 
--- misc/cppunit-1.8.0/include/cppunit/TestFailure.h	2002-03-28 16:47:07.000000000 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/TestFailure.h	2008-02-27 17:09:50.000000000 +0100
@@ -4,6 +4,16 @@
 #include <cppunit/Portability.h>
 #include <string>
 
+namespace ErrorType
+{
+	enum num
+	{
+		ET_FAILURE = 1,
+		ET_ERROR = 2,
+		ET_SIGNAL = 4
+	};
+}
+
 namespace CppUnit {
 
 class Exception;
@@ -20,12 +30,13 @@
  * TestFailure assumes lifetime control for any exception
  * passed to it.
  */
+
 class CPPUNIT_API TestFailure 
 {
 public:
   TestFailure( Test *failedTest,
                Exception *thrownException,
-               bool isError );
+               ErrorType::num eError );
 
   virtual ~TestFailure ();
 
@@ -36,6 +47,7 @@
   virtual SourceLine sourceLine() const;
 
   virtual bool isError() const;
+  virtual ErrorType::num getErrorType() const;
 
   virtual std::string failedTestName() const;
   
@@ -46,7 +58,7 @@
 protected:
   Test *m_failedTest;
   Exception *m_thrownException;
-  bool m_isError;
+  ErrorType::num m_eError;
 
 private: 
   TestFailure( const TestFailure &other ); 
--- misc/cppunit-1.8.0/include/cppunit/TestFixture.h	2002-03-28 16:47:07.000000000 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/TestFixture.h	2008-02-27 17:10:26.000000000 +0100
@@ -74,11 +74,6 @@
  *  }
  * \endcode
  * 
- * A set of macros have been created for convenience. They are located in HelperMacros.h.
- *
- * \see TestResult, TestSuite, TestCaller,
- * \see CPPUNIT_TEST_SUB_SUITE, CPPUNIT_TEST, CPPUNIT_TEST_SUITE_END, 
- * \see CPPUNIT_TEST_SUITE_REGISTRATION, CPPUNIT_TEST_EXCEPTION, CPPUNIT_TEST_FAIL.
  */
 class CPPUNIT_API TestFixture
 {
--- misc/cppunit-1.8.0/include/cppunit/TestSuite.h	2002-03-28 16:47:07.000000000 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/TestSuite.h	2008-02-27 17:11:24.000000000 +0100
@@ -4,17 +4,20 @@
 #include <cppunit/Portability.h>
 
 #if CPPUNIT_NEED_DLL_DECL
+#ifdef _MSC_VER
 #pragma warning( push )
 #pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
 #endif
+#endif
 
 #include <cppunit/Test.h>
 #include <vector>
 #include <string>
+#include <cppunit/autoregister/htestresult.h>
 
 namespace CppUnit {
 
-class TestResult;
+//# class TestResult;
 
 #if CPPUNIT_NEED_DLL_DECL
   template class CPPUNIT_API std::vector<Test *>;
@@ -35,7 +38,6 @@
  * Note that TestSuites assume lifetime
  * control for any tests added to them.
  *
- * TestSuites do not register themselves in the TestRegistry.
  * \see Test 
  * \see TestCaller
  */
@@ -44,10 +46,10 @@
 class CPPUNIT_API TestSuite : public Test
 {
 public:
-  TestSuite( std::string name = "" );
+  TestSuite( std::string const& name = "" );
   ~TestSuite();
 
-  void run( TestResult *result );
+  void run( hTestResult pResult );
   int countTestCases() const;
   std::string getName() const;
   std::string toString() const;
@@ -71,7 +73,9 @@
 
 
 #if CPPUNIT_NEED_DLL_DECL
+#ifdef _MSC_VER
 #pragma warning( pop )
 #endif
+#endif
 
 #endif // CPPUNIT_TESTSUITE_H
--- misc/cppunit-1.8.0/include/cppunit/additionalfunc.hxx	2008-12-10 20:46:05.823290260 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/additionalfunc.hxx	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,61 @@
-dummy
+#ifndef ADDITIONALFUNC_HXX
+#define ADDITIONALFUNC_HXX
+
+#include "cppunit/autoregister/registertestfunction.h"
+#include "sal/types.h"
+
+extern "C" void SAL_CALL RegisterAdditionalFunctions(FktRegFuncPtr _pFunc);
+
+#define NOADDITIONAL \
+void RegisterAdditionalFunctions(FktRegFuncPtr){}
+
+namespace {
+    
+enum T2_OSType {
+    T2_OS_WNT32 = 1,
+    T2_OS_UNIX,
+    T2_OS_OS2
+};
+
+inline T2_OSType getOSType()
+{
+#if defined WNT
+    return T2_OS_WNT32;
+#elif defined OS2
+    return T2_OS_OS2;
+#else
+    return T2_OS_UNIX;
+#endif
+}
+ 
+}
+
+#define TESTSHL2_UNO_BOOTSTRAP(file)                                                    \
+void RegisterAdditionalFunctions(FktRegFuncPtr _pFunc)                                  \
+{                                                                                       \
+   com::sun::star::uno::Reference< com::sun::star::lang::XMultiServiceFactory> xMS;     \
+   com::sun::star::uno::Reference< com::sun::star::uno::XComponentContext > xComponentContext; \
+   try {                                                                                \
+       if (strlen(#file) > 0) {                                                         \
+           ::rtl::OUString iniFile(rtl::OUString::createFromAscii(#file));              \
+           if (getOSType() == T2_OS_WNT32 || getOSType() == T2_OS_OS2) {                \
+               iniFile += ::rtl::OUString::createFromAscii(".ini");                     \
+           } else {                                                                     \
+               iniFile += ::rtl::OUString::createFromAscii("rc");                       \
+           }                                                                            \
+           xComponentContext = cppu::defaultBootstrap_InitialComponentContext(iniFile); \
+       } else {                                                                         \
+           xComponentContext = cppu::defaultBootstrap_InitialComponentContext();        \
+       }                                                                                \
+       xMS.set(xComponentContext->getServiceManager(), com::sun::star::uno::UNO_QUERY); \
+       comphelper::setProcessServiceFactory(xMS);                                       \
+   }                                                                                    \
+   catch (::com::sun::star::uno::Exception e ) {                                        \
+       rtl::OString aError;                                                             \
+       aError = rtl::OUStringToOString(e.Message, RTL_TEXTENCODING_ASCII_US);           \
+       printf("Error at UNO bootstrap time caught: %s\nMust quit.\n", aError.getStr()); \
+       exit(1);                                                                         \
+   }                                                                                    \
+} 
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit: additionalfunc.hxx.dummy.
--- misc/cppunit-1.8.0/include/cppunit/autoregister/callbackfunc_fktptr.h	2008-12-10 20:46:05.931077489 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/autoregister/callbackfunc_fktptr.h	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,63 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _callbackfunc_fktptr_h
+#define _callbackfunc_fktptr_h
+
+#include <sal/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// these typedefs are used for the TestCase, to call the TestResult functions.
+// The TestResult is only in the testshl tool, not in the test libraries.
+
+typedef void* hTest;
+typedef void* hException;
+
+typedef sal_Int32 (* FktPtr_CallbackDispatch)(int x, ...);
+
+//# typedef void (* FktPtr_TestResult_startTest)(hTestResult, hTest );
+//# typedef void (* FktPtr_TestResult_addFailure)( hTestResult, hTest , hException pException );
+//# typedef void (* FktPtr_TestResult_addError)( hTestResult, hTest , hException pException );
+//# typedef void (* FktPtr_TestResult_endTest)( hTestResult, hTest );
+//# typedef bool (* FktPtr_TestResult_shouldStop)(hTestResult);
+//# 
+//# // Additional functions
+//# typedef void (* FktPtr_TestResult_addInfo)( hTestResult, hTest, const char* );
+//# typedef void (* FktPtr_TestResult_enterNode)( hTestResult, const char* );
+//# typedef void (* FktPtr_TestResult_leaveNode)( hTestResult, const char* );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit/autoregister: callbackfunc_fktptr.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/autoregister/callbackstructure.h	2008-12-10 20:46:06.013912039 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/autoregister/callbackstructure.h	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,89 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _callbackstructure_h
+#define _callbackstructure_h
+
+#include <sal/types.h>
+#include <cppunit/autoregister/callbackfunc_fktptr.h>
+#include <cppunit/autoregister/registerfunc.h>
+#include <cppunit/autoregister/registertestfunction.h>
+#include <cppunit/cmdlinebits.hxx>
+
+// this structure will filled by the testshl tool and hand to the testdll
+
+struct CallbackStructure
+{
+    // a version number, if we want to change/expand this struct 
+    sal_Int32 nVersion;
+    sal_Int64 nMagic;
+
+    FktRegFuncPtr                aRegisterFunction;
+    
+    FktPtr_CallbackDispatch      aCallbackDispatch;
+
+    //# FktPtr_TestResult_startTest  aStartTest;
+    //# FktPtr_TestResult_addFailure aAddFailure; 
+    //# FktPtr_TestResult_addError   aAddError;
+    //# FktPtr_TestResult_endTest    aEndTest;  
+    //# FktPtr_TestResult_shouldStop aShouldStop;
+    //# 
+    //# FktPtr_TestResult_addInfo    aAddInfo;
+    //# FktPtr_TestResult_enterNode  aEnterNode;
+    //# FktPtr_TestResult_leaveNode  aLeaveNode;
+    
+	const char* psForward;
+    CmdLineBits nBits;
+
+    // void* pJobList;
+
+    sal_Int64 nMagic2;
+
+    CallbackStructure()
+            :nVersion(1),
+             nMagic(SAL_CONST_INT64(0x0123456789abcdef)),
+             aRegisterFunction(NULL),
+             aCallbackDispatch(NULL),
+             /* aStartTest(NULL),
+             aAddFailure(NULL),
+             aAddError(NULL),
+             aEndTest(NULL),
+             aShouldStop(NULL),
+             aAddInfo(NULL),
+             aEnterNode(NULL),
+             aLeaveNode(NULL), */
+			 psForward(NULL),
+             nBits(0),
+             /* pJobList(NULL), */
+             nMagic2(0)
+        {}
+};
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit/autoregister: callbackstructure.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/autoregister/htestresult.h	2008-12-10 20:46:06.090738039 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/autoregister/htestresult.h	2008-02-27 17:17:34.000000000 +0100
@@ -1 +1,6 @@
-dummy
+#ifndef _htestresult_h
+#define _htestresult_h
+
+typedef void* hTestResult;
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit/autoregister: htestresult.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/autoregister/registerfunc.h	2008-12-10 20:46:06.135034318 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/autoregister/registerfunc.h	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,50 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _registerfunc_h
+#define _registerfunc_h
+
+#include <sal/types.h>
+#include <cppunit/autoregister/htestresult.h>
+#include <cppunit/autoregister/callbackfunc_fktptr.h>
+#include <cppunit/autoregister/testfunc.h>
+
+struct CallbackStructure;
+
+// this function is used to register one function into a Container in the testshl tool.
+extern "C" void SAL_CALL registerFunction(FktPtr aFunc, const char* aFuncName);
+
+// this function is the register function for auto registering
+
+extern "C" void SAL_CALL registerAllTestFunction(CallbackStructure* );
+typedef void (* FktRegAllPtr)(CallbackStructure*);
+
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit/autoregister: registerfunc.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/autoregister/registertestfunction.h	2008-12-10 20:46:06.214882818 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/autoregister/registertestfunction.h	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,54 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _registertestfunction_h
+#define _registertestfunction_h
+
+#include <sal/types.h>
+#include <cppunit/autoregister/testfunc.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+    
+// function ptr, to register a function
+typedef void (* FktRegFuncPtr)(FktPtr aFunc, const char* aFuncName);
+
+// this function is used in the testdll to register the given function
+// into the testshl
+extern "C" void SAL_CALL RegisterTestFunctions(FktRegFuncPtr aFunc);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
Nur in misc/build/cppunit-1.8.0/include/cppunit/autoregister: registertestfunction.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/autoregister/testfunc.h	2008-12-10 20:46:06.292344601 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/autoregister/testfunc.h	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,47 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _testfunc_h
+#define _testfunc_h
+
+#include <cppunit/autoregister/htestresult.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+    
+// typedef for a testfunction
+typedef void (* FktPtr)(hTestResult);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit/autoregister: testfunc.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/checkboom.hxx	2008-12-10 20:46:06.371034174 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/checkboom.hxx	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,40 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef CHECKBOOM_HXX
+#define CHECKBOOM_HXX
+
+#include <string>
+#include <rtl/ustring.hxx>
+
+void CheckBoom(bool bCondition, std::string const& msg);
+void CheckBoom(bool bCondition, rtl::OUString const& msg);
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit: checkboom.hxx.dummy.
--- misc/cppunit-1.8.0/include/cppunit/cmdlinebits.hxx	2008-12-10 20:46:06.465888459 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/cmdlinebits.hxx	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,52 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef CMDLINEBITS_HXX
+#define CMDLINEBITS_HXX
+
+#include <sal/types.h>
+
+typedef sal_uInt32 CmdLineBits;
+const char* getForwardString();
+
+#include <stdarg.h>
+
+enum T_Print_Params {
+    T_INFO = 1,
+    T_VERBOSE,
+    T_DEBUG,
+    T_ERROR
+};
+
+// void t_print(const char*);
+void t_print(const char*, ...);
+void t_print(T_Print_Params, const char*, ...);
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit: cmdlinebits.hxx.dummy.
--- misc/cppunit-1.8.0/include/cppunit/extensions/AutoRegisterSuite.h	2002-03-28 16:47:07.000000000 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/extensions/AutoRegisterSuite.h	2008-02-27 17:16:16.000000000 +0100
@@ -1,6 +1,7 @@
 #ifndef CPPUNIT_EXTENSIONS_AUTOREGISTERSUITE_H
 #define CPPUNIT_EXTENSIONS_AUTOREGISTERSUITE_H
 
+#include <stdio.h>
 #include <string>
 #include <cppunit/extensions/TestSuiteFactory.h>
 #include <cppunit/extensions/TestFactoryRegistry.h>
@@ -30,19 +31,20 @@
       /** Auto-register the suite factory in the global registry.
        */
       AutoRegisterSuite()
-      {
-        TestFactory *factory = new TestSuiteFactory<TestCaseType>();
-        TestFactoryRegistry::getRegistry().registerFactory( factory );
-      }
-
+          {
+              TestFactory *factory = new TestSuiteFactory<TestCaseType>();
+              TestFactoryRegistry::getRegistry().registerFactory( factory );
+	  }
+      
       /** Auto-register the suite factory in the specified registry.
        * \param name Name of the registry.
        */
       AutoRegisterSuite( const std::string &name )
-      {
-        TestFactory *factory = new TestSuiteFactory<TestCaseType>();
-        TestFactoryRegistry::getRegistry( name ).registerFactory( factory );
-      }
+          {
+              // printf("AutoRegisterSuite %s\n", name.c_str());
+              TestFactory *factory = new TestSuiteFactory<TestCaseType>();
+              TestFactoryRegistry::getRegistry( name ).registerFactory( factory );
+          }
   };
 
 } // namespace CppUnit
--- misc/cppunit-1.8.0/include/cppunit/extensions/HelperMacros.h	2002-03-28 16:47:07.000000000 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/extensions/HelperMacros.h	2008-02-27 17:17:12.000000000 +0100
@@ -132,6 +132,14 @@
       }                                                                   \
     };                                                                    \
   public:                                                                 \
+    static CppUnit::TestSuite *suite()                                    \
+    {                                                                     \
+      CppUnit::TestSuiteBuilder<__ThisTestFixtureType>                    \
+          builder __CPPUNIT_SUITE_CTOR_ARGS( ATestFixtureType );          \
+      ThisTestFixtureFactory factory;                                     \
+      __ThisTestFixtureType::registerTests( builder.suite(), &factory );  \
+      return builder.takeSuite();                                         \
+    }                                                                     \
     static void                                                           \
     registerTests( CppUnit::TestSuite *suite,                             \
                    CppUnit::TestFixtureFactory *factory )                 \
@@ -245,14 +253,6 @@
 #define CPPUNIT_TEST_SUITE_END()                                          \
       builder.takeSuite();                                                \
     }                                                                     \
-    static CppUnit::TestSuite *suite()                                    \
-    {                                                                     \
-      CppUnit::TestSuiteBuilder<__ThisTestFixtureType>                    \
-          builder __CPPUNIT_SUITE_CTOR_ARGS( ATestFixtureType );          \
-      ThisTestFixtureFactory factory;                                     \
-      __ThisTestFixtureType::registerTests( builder.suite(), &factory );  \
-      return builder.takeSuite();                                         \
-    }                                                                     \
   private: /* dummy typedef so that the macro can still end with ';'*/    \
     typedef ThisTestFixtureFactory __ThisTestFixtureFactory                   
 
@@ -283,10 +283,12 @@
  * \see CPPUNIT_TEST_SUITE, CppUnit::AutoRegisterSuite, 
  *      CppUnit::TestFactoryRegistry.
  */
-#define CPPUNIT_TEST_SUITE_REGISTRATION( ATestFixtureType )      \
-  static CppUnit::AutoRegisterSuite< ATestFixtureType >          \
-             __CPPUNIT_MAKE_UNIQUE_NAME(__autoRegisterSuite )
 
+/* LLA: 
+ #define CPPUNIT_TEST_SUITE_REGISTRATION( ATestFixtureType )      \
+   static CppUnit::AutoRegisterSuite< ATestFixtureType >          \
+ 			 __CPPUNIT_MAKE_UNIQUE_NAME(__autoRegisterSuite )
+*/
 
 /** Adds the specified fixture suite to the specified registry suite.
  * \ingroup CreatingTestSuite
@@ -325,21 +327,7 @@
  */
 #define CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ATestFixtureType, suiteName ) \
   static CppUnit::AutoRegisterSuite< ATestFixtureType >                      \
-             __CPPUNIT_MAKE_UNIQUE_NAME(__autoRegisterSuite )(suiteName)
-
-
-// Backwards compatibility
-// (Not tested!)
-
-#if CPPUNIT_ENABLE_CU_TEST_MACROS
-
-#define CU_TEST_SUITE(tc) CPPUNIT_TEST_SUITE(tc)
-#define CU_TEST_SUB_SUITE(tc,sc) CPPUNIT_TEST_SUB_SUITE(tc,sc)
-#define CU_TEST(tm) CPPUNIT_TEST(tm)
-#define CU_TEST_SUITE_END() CPPUNIT_TEST_SUITE_END()
-#define CU_TEST_SUITE_REGISTRATION(tc) CPPUNIT_TEST_SUITE_REGISTRATION(tc)
-
-#endif
+             __CPPUNIT_MAKE_UNIQUE_NAME(__autoRegisterSuite )( suiteName )
 
 
 #endif  // CPPUNIT_EXTENSIONS_HELPERMACROS_H
--- misc/cppunit-1.8.0/include/cppunit/extensions/TestFactoryRegistry.h	2002-03-28 16:47:07.000000000 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/extensions/TestFactoryRegistry.h	2008-02-27 17:16:38.000000000 +0100
@@ -4,14 +4,18 @@
 #include <cppunit/Portability.h>
 
 #if CPPUNIT_NEED_DLL_DECL
+#ifdef _MSC_VER
 #pragma warning( push )
 #pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
 #endif
+#endif
 
 #include <cppunit/extensions/TestFactory.h>
 #include <map>
 #include <string>
 
+#include <cppunit/autoregister/htestresult.h>
+
 namespace CppUnit {
 
 class TestSuite;
@@ -79,7 +83,7 @@
    * \param name Name of the registry. It is the name of TestSuite returned by
    *             makeTest().
    */
-  TestFactoryRegistry( std::string name = "All Tests" );
+  TestFactoryRegistry( std::string const& name = "All Tests" );
 
   /// Destructor.
   virtual ~TestFactoryRegistry();
@@ -105,6 +109,7 @@
    *         specified name.
    */
   static TestFactoryRegistry &getRegistry( const std::string &name );
+  static void testRegistries(hTestResult _pResult);
 
   /** Adds the registered tests to the specified suite.
    * \param suite Suite the tests are added to.
@@ -116,9 +121,12 @@
    * \param factory Factory to register. 
    * \deprecated Use registerFactory( TestFactory *) instead.
    */
+protected:
+    
   void registerFactory( const std::string &name,
                         TestFactory *factory );
-
+public:
+    
   /** Adds the specified TestFactory to the registry.
    *
    * \param factory Factory to register. 
@@ -141,8 +149,10 @@
 
 
 #if CPPUNIT_NEED_DLL_DECL
+#ifdef _MSC_VER
 #pragma warning( pop )
 #endif
+#endif
 
 
 #endif  // CPPUNIT_EXTENSIONS_TESTFACTORYREGISTRY_H
--- misc/cppunit-1.8.0/include/cppunit/extensions/TestSuiteBuilder.h	2002-03-28 16:47:07.000000000 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/extensions/TestSuiteBuilder.h	2008-02-27 17:17:22.000000000 +0100
@@ -34,11 +34,11 @@
       }
 #endif
 
-      TestSuiteBuilder( TestSuite *suite ) : m_suite( suite ) 
+      TestSuiteBuilder( TestSuite *_suite ) : m_suite( _suite ) 
       {
       }
 
-      TestSuiteBuilder(std::string name) : m_suite( new TestSuite(name) ) 
+      TestSuiteBuilder(std::string const& name) : m_suite( new TestSuite(name) ) 
       {
       }
 
@@ -57,7 +57,7 @@
         m_suite->addTest( test );
       }
 
-      void addTestCaller( std::string methodName, 
+      void addTestCaller( std::string const& methodName, 
                           TestMethod testMethod )
       {
           Test *test = 
@@ -66,7 +66,7 @@
           addTest( test );
       }
 
-      void addTestCaller( std::string methodName, 
+      void addTestCaller( std::string const& methodName, 
                           TestMethod testMethod, 
                           Fixture *fixture )
       {
@@ -78,7 +78,7 @@
       }
 
       template<typename ExceptionType>
-      void addTestCallerForException( std::string methodName, 
+      void addTestCallerForException( std::string const& methodName, 
                                       TestMethod testMethod, 
                                       Fixture *fixture,
                                       ExceptionType *dummyPointer )
@@ -93,7 +93,8 @@
     
       std::string makeTestName( const std::string &methodName )
       {
-        return m_suite->getName() + "." + methodName;
+          // return m_suite->getName() + "." + methodName;
+          return methodName;
       }
 
     private:
--- misc/cppunit-1.8.0/include/cppunit/externcallbackfunc.hxx	2008-12-10 20:46:06.550085206 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/externcallbackfunc.hxx	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,58 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _externcallbackfunc_hxx
+#define _externcallbackfunc_hxx
+
+#include <cppunit/autoregister/callbackfunc_fktptr.h>
+
+// these pointers have they origin in 'tresregister.cxx'
+extern FktPtr_CallbackDispatch pCallbackFunc;
+
+//# extern FktPtr_TestResult_startTest  pTestResult_StartTest;
+//# extern FktPtr_TestResult_addFailure pTestResult_AddFailure;
+//# extern FktPtr_TestResult_addError   pTestResult_AddError;
+//# extern FktPtr_TestResult_endTest    pTestResult_EndTest;
+//# extern FktPtr_TestResult_addInfo    pTestResult_AddInfo;
+
+// these pointers have they origin in 'tresregister.cxx'
+// extern FktPtr_TestResult_Starter  pTestResult_Starter;
+
+//# extern FktPtr_TestResult_startTest  pTestResult_StartTest;
+//# extern FktPtr_TestResult_addFailure pTestResult_AddFailure;
+//# extern FktPtr_TestResult_addError   pTestResult_AddError;
+//# extern FktPtr_TestResult_endTest    pTestResult_EndTest;
+//# extern FktPtr_TestResult_addInfo    pTestResult_AddInfo;
+//# 
+//# extern FktPtr_TestResult_enterNode  pTestResult_EnterNode;
+//# extern FktPtr_TestResult_leaveNode  pTestResult_LeaveNode;
+//# 
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit: externcallbackfunc.hxx.dummy.
--- misc/cppunit-1.8.0/include/cppunit/joblist.hxx	2008-12-10 20:46:06.643901729 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/joblist.hxx	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,99 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef CPPUNIT_JOBLIST_HXX
+#define CPPUNIT_JOBLIST_HXX
+
+#include <vector>
+#include <string>
+#include <hash_map>
+#include "sal/types.h"
+
+// #include <cppunit/nocopy.hxx>
+
+/*
+  struct eqstr
+  {
+  bool operator()( std::string const & s1, std::string const& s2 ) const 
+  {
+  return ( s1 == s2 );
+  }
+  };
+*/
+
+/*
+  struct hashstr
+  {
+  sal_uInt32 operator()( std::string const & str ) const 
+  {
+  return str.hashCode();
+  }
+  };
+*/
+typedef std::hash_map< std::string, int > HashMap;
+
+// typedef std::vector<std::string> StringList;
+
+#define JOB_UNKNOWN   0
+#define JOB_NOT_FOUND 1
+#define JOB_PASSED    2
+#define JOB_FAILED    3
+#define JOB_ACCESS    4
+
+#define JOB_EXCLUDE_LIST 0x1000
+#define JOB_ONLY_LIST    0x1001
+
+typedef sal_Int16 JobType;
+
+class JobList /* : NOCOPY */
+{
+    HashMap m_aJobList;
+    char** ppsJobList;
+
+    // returns true if the given List contains unxlngi or unxsols or wntmsci...
+    bool isInCurrentEnvironment(std::string const& _sString);
+    std::string trim(std::string const& _sStringToTrim);
+
+public:
+    JobList();
+    ~JobList();
+
+    bool readfile(std::string const& _sFilename, JobType _nJobType);
+    const char** getList() const {return (const char**)ppsJobList;}
+
+    int getJobListEntry(std::string const& _sIndexName);
+    void setJobListEntry(std::string const& _sIndexName, int _nValue);
+
+    int size() {return m_aJobList.size();}
+    HashMap const& getHashMap() {return m_aJobList;}
+};
+
+#endif
+
Nur in misc/build/cppunit-1.8.0/include/cppunit: joblist.hxx.dummy.
--- misc/cppunit-1.8.0/include/cppunit/nocopy.hxx	2008-12-10 20:46:06.720535461 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/nocopy.hxx	2008-02-27 17:08:42.000000000 +0100
@@ -1 +1,13 @@
-dummy
+#ifndef NOCOPY_HXX
+#define NOCOPY_HXX
+
+// prevent illegal copies
+class NOCOPY
+{
+	NOCOPY(NOCOPY const&);
+	NOCOPY& operator=(NOCOPY const&);
+public:
+	NOCOPY(){}
+};
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit: nocopy.hxx.dummy.
--- misc/cppunit-1.8.0/include/cppunit/portability/config-auto.h	2008-12-10 20:46:06.802507987 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/portability/config-auto.h	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,64 @@
-dummy
+#ifndef _INCLUDE_CPPUNIT_CONFIG_AUTO_H
+#define _INCLUDE_CPPUNIT_CONFIG_AUTO_H 1
+ 
+/* include/cppunit/config-auto.h. Generated automatically at end of configure. */
+/* config/config.h.  Generated automatically by configure.  */
+/* config/config.h.in.  Generated automatically from configure.in by autoheader.  */
+
+/* define if library uses std::string::compare(string,pos,n) */
+#ifndef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST 
+#define CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST  1 
+#endif
+
+/* define if the library defines sstream */
+#ifndef CPPUNIT_HAVE_SSTREAM
+#define CPPUNIT_HAVE_SSTREAM 1 
+#endif
+
+/* Define if you have the <cmath> header file. */
+#ifndef CPPUNIT_HAVE_CMATH 
+#define CPPUNIT_HAVE_CMATH  1 
+#endif
+
+/* Define if you have the <dlfcn.h> header file. */
+#ifndef CPPUNIT_HAVE_DLFCN_H 
+#define CPPUNIT_HAVE_DLFCN_H  1 
+#endif
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES 
+#define CPPUNIT_HAVE_NAMESPACES  1 
+#endif
+
+/* define if the compiler supports Run-Time Type Identification */
+#ifndef CPPUNIT_HAVE_RTTI 
+#define CPPUNIT_HAVE_RTTI  0 
+#endif
+
+/* define if the compiler has stringstream */
+#ifndef CPPUNIT_HAVE_SSTREAM
+#define CPPUNIT_HAVE_SSTREAM 1
+#endif
+
+/* Define if you have the <strstream> header file. */
+#ifndef CPPUNIT_HAVE_STRSTREAM 
+#define CPPUNIT_HAVE_STRSTREAM  1 
+#endif
+
+/* Name of package */
+#ifndef CPPUNIT_PACKAGE 
+#define CPPUNIT_PACKAGE  "cppunit" 
+#endif
+
+/* Define to 1 to use type_info::name() for class names */
+#ifndef CPPUNIT_USE_TYPEINFO_NAME 
+#define CPPUNIT_USE_TYPEINFO_NAME  CPPUNIT_HAVE_RTTI 
+#endif
+
+/* Version number of package */
+#ifndef CPPUNIT_VERSION 
+#define CPPUNIT_VERSION  "1.8.0" 
+#endif
+ 
+/* _INCLUDE_CPPUNIT_CONFIG_AUTO_H */
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit/portability: config-auto.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/portability/config-bcb5.h	2008-12-10 20:46:05.287223886 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/portability/config-bcb5.h	2008-02-27 17:15:52.000000000 +0100
@@ -1 +1,48 @@
-dummy
+#ifndef _INCLUDE_CPPUNIT_CONFIG_BCB5_H
+#define _INCLUDE_CPPUNIT_CONFIG_BCB5_H 1
+
+#define HAVE_CMATH 1
+ 
+/* include/cppunit/config-bcb5.h. Manually adapted from 
+   include/cppunit/config-auto.h */
+
+/* define if library uses std::string::compare(string,pos,n) */
+#ifndef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST 
+#define CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST  1 
+#endif
+
+/* Define if you have the <dlfcn.h> header file. */
+#ifdef CPPUNIT_HAVE_DLFCN_H 
+#undef CPPUNIT_HAVE_DLFCN_H 
+#endif
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES 
+#define CPPUNIT_HAVE_NAMESPACES  1 
+#endif
+
+/* define if the compiler supports Run-Time Type Identification */
+#ifndef CPPUNIT_HAVE_RTTI 
+#define CPPUNIT_HAVE_RTTI  1 
+#endif
+
+/* Define to 1 to use type_info::name() for class names */
+#ifndef CPPUNIT_USE_TYPEINFO_NAME 
+#define CPPUNIT_USE_TYPEINFO_NAME  CPPUNIT_HAVE_RTTI 
+#endif
+
+#define CPPUNIT_HAVE_SSTREAM 1
+
+/* Name of package */
+#ifndef CPPUNIT_PACKAGE 
+#define CPPUNIT_PACKAGE  "cppunit" 
+#endif
+
+/* Version number of package */
+#ifndef CPPUNIT_VERSION 
+#define CPPUNIT_VERSION  "1.5.5" 
+#endif
+ 
+ 
+/* _INCLUDE_CPPUNIT_CONFIG_BCB5_H */
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit/portability: config-bcb5.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/portability/config-msvc6.h	2008-12-10 20:46:05.392326519 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/portability/config-msvc6.h	2008-02-27 17:15:40.000000000 +0100
@@ -1 +1,62 @@
-dummy
+#ifndef _INCLUDE_CPPUNIT_CONFIG_MSVC6_H
+#define _INCLUDE_CPPUNIT_CONFIG_MSVC6_H 1
+
+#define HAVE_CMATH 1
+ 
+/* include/cppunit/config-msvc6.h. Manually adapted from 
+   include/cppunit/config-auto.h */
+
+/* define if library uses std::string::compare(string,pos,n) */
+#ifdef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST 
+#undef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST
+#endif
+
+/* Define if you have the <dlfcn.h> header file. */
+#ifdef CPPUNIT_HAVE_DLFCN_H 
+#undef CPPUNIT_HAVE_DLFCN_H 
+#endif
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES 
+#define CPPUNIT_HAVE_NAMESPACES  1 
+#endif
+
+#ifndef CPPUNIT_HAVE_RTTI 
+#define CPPUNIT_HAVE_RTTI  0
+#endif
+
+#ifndef CPPUNIT_USE_TYPEINFO_NAME 
+#define CPPUNIT_USE_TYPEINFO_NAME  CPPUNIT_HAVE_RTTI 
+#endif
+
+#define CPPUNIT_HAVE_SSTREAM 1
+
+/* Name of package */
+#ifndef CPPUNIT_PACKAGE 
+#define CPPUNIT_PACKAGE  "cppunit" 
+#endif
+
+#undef CPPUNIT_API
+
+// define CPPUNIT_DLL_BUILD when building CppUnit dll.
+#ifdef CPPUNIT_BUILD_DLL
+#define CPPUNIT_API __declspec(dllexport)
+#endif
+
+// define CPPUNIT_DLL when linking to CppUnit dll.
+#ifdef CPPUNIT_DLL
+#define CPPUNIT_API __declspec(dllimport)
+#endif
+
+#ifdef CPPUNIT_API
+#undef CPPUNIT_NEED_DLL_DECL
+#define CPPUNIT_NEED_DLL_DECL 1
+#endif
+
+#if _MSC_VER > 1000     // VC++
+#pragma warning( disable : 4786 )   // disable warning debug symbol > 255...
+#endif // _MSC_VER > 1000
+
+ 
+/* _INCLUDE_CPPUNIT_CONFIG_MSVC6_H */
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit/portability: config-msvc6.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/result/SynchronizedObject.h	2008-12-10 20:46:04.893658092 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/result/SynchronizedObject.h	2008-02-27 17:14:06.000000000 +0100
@@ -1 +1,82 @@
-dummy
+#ifndef CPPUNIT_SYNCHRONIZEDOBJECT_H
+#define CPPUNIT_SYNCHRONIZEDOBJECT_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/nocopy.hxx>
+
+namespace CppUnit
+{
+
+/*! \brief Base class for synchronized object.
+ *
+ * Synchronized object are object which members are used concurrently by mutiple
+ * threads.
+ *
+ * This class define the class SynchronizationObject which must be subclassed
+ * to implement an actual lock.
+ *
+ * Each instance of this class holds a pointer on a lock object.
+ *
+ * See src/msvc6/MfcSynchronizedObject.h for an example.
+ */
+class CPPUNIT_API SynchronizedObject
+{
+public:
+  /*! \brief Abstract synchronization object (mutex)
+   */
+  class SynchronizationObject
+  {
+    public:
+      SynchronizationObject() {}
+      virtual ~SynchronizationObject() {}
+
+      virtual void lock() {}
+      virtual void unlock() {}
+  };
+
+  /*! Constructs a SynchronizedObject object.
+   */
+  SynchronizedObject( SynchronizationObject *syncObject =0 );
+
+  /// Destructor.
+  virtual ~SynchronizedObject();
+
+protected:
+  /*! \brief Locks a synchronization object in the current scope.
+   */
+    class ExclusiveZone : NOCOPY
+  {
+    SynchronizationObject *m_syncObject;
+
+  public:
+    ExclusiveZone( SynchronizationObject *syncObject ) 
+        : m_syncObject( syncObject ) 
+    { 
+      m_syncObject->lock(); 
+    }
+
+    ~ExclusiveZone() 
+    { 
+      m_syncObject->unlock (); 
+    }
+  };
+
+  virtual void setSynchronizationObject( SynchronizationObject *syncObject );
+
+protected:
+  SynchronizationObject *m_syncObject;
+
+private:
+  /// Prevents the use of the copy constructor.
+  SynchronizedObject( const SynchronizedObject &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const SynchronizedObject &copy );
+};
+
+
+
+} //  namespace CppUnit
+
+
+#endif  // CPPUNIT_SYNCHRONIZEDOBJECT_H
Nur in misc/build/cppunit-1.8.0/include/cppunit/result: SynchronizedObject.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/result/TestListener.h	2008-12-10 20:46:04.938237839 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/result/TestListener.h	2008-02-27 17:14:38.000000000 +0100
@@ -1 +1,62 @@
-dummy
+#ifndef CPPUNIT_TESTLISTENER_H    // -*- C++ -*-
+#define CPPUNIT_TESTLISTENER_H
+
+#include <cppunit/Portability.h>
+
+
+namespace CppUnit {
+
+class Exception;
+class Test;
+class TestFailure;
+
+
+/*! \brief Listener for test progress and result.
+ * \ingroup TrackingTestExecution
+ *
+ * Implementing the Observer pattern a TestListener may be registered
+ * to a TestResult to obtain information on the testing progress. Use
+ * specialized sub classes of TestListener for text output
+ * (TextTestProgressListener). Do not use the Listener for the test
+ * result output, use a subclass of Outputter instead.
+ *
+ * The test framework distinguishes between failures and errors.
+ * A failure is anticipated and checked for with assertions. Errors are
+ * unanticipated problems signified by exceptions that are not generated
+ * by the framework.
+ *
+ * \see TestResult
+ */
+class CPPUNIT_API TestListener
+{
+public:
+  virtual ~TestListener() {}
+  
+  /// Called when just before a TestCase is run.
+	virtual void startTest( Test *test ) =0 ;
+
+  /*! Called when a failure occurs while running a test.
+   * \see TestFailure.
+   * \warning \a failure is a temporary object that is destroyed after the 
+   *          method call. Use TestFailure::clone() to create a duplicate.
+   */
+	virtual void addFailure( const TestFailure &failure ) =0;
+
+  /// Called just after a TestCase was run (even if a failure occured).
+	virtual void endTest( Test *test ) =0;
+
+	// additional info
+	virtual void addInfo(Test *test, const char*) =0;
+	
+	// info in which node we are
+	// helper functions to create tree structures
+    // old: virtual void enterNode( const char* ) =0;
+    // old: virtual void leaveNode( const char* ) =0;
+};
+
+
+} // namespace CppUnit
+
+#endif // CPPUNIT_TESTLISTENER_H
+
+
Nur in misc/build/cppunit-1.8.0/include/cppunit/result: TestListener.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/result/TestResult.h	2008-12-10 20:46:05.070889564 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/result/TestResult.h	2008-02-27 17:13:08.000000000 +0100
@@ -1 +1,123 @@
-dummy
+#ifndef CPPUNIT_TESTRESULT_H
+#define CPPUNIT_TESTRESULT_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#ifdef _MSC_VER
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+#endif
+
+#include <cppunit/result/SynchronizedObject.h>
+#include <vector>
+#include <string>
+#include <deque>
+//!io #include <iostream>
+
+#include "cppunit/result/optionhelper.hxx"
+#include "cppunit/TestFailure.h"
+
+class Outputter;
+namespace CppUnit {
+
+class Exception;
+class Test;
+// class TestFailure;
+class TestListener;
+
+#if CPPUNIT_NEED_DLL_DECL
+  template class CPPUNIT_API std::deque<TestListener *>;
+#endif
+
+/*! \brief Manages TestListener.
+ * \ingroup TrackingTestExecution
+ *
+ * A single instance of this class is used when running the test. It is usually
+ * created by the test runner (TestRunner).
+ *
+ * This class shouldn't have to be inherited from. Use a TestListener
+ * or one of its subclasses to be informed of the ongoing tests.
+ * Use a Outputter to receive a test summary once it has finished
+ *
+ * TestResult supplies a template method 'setSynchronizationObject()'
+ * so that subclasses can provide mutual exclusion in the face of multiple
+ * threads.  This can be useful when tests execute in one thread and
+ * they fill a subclass of TestResult which effects change in another 
+ * thread.  To have mutual exclusion, override setSynchronizationObject()
+ * and make sure that you create an instance of ExclusiveZone at the 
+ * beginning of each method.
+ *
+ * \see Test, TestListener, TestResultCollector, Outputter.
+ */
+class CPPUNIT_API TestResult : protected SynchronizedObject
+{
+protected:
+	OptionHelper m_aOptionHelper;
+
+public:
+  TestResult( GetOpt & _aOptions, SynchronizationObject *syncObject = 0 );
+  virtual ~TestResult();
+
+  virtual void addListener( TestListener *listener );
+  virtual void removeListener( TestListener *listener );
+
+  virtual void reset();
+  virtual void stop();
+
+  virtual bool shouldStop() const;
+
+  virtual void startTest( Test *test );
+  virtual void addError( Test *test, Exception *e, ErrorType::num eType=ErrorType::ET_ERROR);
+  virtual void addFailure( Test *test, Exception *e );
+  virtual void endTest( Test *test );
+
+    // LLA: additionals
+  virtual void addInfo(Test *test, const char *sInfo);
+
+  virtual void enterNode(const char* Node);
+  virtual void leaveNode(const char* Node);
+  virtual std::string getNodeName();
+
+  // if true, execution is allowed.
+  virtual bool isAllowedToExecute(std::string const & sName);
+  bool isOnlyShowJobs() {return m_aOptionHelper.isOnlyShowJobs();}
+  bool isOptionWhereAmI();
+    
+  virtual void print(Outputter &);
+  void setExitValue(int _nValue) {m_nExitValue = _nValue;}
+  int getExitValue() {return m_nExitValue;}
+    
+protected:
+  void addFailure( const TestFailure &failure );
+  
+protected:
+  typedef std::deque<TestListener *> TestListeners;
+  TestListeners m_listeners;
+  bool m_stop;
+
+    // this vector is used to expand the test name with a current node name
+    std::vector<std::string> m_aCurrentNodeNames;
+
+    //# std::vector<std::string> m_aNodes;
+
+private: 
+  TestResult( const TestResult &other );
+  TestResult &operator =( const TestResult &other );
+  int m_nExitValue;
+};
+
+
+} // namespace CppUnit
+
+
+#if CPPUNIT_NEED_DLL_DECL
+#ifdef _MSC_VER
+#pragma warning( pop )
+#endif
+#endif
+
+#endif // CPPUNIT_TESTRESULT_H
+
+
Nur in misc/build/cppunit-1.8.0/include/cppunit/result: TestResult.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/result/TestResultCollector.h	2008-12-10 20:46:05.024473262 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/result/TestResultCollector.h	2008-02-27 17:14:48.000000000 +0100
@@ -1 +1,165 @@
-dummy
+#ifndef CPPUNIT_TESTRESULTCOLLECTOR_H
+#define CPPUNIT_TESTRESULTCOLLECTOR_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#ifdef _MSC_VER
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+#endif
+
+#include <cppunit/result/TestResult.h>
+#include <cppunit/result/TestSucessListener.h>
+#include <deque>
+#include <vector>
+
+namespace CppUnit
+{
+
+
+#if CPPUNIT_NEED_DLL_DECL
+  template class CPPUNIT_API std::deque<TestFailure *>;
+  template class CPPUNIT_API std::deque<Test *>;
+#endif
+
+
+/*! \brief Collects test result.
+ * \ingroup WritingTestResult
+ * \ingroup BrowsingCollectedTestResult
+ * 
+ * A TestResultCollector is a TestListener which collects the results of executing 
+ * a test case. It is an instance of the Collecting Parameter pattern.
+ *
+ * The test framework distinguishes between failures and errors.
+ * A failure is anticipated and checked for with assertions. Errors are
+ * unanticipated problems signified by exceptions that are not generated
+ * by the framework.
+ * \see TestListener, TestFailure.
+ */
+
+class OneStringContainer
+{
+	std::string m_sName;
+protected:
+	OneStringContainer() {}
+public:
+	OneStringContainer(std::string const& _sName)
+			:m_sName(_sName){}
+	std::string getString() const {return m_sName;}
+    virtual ~OneStringContainer(){}
+};
+
+// -----------------------------------------------------------------------------
+class TestEnvelope : public OneStringContainer
+{
+	Test* m_pTest;
+public:
+	TestEnvelope():m_pTest(NULL){}
+	
+	TestEnvelope(Test* _pTest, std::string const& _sName)
+			: OneStringContainer(_sName),
+              m_pTest(_pTest)
+		{}
+
+	Test* getTest() {return m_pTest;}
+    virtual ~TestEnvelope(){}
+    
+};
+
+// -----------------------------------------------------------------------------
+class TestInfo : public TestEnvelope
+{
+public:
+	TestInfo(Test* _pTest, std::string const& _sName)
+			:TestEnvelope(_pTest, _sName)
+		{}
+};
+
+// -----------------------------------------------------------------------------
+class TestFailureEnvelope : public OneStringContainer
+{
+	TestFailure* m_pTestFailure;
+public:
+	TestFailureEnvelope():m_pTestFailure(NULL){}
+
+	TestFailureEnvelope(TestFailure* _pTestFailure, std::string const& _sName)
+			:OneStringContainer(_sName),
+             m_pTestFailure(_pTestFailure)
+		{}
+
+	TestFailure* getTestFailure() {return m_pTestFailure;}
+    virtual ~TestFailureEnvelope(){}
+    
+};
+// -----------------------------------------------------------------------------
+
+class CPPUNIT_API TestResultCollector : public TestSucessListener
+{
+    TestResult* m_pResult;
+public:
+	typedef std::deque<TestFailureEnvelope *> TestFailures;
+	typedef std::deque<TestEnvelope *> Tests;
+	typedef std::vector<TestInfo *> TestInfos;
+
+
+  /*! Constructs a TestResultCollector object.
+   */
+  TestResultCollector( TestResult *_pResult, SynchronizationObject *syncObject = 0 );
+
+  /// Destructor.
+  virtual ~TestResultCollector();
+
+  void startTest( Test *test );
+  void endTest( Test *test );
+	
+  void addFailure( const TestFailure &failure );
+
+  virtual void reset();
+
+  virtual int runTests() const;
+  virtual int testErrors() const;
+  virtual int testFailures() const;
+  virtual int testFailuresTotal() const;
+
+  virtual const TestFailures& failures() const;
+  virtual const Tests &tests() const;
+  virtual std::string getInfo(Test*);
+
+  virtual void addInfo(Test *test, const char *sInfo);
+
+    // virtual void enterNode(const char* Node);
+    // virtual void leaveNode(const char* Node);
+
+protected:
+  Tests        m_tests;
+  TestFailures m_failures;
+  TestInfos    m_aInfos;
+
+  int m_testErrors;
+
+    // this vector is used to expand the test name with a current node name
+    // std::vector<std::string> m_aCurrentNodeNames;
+    // std::string getNodeName();
+private:
+  /// Prevents the use of the copy constructor.
+  TestResultCollector( const TestResultCollector &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const TestResultCollector &copy );
+};
+
+
+
+} //  namespace CppUnit
+
+
+#if CPPUNIT_NEED_DLL_DECL
+#ifdef _MSC_VER
+#pragma warning( pop )
+#endif
+#endif
+
+
+#endif  // CPPUNIT_TESTRESULTCOLLECTOR_H
Nur in misc/build/cppunit-1.8.0/include/cppunit/result: TestResultCollector.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/result/TestSucessListener.h	2008-12-10 20:46:05.161106554 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/result/TestSucessListener.h	2008-02-27 17:14:16.000000000 +0100
@@ -1 +1,40 @@
-dummy
+#ifndef CPPUNIT_TESTSUCESSLISTENER_H
+#define CPPUNIT_TESTSUCESSLISTENER_H
+
+#include <cppunit/result/SynchronizedObject.h>
+#include <cppunit/result/TestListener.h>
+
+
+namespace CppUnit
+{
+
+/*! \brief TestListener that checks if any test case failed.
+ * \ingroup TrackingTestExecution
+ */
+class CPPUNIT_API TestSucessListener : public TestListener,
+                                       public SynchronizedObject
+{
+public:
+  /*! Constructs a TestSucessListener object.
+   */
+  TestSucessListener( SynchronizationObject *syncObject = 0 );
+
+  /// Destructor.
+  virtual ~TestSucessListener();
+
+  virtual void reset();
+
+  void addFailure( const TestFailure &failure );
+
+  /// Returns whether the entire test was successful or not.
+  virtual bool wasSuccessful() const;
+
+private:
+  bool m_sucess;
+};
+
+
+} //  namespace CppUnit
+
+
+#endif  // CPPUNIT_TESTSUCESSLISTENER_H
Nur in misc/build/cppunit-1.8.0/include/cppunit/result: TestSucessListener.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/result/TextTestResult.h	2008-12-10 20:46:05.242583534 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/result/TextTestResult.h	2008-02-27 17:14:28.000000000 +0100
@@ -1 +1,62 @@
-dummy
+#ifndef CPPUNIT_TEXTTESTRESULT_H
+#define CPPUNIT_TEXTTESTRESULT_H
+
+#include <cppunit/result/TestResult.h>
+#include <cppunit/result/TestResultCollector.h>
+#include <ostream>
+
+class GetOpt;
+namespace CppUnit {
+
+class SourceLine;
+class Exception;
+class Test;
+
+/*! \brief Holds printable test result (DEPRECATED).
+ * \ingroup TrackingTestExecution
+ * 
+ * deprecated Use class TextTestProgressListener and TextOutputter instead.
+ */
+class CPPUNIT_API TextTestResult : public TestResult
+/*									   public TestResultCollector*/
+{
+	TestResultCollector m_aResulter;
+public:
+  TextTestResult(GetOpt& _aOptions);
+
+  virtual void addFailure( const TestFailure &failure );
+  virtual void startTest( Test *test );
+  virtual void endTest( Test *test );
+
+  virtual void print( std::ostream &stream );
+protected:
+    
+  virtual void printFailures( std::ostream &stream );
+  virtual void printHeader( std::ostream &stream );
+
+  virtual void printFailure( TestFailure *failure,
+                             int failureNumber,
+                             std::ostream &stream );
+  virtual void printFailureListMark( int failureNumber,
+                                     std::ostream &stream );
+  virtual void printFailureTestName( TestFailure *failure,
+                                     std::ostream &stream );
+  virtual void printFailureType( TestFailure *failure,
+                                 std::ostream &stream );
+  virtual void printFailureLocation( SourceLine sourceLine,
+                                     std::ostream &stream );
+  virtual void printFailureDetail( Exception *thrownException,
+                                   std::ostream &stream );
+  virtual void printFailureWarning( std::ostream &stream );
+  virtual void printStatistics( std::ostream &stream );
+};
+
+/** insertion operator for easy output */
+std::ostream &operator <<( std::ostream &stream, 
+                           TextTestResult &result );
+
+} // namespace CppUnit
+
+#endif // CPPUNIT_TEXTTESTRESULT_H
+
+
Nur in misc/build/cppunit-1.8.0/include/cppunit/result: TextTestResult.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/result/callbackfunc.h	2008-12-10 20:46:06.881445744 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/result/callbackfunc.h	2008-02-27 17:15:00.000000000 +0100
@@ -1 +1,25 @@
-dummy
+#ifndef _callbackfunc_h
+#define _callbackfunc_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+	// this is the entry point from the DLL back to the executable.
+    sal_Int32 CallbackDispatch(int x, ...);
+
+//# void TestResult_startTest(hTestResult _pResult, hTest _pTest);
+//# void TestResult_addFailure( hTestResult _pResult, hTest _pTest, hException _pException );
+//# void TestResult_addError( hTestResult _pResult, hTest _pTest, hException _pException );
+//# void TestResult_endTest( hTestResult _pResult, hTest _pTest );
+//# bool TestResult_shouldStop(hTestResult _pResult);
+//# void TestResult_addInfo( hTestResult _pResult, hTest _pTest, const char* _sInfo );
+//# 
+//# void TestResult_enterNode( hTestResult _pResult, const char* _sInfo );
+//# void TestResult_leaveNode( hTestResult _pResult, const char* _sInfo );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit/result: callbackfunc.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/result/emacsTestResult.hxx	2008-12-10 20:46:06.924792880 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/result/emacsTestResult.hxx	2008-12-10 20:42:43.000000000 +0100
@@ -1 +1,82 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef cppunit_emacstestresult_h
+#define cppunit_emacstestresult_h
+
+#include <cppunit/result/TestResult.h>
+#include <cppunit/result/TestResultCollector.h>
+#include <ostream>
+#include "testshl/getopt.hxx"
+
+class Outputter;
+namespace CppUnit {
+
+class SourceLine;
+class Exception;
+class Test;
+
+/*! \brief Holds printable test result (DEPRECATED).
+ * \ingroup TrackingTestExecution
+ * 
+ * deprecated Use class TextTestProgressListener and TextOutputter instead.
+ */
+    class CPPUNIT_API emacsTestResult : public TestResult
+	
+/* ,public TestResultCollector*/
+    {
+        GetOpt & m_aOptions;
+        // OptionHelper m_aOptionHelper;
+        TestResultCollector m_aResulter;
+        
+    public:
+        emacsTestResult(GetOpt & _aOptions);
+        
+        // virtual void addFailure( const TestFailure &failure );
+        // virtual void startTest( Test *test );
+        // virtual void endTest( Test *test );
+        
+        virtual void print( Outputter &stream );
+        
+    protected:
+        virtual void printHeader( Outputter &stream );
+        // virtual void printTestLine( Outputter &stream, Test* pTest, std::string const& _sNodeName, std::string const& _sInfo);
+        virtual void printFailureLine( Outputter &stream, TestFailure* pFailure, std::string const& _sNodeName );
+    };
+    
+/** insertion operator for easy output */
+//    std::ostream &operator <<( std::ostream &stream, 
+//                               emacsTestResult &result );
+    
+} // namespace CppUnit
+
+#endif // CPPUNIT_testshlTESTRESULT_H
+
+
Nur in misc/build/cppunit-1.8.0/include/cppunit/result: emacsTestResult.hxx.dummy.
--- misc/cppunit-1.8.0/include/cppunit/result/log.hxx	2008-12-10 20:46:07.004030154 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/result/log.hxx	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,106 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+#ifndef __QADEV_REGSCAN_LOG_HXX__
+#define __QADEV_REGSCAN_LOG_HXX__
+
+#include <time.h>
+#include	<rtl/ustring.hxx>
+#include	<rtl/strbuf.hxx>
+#include	<sal/types.h>
+#include	<osl/thread.h>
+#include	<osl/file.hxx>
+
+#include <cppunit/nocopy.hxx>
+
+//!io #include <iostream>
+#include <vector>
+
+// using namespace std;
+
+
+/**
+ * Log derives the interface of the ::osl::File class ( is-a relation ).
+ * Its members (has-a relation) are the (full qualified)name of the log
+ * and an OStringBuffer which represents the content of the logfile.
+ * It provides the functionality of easy-to-use open and write logs
+ */
+//: Log
+class Log : NOCOPY {
+
+    ::osl::File*            m_logfile;          // fileobject
+    rtl::OUString         m_logurl;           // url of log
+	rtl::OStringBuffer	m_buf;              // content of log
+
+    Log();
+
+public:
+
+	//> c'tor
+	/**
+	 * constructors argument is a full qualified UNC path
+	 * @param OUString logfile ( full qualified UNC path )
+	 */
+    Log( const rtl::OUString& logURL )
+            : m_logfile( new ::osl::File( logURL ))
+			, m_logurl(logURL)
+    {} ///< c'tor
+
+    //> d'tor
+    virtual ~Log()
+        {
+            m_logfile->close();
+            delete( m_logfile );
+        } ///< d'tor
+
+	//> inline methods
+	// returns a reference to name instance
+    inline rtl::OUString getLogURL() { return m_logurl; }
+    inline rtl::OString getName() { return rtl::OUStringToOString(
+                                    m_logurl, RTL_TEXTENCODING_ASCII_US  ); }
+	///< inline methods
+
+	// open logfile for overwrite (default) or append
+	::osl::FileBase::RC open( sal_Bool append = sal_False );
+	::osl::FileBase::RC close() { return m_logfile->close(); }
+
+
+	// write methods without (default) or with echo on display
+	::osl::FileBase::RC write( const sal_Char* buf, sal_Bool v = sal_False );
+	::osl::FileBase::RC write( const rtl::OString& buf,
+													sal_Bool v = sal_False );
+	//! ::osl::FileBase::RC write( rtl::OStringBuffer& buf,
+	//! 												sal_Bool v = sal_False );
+	::osl::FileBase::RC write( const rtl::OUString& buf,
+							rtl_TextEncoding enc = RTL_TEXTENCODING_ASCII_US,
+												 sal_Bool v = sal_False   );
+
+}; ///:~ Log
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit/result: log.hxx.dummy.
--- misc/cppunit-1.8.0/include/cppunit/result/optionhelper.hxx	2008-12-10 20:46:07.084399993 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/result/optionhelper.hxx	2008-12-10 20:42:43.000000000 +0100
@@ -1 +1,98 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef optionhelper_hxx
+#define optionhelper_hxx
+
+#include <string>
+
+#include <sal/types.h>
+
+#include "cppunit/nocopy.hxx"
+#include "testshl/getopt.hxx"
+#include "cppunit/joblist.hxx"
+
+// -----------------------------------------------------------------------------
+
+typedef std::vector<rtl::OString> OStringList;
+
+//!? Better: OptionHelper
+class OptionHelper : NOCOPY
+{
+    GetOpt & m_aOption;
+    JobList     m_aJobOnlyList;
+    JobList     m_aJobExcludeList;
+    OStringList m_aJobFilter;
+    
+    std::string m_sProjectId;
+    std::string m_sBuildId;
+    
+    std::string getProjectId() const;
+    std::string getBuildId() const;
+    std::string createDateTag(std::string const& _sProjectId, std::string const& _sBuildId);
+    
+    void handleJobs();
+public:
+    OptionHelper(GetOpt & _aOption)
+            :m_aOption(_aOption)
+        {
+            if (m_aOption.hasOpt("-projectid"))
+                m_sProjectId = m_aOption.getOpt("-projectid");
+            
+            if (m_aOption.hasOpt("-buildid"))
+                m_sBuildId = m_aOption.getOpt("-buildid");
+
+			handleJobs();
+        }
+    
+    static std::string integerToAscii(sal_Int32 nValue);
+    static std::string twoDigits(std::string const& _sValue);
+
+    std::string createDateTag();
+    bool showErrors();
+    bool showTests();
+
+    JobList getJobOnlyList() {return m_aJobOnlyList;}
+    JobList getJobExcludeList() {return m_aJobExcludeList;}
+    
+    bool isAllowedToExecute(std::string const& _sNode, std::string const& _sName);
+
+    bool isOnlyShowJobs() {return m_aOption.hasOpt("-onlyshowjobs") == sal_True ? true : false;}
+	GetOpt& getOptions() {return m_aOption;}
+	bool isVerbose() {return m_aOption.hasOpt("-verbose") == sal_True ? true : false;} 
+    bool isOptionWhereAmI() {return m_aOption.hasOpt("-whereami") == sal_True ? true : false;}
+};
+
+// -----------------------------------------------------------------------------
+
+
+#endif
+
+
Nur in misc/build/cppunit-1.8.0/include/cppunit/result: optionhelper.hxx.dummy.
--- misc/cppunit-1.8.0/include/cppunit/result/outputter.hxx	2008-12-10 20:46:07.186579135 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/result/outputter.hxx	2008-12-10 20:42:43.000000000 +0100
@@ -1 +1,85 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+//
+
+#ifndef outputter_hxx
+#define outputter_hxx
+
+#include <string>
+#include <ostream>
+#include <memory>
+#include "testshl/log.hxx"
+#include <sal/types.h>
+#include "cppunit/nocopy.hxx"
+
+// #include <fstream>
+
+class Outputter : NOCOPY
+{
+    std::auto_ptr<Log> m_pLog;
+    std::ostream* m_pStream;
+
+    void writeToAll(const sal_Char* _pStr);
+public:
+    class endl
+    {
+        char c;
+    public:
+        endl():c('\0'){}
+    };
+public:
+    Outputter(Log * _pLog )
+            :m_pLog(_pLog),
+             m_pStream(NULL) {}
+    
+    Outputter(std::ostream& _aStream)
+            :m_pLog(NULL),
+             m_pStream(&_aStream) {}
+
+    ~Outputter();
+
+    void write(const sal_Char*);
+    void write(std::string const&);
+    void write(sal_Int32);
+    // void write(double);
+};
+
+Outputter& operator <<( Outputter &stream, const sal_Char* );
+Outputter& operator <<( Outputter &stream, std::string const& );
+Outputter& operator <<( Outputter &stream, sal_Int32 );
+// Outputter& operator <<( Outputter &stream, double );
+
+Outputter& operator <<( Outputter &stream, Outputter::endl const&);
+
+// Outputter& operator <<( Outputter &stream, const char* );
+
+#endif
+
Nur in misc/build/cppunit-1.8.0/include/cppunit/result: outputter.hxx.dummy.
--- misc/cppunit-1.8.0/include/cppunit/result/testshlTestResult.h	2008-12-10 20:46:07.267386761 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/result/testshlTestResult.h	2008-12-10 20:42:43.000000000 +0100
@@ -1 +1,72 @@
-dummy
+#ifndef cppunit_testshltestresult_h
+#define cppunit_testshltestresult_h
+
+#include <map>
+#include <cppunit/result/TestResult.h>
+#include <cppunit/result/TestResultCollector.h>
+#include <ostream>
+#include "testshl/getopt.hxx"
+
+class Outputter;
+
+namespace CppUnit {
+
+class SourceLine;
+class Exception;
+class Test;
+
+struct ltstr
+{
+    bool operator()(const CppUnit::Test* p1, const CppUnit::Test* p2) const
+        {
+            return p1 < p2;
+        }
+};
+typedef std::map<CppUnit::Test*, bool, ltstr> TestPtrList;
+
+
+/*! \brief Holds printable test result (DEPRECATED).
+ * \ingroup TrackingTestExecution
+ * 
+ * deprecated Use class TextTestProgressListener and TextOutputter instead.
+ */
+    class CPPUNIT_API testshlTestResult : public TestResult
+	
+/* ,public TestResultCollector*/
+	{
+		GetOpt & m_aOptions;
+		// OptionHelper m_aOptionHelper;
+		TestResultCollector m_aResulter;
+		
+	public:
+		testshlTestResult(GetOpt & _aOptions);
+		virtual ~testshlTestResult();
+		
+		// virtual void addFailure( const TestFailure &failure );
+		// virtual void startTest( Test *test );
+		// virtual void endTest( Test *test );
+		
+		virtual void print( Outputter &stream );
+		
+	protected:
+		virtual void printHeader( Outputter &stream );
+
+		void printLines(Outputter &stream, HashMap & _aJobList);
+		void printFailedTests(Outputter &stream, TestPtrList &aFailedTests);
+		void printTestLines(Outputter &stream, TestPtrList &aFailedTests);
+		void printUnknownLines(Outputter &stream, HashMap & _aJobList);
+
+		virtual void printTestLine( Outputter &stream, Test* pTest, std::string const& _sNodeName, std::string const& _sInfo);
+		virtual void printFailureLine( Outputter &stream, TestFailure* pFailure, std::string const& _sNodeName );
+		virtual void printUnknownLine( Outputter &stream, std::string const& _sTestName);
+    };
+    
+/** insertion operator for easy output */
+    Outputter &operator <<( Outputter &stream, 
+							testshlTestResult &result );
+    
+} // namespace CppUnit
+
+#endif // CPPUNIT_testshlTESTRESULT_H
+
+
Nur in misc/build/cppunit-1.8.0/include/cppunit/result: testshlTestResult.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/signaltest.h	2008-12-10 20:46:07.349658445 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/signaltest.h	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,65 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SIGNALTEST_H
+#define SIGNALTEST_H
+
+#include <string>
+#include "cppunit/Test.h"
+#include <cppunit/autoregister/htestresult.h>
+
+namespace CppUnit 
+{
+	
+class CPPUNIT_API SignalTest : public Test
+{
+public:
+
+    SignalTest( std::string const& Name );
+	
+    ~SignalTest();
+    
+    virtual void run(hTestResult pResult);
+    virtual int countTestCases() const;
+    std::string getName() const;
+    std::string toString() const;
+
+private:
+    SignalTest( const SignalTest &other );
+    SignalTest &operator=( const SignalTest &other );
+    
+private:
+    const std::string m_sName;
+};
+ 
+} // namespace CppUnit
+
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit: signaltest.h.dummy.
--- misc/cppunit-1.8.0/include/cppunit/simpleheader.hxx	2008-12-10 20:46:07.425092111 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/simpleheader.hxx	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,45 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef CPPUNIT_SIMPLEHEADER_HXX
+#define CPPUNIT_SIMPLEHEADER_HXX
+
+// This file contains only the cppunit header files, for simplification.
+
+#include <cppunit/TestFixture.h>
+#include <cppunit/TestCaller.h>
+#include <cppunit/TestSuite.h>
+#include <cppunit/TestAssert.h>
+#include <cppunit/autoregister/registertestfunction.h>
+#include <cppunit/extensions/HelperMacros.h>
+#include <cppunit/additionalfunc.hxx>
+#include <cppunit/cmdlinebits.hxx>
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit: simpleheader.hxx.dummy.
--- misc/cppunit-1.8.0/include/cppunit/stringhelper.hxx	2008-12-10 20:46:07.500255274 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/stringhelper.hxx	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,42 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef STRINGHELPER_HXX
+#define STRINGHELPER_HXX
+
+#include <rtl/ustring.hxx>
+#include <rtl/string.hxx>
+
+inline void operator <<= (rtl::OString& _rAsciiString, const rtl::OUString& _rUnicodeString)
+{
+	_rAsciiString = rtl::OUStringToOString(_rUnicodeString,RTL_TEXTENCODING_ASCII_US);
+}
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit: stringhelper.hxx.dummy.
--- misc/cppunit-1.8.0/include/cppunit/taghelper.hxx	2008-12-10 20:46:07.588895546 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/taghelper.hxx	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,91 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef TAGHELPER_HXX
+#define TAGHELPER_HXX
+
+#include <map>
+#include <sal/types.h>
+#include <cppunit/nocopy.hxx>
+
+/* Tags are a general mechanism of extensible data arrays for parameter
+ * specification and property inquiry. In practice, tags are used in arrays,
+ * or chain of arrays.
+ *
+ */
+
+typedef sal_IntPtr Tag;
+typedef sal_IntPtr TagData;
+
+//# struct TagItem
+//# {
+//#     Tag     ti_Tag;     /* identifies the type of data */
+//#     TagData ti_Data;    /* type-specific data          */
+//# };
+
+/* constants for Tag.ti_Tag, control tag values */
+#define TAG_DONE   (Tag(0L))     /* terminates array of TagItems. ti_Data unused */
+#define TAG_END    (Tag(0L))     /* synonym for TAG_DONE             */
+#define TAG_IGNORE (Tag(1L))     /* ignore this item, not end of array       */
+#define TAG_MORE   (Tag(2L))     /* ti_Data is pointer to another array of TagItems
+               * note that this tag terminates the current array
+               */
+#define TAG_SKIP   (Tag(3L))      /* skip this and the next ti_Data items     */
+
+/* differentiates user tags from control tags */
+#define TAG_USER   (Tag(1L<<31))
+
+// -----------------------------------------------------------------------------
+class TagHelper /* : NOCOPY */
+{
+    typedef std::map<Tag, TagData> TagItems;
+    TagItems m_aTagItems;
+
+public:
+    TagHelper(){}
+    void insert(Tag _nTag, TagData _nData)
+    {
+        m_aTagItems[_nTag] = _nData;
+    }
+    // const TagItems& get() const { return m_aTagItems; }
+
+    TagData GetTagData(Tag _aTagValue, TagData _aDefaultValue = 0 /* NULL */) const
+    {
+        TagItems::const_iterator it = m_aTagItems.find(_aTagValue);
+        if (it != m_aTagItems.end())
+            return (*it).second;
+        else
+            return _aDefaultValue;
+    }
+};
+
+#endif
+
+
Nur in misc/build/cppunit-1.8.0/include/cppunit: taghelper.hxx.dummy.
--- misc/cppunit-1.8.0/include/cppunit/tagvalues.hxx	2008-12-10 20:46:07.672788513 +0100
+++ misc/build/cppunit-1.8.0/include/cppunit/tagvalues.hxx	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,81 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef TAGVALUES_H
+#define TAGVALUES_H
+
+#include <cppunit/taghelper.hxx>
+
+#define TAG_TYPE           (Tag(TAG_USER | (0x01L)))
+
+#define TAG_RESULT (TAG_USER | 0x100)
+                          
+#define RESULT_START       (Tag(TAG_RESULT | (0x02L)))
+#define TAG_RESULT_PTR     (Tag(TAG_RESULT | (0x03L)))
+#define TAG_TEST_PTR       (Tag(TAG_RESULT | (0x04L)))
+                           
+#define RESULT_END         (Tag(TAG_RESULT | (0x05L)))
+                           
+#define RESULT_ADD_FAILURE (Tag(TAG_RESULT | (0x06L)))
+#define RESULT_ADD_ERROR   (Tag(TAG_RESULT | (0x07L)))
+                           
+#define TAG_EXCEPTION      (Tag(TAG_RESULT | (0x08L)))
+                           
+#define RESULT_ADD_INFO    (Tag(TAG_RESULT | (0x09L)))
+#define TAG_INFO           (Tag(TAG_RESULT | (0x0aL)))
+                           
+#define RESULT_ENTER_NODE  (Tag(TAG_RESULT | (0x0bL)))
+#define RESULT_LEAVE_NODE  (Tag(TAG_RESULT | (0x0cL)))
+#define TAG_NODENAME       (Tag(TAG_RESULT | (0x0dL)))
+                           
+#define RESULT_SHOULD_STOP (Tag(TAG_RESULT | (0x0eL)))
+
+
+#define TAG_SIGNAL       		(TAG_USER | 0x200)
+// #define SIGNAL_CHECK     	    (Tag(TAG_SIGNAL | (0x01L)))
+// #define INIT_SIGNAL_HANDLING    (Tag(TAG_SIGNAL | (0x04L)))
+// #define RELEASE_SIGNAL_HANDLING (Tag(TAG_SIGNAL | (0x05L)))
+
+#define SIGNAL_START_TEST 	    (Tag(TAG_SIGNAL | (0x06L)))
+#define SIGNAL_END_TEST  	    (Tag(TAG_SIGNAL | (0x07L)))
+
+#define TAG_EXECUTION           (TAG_USER | 0x400)
+#define EXECUTION_CHECK         (Tag(TAG_EXECUTION | (0x01)))
+#define INIT_TEST               (Tag(TAG_EXECUTION | (0x02)))
+#define RELEASE_TEST            (Tag(TAG_EXECUTION | (0x03)))
+// #define EXECUTION_PUSH_NAME     (Tag(TAG_EXECUTION | (0x04)))
+// #define EXECUTION_POP_NAME      (Tag(TAG_EXECUTION | (0x05)))
+
+#define DO_NOT_EXECUTE 666
+#define GO_EXECUTE 1
+
+typedef sal_Int32 ReturnValue;
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/cppunit: tagvalues.hxx.dummy.
--- misc/cppunit-1.8.0/include/makefile.mk	2008-12-10 20:46:08.530624271 +0100
+++ misc/build/cppunit-1.8.0/include/makefile.mk	2008-07-14 07:25:14.000000000 +0200
@@ -1 +1,53 @@
-dummy
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile$
+#
+# $Revision$
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+PRJ=..
+# PRJINC=..
+
+PRJNAME=cppunit
+TARGET=inc
+UWINAPILIB=
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+# --- Files --------------------------------------------------------
+# --- Targets -------------------------------------------------------
+
+.INCLUDE :  target.mk
+
+.IF "$(ENABLE_PCH)"!=""
+ALLTAR : \
+	$(SLO)$/precompiled.pch \
+	$(SLO)$/precompiled_ex.pch
+
+.ENDIF			# "$(ENABLE_PCH)"!=""
+
Nur in misc/build/cppunit-1.8.0/include: makefile.mk.dummy.
--- misc/cppunit-1.8.0/include/testshl/autoregisterhelper.hxx	2008-12-10 20:46:07.771638742 +0100
+++ misc/build/cppunit-1.8.0/include/testshl/autoregisterhelper.hxx	2008-07-07 08:13:42.000000000 +0200
@@ -1 +1,65 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef AUTOREGISTER_HXX
+#define AUTOREGISTER_HXX
+
+#include <vector>
+#include <rtl/ustring.hxx>
+
+#include <cppunit/autoregister/testfunc.h>
+
+#include "dynamicregister.hxx"
+#include "getopt.hxx"
+
+typedef std::vector<FktPtr> FunctionList;
+
+// -----------------------------------------------------------------------------
+class JobList;
+class AutomaticRegisterHelper : public DynamicLibraryHelper
+{
+    FunctionList m_aFunctionList;
+    bool m_bLoadLibraryOK;
+    // GetOpt & m_aOptions; // use getOptions() instead!
+
+public:
+    AutomaticRegisterHelper(rtl::OUString const& _sDLLName, GetOpt & _aOptions/* , JobList * _pJobList = NULL */ );
+
+    // FunctionList getFunctions(){return m_aFunctionList;}
+    void CallAll(hTestResult _hResult) const;
+
+    /// @return true, if the given DLLName library could load and initialised.
+    bool isOkToStartTests() const {return m_bLoadLibraryOK;}
+
+    virtual ~AutomaticRegisterHelper();
+};
+
+#endif
+
Nur in misc/build/cppunit-1.8.0/include/testshl: autoregisterhelper.hxx.dummy.
--- misc/cppunit-1.8.0/include/testshl/dynamicregister.hxx	2008-12-10 20:46:07.812458771 +0100
+++ misc/build/cppunit-1.8.0/include/testshl/dynamicregister.hxx	2008-07-07 08:13:42.000000000 +0200
@@ -1 +1,67 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef DYNAMICREGISTER_HXX
+#define DYNAMICREGISTER_HXX
+
+#include <rtl/ustring.hxx>
+#include <osl/module.hxx>
+
+#include "getopt.hxx"
+#include "cppunit/nocopy.hxx"
+
+// -------------------------------------------------
+
+class DynamicLibraryHelper : NOCOPY
+{
+protected:
+    osl::Module*  m_pModule;
+    rtl::OUString m_suDLLName;
+    GetOpt & m_aOptions;
+
+    GetOpt& getOptions() {return m_aOptions;}
+    
+public:
+    DynamicLibraryHelper(rtl::OUString const& _sDLLName, GetOpt & _aOptions);
+    virtual ~DynamicLibraryHelper();
+
+private:
+    void showFilenameIfVerbose();
+    void realLoadLibrary(rtl::OUString const& _sLibToLoad);
+    void loadLibraryFromAbsolutePath();
+    void loadLibraryFromLocalPath();
+
+    rtl::OUString m_suAbsolutePathFile;  // file:///D:/foo/bar/library.dll
+    rtl::OUString m_suAbsolutePath;      // file:///D:/foo/bar
+    rtl::OUString m_suFilename;          // library.dll
+};
+
+#endif
+
Nur in misc/build/cppunit-1.8.0/include/testshl: dynamicregister.hxx.dummy.
--- misc/cppunit-1.8.0/include/testshl/filehelper.hxx	2008-12-10 20:46:07.901872218 +0100
+++ misc/build/cppunit-1.8.0/include/testshl/filehelper.hxx	2008-07-07 08:13:42.000000000 +0200
@@ -1 +1,50 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef FILEHELPER_HXX
+#define FILEHELPER_HXX
+
+#include <string>
+#include <rtl/ustring.hxx>
+#include <rtl/string.hxx>
+#include <cppunit/cmdlinebits.hxx>
+#include "getopt.hxx"
+
+namespace FileHelper
+{
+	
+	std::string getTempPath();
+	rtl::OUString convertPath( rtl::OUString const& _suSysPath );
+	rtl::OUString convertPath( rtl::OString const& sysPth );
+	CmdLineBits createFlags( GetOpt & _aOptions );
+	
+}
+#endif
+
Nur in misc/build/cppunit-1.8.0/include/testshl: filehelper.hxx.dummy.
--- misc/cppunit-1.8.0/include/testshl/getopt.hxx	2008-12-10 20:46:07.985642414 +0100
+++ misc/build/cppunit-1.8.0/include/testshl/getopt.hxx	2008-07-07 08:13:42.000000000 +0200
@@ -1 +1,335 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+/*************************************************************************
+#*    class GetOpt
+#*
+#*
+#*    Implementation    getopt.cxx
+#*
+#*    Description: 	class to reflect the commandline options. In addition
+#*                  it provides functinality to get options from an inifile
+#*                  ( getIniOptions()), evaluate, test and get options
+#*                  ( hasOpt(), getOpt() ) and display an usage screen
+#*                  formated in dependance of the given optionset, as well
+#*                  as display a status about activ options
+#*
+#*
+#* further descriptions:
+#*
+#* the constructor is called with two parameters:
+#* char* argv[] and char* optionSet[],
+#* the commandline and the available set of options.
+#* Valid optionstrings have to start with a minus '-', otherwise it will
+#* be ignored. Optionstrings consist of one or two arguments divided by a
+#* comma separator, where the second (optional) argument is a short
+#* description of the option, called hint. It will be automatically
+#* formated and displayed in the usage screen if available.
+#* The first argument of the optionstring can consist of two sections,
+#* the name and the optional necessity and format.
+#* The name of the option will be the starting minus followed by a string
+#* like "-src".
+#* One section options will be treated as flag (see '-v' option in example).
+#* The second section consist of '=' or ':' which defines the necessity,
+#* in combination with a character 's' for string or 'n' for numeric and
+#* an optional '@' standing for 'vector of'.
+#* '=' means this option needs an argument, ':' means can take an argument
+#* followed by 's' is, as mentioned above, a single string paramenter,
+#* followed by a 's' in combination with '@' means this argument consists
+#* of one string or a vector of strings separated by commas
+#*
+#* an example for an optionset:
+#*
+#*	static char* optionSet[] = {
+#*					"-src=s,    release or version of sources",
+#*					"-ini=s,    ini file with additional options",
+#*					"-db=s,  	path of type description database",
+#*					"-inPth=s,  source path of component descriptions",
+#*					"-outPth=s, destination path for testcases",
+#*					"-logPth=s, destination path for logging",
+#*					"-mdl=s@,   name(s) of module(s) to generate",
+#*					"-v,        enable verbose screen messages",
+#*					"-dbg,      enable debug messages",
+#*					"-h:s,      display help or help on option",
+#*					"-help:s,   see -h",
+#*					NULL
+#*					};
+#*
+#*    As seen a GetOpt class object will be created via:
+#*         GetOpt  myOptions( argv, optionSet );
+#*
+*************************************************************************/
+#ifndef __QADEV_REGSCAN_GETOPT_HXX__
+#define __QADEV_REGSCAN_GETOPT_HXX__
+
+#include	<osl/file.hxx>
+#include 	<sal/types.h>
+#include	<rtl/strbuf.hxx>
+
+
+#include	<rtl/string.hxx>
+
+// #ifndef __QADEV_REGSCAN_UTIL_HXX__
+// #include "inc/util.hxx"
+// #endif
+
+
+#ifdef SOLARIS
+#include <sys/time.h>
+#endif
+
+#include <iostream>
+#include <hash_map>
+// #include "rsexception.hxx"
+
+// using namespace std;
+
+struct gstr {
+	sal_Bool operator()( const rtl::OString& oStr1,
+									const rtl::OString& oStr2 ) const {
+		return( oStr1 == oStr2 );
+	}
+};
+
+struct ghstr
+{
+	sal_uInt32 operator()( const rtl::OString& str ) const {
+        return str.hashCode();
+	}
+};
+
+struct frmt {
+	sal_uInt32 fCol;
+	sal_uInt32 sCol;
+	sal_uInt32 len;
+};
+
+typedef	std::hash_map< rtl::OString, std::vector< rtl::OString >, ghstr, gstr >
+																optHashMap;
+
+typedef frmt sFormat;
+typedef sal_uInt16 optType;
+
+#define OT_INVALID			0x0000
+#define OT_BOOL				0x0001
+#define OT_STRING			0x0002
+#define OT_NUMBER		  	0x0004
+#define OT_SINGLE		  	0x0010
+#define OT_MULTI			0x0020
+#define OT_OPTIONAL			0x0100
+
+//: Option
+class OptDsc {
+
+	rtl::OString 	m_name;
+	rtl::OString	m_hint;
+	rtl::OString	m_legend;
+	optType 		m_type;
+
+	/**
+ 	* analysis of optionstring and creation of option description class
+ 	* @param const rtl::OString& opt = optionstring to analyse
+ 	* @return void
+ 	*/
+	void createOptDsc( const rtl::OString& opt );
+
+	/**
+ 	* splitting of an optionstring and creation of a tokenvector
+ 	* in dependance of a charset
+ 	*
+ 	* @param const rtl::OString& opt  = optionstring to split
+ 	* @param const rtl::OString& cSet = delimiter charset
+ 	* @param vector< rtl::OString >& optLine = tokenvector to fill
+ 	*
+ 	* @return void
+ 	*/
+	void split( const rtl::OString& opt, const rtl::OString& charSet,
+                    std::vector< rtl::OString >& optLine );
+
+	/**
+	 * private default c'tor, copy c'tor and assignment operator
+	 * to get compiler errors on dumb effords
+	 */
+	OptDsc();
+	OptDsc( OptDsc& );
+	OptDsc& operator = ( OptDsc& );
+
+public:
+
+	//> c'tor
+	OptDsc( const rtl::OString& opt )
+			: m_name(),
+              m_hint(),
+              m_legend(),
+              m_type( 0 ) {
+
+		createOptDsc( opt );
+	} ///< c'tor
+
+	//> d'tor
+	~OptDsc(){}
+
+	/**
+	 * returns the name of this option
+	 * @return rtl::OString&
+	 */
+	inline rtl::OString& getName() { return m_name; }
+	/**
+	 * returns the hint of this option
+	 * @return rtl::OString&
+	 */
+	inline rtl::OString& getHint() { return m_hint; }
+	/**
+	 * returns the legend of this option
+	 * @return rtl::OString&
+	 */
+	inline rtl::OString& getLegend() { return m_legend; }
+
+	/**
+	 * returns the type of this option
+	 * @return optType
+	 */
+	inline optType getType() { return m_type; }
+
+
+	inline sal_Bool isFlag() {
+		return( ( m_type &~ 0xfffe ) == OT_BOOL ) ? sal_True : sal_False;
+	}
+	inline sal_Bool isString() {
+		return( ( m_type &~ 0xfffd ) == OT_STRING ) ? sal_True : sal_False;
+	}
+	inline sal_Bool isNumber() {
+		return( ( m_type &~ 0xfffb ) == OT_NUMBER ) ? sal_True : sal_False;
+	}
+	inline sal_Bool isSingle() {
+		return( ( m_type &~ 0xffef ) == OT_SINGLE ) ? sal_True : sal_False;
+	}
+	inline sal_Bool isMulti() {
+		return( ( m_type &~ 0xffdf ) == OT_MULTI ) ? sal_True : sal_False;
+	}
+	inline sal_Bool isOptional() {
+		return( ( m_type &~ 0xfeff ) == OT_OPTIONAL ) ? sal_True : sal_False;
+	}
+
+}; ///:~ Option
+
+class Exception
+{
+	rtl::OString m_sAsciiMessage;
+public:
+	Exception();
+    virtual ~Exception(){}
+    
+	Exception(char const* sAsciiMessage);
+	Exception(rtl::OString const& sAsciiMessage);
+	
+	virtual rtl::OUString message() const;
+	virtual char const* what() const;
+};
+
+class ValueNotFoundException : public Exception
+{
+public:
+	ValueNotFoundException();
+	ValueNotFoundException(char const* sExit);
+};
+
+//: GetOpt
+class GetOpt {
+
+	rtl::OString 				m_prgname;
+	rtl::OString				m_vardelim;
+    std::vector< rtl::OString > 	m_cmdline;
+    std::vector< rtl::OString > 	m_param;
+    std::vector< rtl::OString >	m_varvec;
+    std::vector< OptDsc* >		 	m_optionset;
+  	optHashMap		 			m_opthash;
+
+	//> private methods
+	void initialize( char* cmdLine[], char const * optSet[] );
+	void createCmdLineOptions();
+	sal_uInt32 getMaxNameLength();
+	sal_uInt32 getMaxLegendLength();
+	const rtl::OString optDsc2Str( OptDsc* optDsc , sFormat frm );
+	void tokenize( 	const rtl::OString& opt, const rtl::OString& charSet,
+				std::vector< rtl::OString >& optLine, sal_Bool strip = sal_True );
+	///< private methods
+
+	GetOpt();
+	GetOpt( GetOpt& );
+	GetOpt& operator = ( GetOpt& );
+
+public:
+
+	//> c'tor
+	GetOpt( char* cmdLine[], char const * optSet[], rtl::OString varDelim =
+														rtl::OString( "$" ) )
+			: m_vardelim( varDelim ) {
+
+		initialize( cmdLine, optSet );
+		createCmdLineOptions();
+	} ///< c'tor
+
+	//> d'tor
+	~GetOpt();
+	///< d'tor
+
+	//> inline methods
+	inline std::vector< rtl::OString >* getCmdLine() { return &m_cmdline; }
+	inline optHashMap* getOptions() { return ( &m_opthash ); }
+	inline rtl::OString& getName() { return m_prgname; }
+	inline rtl::OString& getFirstParam() { return *(m_param.begin()); }
+	inline std::vector< rtl::OString >& getParams() { return m_param; }
+	rtl::OString& getOpt( const rtl::OString& opt );
+	void rmvOpt( rtl::OString& opt ) {
+		m_opthash.erase( opt );
+	}
+	inline std::vector< rtl::OString >& getOptVec( const rtl::OString& opt ) {
+		return m_opthash[ opt ];
+	}
+	///< inline methods
+
+
+	sal_Bool exist( rtl::OString& opt );
+	sal_Bool hasParam( std::vector< rtl::OString >::iterator iter );
+	sal_Bool hasVars( void );
+	sal_Bool evaluateOpt( std::vector< rtl::OString >::iterator iter );
+	OptDsc* getOptDsc( rtl::OString& opt );
+	sal_Bool hasOpt( const rtl::OString& opt ) const;
+	::osl::FileBase::RC getIniOptions( rtl::OString iniPth );
+    void createOpt( rtl::OString& optdsc );
+	void str2Opt( rtl::OString iOpts );
+    void addOpt( rtl::OString& opt, sal_Bool evaluate = sal_True );
+	void replVars( void );
+	void showUsage( void );
+	void printStatus( void );
+
+}; ///:~ GetOpt
+#endif
Nur in misc/build/cppunit-1.8.0/include/testshl: getopt.hxx.dummy.
--- misc/cppunit-1.8.0/include/testshl/log.hxx	2008-12-10 20:46:08.078572827 +0100
+++ misc/build/cppunit-1.8.0/include/testshl/log.hxx	2008-07-07 08:13:42.000000000 +0200
@@ -1 +1,116 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ *************************************************************************
+
+      Source Code Control System - Header
+
+      $Header$
+
+      Source Code Control System - Update
+
+*************************************************************************/
+#ifndef __QADEV_REGSCAN_LOG_HXX__
+#define __QADEV_REGSCAN_LOG_HXX__
+
+#include <time.h>
+#include	<rtl/ustring.hxx>
+#include	<rtl/strbuf.hxx>
+#include	<sal/types.h>
+#include	<osl/thread.h>
+#include	<osl/file.hxx>
+
+//!io #include <iostream>
+#include <vector>
+
+// using namespace std;
+
+
+/**
+ * Log derives the interface of the ::osl::File class ( is-a relation ).
+ * Its members (has-a relation) are the (full qualified)name of the log
+ * and an OStringBuffer which represents the content of the logfile.
+ * It provides the functionality of easy-to-use open and write logs
+ */
+//: Log
+class Log {
+
+    ::osl::File*            m_logfile;          // fileobject
+    rtl::OUString         m_logurl;           // url of log
+	rtl::OStringBuffer	m_buf;              // content of log
+
+    Log();
+
+public:
+
+	//> c'tor
+	/**
+	 * constructors argument is a full qualified UNC path
+	 * @param OUString logfile ( full qualified UNC path )
+	 */
+    Log( const rtl::OUString& logURL )
+            : m_logfile( new ::osl::File( logURL ))
+			, m_logurl(logURL)
+    {} ///< c'tor
+
+    //> d'tor
+    virtual ~Log() {
+        m_logfile->close();
+        delete( m_logfile );
+    } ///< d'tor
+
+	//> inline methods
+	// returns a reference to name instance
+    inline rtl::OUString getLogURL() { return m_logurl; }
+    inline rtl::OString getName() { return rtl::OUStringToOString(
+                                    m_logurl, RTL_TEXTENCODING_ASCII_US  ); }
+	///< inline methods
+
+	// open logfile for overwrite (default) or append
+	::osl::FileBase::RC open( sal_Bool append = sal_False );
+	::osl::FileBase::RC close() { return m_logfile->close(); }
+
+
+	// write methods without (default) or with echo on display
+	::osl::FileBase::RC write( const sal_Char* buf, sal_Bool v = sal_False );
+	::osl::FileBase::RC write( const rtl::OString& buf,
+                                   sal_Bool v = sal_False );
+	// ::osl::FileBase::RC write( rtl::OStringBuffer const& buf,
+    //                                sal_Bool v = sal_False );
+	::osl::FileBase::RC write( const rtl::OUString& buf,
+                                   rtl_TextEncoding enc = RTL_TEXTENCODING_ASCII_US,
+                                   sal_Bool v = sal_False   );
+    
+}; ///:~ Log
+
+Log &operator <<( Log &_aLog, const sal_Char * _sValue );
+Log &operator <<( Log &_aLog, rtl::OString const& _sValue );
+Log &operator <<( Log &_aLog, rtl::OUString const& _sValue );
+// Log &operator <<( Log &_aLog, rtl::OStringBuffer const& _sValue );
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/testshl: log.hxx.dummy.
--- misc/cppunit-1.8.0/include/testshl/tresstatewrapper.h	2008-12-10 20:46:08.171096366 +0100
+++ misc/build/cppunit-1.8.0/include/testshl/tresstatewrapper.h	2008-07-07 08:13:42.000000000 +0200
@@ -1 +1,66 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef TESTSTATEWRAPPER_H
+#define TESTSTATEWRAPPER_H
+
+#ifdef _RTL_TRES_H_
+#error "This is old code, please remove the include of rtl/tres.h"
+#endif
+
+#include <sal/types.h>
+#include "cppunit/autoregister/registertestfunction.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// typedef void* hTestResult;
+typedef hTestResult rtlTestResult;
+
+// -----------------------------------------------------------------------------
+void c_rtl_tres_state_start(hTestResult _aResult, const sal_Char* _pName);
+void c_rtl_tres_state_end(hTestResult _aResult, const sal_Char* _pName);
+
+// -----------------------------------------------------------------------------
+// the old test state function, which here convert all values for using with the
+// new testshl tool
+
+sal_Bool SAL_CALL c_rtl_tres_state(
+	hTestResult pResult,
+	sal_Bool bSuccess,
+	char const * pTestMsg,
+	char const * pFuncName);
+
+#ifdef __cplusplus
+}
+#endif    
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/testshl: tresstatewrapper.h.dummy.
--- misc/cppunit-1.8.0/include/testshl/tresstatewrapper.hxx	2008-12-10 20:46:08.253163483 +0100
+++ misc/build/cppunit-1.8.0/include/testshl/tresstatewrapper.hxx	2008-12-10 20:42:43.000000000 +0100
@@ -1 +1,60 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef teststatewrapper_hxx
+#define teststatewrapper_hxx
+
+#include <cppunit/nocopy.hxx>
+#include <sal/types.h>
+
+#include <cppunit/simpleheader.hxx>
+#include <cppunit/autoregister/callbackfunc_fktptr.h>
+
+// This is a hack, because it's possible that the testshl directory doesn't exist.
+#ifdef LOAD_TRESSTATEWRAPPER_LOCAL
+#include "tresstatewrapper.h"
+#else
+#include <testshl/tresstatewrapper.h>
+#endif
+
+// -----------------------------------------------------------------------------
+// helper class to mark the start off old test code
+// the name is need in the test result generator
+class rtl_tres_state_start : NOCOPY
+{
+    const sal_Char* m_pName;
+    hTestResult     m_aResult;
+public:
+    rtl_tres_state_start(hTestResult _aResult, const sal_Char* _pName);
+    ~rtl_tres_state_start();
+};
+
+#endif
+
Nur in misc/build/cppunit-1.8.0/include/testshl: tresstatewrapper.hxx.dummy.
--- misc/cppunit-1.8.0/include/testshl/versionhelper.hxx	2008-12-10 20:46:08.329903269 +0100
+++ misc/build/cppunit-1.8.0/include/testshl/versionhelper.hxx	2008-07-07 08:13:42.000000000 +0200
@@ -1 +1,87 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef AUTOREGISTER_HXX
+#define AUTOREGISTER_HXX
+
+#include <stdio.h>
+#include <vector>
+#include <ostream>
+#include <iostream>
+
+#include <rtl/ustring.hxx>
+#include <rtl/string.hxx>
+
+#include "dynamicregister.hxx"
+
+// -----------------------------------------------------------------------------
+// ---------------------------------- Version ----------------------------------
+// -----------------------------------------------------------------------------
+// extern "C" const struct VersionInfo *GetVersionInfo();
+
+// this is a Hack, but at the moment, no change to handle this behaviour better.
+struct VersionInfo
+{
+	const char*	pTime;
+	const char*	pDate;
+	const char*	pUpd;
+	const char*	pMinor;
+	const char*	pBuild;
+	const char*	pInpath;
+};
+typedef const struct VersionInfo* (*FktGetVersionInfoPtr)();
+
+// -----------------------------------------------------------------------------
+class VersionHelper : public DynamicLibraryHelper
+{
+	const VersionInfo *m_pInfo;
+
+public:
+    VersionHelper(rtl::OUString const& _sDLLName, GetOpt & _aOptions);
+//	void print(std::ostream& _aStream);
+    void printall(FILE*);
+
+    rtl::OString getTime() const;
+    rtl::OString getDate() const;
+    rtl::OString getUpd() const;
+    rtl::OString getMinor() const;
+    rtl::OString getBuild() const;
+    rtl::OString getInpath() const;
+
+    bool isOk() const;
+};
+
+/** insertion operator for easy output */
+// std::ostream &operator <<( std::ostream &stream, 
+//                           VersionHelper &version );
+
+
+#endif
+
Nur in misc/build/cppunit-1.8.0/include/testshl: versionhelper.hxx.dummy.
--- misc/cppunit-1.8.0/include/testshl/winstuff.hxx	2008-12-10 20:46:08.412541288 +0100
+++ misc/build/cppunit-1.8.0/include/testshl/winstuff.hxx	2008-07-16 14:09:24.000000000 +0200
@@ -1 +1,44 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile$
+ *
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef WINSTUFF_HXX
+#define WINSTUFF_HXX
+
+#include <sal/types.h>
+
+// Isolated into own compilation unit, to avoid interference with
+// windows headers
+void        WinDebugBreak();
+void        WinSleep( sal_uInt32 sec );
+sal_uInt32  WinGetCurrentProcessId();
+void        WinTerminateApp( sal_uInt32 dwPID, sal_uInt32 dwTimeout );
+
+#endif
Nur in misc/build/cppunit-1.8.0/include/testshl: winstuff.hxx.dummy.
--- misc/cppunit-1.8.0/makefile.mk	2008-12-10 20:46:08.628149187 +0100
+++ misc/build/cppunit-1.8.0/makefile.mk	2008-12-09 14:43:50.000000000 +0100
@@ -1 +1,35 @@
-dummy
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile$
+#
+# $Revision$
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+target:
+	cd src$/win32 && $(MAKE) $(MFLAGS) $(CALLMACROS)
+	cd src$/result && $(MAKE) $(MFLAGS) $(CALLMACROS)
+	cd src$/cppunit && $(MAKE) $(MFLAGS) $(CALLMACROS)
Nur in misc/build/cppunit-1.8.0: makefile.mk.dummy.
--- misc/cppunit-1.8.0/src/cppunit/Asserter.cpp	2002-03-27 20:04:02.000000000 +0100
+++ misc/build/cppunit-1.8.0/src/cppunit/Asserter.cpp	2008-02-27 17:21:16.000000000 +0100
@@ -1,52 +1,76 @@
 #include <cppunit/Asserter.h>
 #include <cppunit/NotEqualException.h>
-
+#include <cppunit/stringhelper.hxx>
 
 namespace CppUnit
 {
-
+ 
 
 namespace Asserter
 {
 
+void 
+fail( std::string const& message, 
+      SourceLine const& sourceLine )
+{
+    throw Exception( message, sourceLine );
+}
 
 void 
-fail( std::string message, 
-      SourceLine sourceLine )
+failStub( std::string const& message, 
+		  SourceLine const& sourceLine )
 {
-  throw Exception( message, sourceLine );
+    throw StubException( message, sourceLine );
 }
 
 
 void 
 failIf( bool shouldFail, 
-        std::string message, 
-        SourceLine location )
+        std::string const& message, 
+        SourceLine const& location )
 {
   if ( shouldFail )
-    fail( message, location );
+  {
+      fail( message, location );
+  }
 }
 
-
+// -----------------------------------------------------------------------------
 void 
-failNotEqual( std::string expected, 
-              std::string actual, 
-              SourceLine sourceLine,
-              std::string additionalMessage )
+failIf( bool shouldFail, 
+        rtl::OUString const& _suMessage, 
+        SourceLine const& location )
 {
-  throw NotEqualException( expected, 
-                           actual, 
-                           sourceLine, 
-                           additionalMessage );
+  if ( shouldFail )
+  {
+      rtl::OString sMessage;
+      sMessage <<= _suMessage;
+      std::string message;
+      message = sMessage.getStr();
+      fail( message, location );
+  }
+}
+// -----------------------------------------------------------------------------
+
+void 
+failNotEqual( std::string const& expected, 
+              std::string const& actual, 
+              SourceLine const& sourceLine,
+              std::string const& additionalMessage )
+{
+    throw NotEqualException( expected, 
+                             actual, 
+                             sourceLine, 
+                             additionalMessage );
 }
 
 
 void 
 failNotEqualIf( bool shouldFail,
-                std::string expected, 
-                std::string actual, 
-                SourceLine sourceLine,
-                std::string additionalMessage )
+                std::string const& expected, 
+                std::string const& actual, 
+                SourceLine const& sourceLine,
+                std::string const& additionalMessage )
 {
   if ( shouldFail )
     failNotEqual( expected, actual, sourceLine, additionalMessage );
--- misc/cppunit-1.8.0/src/cppunit/Exception.cpp	2001-10-19 20:37:24.000000000 +0200
+++ misc/build/cppunit-1.8.0/src/cppunit/Exception.cpp	2008-02-27 17:21:46.000000000 +0100
@@ -19,20 +19,19 @@
 
 /// Construct the exception
 Exception::Exception( const Exception &other ) : 
-    std::exception( other )
-{ 
-  m_message = other.m_message; 
-  m_sourceLine = other.m_sourceLine;
-} 
+        std::exception( other ), 
+        m_message( other.m_message),
+        m_sourceLine(other.m_sourceLine)
+{}
 
 
 /*!
  * \deprecated Use other constructor instead.
  */
-Exception::Exception( std::string message, 
-                      SourceLine sourceLine ) : 
-    m_message( message ), 
-    m_sourceLine( sourceLine )
+Exception::Exception( std::string const& _message, 
+                      SourceLine const& _sourceLine ) : 
+    m_message( _message ), 
+    m_sourceLine( _sourceLine )
 {
 }
 
@@ -41,9 +40,9 @@
 /*!
  * \deprecated Use other constructor instead.
  */
-Exception::Exception( std::string message, 
+Exception::Exception( std::string const& message, 
                       long lineNumber, 
-                      std::string fileName ) : 
+                      std::string const& fileName ) : 
     m_message( message ), 
     m_sourceLine( fileName, lineNumber )
 {
--- misc/cppunit-1.8.0/src/cppunit/NotEqualException.cpp	2001-10-06 00:27:14.000000000 +0200
+++ misc/build/cppunit-1.8.0/src/cppunit/NotEqualException.cpp	2008-02-27 17:21:34.000000000 +0100
@@ -3,17 +3,17 @@
 namespace CppUnit {
 
 
-NotEqualException::NotEqualException( std::string expected,
-                                      std::string actual, 
-                                      SourceLine sourceLine ,
-                                      std::string additionalMessage ) :
-    Exception( "Expected: " + expected + 
-                   ", but was: " + actual + 
-                   "." + additionalMessage ,
-               sourceLine),
-    m_expected( expected ),
-    m_actual( actual ),
-    m_additionalMessage( additionalMessage )
+NotEqualException::NotEqualException( std::string const& _expected,
+                                      std::string const& _actual, 
+                                      SourceLine const& _sourceLine ,
+                                      std::string const& _additionalMessage ) :
+    Exception( "Expected: " + _expected + 
+                   ", but was: " + _actual + 
+                   "." + _additionalMessage ,
+               _sourceLine),
+    m_expected( _expected ),
+    m_actual( _actual ),
+    m_additionalMessage( _additionalMessage )
 {
 }
 
@@ -22,10 +22,10 @@
 /*!
  * \deprecated Use other constructor instead.
  */
-NotEqualException::NotEqualException( std::string expected,
-                                      std::string actual,
+NotEqualException::NotEqualException( std::string const& expected,
+                                      std::string const& actual,
                                       long lineNumber, 
-                                      std::string fileName ) : 
+                                      std::string const& fileName ) : 
     Exception( "Expected: " + expected + ", but was: " + actual,
                lineNumber,
                fileName ),
--- misc/cppunit-1.8.0/src/cppunit/SourceLine.cpp	2001-10-06 00:27:14.000000000 +0200
+++ misc/build/cppunit-1.8.0/src/cppunit/SourceLine.cpp	2008-02-27 17:23:14.000000000 +0100
@@ -10,10 +10,10 @@
 }
 
 
-SourceLine::SourceLine( const std::string &fileName,
-                        int lineNumber ) :
-    m_fileName( fileName ),
-    m_lineNumber( lineNumber )
+SourceLine::SourceLine( const std::string &file,
+                        int line ) :
+    m_fileName( file ),
+    m_lineNumber( line )
 {
 }
 
--- misc/cppunit-1.8.0/src/cppunit/TestAssert.cpp	2001-10-07 21:36:47.000000000 +0200
+++ misc/build/cppunit-1.8.0/src/cppunit/TestAssert.cpp	2008-02-27 17:23:24.000000000 +0100
@@ -1,4 +1,4 @@
-#if HAVE_CMATH
+#ifdef HAVE_CMATH
 #   include <cmath>
 #else
 #   include <math.h>
@@ -15,56 +15,56 @@
 /// Check for a failed general assertion 
 void 
 TestAssert::assertImplementation( bool condition,
-                                  std::string conditionExpression,
-                                  long lineNumber,
-                                  std::string fileName )
+								  std::string conditionExpression,
+								  long lineNumber,
+								  std::string fileName )
 {
   Asserter::failIf( condition, 
-                    conditionExpression, 
-                    SourceLine( fileName, lineNumber ) );
+					conditionExpression, 
+					SourceLine( fileName, lineNumber ) );
 }
 
 
 /// Reports failed equality
 void 
 TestAssert::assertNotEqualImplementation( std::string expected,
-                                          std::string actual,
-                                          long lineNumber,
-                                          std::string fileName )
+										  std::string actual,
+										  long lineNumber,
+										  std::string fileName )
 {
   Asserter::failNotEqual( expected, 
-                          actual, 
-                          SouceLine( fileName, lineNumber ), "" );
+						  actual, 
+						  SouceLine( fileName, lineNumber ), "" );
 }
 
 
 /// Check for a failed equality assertion
 void 
 TestAssert::assertEquals( double expected, 
-                          double actual, 
-                          double delta,
-                          long lineNumber,
-                          std::string fileName )
+						  double actual, 
+						  double delta,
+						  long lineNumber,
+						  std::string fileName )
 { 
   if (fabs (expected - actual) > delta) 
-    assertNotEqualImplementation( assertion_traits<double>::toString(expected),
-                                  assertion_traits<double>::toString(actual),
-                                  lineNumber, 
-                                  fileName ); 
+	assertNotEqualImplementation( assertion_traits<double>::toString(expected),
+								  assertion_traits<double>::toString(actual),
+								  lineNumber, 
+								  fileName ); 
 }
 
 #else  // CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
 
 void 
 TestAssert::assertDoubleEquals( double expected,
-                                double actual,
-                                double delta,
-                                SourceLine sourceLine )
+								double actual,
+								double delta,
+								SourceLine sourceLine )
 {
   Asserter::failNotEqualIf( fabs( expected - actual ) > delta,
-                            assertion_traits<double>::toString(expected),
-                            assertion_traits<double>::toString(actual),
-                            sourceLine );
+							assertion_traits<double>::toString(expected),
+							assertion_traits<double>::toString(actual),
+							sourceLine );
 }
 
 
--- misc/cppunit-1.8.0/src/cppunit/TestCase.cpp	2002-03-25 23:35:34.000000000 +0100
+++ misc/build/cppunit-1.8.0/src/cppunit/TestCase.cpp	2008-02-27 17:21:24.000000000 +0100
@@ -1,70 +1,141 @@
+#include <stdlib.h>
 #include <cppunit/Portability.h>
 #include <typeinfo>
 #include <stdexcept>
 
 #include "cppunit/TestCase.h"
 #include "cppunit/Exception.h"
-#include "cppunit/TestResult.h"
+// #include "cppunit/TestResult.h"
 
+#include <cppunit/autoregister/callbackfunc_fktptr.h>
+#include <cppunit/tagvalues.hxx>
+#include <cppunit/externcallbackfunc.hxx>
 
 namespace CppUnit {
 
 /// Create a default TestResult
-CppUnit::TestResult* 
-TestCase::defaultResult()
-{ 
-  return new TestResult; 
-} 
+//# CppUnit::TestResult* 
+//# TestCase::defaultResult()
+//# { 
+//#   return new TestResult; 
+//# } 
 
 
 /// Run the test and catch any exceptions that are triggered by it 
+//# void 
+//# TestCase::run( TestResult *result )
+//# {
+//#   result->startTest(this);
+//# 
+//#   try {
+//# 	  setUp();
+//# 
+//# 	  try {
+//# 		runTest();
+//# 	  }
+//# 	  catch ( Exception &e ) {
+//# 		Exception *copy = e.clone();
+//# 		result->addFailure( this, copy );
+//# 	  }
+//# 	  catch ( std::exception &e ) {
+//# 		result->addError( this, new Exception( e.what() ) );
+//# 	  }
+//# 	  catch (...) {
+//# 		Exception *e = new Exception( "caught unknown exception" );
+//# 		result->addError( this, e );
+//# 	  }
+//# 
+//# 	  try {
+//# 		tearDown();
+//# 	  }
+//# 	  catch (...) {
+//# 		result->addError( this, new Exception( "tearDown() failed" ) );
+//# 	  }
+//#   }
+//#   catch (...) {
+//# 	  result->addError( this, new Exception( "setUp() failed" ) );
+//#   }
+//#   
+//#   result->endTest( this );
+//# }
+//#
+
 void 
-TestCase::run( TestResult *result )
+TestCase::run( hTestResult result )
 {
-  result->startTest(this);
-
-  try {
-	  setUp();
+	Test* pTest = this;
 
-	  try {
-	    runTest();
-	  }
-	  catch ( Exception &e ) {
-	    Exception *copy = e.clone();
-	    result->addFailure( this, copy );
-	  }
-	  catch ( std::exception &e ) {
-	    result->addError( this, new Exception( e.what() ) );
-	  }
-	  catch (...) {
-	    Exception *e = new Exception( "caught unknown exception" );
-	    result->addError( this, e );
-	  }
-
-	  try {
-	    tearDown();
-	  }
-	  catch (...) {
-	    result->addError( this, new Exception( "tearDown() failed" ) );
-	  }
-  }
-  catch (...) {
-	  result->addError( this, new Exception( "setUp() failed" ) );
-  }
-  
-  result->endTest( this );
+    // if (signalCheck(pTest->getName()) == HAS_SIGNAL)
+	sal_Int32 nValue = (pCallbackFunc)(0 /* NULL */, TAG_TYPE, EXECUTION_CHECK, TAG_RESULT_PTR, result, TAG_NODENAME, pTest->getName().c_str(), TAG_DONE);
+	if (nValue == DO_NOT_EXECUTE)
+    {
+        return;
+    }
+    
+	// (pTestResult_StartTest)(result, pTest);
+    (pCallbackFunc)(0 /* NULL */, TAG_TYPE, RESULT_START, TAG_RESULT_PTR, result, TAG_TEST_PTR, pTest, TAG_DONE);
+
+	try 
+	{
+		setUp();
+		
+		try 
+		{
+			runTest();
+			// (pTestResult_AddInfo)(result, pTest, "PASSED");
+            (pCallbackFunc)(0 /* NULL */, TAG_TYPE, RESULT_ADD_INFO, TAG_RESULT_PTR, result, TAG_TEST_PTR, pTest, TAG_INFO, "PASSED", TAG_DONE);
+		}
+		catch ( StubException &)
+		{
+			(pCallbackFunc)(0 /* NULL */, TAG_TYPE, RESULT_ADD_INFO, TAG_RESULT_PTR, result, TAG_TEST_PTR, pTest, TAG_INFO, "STUB", TAG_DONE );
+		}
+		catch ( Exception &e ) 
+		{
+			Exception *copy = e.clone();
+			// (pTestResult_AddFailure)( result, pTest, copy );
+			(pCallbackFunc)(0 /* NULL */, TAG_TYPE, RESULT_ADD_FAILURE, TAG_RESULT_PTR, result, TAG_TEST_PTR, pTest, TAG_EXCEPTION, copy, TAG_DONE );
+		}
+		catch ( std::exception &e ) 
+		{
+			// (pTestResult_AddError)( result, pTest, new Exception( e.what() ) );
+			(pCallbackFunc)( 0 /* NULL */, TAG_TYPE, RESULT_ADD_ERROR, TAG_RESULT_PTR, result, TAG_TEST_PTR, pTest, TAG_EXCEPTION, new Exception( e.what() ), TAG_DONE );
+		}
+		catch (...) 
+		{
+			Exception *e = new Exception( "caught unknown exception" );
+			// (pTestResult_AddError)( result, pTest, e );
+			(pCallbackFunc)( 0 /* NULL */, TAG_TYPE, RESULT_ADD_ERROR, TAG_RESULT_PTR, result, TAG_TEST_PTR, pTest, TAG_EXCEPTION, e, TAG_DONE );
+		}
+		
+		try 
+		{
+			tearDown();
+		}
+		catch (...) 
+		{
+			// (pTestResult_AddError)( result, pTest, new Exception( "tearDown() failed" ) );
+			(pCallbackFunc)( 0 /* NULL */, TAG_TYPE, RESULT_ADD_ERROR, TAG_RESULT_PTR, result, TAG_TEST_PTR, pTest, TAG_EXCEPTION, new Exception( "tearDown() failed" ), TAG_DONE );
+		}
+	}
+	catch (...) 
+	{
+		// (pTestResult_AddError)( result, pTest, new Exception( "setUp() failed" ) );
+		(pCallbackFunc)( 0 /* NULL */, TAG_TYPE, RESULT_ADD_ERROR, TAG_RESULT_PTR, result, TAG_TEST_PTR, pTest, TAG_EXCEPTION, new Exception( "setUp() failed" ), TAG_DONE );
+	}
+	
+	// (pTestResult_EndTest)( result, pTest );
+	(pCallbackFunc)( 0 /* NULL */, TAG_TYPE, RESULT_END, TAG_RESULT_PTR, result, TAG_TEST_PTR, pTest, TAG_DONE );
 }
 
-
 /// A default run method 
-TestResult *
-TestCase::run()
-{
-  TestResult *result = defaultResult();
-
-  run (result);
-  return result;
-}
+//# TestResult *
+//# TestCase::run()
+//# {
+//#   TestResult *result = defaultResult();
+//# 
+//#   run (result);
+//#   return result;
+//# }
 
 
 /// All the work for runTest is deferred to subclasses 
@@ -77,7 +148,7 @@
 /** Constructs a test case.
  *  \param name the name of the TestCase.
  **/
-TestCase::TestCase( std::string name )
+TestCase::TestCase( std::string const& name )
     : m_name(name)
 {
 }
@@ -133,3 +204,8 @@
   
 
 } // namespace CppUnit
+
+// The following sets variables for GNU EMACS
+// Local Variables:
+// tab-width:4
+// End:
--- misc/cppunit-1.8.0/src/cppunit/TestFactoryRegistry.cpp	2002-03-28 16:47:08.000000000 +0100
+++ misc/build/cppunit-1.8.0/src/cppunit/TestFactoryRegistry.cpp	2008-02-27 17:22:38.000000000 +0100
@@ -1,12 +1,20 @@
+#include <stdio.h>
+#include <stdlib.h>
 #include <cppunit/extensions/TestFactoryRegistry.h>
 #include <cppunit/TestSuite.h>
-#include <set>
 
+#include <set>
+//!io #include <iostream>
+#include <sstream>
 
 #if CPPUNIT_USE_TYPEINFO_NAME
 #  include "cppunit/extensions/TypeInfoHelper.h"
 #endif
 
+#include <cppunit/externcallbackfunc.hxx>
+#include <cppunit/tagvalues.hxx>
+
+#undef HELLOWORLD_DEBUGGER
 
 namespace CppUnit {
 
@@ -26,15 +34,18 @@
 
   static NamedRegistries &getInstance();
 
-  TestFactoryRegistry &getRegistry( std::string name );
+  TestFactoryRegistry &getRegistry( std::string const& name );
 
   void wasDestroyed( TestFactory *factory );
 
   bool needDestroy( TestFactory *factory );
 
+  void testRegistries( hTestResult );
 private:
-  typedef std::map<std::string, TestFactoryRegistry *> Registries;
-  Registries m_registries;
+    typedef std::map<std::string, TestFactoryRegistry *> MapRegistries;
+    // typedef std::pair<std::string, TestFactoryRegistry *> StringTestFactoryRegistry;
+    // typedef std::vector< StringTestFactoryRegistry > MapRegistries;
+  MapRegistries m_registries;
 
   typedef std::set<TestFactory *> Factories;
   Factories m_factoriesToDestroy;
@@ -44,13 +55,27 @@
 
 NamedRegistries::~NamedRegistries()
 {
-  Registries::iterator it = m_registries.begin();
-  while ( it != m_registries.end() )
-  {
-    TestFactoryRegistry *registry = (it++)->second;
-    if ( needDestroy( registry ) )
-      delete registry;
-  }
+#ifdef HELLOWORLD_DEBUGGER
+	printf("~NamedRegistries.\n");
+#endif
+	MapRegistries::iterator it = m_registries.begin();
+	while ( it != m_registries.end() )
+	{
+		TestFactoryRegistry *registry = (it++)->second;
+		if ( needDestroy( registry ) )
+			delete registry;
+	}
+/*
+    for (MapRegistries::iterator it = m_registries.begin();
+         it != m_registries.end();
+         ++it)
+    {
+        StringTestFactoryRegistry stfr = *it;
+        TestFactoryRegistry *registry = stfr.second;
+        if ( needDestroy( registry ) )
+            delete registry;
+    }
+*/
 }
 
 
@@ -63,17 +88,55 @@
 
 
 TestFactoryRegistry &
-NamedRegistries::getRegistry( std::string name )
+NamedRegistries::getRegistry( std::string const& name )
 {
-  Registries::const_iterator foundIt = m_registries.find( name );
-  if ( foundIt == m_registries.end() )
+#ifdef HELLOWORLD_DEBUGGER
+	printf("getRegistry '%s', ", name.c_str());
+#endif
+	MapRegistries::const_iterator foundIt = m_registries.find( name );
+	if ( foundIt == m_registries.end() )
+	{
+		TestFactoryRegistry *factory = new TestFactoryRegistry( name );
+		// m_registries.insert( std::make_pair( name, factory ) );
+		m_registries[name] = factory;
+		m_factoriesToDestroy.insert( factory );
+
+#ifdef HELLOWORLD_DEBUGGER
+		printf("factory not found, create.\n");
+#endif
+		return *factory;
+	}
+#ifdef HELLOWORLD_DEBUGGER
+	printf("factory found.\n");
+#endif
+	return *foundIt->second;
+/*
+    // MapRegistries::const_iterator foundIt;
+    TestFactoryRegistry *pFound = NULL;
+    for (MapRegistries::const_iterator it = m_registries.begin();
+         it != m_registries.end();
+         ++it)
+    {
+        StringTestFactoryRegistry stfr = *it;
+        if (name == stfr.first)
+        {
+            pFound = stfr.second;
+            break;
+        }
+    }
+    
+    // MapRegistries::const_iterator foundIt = m_registries.find( name );
+  if ( pFound != NULL )
   {
     TestFactoryRegistry *factory = new TestFactoryRegistry( name );
-    m_registries.insert( std::make_pair( name, factory ) );
+    // m_registries.insert( std::make_pair( name, factory ) );
+    StringTestFactoryRegistry stfr = std::make_pair(name, factory);
+    m_registries.push_back(stfr);
     m_factoriesToDestroy.insert( factory );
     return *factory;
   }
-  return *foundIt->second;
+  return *pFound;
+*/
 }
 
 
@@ -91,9 +154,32 @@
   return m_destroyedFactories.count( factory ) == 0;
 }
 
+void NamedRegistries::testRegistries( hTestResult _pResult)
+{
+    // initialise the test handling
+    (pCallbackFunc)(0 /* NULL */, TAG_TYPE, INIT_TEST, TAG_RESULT_PTR, _pResult, TAG_DONE);
+
+    // Start signal based Check
+    for (MapRegistries::const_iterator it = m_registries.begin();
+         it != m_registries.end();
+         ++it)
+    {
+        std::string sName = (*it).first;
+        
+        CppUnit::Test* tp = CppUnit::TestFactoryRegistry::getRegistry(sName).makeTest();
+        tp->run(_pResult);
+    }
 
+    // release test handling
+    (pCallbackFunc)(0 /* NULL */, TAG_TYPE, RELEASE_TEST, TAG_RESULT_PTR, _pResult, TAG_DONE);
+    // start normal based tests, leave signal signed tests out.
 
-TestFactoryRegistry::TestFactoryRegistry( std::string name ) :
+    //! Allfunction in the inclusion list which has a flag, not found, has to call here.
+}
+
+// -----------------------------------------------------------------------------
+
+TestFactoryRegistry::TestFactoryRegistry( std::string const& name ) :
     m_name( name )
 {
 }
@@ -116,26 +202,38 @@
   }
 }
 
-
+// static
 TestFactoryRegistry &
 TestFactoryRegistry::getRegistry()
 {
   return getRegistry( "All Tests" );
 }
 
-
+// static
 TestFactoryRegistry &
 TestFactoryRegistry::getRegistry( const std::string &name )
 {
   return NamedRegistries::getInstance().getRegistry( name );
 }
 
+// static
+void TestFactoryRegistry::testRegistries( hTestResult _pResult )
+{
+    NamedRegistries::getInstance().testRegistries( _pResult );
+}
+
 
 void 
 TestFactoryRegistry::registerFactory( const std::string &name,
                                       TestFactory *factory )
 {
-  m_factories[name] = factory;
+#ifdef HELLOWORLD_DEBUGGER
+    printf("registerFactory %s\n", name.c_str());
+#endif
+    m_factories[name] = factory;
+#ifdef HELLOWORLD_DEBUGGER
+    printf("FactorySize: %d\n ", m_factories.size());
+#endif
 }
 
 
@@ -144,10 +242,23 @@
 {
     static int serialNumber = 1;
 
-    OStringStream ost;
-    ost << "@Dummy@" << serialNumber++;
-
-    registerFactory( ost.str(), factory );
+    std::string aStr("@Dummy@_");
+    
+    sal_Char cBuf[20];
+    sal_Char *pBuf = cBuf;
+    sprintf(pBuf, "%d", serialNumber++ );
+    
+    aStr += std::string(pBuf);
+
+    // LLA: this does not work within Solaris, could be a problem of the osl::Module::load?
+    // std::ostringstream ost;
+    // ost << "@Dummy@" << nValue;
+    // registerFactory( ost.str(), factory );
+	
+#ifdef HELLOWORLD_DEBUGGER
+	printf("aStr: %s\n", aStr.c_str());
+#endif
+    registerFactory( aStr, factory );
 }
 
 
@@ -163,6 +274,9 @@
 void 
 TestFactoryRegistry::addTestToSuite( TestSuite *suite )
 {
+#ifdef HELLOWORLD_DEBUGGER
+  printf("addTestToSuite %s\n", suite->getName().c_str());
+#endif
   for ( Factories::iterator it = m_factories.begin(); 
         it != m_factories.end(); 
         ++it )
--- misc/cppunit-1.8.0/src/cppunit/TestFailure.cpp	2002-02-28 11:57:20.000000000 +0100
+++ misc/build/cppunit-1.8.0/src/cppunit/TestFailure.cpp	2008-02-27 17:23:02.000000000 +0100
@@ -5,12 +5,12 @@
 namespace CppUnit {
 
 /// Constructs a TestFailure with the given test and exception.
-TestFailure::TestFailure( Test *failedTest, 
-                          Exception *thrownException,
-                          bool isError ) :
-    m_failedTest( failedTest ), 
-    m_thrownException( thrownException ),
-    m_isError( isError )
+TestFailure::TestFailure( Test *failed, 
+                          Exception *_thrownException,
+                          ErrorType::num eError ) :
+    m_failedTest( failed ), 
+    m_thrownException( _thrownException ),
+    m_eError( eError )
 {
 }
 
@@ -45,10 +45,19 @@
 
 
 /// Indicates if the failure is a failed assertion or an error.
-bool 
+bool
 TestFailure::isError() const
 {
-  return m_isError;
+	if (m_eError == ErrorType::ET_ERROR ||
+		m_eError == ErrorType::ET_SIGNAL)
+		return true;
+	return false;
+}
+
+ErrorType::num
+TestFailure::getErrorType() const
+{
+  return m_eError;
 }
 
 
@@ -71,7 +80,7 @@
 TestFailure *
 TestFailure::clone() const
 {
-  return new TestFailure( m_failedTest, m_thrownException->clone(), m_isError );
+  return new TestFailure( m_failedTest, m_thrownException->clone(), m_eError );
 }
 
 } // namespace CppUnit
--- misc/cppunit-1.8.0/src/cppunit/TestSuite.cpp	2002-03-24 20:39:55.000000000 +0100
+++ misc/build/cppunit-1.8.0/src/cppunit/TestSuite.cpp	2008-02-27 17:24:10.000000000 +0100
@@ -1,11 +1,15 @@
+#include <stdlib.h>
 #include "cppunit/TestSuite.h"
-#include "cppunit/TestResult.h"
+// #include "cppunit/TestResult.h"
+#include <cppunit/tagvalues.hxx>
+#include <cppunit/autoregister/callbackfunc_fktptr.h>
+#include <cppunit/externcallbackfunc.hxx>
 
 namespace CppUnit {
 
 /// Default constructor
-TestSuite::TestSuite( std::string name )
-    : m_name( name )
+TestSuite::TestSuite( std::string const& name )
+		: m_name( name )
 {
 }
 
@@ -13,7 +17,7 @@
 /// Destructor
 TestSuite::~TestSuite()
 { 
-  deleteContents(); 
+	deleteContents(); 
 }
 
 
@@ -21,28 +25,37 @@
 void 
 TestSuite::deleteContents()
 {
-  for ( std::vector<Test *>::iterator it = m_tests.begin();
-        it != m_tests.end();
-        ++it)
-    delete *it;
-  m_tests.clear();
+	for ( std::vector<Test *>::iterator it = m_tests.begin();
+		  it != m_tests.end();
+		  ++it)
+		delete *it;
+	m_tests.clear();
 }
 
 
 /// Runs the tests and collects their result in a TestResult.
+
 void 
-TestSuite::run( TestResult *result )
+TestSuite::run( hTestResult result )
 {
-  for ( std::vector<Test *>::iterator it = m_tests.begin();
-        it != m_tests.end();
-        ++it )
-  {
-    if ( result->shouldStop() )
-        break;
-
-    Test *test = *it;
-    test->run( result );
-  }
+	// (pTestResult_EnterNode)(result, getName().c_str());
+	(pCallbackFunc)(0 /* NULL */, TAG_TYPE, RESULT_ENTER_NODE, TAG_RESULT_PTR, result, TAG_NODENAME, getName().c_str(), TAG_DONE);
+	for ( std::vector<Test *>::iterator it = m_tests.begin();
+		  it != m_tests.end();
+		  ++it )
+	{
+		//# if ( result->shouldStop() )
+		//#     break;
+		// if ( pTestResult_ShouldStop(result) )
+		if ( (pCallbackFunc)(0 /* NULL */, TAG_TYPE, RESULT_SHOULD_STOP, TAG_RESULT_PTR, result, TAG_DONE) )
+		{
+			break;
+		}
+		Test *test = *it;
+		test->run( result );
+	}
+	// (pTestResult_LeaveNode)(result, getName().c_str());
+	(pCallbackFunc)(0 /* NULL */, TAG_TYPE, RESULT_LEAVE_NODE, TAG_RESULT_PTR, result, TAG_NODENAME, getName().c_str(), TAG_DONE);
 }
 
 
@@ -50,14 +63,14 @@
 int 
 TestSuite::countTestCases() const
 {
-  int count = 0;
-
-  for ( std::vector<Test *>::const_iterator it = m_tests.begin();
-        it != m_tests.end();
-        ++it )
-    count += (*it)->countTestCases();
-
-  return count;
+	int count = 0;
+	
+	for ( std::vector<Test *>::const_iterator it = m_tests.begin();
+		  it != m_tests.end();
+		  ++it )
+		count += (*it)->countTestCases();
+	
+	return count;
 }
 
 
@@ -65,7 +78,7 @@
 void 
 TestSuite::addTest( Test *test )
 { 
-  m_tests.push_back( test ); 
+	m_tests.push_back( test ); 
 }
 
 
@@ -73,7 +86,7 @@
 std::string 
 TestSuite::toString() const
 { 
-  return "suite " + getName();
+	return "suite " + getName();
 }
 
 
@@ -81,16 +94,20 @@
 std::string 
 TestSuite::getName() const
 { 
-  return m_name; 
+	return m_name; 
 }
 
 
 const std::vector<Test *> &
 TestSuite::getTests() const
 {
-  return m_tests;
+	return m_tests;
 }
 
 
 } // namespace CppUnit
 
+// The following sets variables for GNU EMACS
+// Local Variables:
+// tab-width:4
+// End:
--- misc/cppunit-1.8.0/src/cppunit/cmdlinebits.cxx	2008-12-10 20:46:08.820775372 +0100
+++ misc/build/cppunit-1.8.0/src/cppunit/cmdlinebits.cxx	2008-12-10 20:42:44.000000000 +0100
@@ -1 +1,144 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+// #include "precompiled_cppunit.hxx"
+
+#ifdef WNT
+# define UNDER_WINDOWS_DEBUGGING
+# include "testshl/winstuff.hxx"
+#endif /* WNT */
+
+#include <stdio.h>
+#include <cppunit/cmdlinebits.hxx>
+#include "cppunit/checkboom.hxx"
+
+#include <cppunit/autoregister/callbackstructure.h>
+#include <osl/diagnose.h>
+#include <rtl/tres.h>
+#include <cppunit/stringhelper.hxx>
+
+extern CallbackStructure aGlobalStructure;
+
+sal_Bool isBit( CmdLineBits _nBits, CmdLineBits _nFlag );
+
+// sal_Bool isBit( CmdLineBits _nBits, CmdLineBits _nFlag )
+// {
+//     return( ( _nBits & _nFlag ) == _nFlag );
+// }
+
+void CheckBoom(bool bCondition, std::string const& msg)
+{
+    (void) msg; // avoid warning
+	if ( isBit( aGlobalStructure.nBits, rtl_tres_Flag_BOOM ) ) 
+	{ 
+		/* force an assertion on false state */ 
+        if ( !bCondition ) {
+#ifdef UNDER_WINDOWS_DEBUGGING
+            WinDebugBreak();
+#else
+            OSL_ENSURE( false, msg.c_str() ); 
+#endif
+        }
+	} 
+} 
+
+void CheckBoom(bool bCondition, rtl::OUString const& msg)
+{                                                              
+	if ( isBit( aGlobalStructure.nBits, rtl_tres_Flag_BOOM ) ) 
+	{ 
+		/* force an assertion on false state */ 
+        rtl::OString sMessage;
+        sMessage <<= msg;
+        if ( !bCondition ) {
+#ifdef UNDER_WINDOWS_DEBUGGING
+            WinDebugBreak();
+#else
+            OSL_ENSURE( false, sMessage.getStr() );
+#endif
+        }
+	}
+}
+ 
+const char* getForwardString()
+{
+	return aGlobalStructure.psForward;
+}
+
+// -----------------------------------------------------------------------------
+// ----------------------------- own printf method -----------------------------
+// -----------------------------------------------------------------------------
+
+// bool isVerbose()
+// {
+// 	if ( isBit( aGlobalStructure.nBits, rtl_tres_Flag_VERBOSE ) ) 
+// 	{ 
+//         return true;
+// 	} 
+//     return false;
+// }
+// 
+// bool isQuiet()
+// {
+// 	if ( isBit( aGlobalStructure.nBits, rtl_tres_Flag_QUIET ) ) 
+// 	{ 
+//         return true;
+// 	} 
+//     return false;
+// }
+// 
+// void impl_t_print(const char* _pFormatStr, va_list &args)
+// {
+//     if (! isQuiet())
+//     {
+//         printf("# ");
+//         vprintf(_pFormatStr, args);
+//     }
+// }
+// 
+// void t_print(const char* _pFormatStr, ...)
+// {
+//     va_list  args;
+//     va_start( args, _pFormatStr );
+//     impl_t_print(_pFormatStr, args);
+//     va_end( args );
+// }
+// 
+// void t_print(T_Print_Params _eType, const char* _pFormatStr, ...)
+// {
+//     if (_eType == T_VERBOSE && isVerbose())
+//     {
+//         // if T_VERBOSE and we should be verbose, print info
+//         va_list  args;
+//         va_start( args, _pFormatStr );
+//         impl_t_print(_pFormatStr, args);
+//         va_end( args );
+//     }
+// }
Nur in misc/build/cppunit-1.8.0/src/cppunit: cmdlinebits.cxx.dummy.
--- misc/cppunit-1.8.0/src/cppunit/joblist.cxx	2008-12-10 20:46:08.893444692 +0100
+++ misc/build/cppunit-1.8.0/src/cppunit/joblist.cxx	2008-12-09 09:03:54.000000000 +0100
@@ -1 +1,224 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+// #include "precompiled_cppunit.hxx"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <fstream>
+#include <rtl/string.hxx>
+#include "cppunit/joblist.hxx"
+
+#define C_SEPARATOR_LIST " \t,;:#"
+JobList::JobList() 
+        :ppsJobList(NULL)
+{}
+
+// -----------------------------------------------------------------------------
+bool JobList::isInCurrentEnvironment(std::string const& _sString)
+{
+    int nSpace = 0;
+    std::string sSearchString = _sString;
+    bool bEnd = false;
+    // run through the hole given string, 
+    std::string sEnv;
+
+    do {
+        nSpace = sSearchString.find_first_of(C_SEPARATOR_LIST);
+        if (nSpace < 0)
+        {
+            sEnv = sSearchString;
+            bEnd = true;
+        }
+        else
+        {
+            sEnv = sSearchString.substr(0, nSpace);
+            sSearchString = sSearchString.substr(nSpace + 1);
+        }
+        if (sEnv.length() > 0)
+        {
+            // cout << sEnv << endl;
+#ifdef LINUX
+            int nLinux = sEnv.find("unxlng");
+            if (nLinux >= 0)
+            {
+                // found unxlng
+                return true;
+            }
+#endif
+#ifdef SOLARIS
+            int nSolaris = sEnv.find("unxsol");
+            if (nSolaris >= 0)
+            {
+                // found unxsol
+                return true;
+            }            
+#endif
+#ifdef WNT
+            int nWindows = sEnv.find("wnt");
+            if (nWindows >= 0)
+            {
+                // found wnt
+                return true;
+            }
+#endif
+        }
+    } while ( !bEnd );
+    return false;
+}
+
+std::string JobList::trim(std::string const& _sStringToTrim)
+{
+    rtl::OString sStr(_sStringToTrim.c_str());
+    sStr = sStr.trim();
+    return std::string(sStr.getStr());
+}
+
+// -----------------------------------------------------------------------------
+bool JobList::readfile(std::string const& _sFilename, JobType _nJobType)
+{
+    // StringList aJobList;
+    m_aJobList.clear();
+    
+    std::ifstream in(_sFilename.c_str(), std::ios::in);
+    
+    if (!in)
+    {
+        // fprintf(stderr, "warning: Can't open job file: %s\n", _sFilename.c_str());
+        return false;
+    }
+    else
+    {
+        if (_nJobType == JOB_EXCLUDE_LIST)
+        {
+            fprintf(stderr, "warning: There exist a job exclusion list file: %s\n", _sFilename.c_str());
+        }
+        
+        // std::cout << "Check for signal" << std::endl;
+        std::string sLine;
+        while (std::getline(in, sLine))
+        {
+            if (sLine.size() > 0)
+            {
+                char ch = sLine[0];
+                if (ch != '#' &&
+                    isspace(ch) == 0)
+                {
+                    sLine = trim(sLine);
+                    
+                    // m_aJobList.push_back( sLine );
+                    int nSpace = sLine.find_first_of(C_SEPARATOR_LIST);
+                    if (nSpace < 0)
+                    {
+                        m_aJobList[sLine] = JOB_UNKNOWN;
+                    }
+                    else
+                    {
+                        // found a separator
+                        std::string sTest = sLine.substr(0, nSpace);
+                        std::string sRest = sLine.substr(nSpace + 1);
+                        if (isInCurrentEnvironment(sRest))
+                        {
+                            m_aJobList[sTest] = JOB_UNKNOWN;
+                        }
+                    }
+                }
+            }
+        }
+
+        // inclusion list
+/*
+  int nSize = m_aJobList.size();
+                
+  ppsJobList = (char**) malloc((nSize + 1) * sizeof(char*));
+                
+  int nIdx = 0;
+  StringList::const_iterator aItEnd = m_aJobList.end();
+  for(StringList::const_iterator it = m_aJobList.begin();
+  it != aItEnd; ++it)
+  {
+  std::string sValue = *it;
+  char* psTestFkt = (char*) malloc(sValue.size() + 1);
+  strcpy(psTestFkt, sValue.c_str());
+  ppsJobList[nIdx] = psTestFkt;
+  ++nIdx;
+  }
+        
+  ppsJobList[nIdx] = NULL;
+*/
+    }
+    return true;
+}
+
+// -----------------------------------------------------------------------------
+int JobList::getJobListEntry(std::string const& _sIndexName)
+{
+    if (m_aJobList.find(_sIndexName) != m_aJobList.end())
+    {
+        return m_aJobList[_sIndexName];
+    }
+    return JOB_NOT_FOUND;
+}
+
+// -----------------------------------------------------------------------------
+void JobList::setJobListEntry(std::string const& _sIndexName, int _nValue)
+{
+    // if (m_aJobList.find(_sIndexName) == m_aJobList.end())
+    // {
+    m_aJobList[_sIndexName] = _nValue;
+    // }
+    // else
+    // {
+    //  fprintf(stderr, "error: test function '%s' already exist.\n", _sIndexName);
+    // }
+}
+
+// -----------------------------------------------------------------------------
+JobList::~JobList()
+{
+    int nIdx = 0;
+    if (ppsJobList)
+    {
+        while(ppsJobList[nIdx] != NULL)
+        {
+            free(ppsJobList[nIdx]);
+            ++nIdx;
+        }
+        free(ppsJobList);
+    }
+}
+// -----------------------------------------------------------------------------
+/*
+  bool JobList::checkFilter(JobList m_aJobFilter, std::string const& _sNodeName, std::string const& _sName)
+  {
+  std::string sFilter = m_aJobFilter.m_aJobList.begin();
+  }
+*/
Nur in misc/build/cppunit-1.8.0/src/cppunit: joblist.cxx.dummy.
--- misc/cppunit-1.8.0/src/cppunit/makefile.mk	2008-12-10 20:46:08.970632544 +0100
+++ misc/build/cppunit-1.8.0/src/cppunit/makefile.mk	2008-12-10 19:44:52.000000000 +0100
@@ -1 +1,113 @@
-dummy
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile$
+#
+# $Revision$
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=..$/..$/..$/..$/..$/..
+INCEXT=..$/..$/include
+
+PRJNAME=cppunit
+TARGET=cppunit
+LIBTARGET=NO
+ENABLE_EXCEPTIONS=TRUE
+# ENABLE_RTTI=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+# --- Files --------------------------------------------------------
+
+# CXXFILES = \
+# 		  querytemplate.cxx	\
+# 		  stringhelper.cxx
+
+# ENVCFLAGSCXX+=-DCPPUNIT_BUILD_DLL
+
+CPPUNIT_TESTSHL_SLOFILES = \
+	$(SLO)$/SourceLine.obj \
+	$(SLO)$/Exception.obj \
+	$(SLO)$/NotEqualException.obj \
+	$(SLO)$/TestFailure.obj \
+	$(SLO)$/joblist.obj \
+	$(SLO)$/t_print.obj \
+	$(SLO)$/signaltest.obj
+
+CPPUNIT_STATIC_SOLFILES = \
+	$(SLO)$/Asserter.obj \
+	$(SLO)$/TestCase.obj \
+	$(SLO)$/TestSuite.obj \
+	$(SLO)$/TestAssert.obj \
+	$(SLO)$/TestFactoryRegistry.obj \
+	$(SLO)$/cmdlinebits.obj \
+	$(SLO)$/tresregister.obj \
+	$(SLO)$/tresstatewrapper.obj \
+	$(SLO)$/registertestfunction.obj 
+
+
+SLOFILES = \
+	$(CPPUNIT_TESTSHL_SLOFILES) \
+	$(CPPUNIT_STATIC_SOLFILES)
+#-------------------------------------------------------------------------------
+# This is statically cppunit library
+LIB1TARGET= $(LB)$/$(TARGET).lib
+LIB1OBJFILES= \
+	$(SLOFILES)
+
+.IF "$(GUI)"=="WNT" 
+.IF "$(COM)"=="GCC"
+LIB1ARCHIV=$(LB)$/lib$(TARGET)$(DLLPOSTFIX).a
+.ENDIF
+LIB1FILES=$(LB)$/c5t_winstuff.lib
+.ENDIF
+
+.IF "$(GUI)" == "UNX"
+LIB1ARCHIV=$(LB)$/lib$(TARGET)$(DLLPOSTFIX).a
+.ENDIF
+
+#-------------------------------------------------------------------------------
+TARGET2=c5t_no_regallfkt
+LIB2TARGET= $(LB)$/$(TARGET2).lib
+LIB2OBJFILES= \
+	$(CPPUNIT_TESTSHL_SLOFILES)
+
+.IF "$(GUI)"=="WNT" 
+.IF "$(COM)"=="GCC"
+LIB2ARCHIV=$(LB)$/lib$(TARGET2)$(DLLPOSTFIX).a
+.ENDIF
+.ENDIF
+
+.IF "$(GUI)" == "UNX"
+LIB2ARCHIV=$(LB)$/lib$(TARGET2)$(DLLPOSTFIX).a
+.ENDIF
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
Nur in misc/build/cppunit-1.8.0/src/cppunit: makefile.mk.dummy.
--- misc/cppunit-1.8.0/src/cppunit/registertestfunction.cxx	2008-12-10 20:46:09.058854031 +0100
+++ misc/build/cppunit-1.8.0/src/cppunit/registertestfunction.cxx	2008-12-09 09:04:23.000000000 +0100
@@ -1 +1,60 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+// #include "precompiled_cppunit.hxx"
+
+#include <stdlib.h>
+#include <cppunit/simpleheader.hxx>
+#include <cppunit/additionalfunc.hxx>
+
+extern "C" void SAL_CALL testAllRegisteredFunctions(hTestResult _pResult)
+{
+	CppUnit::TestFactoryRegistry::testRegistries(_pResult);
+	// CppUnit::Test* tp = CppUnit::TestFactoryRegistry::getRegistry("rtl_OUString").makeTest();
+	// tp->run(pResult);
+}
+
+// -----------------------------------------------------------------------------
+// ---------------------------- RegisterTestFunctions ----------------------------
+// -----------------------------------------------------------------------------
+
+extern "C" void SAL_CALL RegisterTestFunctions(FktRegFuncPtr _pFunc)
+{
+    if (_pFunc)
+    {
+        (_pFunc)(&testAllRegisteredFunctions, "");
+    }
+    else
+    {
+        // error, FktRegFuncPtr not given
+    }
+    RegisterAdditionalFunctions(_pFunc);
+}
Nur in misc/build/cppunit-1.8.0/src/cppunit: registertestfunction.cxx.dummy.
--- misc/cppunit-1.8.0/src/cppunit/signaltest.cxx	2008-12-10 20:46:09.119798751 +0100
+++ misc/build/cppunit-1.8.0/src/cppunit/signaltest.cxx	2008-12-09 09:04:24.000000000 +0100
@@ -1 +1,92 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+// #include "precompiled_cppunit.hxx"
+
+#include <typeinfo>
+
+#include "cppunit/signaltest.h"
+
+namespace CppUnit 
+{
+
+/** Constructs a test case for a suite.
+ *  This TestCase is intended for use by the TestCaller and should not
+ *  be used by a test case for which run() is called.
+ **/
+SignalTest::SignalTest(std::string const& _sName)
+    : m_sName( _sName )
+{
+}
+
+
+/// Destructs a test case
+SignalTest::~SignalTest()
+{
+}
+
+
+/// Returns a count of all the tests executed
+int 
+SignalTest::countTestCases() const
+{ 
+  return 1; 
+}
+
+/// We never need to start this
+void SignalTest::run(hTestResult) {}
+
+
+/// Returns the name of the test case
+std::string 
+SignalTest::getName() const
+{ 
+  return m_sName; 
+}
+
+
+/// Returns the name of the test case instance
+std::string 
+SignalTest::toString() const
+{ 
+  std::string className;
+
+#if CPPUNIT_USE_TYPEINFO_NAME
+  const std::type_info& thisClass = typeid( *this );
+  className = thisClass.name();
+#else
+  className = "SignalTest";
+#endif
+
+  return className + "." + getName(); 
+}
+ 
+} // namespace CppUnit
Nur in misc/build/cppunit-1.8.0/src/cppunit: signaltest.cxx.dummy.
--- misc/cppunit-1.8.0/src/cppunit/t_print.cxx	2008-12-10 20:46:09.210907830 +0100
+++ misc/build/cppunit-1.8.0/src/cppunit/t_print.cxx	2008-12-09 09:04:23.000000000 +0100
@@ -1 +1,98 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+// #include "precompiled_cppunit.hxx"
+
+#include <stdio.h>
+#include <cppunit/cmdlinebits.hxx>
+#include <rtl/tres.h>
+#include <osl/mutex.hxx>
+
+extern CmdLineBits st_nBits;
+
+sal_Bool isBit( CmdLineBits _nBits, CmdLineBits _nFlag )
+{
+    return( ( _nBits & _nFlag ) == _nFlag );
+}
+
+// -----------------------------------------------------------------------------
+// ----------------------------- own printf method -----------------------------
+// -----------------------------------------------------------------------------
+
+bool isVerbose()
+{
+    if ( isBit( st_nBits, rtl_tres_Flag_VERBOSE ) ) 
+    { 
+        return true;
+    } 
+    return false;
+}
+
+bool isQuiet()
+{
+    if ( isBit( st_nBits, rtl_tres_Flag_QUIET ) ) 
+    { 
+        return true;
+    } 
+    return false;
+}
+
+// ::osl::Mutex   m_aTPrintMutex;
+
+void impl_t_print(const char* _pFormatStr, va_list &args)
+{
+    if (! isQuiet())
+    {
+        // ::osl::MutexGuard g(m_aTPrintMutex);
+        printf("# ");
+        vprintf(_pFormatStr, args);
+    }
+}
+
+void t_print(const char* _pFormatStr, ...)
+{
+    va_list  args;
+    va_start( args, _pFormatStr );
+    impl_t_print(_pFormatStr, args);
+    va_end( args );
+}
+
+void t_print(T_Print_Params _eType, const char* _pFormatStr, ...)
+{
+    if (_eType == T_VERBOSE && isVerbose())
+    {
+        // if T_VERBOSE and we should be verbose, print info
+        va_list  args;
+        va_start( args, _pFormatStr );
+        impl_t_print(_pFormatStr, args);
+        va_end( args );
+    }
+}
Nur in misc/build/cppunit-1.8.0/src/cppunit: t_print.cxx.dummy.
--- misc/cppunit-1.8.0/src/cppunit/tresregister.cxx	2008-12-10 20:46:09.288665520 +0100
+++ misc/build/cppunit-1.8.0/src/cppunit/tresregister.cxx	2008-12-09 09:04:23.000000000 +0100
@@ -1 +1,69 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+// #include "precompiled_cppunit.hxx"
+
+#include <stdio.h>
+#include <sal/types.h>
+#include <cppunit/autoregister/registerfunc.h>
+#include <cppunit/autoregister/callbackstructure.h>
+#include <cppunit/cmdlinebits.hxx>
+
+//! is this global CallbackStructure need?
+CallbackStructure aGlobalStructure;
+CmdLineBits st_nBits;
+
+FktPtr_CallbackDispatch  pCallbackFunc = NULL;
+
+// This function is called from the TestShl tool.
+extern "C" void SAL_CALL registerAllTestFunction(CallbackStructure* _pCallback)
+{
+	aGlobalStructure = *_pCallback;
+
+        st_nBits = aGlobalStructure.nBits;
+
+	pCallbackFunc = _pCallback->aCallbackDispatch;
+	FktRegFuncPtr pFunc = _pCallback->aRegisterFunction;
+	if (pFunc)
+	{
+		RegisterTestFunctions(pFunc);
+	}
+	else
+	{
+		// error, should be echoed
+		fprintf(stderr, "error: Callback Structure doesn't contain a test function ptr.\n");
+	}
+
+	// all is done, copy the magic value
+	// this is only a simple internal invariant check,
+	// if the called registerAllTestFunctions Function do, what we want.
+	_pCallback->nMagic2 = _pCallback->nMagic;
+}
Nur in misc/build/cppunit-1.8.0/src/cppunit: tresregister.cxx.dummy.
--- misc/cppunit-1.8.0/src/cppunit/tresstatewrapper.cxx	2008-12-10 20:46:09.345773546 +0100
+++ misc/build/cppunit-1.8.0/src/cppunit/tresstatewrapper.cxx	2008-12-10 20:42:43.000000000 +0100
@@ -1 +1,168 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+// #include "precompiled_cppunit.hxx"
+
+// this functions build the wrapper, to handle old function calls to rtl_tres_state
+// IMPORTANT: Due to the fact that rtl_tres_state is in the sal.lib 
+// you have to rename rtl_tres_state to c_rtl_tres_state
+//
+// return c_rtl_tres_state
+// (
+// 	   hRtlTestResult,
+// 	   pData->length == 0 &&
+// 	   ! *pData->buffer,
+// 	   "New OString containing no characters",
+// 	   "ctor_001"
+// )
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include "cppunit/Test.h"
+#include "cppunit/autoregister/htestresult.h"
+#include "cppunit/autoregister/callbackfunc_fktptr.h"
+#include "cppunit/TestAssert.h"
+
+#define LOAD_TRESSTATEWRAPPER_LOCAL
+#include "testshl/tresstatewrapper.hxx"
+#undef LOAD_TRESSTATEWRAPPER_LOCAL
+
+#include "cppunit/tagvalues.hxx"
+#include "cppunit/externcallbackfunc.hxx"
+
+// -----------------------------------------------------------------------------
+// Wrapper class for the CppUnit::Test, because the new TestResult
+// expect a CppUnit::Test interface
+
+class WrappedTest : public CppUnit::Test
+{
+	std::string m_sName;
+public:
+	WrappedTest(std::string const& _sName)
+			:m_sName(_sName){}
+	
+    virtual                       ~WrappedTest () {}
+    virtual void                  run (hTestResult /*pResult*/){}
+    virtual int                   countTestCases () const {return 1;}
+    virtual std::string           getName () const {return m_sName;}
+    virtual std::string           toString () const {return "WrappedTest";}
+};
+
+// -----------------------------------------------------------------------------
+rtl_tres_state_start::rtl_tres_state_start(hTestResult _aResult, const sal_Char* _pName)
+        :m_pName(_pName),
+         m_aResult(_aResult)
+{
+    // (pTestResult_EnterNode)(m_aResult, m_pName);
+    (pCallbackFunc)( 0 /* NULL */, TAG_TYPE, RESULT_ENTER_NODE, TAG_RESULT_PTR, m_aResult, TAG_NODENAME, m_pName, TAG_DONE);
+}
+rtl_tres_state_start::~rtl_tres_state_start()
+{
+    // (pTestResult_LeaveNode)(m_aResult, m_pName);
+    (pCallbackFunc)(0 /* NULL */, TAG_TYPE, RESULT_LEAVE_NODE, TAG_RESULT_PTR, m_aResult, TAG_NODENAME, m_pName, TAG_DONE);
+}
+
+// --------------------------------- C-Wrapper ---------------------------------
+typedef std::vector<rtl_tres_state_start*> rtl_tres_states;
+rtl_tres_states m_StateStack;
+
+extern "C" void c_rtl_tres_state_start(hTestResult _aResult, const sal_Char* _pName)
+{
+    rtl_tres_state_start* pState = new rtl_tres_state_start(_aResult, _pName);
+    m_StateStack.push_back(pState);
+}
+
+extern "C" void c_rtl_tres_state_end(hTestResult, const sal_Char*)
+{
+    rtl_tres_state_start* pState = m_StateStack.back();
+
+    delete pState;
+    m_StateStack.pop_back();
+}
+// -----------------------------------------------------------------------------
+// -----------------------------------------------------------------------------
+// -----------------------------------------------------------------------------
+
+// -----------------------------------------------------------------------------
+// ------------------------- Wrapper for rtl_tres_state -------------------------
+// -----------------------------------------------------------------------------
+
+sal_Bool SAL_CALL c_rtl_tres_state(
+    hTestResult pResult,
+    sal_Bool bSuccess,
+    char const * pTestMsg,
+    char const * pFuncName)
+{
+    CppUnit::Test* pTest = new WrappedTest(pFuncName);
+    
+    sal_Int32 nValue = (pCallbackFunc)(0 /* NULL */, TAG_TYPE, EXECUTION_CHECK, TAG_RESULT_PTR, pResult, TAG_NODENAME, pTest->getName().c_str(), TAG_DONE);
+    if (nValue == DO_NOT_EXECUTE)
+    {
+        return false;
+    }
+
+    // This code is copied from CppUnit::TestCase and less adapted, to work with the
+    // old test code.
+    // (pTestResult_StartTest)(pResult, pTest);
+    (pCallbackFunc)(0 /* NULL */, TAG_TYPE, RESULT_START, TAG_RESULT_PTR, pResult, TAG_TEST_PTR, pTest, TAG_DONE);
+    
+    try 
+    {
+        CPPUNIT_ASSERT_MESSAGE( pTestMsg, bSuccess ? true : false );
+        // (pTestResult_AddInfo)(pResult, pTest, "#PASSED#");
+        (pCallbackFunc)(0 /* NULL */, TAG_TYPE, RESULT_ADD_INFO, TAG_RESULT_PTR, pResult, TAG_TEST_PTR, pTest, TAG_INFO, "PASSED", TAG_DONE);
+    }
+    catch ( CppUnit::Exception &e ) 
+    {
+        CppUnit::Exception *copy = e.clone();
+        // (pTestResult_AddFailure)( pResult, pTest, copy );
+        (pCallbackFunc)( 0 /* NULL */, TAG_TYPE, RESULT_ADD_FAILURE, TAG_RESULT_PTR, pResult, TAG_TEST_PTR, pTest, TAG_EXCEPTION, copy, TAG_DONE );
+    }
+    catch ( std::exception &e ) 
+    {
+        //(pTestResult_AddError)( pResult, pTest, new CppUnit::Exception( e.what() ) );
+        (pCallbackFunc)( 0 /* NULL */, TAG_TYPE, RESULT_ADD_ERROR, TAG_RESULT_PTR, pResult, TAG_TEST_PTR, pTest, TAG_EXCEPTION, new CppUnit::Exception( e.what() ), TAG_DONE );
+    }
+    catch (...) 
+    {
+        CppUnit::Exception *e = new CppUnit::Exception( "caught unknown exception" );
+        // (pTestResult_AddError)( pResult, pTest, e );
+        (pCallbackFunc)( 0 /* NULL */, TAG_TYPE, RESULT_ADD_ERROR, TAG_RESULT_PTR, pResult, TAG_TEST_PTR, pTest, TAG_EXCEPTION, e, TAG_DONE );
+    }
+    
+
+    // (pTestResult_EndTest)( pResult, pTest );
+    (pCallbackFunc)( 0 /* NULL */, TAG_TYPE, RESULT_END, TAG_RESULT_PTR, pResult, TAG_TEST_PTR, pTest, TAG_DONE );
+    
+    return bSuccess;
+}
+
Nur in misc/build/cppunit-1.8.0/src/cppunit: tresstatewrapper.cxx.dummy.
--- misc/cppunit-1.8.0/src/makefile.mk	2008-12-10 20:46:08.706925653 +0100
+++ misc/build/cppunit-1.8.0/src/makefile.mk	2008-12-09 08:57:10.000000000 +0100
@@ -1 +1,35 @@
-dummy
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile$
+#
+# $Revision$
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+target:
+	cd cppunit && $(MAKE) $(MFLAGS) $(CALLMACROS)
+	cd result && $(MAKE) $(MFLAGS) $(CALLMACROS)
+	cd win32 && $(MAKE) $(MFLAGS) $(CALLMACROS)
Nur in misc/build/cppunit-1.8.0/src: makefile.mk.dummy.
--- misc/cppunit-1.8.0/src/result/SynchronizedObject.cpp	2008-12-10 20:46:05.438373643 +0100
+++ misc/build/cppunit-1.8.0/src/result/SynchronizedObject.cpp	2008-02-27 17:26:28.000000000 +0100
@@ -1 +1,35 @@
-dummy
+#include <cppunit/result/SynchronizedObject.h>
+
+
+namespace CppUnit
+{
+
+
+
+
+SynchronizedObject::SynchronizedObject( SynchronizationObject *syncObject )
+    : m_syncObject( syncObject == 0 ? new SynchronizationObject() : 
+                                      syncObject )
+{
+}
+
+
+SynchronizedObject::~SynchronizedObject()
+{
+  delete m_syncObject;
+}
+
+
+/** Accept a new synchronization object for protection of this instance
+ * TestResult assumes ownership of the object
+ */
+void 
+SynchronizedObject::setSynchronizationObject( SynchronizationObject *syncObject )
+{ 
+  delete m_syncObject; 
+  m_syncObject = syncObject; 
+}
+
+
+} //  namespace CppUnit
+
Nur in misc/build/cppunit-1.8.0/src/result: SynchronizedObject.cpp.dummy.
--- misc/cppunit-1.8.0/src/result/TestResult.cpp	2008-12-10 20:46:05.577200921 +0100
+++ misc/build/cppunit-1.8.0/src/result/TestResult.cpp	2008-12-10 20:42:45.000000000 +0100
@@ -1 +1,261 @@
-dummy
+#include <cppunit/TestFailure.h>
+#include <cppunit/result/TestListener.h>
+#include "testshl/getopt.hxx"
+#include <cppunit/result/TestResult.h>
+#include <algorithm>
+#include "cppunit/result/outputter.hxx"
+#include <cppunit/Test.h>
+#include <cppunit/cmdlinebits.hxx>
+
+namespace CppUnit {
+
+/// Construct a TestResult
+TestResult::TestResult( GetOpt &_pOptions, SynchronizationObject *syncObject )
+    : SynchronizedObject( syncObject ),
+      m_aOptionHelper(_pOptions),
+      m_nExitValue(0)
+{
+  reset();
+}
+
+
+/// Destroys a test result
+TestResult::~TestResult()
+{
+}
+
+
+/** Resets the result for a new run.
+ *
+ * Clear the previous run result.
+ */
+void 
+TestResult::reset()
+{
+  ExclusiveZone zone( m_syncObject ); 
+  m_stop = false;
+}
+
+
+/** Adds an error to the list of errors. 
+ *  The passed in exception
+ *  caused the error
+ */
+void 
+TestResult::addError( Test *test, 
+                      Exception *e, ErrorType::num _eType )
+{ 
+  TestFailure aTestFailure( test, e, _eType );
+  addFailure( aTestFailure );
+}
+
+
+/** Adds a failure to the list of failures. The passed in exception
+ * caused the failure.
+ */
+void 
+TestResult::addFailure( Test *test, Exception *e )
+{ 
+  TestFailure aTestFailure( test, e, ErrorType::ET_FAILURE );
+  addFailure( aTestFailure );
+}
+
+
+/** Called to add a failure to the list of failures.
+ */
+void 
+TestResult::addFailure( const TestFailure &failure )
+{
+  ExclusiveZone zone( m_syncObject ); 
+
+  // LLA: 
+  // this set the global returnvalue, due to the fact, there occurs a failure, we have to return a non zero value
+  // at the moment this seams to be a good place.
+  setExitValue(1);
+  
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end(); 
+        ++it )
+  {
+	  TestListener *pListener = *it;
+	  pListener->addFailure( failure );
+  }
+}
+
+
+/// Informs the result that a test will be started.
+void 
+TestResult::startTest( Test *test )
+{ 
+  ExclusiveZone zone( m_syncObject ); 
+  if (m_aOptionHelper.isVerbose())
+  {
+      std::string aStr;
+      if (test)
+      {
+          aStr = getNodeName();
+          aStr += ".";
+          aStr += test->getName();
+      }
+      // fprintf(stderr, "Start test: %s\n", aStr.c_str());
+      t_print( T_VERBOSE, "Start test: %s\n", aStr.c_str());
+  }
+  
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end(); 
+        ++it )
+  {
+	  TestListener *pListener = *it;
+	  pListener->startTest( test );
+  }
+}
+
+  
+/// Informs the result that a test was completed.
+void 
+TestResult::endTest( Test *test )
+{ 
+  ExclusiveZone zone( m_syncObject ); 
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end(); 
+        ++it )
+  {
+	  TestListener *pListener = *it;
+	  pListener->endTest( test );
+  }
+}
+
+
+/// Returns whether testing should be stopped
+bool 
+TestResult::shouldStop() const
+{ 
+  ExclusiveZone zone( m_syncObject );
+  return m_stop; 
+}
+
+
+/// Stop testing
+void 
+TestResult::stop()
+{ 
+  ExclusiveZone zone( m_syncObject );
+  m_stop = true; 
+}
+
+
+void 
+TestResult::addListener( TestListener *listener )
+{
+  ExclusiveZone zone( m_syncObject ); 
+  m_listeners.push_back( listener );
+}
+
+
+void 
+TestResult::removeListener ( TestListener *listener )
+{
+  ExclusiveZone zone( m_syncObject ); 
+#if defined(_MSC_VER) && (_MSC_VER >=1400)
+  m_listeners.erase( remove( m_listeners.begin(), 
+#else
+  m_listeners.erase( std::remove( m_listeners.begin(), 
+#endif
+                                  m_listeners.end(), 
+                                  listener ),
+                     m_listeners.end());
+}
+
+void
+TestResult::addInfo(Test *test, const char* _aStr)
+{
+	ExclusiveZone zone( m_syncObject ); 
+	for ( TestListeners::iterator it = m_listeners.begin();
+		  it != m_listeners.end(); 
+		  ++it )
+	{
+		TestListener *pListener = *it;
+		pListener->addInfo( test, _aStr );
+	}
+}
+
+// old: void
+// old: TestResult::enterNode(const char* _aStr)
+// old: {
+// old:         ExclusiveZone zone( m_syncObject ); 
+// old:         for ( TestListeners::iterator it = m_listeners.begin();
+// old:                   it != m_listeners.end(); 
+// old:                   ++it )
+// old:         {
+// old:                 TestListener *pListener = *it;
+// old:                 pListener->enterNode( _aStr );
+// old:         }
+// old: }
+// old: 
+// old: void
+// old: TestResult::leaveNode(const char* _aStr)
+// old: {
+// old:         ExclusiveZone zone( m_syncObject ); 
+// old: 
+// old:         for ( TestListeners::iterator it = m_listeners.begin();
+// old:                   it != m_listeners.end(); 
+// old:                   ++it )
+// old:         {
+// old:                 TestListener *pListener = *it;
+// old:                 pListener->leaveNode( _aStr );
+// old:         }
+// old: }
+
+void TestResult::enterNode(const char* _sNode)
+{
+	ExclusiveZone zone( m_syncObject );
+	m_aCurrentNodeNames.push_back(std::string(_sNode));
+}
+
+void TestResult::leaveNode(const char* /*_sNode*/)
+{
+	ExclusiveZone zone( m_syncObject );
+	std::string sBack = m_aCurrentNodeNames.back();
+	m_aCurrentNodeNames.pop_back();
+	
+	// due to a -Wall warning, comment out.
+	// if (sBack != std::string(_sNode))
+	// {
+	//     volatile int dummy = 0;
+	//     // problem?!
+	// }
+}
+
+std::string TestResult::getNodeName()
+{
+	std::string sName;
+	for (std::vector<std::string>::const_iterator it = m_aCurrentNodeNames.begin();
+		 it != m_aCurrentNodeNames.end();
+		 ++it)
+	{
+		if (sName.size() != 0)
+		{
+			sName += ".";
+		}
+		sName += *it;
+	}
+	return sName;
+}
+
+// -----------------------------------------------------------------------------
+bool TestResult::isAllowedToExecute(std::string const& _sName)
+{
+	return m_aOptionHelper.isAllowedToExecute(getNodeName(), _sName);
+}
+// -----------------------------------------------------------------------------
+bool TestResult::isOptionWhereAmI()
+{
+    return m_aOptionHelper.isOptionWhereAmI();
+}
+
+// -----------------------------------------------------------------------------
+void TestResult::print(Outputter&)
+{
+}
+
+} // namespace CppUnit
Nur in misc/build/cppunit-1.8.0/src/result: TestResult.cpp.dummy.
--- misc/cppunit-1.8.0/src/result/TestResultCollector.cpp	2008-12-10 20:46:05.532229436 +0100
+++ misc/build/cppunit-1.8.0/src/result/TestResultCollector.cpp	2008-02-27 17:25:50.000000000 +0100
@@ -1 +1,147 @@
-dummy
+#include <cppunit/TestFailure.h>
+#include <cppunit/result/TestResultCollector.h>
+
+
+namespace CppUnit
+{
+
+
+TestResultCollector::TestResultCollector( TestResult* _pResult, SynchronizationObject *syncObject )
+        : TestSucessListener( syncObject ),
+          m_pResult(_pResult),
+          m_testErrors(0)
+{
+  reset();
+}
+
+
+TestResultCollector::~TestResultCollector()
+{
+	TestFailures::iterator itFailure = m_failures.begin();
+	while ( itFailure != m_failures.end() )
+	{
+		TestFailureEnvelope *pEnvelope = *itFailure++;
+		TestFailure *pFailure = pEnvelope->getTestFailure();
+		delete pFailure;
+	}
+}
+
+
+void 
+TestResultCollector::reset()
+{
+  TestSucessListener::reset();
+
+  ExclusiveZone zone( m_syncObject ); 
+  m_testErrors = 0;
+  m_tests.clear();
+  m_failures.clear();
+}
+
+
+void 
+TestResultCollector::startTest( Test *test )
+{
+  ExclusiveZone zone (m_syncObject); 
+  
+  m_tests.push_back( new TestEnvelope(test, m_pResult->getNodeName()) );
+}
+
+void 
+TestResultCollector::endTest( Test * )
+{
+	// ExclusiveZone zone (m_syncObject); 
+	// Nothing!
+}
+
+
+void 
+TestResultCollector::addFailure( const TestFailure &failure )
+{
+  TestSucessListener::addFailure( failure );
+
+  ExclusiveZone zone( m_syncObject ); 
+  if ( failure.isError() )
+    ++m_testErrors;
+  m_failures.push_back( new TestFailureEnvelope(failure.clone(), m_pResult->getNodeName()) );
+}
+
+
+/// Gets the number of run tests.
+int 
+TestResultCollector::runTests() const
+{ 
+  ExclusiveZone zone( m_syncObject ); 
+  return m_tests.size(); 
+}
+
+
+/// Gets the number of detected errors (uncaught exception).
+int 
+TestResultCollector::testErrors() const
+{ 
+  ExclusiveZone zone( m_syncObject );
+  return m_testErrors;
+}
+
+
+/// Gets the number of detected failures (failed assertion).
+int 
+TestResultCollector::testFailures() const
+{ 
+  ExclusiveZone zone( m_syncObject ); 
+  return m_failures.size() - m_testErrors;
+}
+
+
+/// Gets the total number of detected failures.
+int 
+TestResultCollector::testFailuresTotal() const
+{
+  ExclusiveZone zone( m_syncObject ); 
+  return m_failures.size();
+}
+
+
+/// Returns a the list failures (random access collection).
+const TestResultCollector::TestFailures & 
+TestResultCollector::failures() const
+{ 
+  ExclusiveZone zone( m_syncObject );
+  return m_failures; 
+}
+
+
+const TestResultCollector::Tests &
+TestResultCollector::tests() const
+{
+  ExclusiveZone zone( m_syncObject );
+  return m_tests;
+}
+
+void TestResultCollector::addInfo(Test *_pTest, const char* _sInfo)
+{
+	ExclusiveZone zone( m_syncObject );
+	m_aInfos.push_back(new TestInfo(_pTest, _sInfo));
+}
+
+std::string TestResultCollector::getInfo(Test *_pTest)
+{
+	for (TestInfos::const_iterator it = m_aInfos.begin();
+		 it != m_aInfos.end();
+		 ++it)
+	{
+		TestInfo *pInfo   = *it;
+		Test *pTest       = pInfo->getTest();
+		if (pTest == _pTest)
+		{
+			std::string sInfo = pInfo->getString();
+			return sInfo;
+		}
+	}
+	return std::string();
+}
+
+
+} //  namespace CppUnit
+
Nur in misc/build/cppunit-1.8.0/src/result: TestResultCollector.cpp.dummy.
--- misc/cppunit-1.8.0/src/result/TestSucessListener.cpp	2008-12-10 20:46:05.660884351 +0100
+++ misc/build/cppunit-1.8.0/src/result/TestSucessListener.cpp	2008-02-27 17:26:16.000000000 +0100
@@ -1 +1,46 @@
-dummy
+#include <cppunit/result/TestSucessListener.h>
+
+
+
+namespace CppUnit
+{
+
+
+TestSucessListener::TestSucessListener( SynchronizationObject *syncObject )
+    : SynchronizedObject( syncObject )
+    , m_sucess( true )
+{
+}
+
+
+TestSucessListener::~TestSucessListener()
+{
+}
+
+
+void 
+TestSucessListener::reset()
+{
+  ExclusiveZone zone( m_syncObject );
+  m_sucess = true;
+}
+
+
+void 
+TestSucessListener::addFailure( const TestFailure & )
+{
+  ExclusiveZone zone( m_syncObject );
+  m_sucess = false;
+}
+
+
+bool 
+TestSucessListener::wasSuccessful() const
+{
+  ExclusiveZone zone( m_syncObject );
+  return m_sucess;
+}
+
+
+} //  namespace CppUnit
+
Nur in misc/build/cppunit-1.8.0/src/result: TestSucessListener.cpp.dummy.
--- misc/cppunit-1.8.0/src/result/TextTestResult.cpp	2008-12-10 20:46:05.742386241 +0100
+++ misc/build/cppunit-1.8.0/src/result/TextTestResult.cpp	2008-02-27 17:24:56.000000000 +0100
@@ -1 +1,191 @@
-dummy
+#include <cppunit/Exception.h>
+#include <cppunit/NotEqualException.h>
+#include <cppunit/Test.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/result/TextTestResult.h>
+// #include <TextTestResult.h>
+//!io #include <iostream>
+
+namespace CppUnit {
+
+
+TextTestResult::TextTestResult(GetOpt& _aOptions)
+        :TestResult(_aOptions),
+		 m_aResulter(this)
+{
+	addListener( &m_aResulter );
+}
+
+
+void 
+TextTestResult::addFailure( const TestFailure &failure )
+{
+	TestResult::addFailure( failure );
+	// std::cerr << ( failure.isError() ? "E" : "F" );
+	if (failure.isError())
+		fprintf(stderr, "E");
+	else
+		fprintf(stderr, "F");
+}
+
+
+void 
+TextTestResult::startTest( Test *test )
+{
+	TestResult::startTest (test);
+	// std::cerr << ".";
+	fprintf(stderr, ".");
+}
+
+void TextTestResult::endTest( Test *test )
+{
+	TestResult::endTest (test);
+}
+
+
+void 
+TextTestResult::printFailures( std::ostream &stream )
+{
+	TestResultCollector::TestFailures::const_iterator itFailure = m_aResulter.failures().begin();
+	int failureNumber = 1;
+	while ( itFailure != m_aResulter.failures().end() ) 
+	{
+		stream  <<  std::endl;
+		TestFailure *pFailure= (*itFailure++)->getTestFailure();
+		printFailure( pFailure, failureNumber++, stream );
+  }
+}
+
+
+void 
+TextTestResult::printFailure( TestFailure *failure,
+                              int failureNumber,
+                              std::ostream &stream )
+{
+  printFailureListMark( failureNumber, stream );
+  stream << ' ';
+  printFailureTestName( failure, stream );
+  stream << ' ';
+  printFailureType( failure, stream );
+  stream << ' ';
+  printFailureLocation( failure->sourceLine(), stream );
+  stream << std::endl;
+  printFailureDetail( failure->thrownException(), stream );
+  stream << std::endl;
+}
+
+
+void 
+TextTestResult::printFailureListMark( int failureNumber,
+                                      std::ostream &stream )
+{
+  stream << failureNumber << ")";
+}
+
+
+void 
+TextTestResult::printFailureTestName( TestFailure *failure,
+                                      std::ostream &stream )
+{
+	Test* pTest = failure->failedTest();
+	stream << "test: " << pTest->getName();
+}
+
+
+void 
+TextTestResult::printFailureType( TestFailure *failure,
+                                  std::ostream &stream )
+{
+  stream << "("
+         << (failure->isError() ? "E" : "F")
+         << ")";
+}
+
+
+void 
+TextTestResult::printFailureLocation( SourceLine sourceLine,
+                                      std::ostream &stream )
+{
+  if ( !sourceLine.isValid() )
+    return;
+
+  stream << "line: " << sourceLine.lineNumber()
+         << ' ' << sourceLine.fileName();
+}
+
+
+void 
+TextTestResult::printFailureDetail( Exception *thrownException,
+                                    std::ostream &stream )
+{
+  if ( thrownException->isInstanceOf( NotEqualException::type() ) )
+  {
+    NotEqualException *e = (NotEqualException*)thrownException;
+    stream << "expected: " << e->expectedValue() << std::endl
+           << "but was:  " << e->actualValue();
+    if ( !e->additionalMessage().empty() )
+    {
+      stream  << std::endl;
+      stream  <<  "additional message:"  <<  std::endl
+              <<  e->additionalMessage();
+    }
+  }
+  else
+  {
+    stream << " \"" << thrownException->what() << "\"";
+  }
+}
+
+
+void 
+TextTestResult::print( std::ostream& stream ) 
+{
+  printHeader( stream );
+  stream << std::endl;
+  printFailures( stream );
+}
+
+
+void 
+TextTestResult::printHeader( std::ostream &stream )
+{
+	if (m_aResulter.wasSuccessful ())
+		stream << std::endl << "OK (" << m_aResulter.runTests () << " tests)" 
+			   << std::endl;
+	else
+	{
+		stream << std::endl;
+		printFailureWarning( stream );
+		printStatistics( stream );
+	}
+}
+
+
+void 
+TextTestResult::printFailureWarning( std::ostream &stream )
+{
+  stream  << "!!!FAILURES!!!" << std::endl;
+}
+
+
+void 
+TextTestResult::printStatistics( std::ostream &stream )
+{
+  stream  << "Test Results:" << std::endl;
+
+  stream  <<  "Run:  "  <<  m_aResulter.runTests()
+          <<  "   Failures: "  <<  m_aResulter.testFailures()
+          <<  "   Errors: "  <<  m_aResulter.testErrors()
+          <<  std::endl;
+}
+
+
+std::ostream &
+operator <<( std::ostream &stream, 
+             TextTestResult &result )
+{ 
+  result.print (stream); return stream; 
+}
+
+
+} // namespace CppUnit
Nur in misc/build/cppunit-1.8.0/src/result: TextTestResult.cpp.dummy.
--- misc/cppunit-1.8.0/src/result/emacsTestResult.cxx	2008-12-10 20:46:09.419267625 +0100
+++ misc/build/cppunit-1.8.0/src/result/emacsTestResult.cxx	2008-12-09 09:06:11.000000000 +0100
@@ -1 +1,193 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+// #include "precompiled_cppunit.hxx"
+
+#include <stdlib.h>
+
+#include <map>
+#include <cppunit/Exception.h>
+#include <cppunit/NotEqualException.h>
+#include <cppunit/Test.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/result/emacsTestResult.hxx>
+// #include <TextTestResult.h>
+//!io #include <iostream>
+#include <string>
+
+#include <rtl/string.hxx>
+#include "cppunit/result/outputter.hxx"
+
+namespace CppUnit {
+
+    emacsTestResult::emacsTestResult(GetOpt & _aOptions)
+            :TestResult(_aOptions),
+			 m_aOptions(_aOptions),
+             m_aResulter(this)
+    {
+        addListener( &m_aResulter );
+    }
+
+    //# struct ltstr
+    //# {
+    //#     bool operator()(const CppUnit::Test* p1, const CppUnit::Test* p2) const
+    //#         {
+    //#             return p1 < p2;
+    //#         }
+    //# };
+    //# typedef std::map<CppUnit::Test*, bool, ltstr> TestPtrList;
+
+    void 
+    emacsTestResult::print( Outputter& stream ) 
+    {
+        printHeader( stream );
+        // stream << std::endl;
+        // printFailures( stream );
+    
+        // TestPtrList aFailedTests;
+    
+        for (TestResultCollector::TestFailures::const_iterator it2 = m_aResulter.failures().begin();
+             it2 != m_aResulter.failures().end();
+             ++it2)
+        {
+            TestFailureEnvelope *pEnvelop = *it2;
+            TestFailure *pFailure = pEnvelop->getTestFailure();
+            std::string sNodeName = pEnvelop->getString();
+        
+            // aFailedTests[ pFailure->failedTest() ] = true;
+        
+            printFailureLine(stream, pFailure, sNodeName);
+        }
+    
+        // only errors are from interest here
+        //# for (TestResultCollector::Tests::const_iterator it = m_aResulter.tests().begin();
+        //#      it != m_aResulter.tests().end();
+        //#      ++it)
+        //# {
+        //#     TestEnvelope *pEnvelop = *it;
+        //#     Test* pTest = pEnvelop->getTest();
+        //#     std::string sNodeName = pEnvelop->getString();
+        //# 
+        //#     if (aFailedTests.find(pTest) == aFailedTests.end())
+        //#     {
+        //#         std::string sInfo = m_aResulter.getInfo(pTest);
+        //#         printTestLine(stream, pTest, sNodeName, sInfo);
+        //#     }
+        //# }
+        stream << "Test #PASSED#" << Outputter::endl();
+    }
+
+
+    void 
+    emacsTestResult::printHeader( Outputter &stream )
+    {
+	std::string sDate(m_aOptionHelper.createDateTag());
+	stream << sDate << Outputter::endl();
+    }
+
+    void
+    emacsTestResult::printFailureLine( Outputter &stream, TestFailure *_pFailure, std::string const& _sNodeName)
+    {
+	std::string aName;
+	aName += _sNodeName;
+	aName += ".";
+	aName += _pFailure->failedTestName();
+
+	SourceLine aLine = _pFailure->sourceLine();
+	sal_Int32 nLine = -1;
+	std::string sFilename;
+	if (aLine.isValid())
+	{
+            nLine = aLine.lineNumber();
+            sFilename = aLine.fileName();
+	}
+	
+	Exception  *pExp  = _pFailure->thrownException();
+	std::string sWhat;
+	if (pExp)
+	{
+            sWhat = pExp->what();
+	}
+	
+	stream << sFilename;
+	stream << ":";
+	stream << nLine;
+	stream << ":";
+        
+	stream << aName;
+	stream << ";#FAILED#";
+	// ErrorType::num eErr = _pFailure->getErrorType();
+	//# if (isErr)
+        //#     stream << "FAILED#;";
+	//# else
+        //#     stream << "ERROR#;";
+
+	stream << sWhat;
+	stream << Outputter::endl();
+    }
+
+    //# void 
+    //# emacsTestResult::printTestLine( Outputter &stream, Test* _pTest, std::string const& _sNodeName, std::string const& _sInfo)
+    //# {
+    //#     std::string aName;
+    //#     aName += _sNodeName;
+    //#     aName += ".";
+    //#     aName += _pTest->getName();
+    //# 
+    //#     stream << aName;
+    //#     stream << ";";
+    //#     stream << _sInfo << "#";
+    //#     stream << "OK#";
+    //#     stream << std::endl;
+    //# }
+
+
+//# void 
+//# emacsTestResult::printStatistics( Outputter &stream )
+//# {
+//# 	stream  << "Test Results:" << std::endl;
+//# 	
+//# 	stream  <<  "Run:  "  <<  runTests()
+//# 			<<  "   Failures: "  <<  testFailures()
+//# 			<<  "   Errors: "  <<  testErrors()
+//# 			<<  std::endl;
+//# }
+
+
+    Outputter &
+    operator <<( Outputter &stream, 
+                 emacsTestResult &result )
+    { 
+        result.print (stream); return stream; 
+    }
+
+
+} // namespace CppUnit
Nur in misc/build/cppunit-1.8.0/src/result: emacsTestResult.cxx.dummy.
--- misc/cppunit-1.8.0/src/result/log.cxx	2008-12-10 20:46:09.499346711 +0100
+++ misc/build/cppunit-1.8.0/src/result/log.cxx	2008-12-10 20:42:45.000000000 +0100
@@ -1 +1,125 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+// #include "precompiled_cppunit.hxx"
+
+#include "testshl/log.hxx"
+
+// #include <hash_map>
+// #include <list>
+// #include <set>
+
+using namespace std;
+
+::osl::FileBase::RC Log::open( sal_Bool append ) {
+
+	::osl::FileBase::RC ret;
+
+	if ( ! append ) {
+        ret = ::osl::File::remove( m_logurl );
+	}
+
+    if( m_logfile->open( OpenFlag_Write ) == ::osl::FileBase::E_NOENT ) {
+        ret = m_logfile->open( OpenFlag_Write | OpenFlag_Create );
+	}
+	else  {
+        ret = m_logfile->setPos( Pos_End, 0 );
+	}
+	return ret;
+}
+
+::osl::FileBase::RC Log::write( const sal_Char* buf, sal_Bool v ) {
+	sal_uInt64 uBytes=0;
+    sal_uInt32 len = 0;
+    const sal_Char* ptr = buf;
+
+    if( ptr ) {
+        while( *ptr++ ) len++;
+    }
+
+	if ( v ) {
+		// cout << buf << flush;
+		printf("%s", buf);
+	}
+    return m_logfile->write( buf, len , uBytes );
+}
+
+::osl::FileBase::RC Log::write( const rtl::OString& buf, sal_Bool v  ) {
+	sal_uInt64 uBytes=0;
+	if ( v ) {
+		// cout << buf.getStr() << flush;
+		printf("%s", buf.getStr());
+	}
+    return m_logfile->write( buf.getStr(), buf.getLength(), uBytes );
+}
+/*
+// LLA: due to a problem with sal/OUStingBuffer getLength() which isn't const, this
+// is so not compilable.
+::osl::FileBase::RC Log::write( rtl::OStringBuffer const& buf, sal_Bool v  ) {
+	sal_uInt64 uBytes=0;
+	if ( v ) {
+		cout << buf.getStr() << flush;
+	}
+    return m_logfile->write( buf.getStr(), buf.getLength(), uBytes );
+}
+*/
+::osl::FileBase::RC Log::write( const rtl::OUString& buf,
+									rtl_TextEncoding tenc, sal_Bool v  ) {
+	sal_uInt64 uBytes=0;
+	if ( ! tenc ) {
+		tenc = RTL_TEXTENCODING_ASCII_US;
+	}
+	rtl::OStringBuffer osbuf(
+							rtl::OUStringToOString( buf, tenc ).getStr() );
+
+	if ( v ) {
+		// cout << osbuf.getStr() << flush;
+		printf("%s", osbuf.getStr());		
+	}
+    return m_logfile->write( osbuf.getStr(), osbuf.getLength(), uBytes );
+}
+
+Log &operator <<( Log &_aLog, const sal_Char * _sValue )
+{ 
+	_aLog.write(_sValue); return _aLog;
+}
+Log &operator <<( Log &_aLog, rtl::OString const& _sValue )
+{ 
+	_aLog.write(_sValue); return _aLog;
+}
+Log &operator <<( Log &_aLog, rtl::OUString const& _sValue )
+{ 
+	_aLog.write(_sValue); return _aLog;
+}
+//! Log &operator <<( Log &_aLog, rtl::OStringBuffer const& _sValue )
+//! { 
+//! 	_aLog.write(_sValue); return _aLog;
+//! }
Nur in misc/build/cppunit-1.8.0/src/result: log.cxx.dummy.
--- misc/cppunit-1.8.0/src/result/makefile.mk	2008-12-10 20:46:09.542019008 +0100
+++ misc/build/cppunit-1.8.0/src/result/makefile.mk	2008-12-10 20:23:07.000000000 +0100
@@ -1 +1,88 @@
-dummy
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile$
+#
+# $Revision$
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=..$/..$/..$/..$/..$/..
+INCEXT=..$/..$/include
+# INCEXT=$(SOLARSRC)$/cppunit/$/$(INPATH)/$/misc$/build$/cppunit-1.8.0$/include
+# PRJ=..$/..
+# PRJINC=..$/..
+
+
+PRJNAME=cppunit
+TARGET=c5t_testresult
+LIBTARGET=NO
+ENABLE_EXCEPTIONS=TRUE
+# ENABLE_RTTI=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+# --- Files --------------------------------------------------------
+
+# CXXFILES = \
+# 		  querytemplate.cxx	\
+# 		  stringhelper.cxx
+
+# ENVCFLAGSCXX+=-DCPPUNIT_BUILD_DLL
+SLOFILES = \
+	$(SLO)$/SynchronizedObject.obj \
+	$(SLO)$/TestResult.obj \
+	$(SLO)$/TestResultCollector.obj \
+	$(SLO)$/TestSucessListener.obj \
+	$(SLO)$/emacsTestResult.obj \
+	$(SLO)$/log.obj \
+	$(SLO)$/optionhelper.obj \
+	$(SLO)$/outputter.obj \
+	$(SLO)$/signal.obj \
+	$(SLO)$/testshlTestResult.obj \
+	$(SLO)$/treswrapper.obj 
+
+# currently unused
+# 	$(SLO)$/TextTestResult.obj
+
+LIB1TARGET= $(LB)$/$(TARGET).lib
+LIB1OBJFILES=  $(SLOFILES)
+
+.IF "$(GUI)"=="WNT" 
+.IF "$(COM)"=="GCC"
+LIB1ARCHIV=$(LB)$/lib$(TARGET)$(DLLPOSTFIX).a
+.ENDIF
+.ENDIF
+
+.IF "$(GUI)" == "UNX"
+LIB1ARCHIV=$(LB)$/lib$(TARGET)$(DLLPOSTFIX).a
+.ENDIF
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
Nur in misc/build/cppunit-1.8.0/src/result: makefile.mk.dummy.
--- misc/cppunit-1.8.0/src/result/optionhelper.cxx	2008-12-10 20:46:09.615952197 +0100
+++ misc/build/cppunit-1.8.0/src/result/optionhelper.cxx	2008-12-09 09:06:14.000000000 +0100
@@ -1 +1,317 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+// #include "precompiled_cppunit.hxx"
+
+#include "cppunit/result/optionhelper.hxx"
+// #include <sstream>
+// #include <string>
+#include <osl/time.h>
+#include "cppunit/cmdlinebits.hxx"
+
+// -----------------------------------------------------------------------------
+
+namespace 
+{
+    void split( const rtl::OString& opt,
+                const rtl::OString& _sSeparator,
+                OStringList& optLine )
+    {
+        optLine.clear();
+        // const sal_Int32 cSetLen = cSet.getLength();
+        sal_Int32 index = 0;
+        sal_Int32 oldIndex = 0;
+                
+        // sal_Int32 i;
+        // sal_Int32 j = 0;
+        while ( opt.getLength() > 0)
+        {
+            // for ( i = 0; i < cSetLen; i++ ) 
+            // {
+            index = opt.indexOf( _sSeparator, oldIndex);
+            if( index != -1 ) 
+            {
+                optLine.push_back( opt.copy( oldIndex, index - oldIndex ) );
+                oldIndex = index + _sSeparator.getLength();
+            }
+            // }
+            else // if (index == -1)
+            {
+                optLine.push_back( opt.copy( oldIndex ) );
+                break;
+            }
+        }
+    } ///< split
+        
+    bool match(OStringList const& _aFilter, OStringList const& _aName)
+    {
+        OStringList::const_iterator aFilterIter = _aFilter.begin();
+        OStringList::const_iterator aValueIter = _aName.begin();
+                
+        bool bMatch = false;
+                
+        while (aFilterIter != _aFilter.end() && aValueIter != _aName.end())
+        {
+            rtl::OString sFilter = *aFilterIter;
+            rtl::OString sName   = *aValueIter;
+                        
+            if (sFilter == sName)
+            {
+                bMatch = true;
+                ++aFilterIter;
+                ++aValueIter;
+            }
+            else if (sFilter == "*")
+            {
+                bMatch = true;
+                break;
+            }
+            else
+            {
+                // Filter does not match
+                bMatch = false;
+                break;
+            }
+        }
+        return bMatch;
+    }
+}
+
+/* static */
+std::string OptionHelper::integerToAscii(sal_Int32 nValue)
+{
+    sal_Char cBuf[30];
+    sal_Char *pBuf = cBuf;
+    sprintf(pBuf, "%d", static_cast<int>(nValue));
+//#     std::ostringstream sBuf;
+//#     sBuf << nValue;
+//    rtl::OString sStr;
+//    sStr = rtl::OString::valueOf(nValue);
+    return std::string(pBuf);
+}
+
+/* static */
+// if a given String is less then 2 char, add a "0" in front.
+std::string OptionHelper::twoDigits(std::string const& _sValue)
+{
+    std::string sBack;
+    if (_sValue.length() == 0)
+    {
+        sBack = "00";
+    }
+    else if (_sValue.length() == 1)
+    {
+        sBack = "0";
+        sBack += _sValue;
+    }
+    else
+    {
+        sBack = _sValue;
+    }
+    return sBack;
+}
+
+
+std::string OptionHelper::createDateTag(std::string const& _sProjectId, std::string const& _sBuildId)
+{
+    TimeValue tmv_system;
+    TimeValue tmv_local;
+    oslDateTime dt;
+    osl_getSystemTime( &tmv_system );
+    osl_getLocalTimeFromSystemTime(&tmv_system, &tmv_local);
+    osl_getDateTimeFromTimeValue( &tmv_local, &dt );
+
+    sal_Int32 nYear = dt.Year;
+    sal_Int32 nMonth = dt.Month;
+    sal_Int32 nDay = dt.Day;
+
+    std::string sDate;
+    sDate = "# Current Time: ";
+    sDate += std::string(twoDigits(integerToAscii(dt.Hours)));
+    sDate += ":";
+    sDate += std::string(twoDigits(integerToAscii(dt.Minutes)));
+    sDate += ":";
+    sDate += std::string(twoDigits(integerToAscii(dt.Seconds)));
+    sDate += "\n";
+
+    sDate += "[";
+
+    // sDate += rtl::OString::valueOf(nYear);
+    sDate.append(integerToAscii(nYear));
+    sDate += ".";
+    if (nMonth < 10)
+        sDate += "0";
+    // sDate += rtl::OString::valueOf(nMonth);
+    sDate.append(integerToAscii(nMonth));
+    sDate += ".";
+    if (nDay < 10)
+        sDate += "0";
+    // sDate += rtl::OString::valueOf(nDay);
+    sDate += std::string(integerToAscii(nDay));
+    sDate += "/";
+    sDate += _sProjectId;
+    sDate += "/";
+    sDate += _sBuildId;
+    sDate += "]";
+
+    return sDate;
+}
+
+//# rtl::OString createDateTag()
+//# {
+//#     TimeValue tmv;
+//#     oslDateTime dt;
+//#     osl_getSystemTime( &tmv );
+//#     osl_getDateTimeFromTimeValue( &tmv, &dt );
+//# 
+//#     sal_Int32 nYear = dt.Year;
+//#     sal_Int32 nMonth = dt.Month;
+//#     sal_Int32 nDay = dt.Day;
+//# 
+//#     rtl::OString sDate("[");
+//#     sDate += rtl::OString::valueOf(nYear);
+//#     sDate += ".";
+//#     if (nMonth < 10)
+//#             sDate += "0";
+//#     sDate += rtl::OString::valueOf(nMonth);
+//#     sDate += ".";
+//#     if (nDay < 10)
+//#             sDate += "0";
+//#     sDate += rtl::OString::valueOf(nDay);
+//#     sDate += "//]";
+//# 
+//#     return sDate;
+//# }
+
+std::string OptionHelper::createDateTag()
+{
+    return createDateTag(m_sProjectId, m_sBuildId);
+}
+
+bool OptionHelper::showErrors()
+{
+    bool bRetValue = true; // default, show all
+    if (m_aOption.hasOpt("-noerrors"))
+    {
+        bRetValue = false;
+    }
+    return bRetValue;
+}
+
+bool OptionHelper::showTests()
+{
+    bool bRetValue = true; // default, show all
+    if (m_aOption.hasOpt("-onlyerrors"))
+    {
+        bRetValue = false;
+    }
+    return bRetValue;
+}
+
+// Check which parameter is given for handle the jobs.
+// If no parameter is given, all jobs (tests) will run through
+void OptionHelper::handleJobs()
+{
+    // load job file, the file contains the functions which we only want to test.
+    if (m_aOption.hasOpt("-jobexclude"))
+    {
+        rtl::OString sJobFile = m_aOption.getOpt("-jobexclude");        
+        m_aJobExcludeList.readfile(sJobFile.getStr(), JOB_EXCLUDE_LIST);
+    }
+    
+    if (m_aOption.hasOpt("-jobonly"))
+    {
+        rtl::OString sJobFile = m_aOption.getOpt("-jobonly");
+        m_aJobOnlyList.readfile(sJobFile.getStr(), JOB_ONLY_LIST);
+    }
+
+    // 
+    if (m_aOption.hasOpt("-jobfilter"))
+    {
+        rtl::OString sJobFilter = m_aOption.getOpt("-jobfilter");
+        split(sJobFilter, ".", m_aJobFilter);
+    }
+}
+
+// -----------------------------------------------------------------------------
+// Here will be decide, if a job/test will execute or not.
+// therefore exist some lists, in which stay all jobs (positive list) or a list (negative list) which jobs should not execute
+// or if only specific jobs should execute by a given filter
+
+bool OptionHelper::isAllowedToExecute(std::string const& _sNodeName, std::string const& _sName)
+{
+    std::string sJobName = _sNodeName + "." + _sName;
+    // t_print(T_VERBOSE, "Jobname %s\n", sJobName.c_str());
+    if (isOnlyShowJobs())                        // true, if parameter -onlyshowjob
+    {
+        m_aJobOnlyList.setJobListEntry(sJobName, JOB_ACCESS);
+        return false;
+    }
+    
+    if (m_aJobOnlyList.size())                   // >0 if parameter -jobonly
+    {
+        if (m_aJobOnlyList.getJobListEntry(sJobName) != JOB_NOT_FOUND)
+        {
+            // job entry found, mark as accessed
+            m_aJobOnlyList.setJobListEntry(sJobName, JOB_ACCESS);
+            return true;
+        }
+        return false;
+    }
+    else if (m_aJobFilter.size() > 0)            // >0 if parameter -jobfilter
+    {
+        OStringList aSplitName;
+        split(sJobName.c_str(), ".", aSplitName);
+        if (! match(m_aJobFilter, aSplitName))
+        {
+            t_print(T_VERBOSE, "job: '%s' filtered by [-jobfilter]\n", sJobName.c_str());
+            return false;
+        }
+    }
+    else if (m_aJobExcludeList.size() > 0)       // >0 if parameter -jobexclude
+    {
+        if (m_aJobExcludeList.getJobListEntry(sJobName) != JOB_NOT_FOUND)
+        {
+            // job entry found, this job should not executed, so return false
+            t_print(T_VERBOSE, "job: '%s' filtered by [-jobexclude]\n", sJobName.c_str());
+            return false;
+        }
+        // m_aJobOnlyList.setJobListEntry(sJobName, JOB_ACCESS);
+        return true;
+    }
+    else
+    {
+        //! not handled yet
+    }
+        
+    return true;
+}
+
Nur in misc/build/cppunit-1.8.0/src/result: optionhelper.cxx.dummy.
--- misc/cppunit-1.8.0/src/result/outputter.cxx	2008-12-10 20:46:09.657356434 +0100
+++ misc/build/cppunit-1.8.0/src/result/outputter.cxx	2008-12-09 09:06:18.000000000 +0100
@@ -1 +1,106 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+// #include "precompiled_cppunit.hxx"
+
+//
+#include <string>
+#include <sal/types.h>
+#include "cppunit/result/outputter.hxx"
+
+// -----------------------------------------------------------------------------
+
+Outputter::~Outputter()
+{
+    // delete m_pLog;
+}
+
+void Outputter::writeToAll(const sal_Char* _sCharStr)
+{
+    // std::cout << _sCharStr;
+    if (m_pStream)
+    {
+        *m_pStream << _sCharStr;
+    }
+    if (m_pLog.get())
+    {
+        m_pLog->write(_sCharStr);
+    }
+}
+
+void Outputter::write(const sal_Char* _sCharStr)
+{
+    writeToAll(_sCharStr);
+}
+
+void Outputter::write(std::string const& _sStr)
+{
+    writeToAll(_sStr.c_str());
+}
+
+void Outputter::write(sal_Int32 _nValue)
+{
+    sal_Char cBuf[20];
+    sal_Char* pBuf = cBuf;
+    sprintf(pBuf, "%d", SAL_STATIC_CAST(int, _nValue));
+    writeToAll(pBuf);
+}
+
+// -----------------------------------------------------------------------------
+
+Outputter& operator <<( Outputter &_aStreamWrapper, const sal_Char* _sValue)
+{
+    _aStreamWrapper.write(_sValue);
+    return _aStreamWrapper;
+}
+
+Outputter& operator <<( Outputter &_aStreamWrapper, std::string const& _sValue)
+{
+    _aStreamWrapper.write(_sValue);
+    return _aStreamWrapper;
+}
+
+Outputter& operator <<( Outputter &_aStreamWrapper, sal_Int32 _nValue)
+{
+    _aStreamWrapper.write(_nValue);
+    return _aStreamWrapper;
+}
+
+//# Outputter& operator <<( Outputter &_aStreamWrapper, double )
+//# {
+//#     return _aStreamWrapper;
+//# }
+
+Outputter& operator <<( Outputter &_aStreamWrapper, Outputter::endl const&)
+{
+    _aStreamWrapper.write("\n");
+    return _aStreamWrapper;
+}
Nur in misc/build/cppunit-1.8.0/src/result: outputter.cxx.dummy.
--- misc/cppunit-1.8.0/src/result/signal.cxx	2008-12-10 20:46:09.750401577 +0100
+++ misc/build/cppunit-1.8.0/src/result/signal.cxx	2008-12-10 20:42:46.000000000 +0100
@@ -1 +1,998 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+// #include "precompiled_cppunit.hxx"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#if (defined UNX) || (defined OS2)
+#include <signal.h>
+#include <errno.h>
+#endif
+
+#include <fstream>
+#include <vector>
+#include <hash_map>
+
+#include <rtl/tres.h>
+#include <rtl/string.hxx>
+
+#include "testshl/autoregisterhelper.hxx"
+#include "testshl/getopt.hxx"
+#include "signal.hxx"
+#include <cppunit/tagvalues.hxx>
+#include <unistd.h>
+#include "testshl/filehelper.hxx"
+#include <cppunit/result/TestResult.h>
+#include "cppunit/signaltest.h"
+#include "cppunit/Exception.h"
+
+#ifdef WNT
+#include "testshl/winstuff.hxx"
+#endif
+
+// typedef std::vector<std::string> StringList;
+// StringList sCurrentNodeName;
+CppUnit::TestResult *pTestResult = NULL;
+std::string sSignalFile;
+
+typedef	std::hash_map< std::string, int > HashMap;
+HashMap m_aSignalHash;
+bool bSignalsCached = false;
+bool bDoNotTouchSignalFile = false;
+
+// -----------------------------------------------------------------------------
+
+// return 'true' if signalfile doesn't exist.
+// else 'false'
+bool existsSignalFile(std::string const& _sSignalFilename)
+{
+    FILE* pFile = fopen(_sSignalFilename.c_str(), "r");
+    if (!pFile)
+    {
+        return false;
+    }
+    fprintf(stderr, "'%s' exists.\n", _sSignalFilename.c_str());
+    fclose(pFile);
+    return true;
+}
+
+// -----------------------------------------------------------------------------
+void createEmptySignalFile(std::string const& _sSignalFilename)
+{
+    FILE* pFile = fopen(_sSignalFilename.c_str(), "w");
+    if (!pFile)
+    {
+        fprintf(stderr, "error: Could not create signal helper file %s for signal info.\n", _sSignalFilename.c_str());
+    }
+    else
+    {
+        fprintf(pFile, "# This is an auto generated helper file for signal handling.\n");
+        fprintf(pFile, "# An entry start by '#' is a comment.\n");
+        fprintf(pFile, "# All other are test functions which have abort, before this line is removed.\n");
+        fprintf(pFile, "# So you have to check this functions by hand.\n");
+        
+        fclose(pFile);
+    }
+}
+
+// -----------------------------------------------------------------------------
+/** get Current PID.
+*/
+inline ::rtl::OUString getCurrentPID(  )
+{
+        //~ Get current PID and turn it into OUString;
+        sal_uInt32 nPID = 0;
+#ifdef WNT
+        nPID = WinGetCurrentProcessId();
+#else
+        nPID = getpid();
+#endif
+        return ( ::rtl::OUString::valueOf( static_cast<long>(nPID ) ) );
+}
+// -----------------------------------------------------------------------------
+static std::string integerToAscii(sal_uInt32 nValue)
+{
+    sal_Char cBuf[30];
+    sal_Char *pBuf = cBuf;
+    sprintf(pBuf, "%d", static_cast<unsigned int>(nValue));
+    return std::string(pBuf);
+}
+void my_sleep(int sec);
+
+// -----------------------------------------------------------------------------
+void setSignalFilename(GetOpt & opt)
+{
+    if (opt.hasOpt("-dntsf") || opt.hasOpt("-donottouchsignalfile"))
+    {
+        // special feature, for debugging, so the signal file will not manipulate.
+        // but create, if no one exist.
+        bDoNotTouchSignalFile = true;
+    }
+    
+    if (opt.hasOpt("-sf") || opt.hasOpt("-signalfile"))
+    {
+        if (opt.hasOpt("-sf"))
+        {
+            sSignalFile = opt.getOpt("-sf");
+        }
+        else if (opt.hasOpt("-signalfile"))
+        {
+            sSignalFile = opt.getOpt("-signalfile");
+        }
+	}
+    else
+    {
+        std::string sPath;
+        // std::string sPath(FileHelper::getTempPath());
+        std::string sFilename("signalfile");
+        std::string sFilenameExt(".txt");
+        bool bCanQuitLoop = true;
+        do
+        {
+            
+// #ifdef WNT
+//         sPath += "\\";
+// #endif
+// #ifdef UNX
+//         sPath += "/";
+// #endif
+            sPath = sFilename;
+            // BUG: i72675
+            // add "_12345" where 12345 is the current process ID
+        
+            TimeValue aTimeValue;
+            osl_getSystemTime(&aTimeValue);
+            
+            sPath += "_";
+            sPath += integerToAscii(aTimeValue.Seconds);
+            // rtl::OUString suPID = getCurrentPID();
+            // rtl::OString sPID = rtl::OUStringToOString(suPID, RTL_TEXTENCODING_ASCII_US);
+            // sPath += sPID.getStr();
+            sPath += sFilenameExt;
+            bCanQuitLoop = true;
+            if (existsSignalFile(sPath))
+            {
+                // there is already a signal file, wait a second, choose an other one.
+                my_sleep(1);
+                bCanQuitLoop = false;
+            }
+        }
+        while (!(bCanQuitLoop));
+
+        sSignalFile = sPath;
+        fprintf(stderr, "Use default signal file name '%s'\n", sSignalFile.c_str());
+    }
+
+    if (opt.hasOpt("-dnrmsf"))
+    {
+        fprintf(stderr, "'Don't remove signal file' (-dnrmsf) is set.\n");
+    }
+    else
+    {
+        if (bDoNotTouchSignalFile == true)
+        {
+            fprintf(stderr, "warning: 'Don't touch signal file' parameter (-dntsf) is set, will not remove existing signal file.\n");
+        }
+        else
+        {
+            // remove signalfile
+            createEmptySignalFile(sSignalFile);
+        }
+    }
+}
+
+// -----------------------------------------------------------------------------
+bool doNotTouchSignalFile() { return bDoNotTouchSignalFile; }
+
+// -----------------------------------------------------------------------------
+std::string buildTestFunctionName(std::string const& _sName)
+{
+    std::string sName;
+    if (pTestResult)
+    {
+        sName = pTestResult->getNodeName();
+        sName += ".";
+    }
+    
+/*
+    for (StringList::const_iterator it = sCurrentNodeName.begin();
+         it != sCurrentNodeName.end();
+         ++it)
+    {
+        sName += *it;
+        sName += ".";
+    }
+*/    
+    sName += _sName;
+
+    return sName;
+}
+// -----------------------------------------------------------------------------
+// old: void executionPushName(std::string const& _sName)
+// old: {
+// old:     sCurrentNodeName.push_back(_sName);
+// old: }
+// old: void executionPopName()
+// old: {
+// old:     sCurrentNodeName.pop_back();
+// old: }
+// old: 
+
+// -----------------------------------------------------------------------------
+// ------------------------------ Signal Handling ------------------------------
+// -----------------------------------------------------------------------------
+
+// std::string sLastTestFunctionName;
+
+std::string getSignalName(sal_Int32 nSignalNo);
+// -----------------------------------------------------------------------------
+
+std::string getSignalFilename()
+{
+    return sSignalFile;
+}
+
+// -----------------------------------------------------------------------------
+// void storeNoSignal(std::string const& _sTestName)
+// {
+    // sLastTestFunctionName = buildTestFunctionName(_sTestName);
+    // std::ofstream out(getSignalFilename().c_str(), std::ios::out);
+    // out << NO_SIGNAL << std::endl;               // no signal!
+// }
+
+void markSignalAsAlreadyDone(sal_Int32 _nSignalNo)
+{
+    // std::ofstream out(getSignalFilename().c_str(), std::ios::out | std::ios::app);
+	FILE *out = fopen(getSignalFilename().c_str(), "a");
+    if (out != NULL)
+    {
+//#         out << "# the previous test function creates signal: " 
+//#             << getSignalName(_nSignalNo) 
+//#             << " (" 
+//#             << _nSignalNo 
+//#             << ")" << std::endl;
+//#         // out << sLastTestFunctionName << std::endl;               // SIGNAL!
+
+		fprintf(out, "# the previous test function creates signal: %s(%d)\n", getSignalName(_nSignalNo).c_str(), SAL_STATIC_CAST(int, _nSignalNo));
+		// fprintf(out, "%s\n", sLastTestFunctionName );
+		fclose(out);
+    }
+    else
+    {
+        fprintf(stderr, "error: Can't write signal info to file %s \n", getSignalFilename().c_str());
+    }
+}
+
+// -----------------------------------------------------------------------------
+
+Signal hasSignaled(std::string const& _sTestName)
+{
+    // BACK:  true: signal
+    //       false: nothing
+
+	if (bSignalsCached == true)
+	{
+
+		if (m_aSignalHash.find(buildTestFunctionName(_sTestName)) != m_aSignalHash.end())
+		{
+			return HAS_SIGNAL;
+		}
+		return NO_SIGNAL;
+	}
+	
+    std::ifstream in(getSignalFilename().c_str(), std::ios::in);
+
+    // std::cout << "Check for signal" << std::endl;
+    std::string sLine, sLastLine;
+    while (std::getline(in, sLine))
+    {
+        // std::cout << sTest << std::endl;
+		char ch = sLine[0];
+		if (isspace(ch) == 0 &&
+			sLine.size() > 0)
+		{
+			if (ch == '#')
+			{
+				if (sLastLine.size() > 0)
+				{
+					rtl::OString aStrLine(sLine.c_str());
+					sal_Int32 nIdx = aStrLine.indexOf("(") + 1;
+					sal_Int32 nIdx2 = aStrLine.indexOf(")");
+					sal_Int32 nSignalNo = 0;
+					if (nIdx > 0 && nIdx2 > 0)
+					{
+						rtl::OString sSignalNo = aStrLine.copy(nIdx, nIdx2 - nIdx);
+						nSignalNo = sSignalNo.toInt32();
+						m_aSignalHash[sLastLine] = nSignalNo;
+					}
+					sLastLine.clear();
+				}
+			}
+			else
+			{
+				// if (sTest == buildTestFunctionName(_sTestName))
+				m_aSignalHash[sLine] = 1;
+				sLastLine = sLine;
+				// return HAS_SIGNAL;
+			}
+		}
+	}
+	
+	bSignalsCached = true;
+	return hasSignaled(_sTestName);
+    // return NO_SIGNAL;
+}
+
+#ifdef UNX
+
+// -----------------------------------------------------------------------------
+
+void release_signal_Handling();
+
+//# void signalFunction(int value)
+//# {
+//#     std::cout << "Signal caught: (" << value << "), please restart." << std::endl;
+//#     markSignalAsAlreadyDone();
+//# 
+//#     release_signal_Handling();
+//#         std::cout.flush();
+//#     abort();
+//# }
+
+// -----------------------------------------------------------------------------
+extern "C" void SignalHandlerFunction(int _nSignalNo, siginfo_t *, void*)
+{
+    // std::cout << "Signal caught: " << getSignalName(_nSignalNo) << " (" << _nSignalNo << "), please restart." << std::endl;
+	fprintf(stderr, "Signal caught %s(%d)\n", getSignalName(_nSignalNo).c_str(), _nSignalNo);
+    markSignalAsAlreadyDone(_nSignalNo);
+
+    release_signal_Handling();
+    // std::cout.flush();
+    abort();
+}
+
+// -----------------------------------------------------------------------------
+// This is a copy of the osl/signal.c code
+#define ACT_IGNORE      1
+#define ACT_ABORT       2
+#define ACT_EXIT        3
+#define ACT_SYSTEM      4
+#define ACT_HIDE        5
+
+extern "C" {
+static struct SignalAction
+{
+    int Signal;
+    int Action;
+    void (*Handler)(int);
+} Signals[] =
+{
+    { SIGHUP,    ACT_IGNORE, NULL },    /* hangup */
+    { SIGINT,    ACT_EXIT,   NULL },    /* interrupt (rubout) */
+    { SIGQUIT,   ACT_ABORT,  NULL },    /* quit (ASCII FS) */
+    { SIGILL,    ACT_SYSTEM,  NULL },    /* illegal instruction (not reset when caught) */
+/* changed from ACT_ABOUT to ACT_SYSTEM to try and get collector to run*/
+    { SIGTRAP,   ACT_ABORT,  NULL },    /* trace trap (not reset when caught) */
+#if ( SIGIOT != SIGABRT )
+    { SIGIOT,    ACT_ABORT,  NULL },    /* IOT instruction */
+#endif 
+//      { SIGABRT,   ACT_ABORT,  NULL },    /* used by abort, replace SIGIOT in the future */
+#ifdef SIGEMT   
+    { SIGEMT,    ACT_SYSTEM,  NULL },    /* EMT instruction */
+/* changed from ACT_ABORT to ACT_SYSTEM to remove handler*/
+/* SIGEMT may also be used by the profiler - so it is probably not a good
+   plan to have the new handler use this signal*/
+#endif  
+    { SIGFPE,    ACT_ABORT,  NULL },    /* floating point exception */
+    { SIGKILL,   ACT_SYSTEM, NULL },    /* kill (cannot be caught or ignored) */
+    { SIGBUS,    ACT_ABORT,  NULL },    /* bus error */
+    { SIGSEGV,   ACT_ABORT,  NULL },    /* segmentation violation */
+#ifdef SIGSYS
+    { SIGSYS,    ACT_ABORT,  NULL },    /* bad argument to system call */
+#endif
+    { SIGPIPE,   ACT_HIDE,   NULL },    /* write on a pipe with no one to read it */
+    { SIGALRM,   ACT_EXIT,   NULL },    /* alarm clock */
+    { SIGTERM,   ACT_EXIT,   NULL },    /* software termination signal from kill */
+    { SIGUSR1,   ACT_SYSTEM, NULL },    /* user defined signal 1 */
+    { SIGUSR2,   ACT_SYSTEM, NULL },    /* user defined signal 2 */
+    { SIGCHLD,   ACT_SYSTEM, NULL },    /* child status change */
+#ifdef SIGPWR
+    { SIGPWR,    ACT_IGNORE, NULL },    /* power-fail restart */
+#endif
+    { SIGWINCH,  ACT_IGNORE, NULL },    /* window size change */
+    { SIGURG,    ACT_EXIT,   NULL },    /* urgent socket condition */
+#ifdef SIGPOLL
+    { SIGPOLL,   ACT_EXIT,   NULL },    /* pollable event occured */
+#endif
+    { SIGSTOP,   ACT_SYSTEM, NULL },    /* stop (cannot be caught or ignored) */
+    { SIGTSTP,   ACT_SYSTEM, NULL },    /* user stop requested from tty */
+    { SIGCONT,   ACT_SYSTEM, NULL },    /* stopped process has been continued */
+    { SIGTTIN,   ACT_SYSTEM, NULL },    /* background tty read attempted */
+    { SIGTTOU,   ACT_SYSTEM, NULL },    /* background tty write attempted */
+    { SIGVTALRM, ACT_EXIT,   NULL },    /* virtual timer expired */
+    { SIGPROF,   ACT_SYSTEM,   NULL },    /* profiling timer expired */
+/*Change from ACT_EXIT to ACT_SYSTEM for SIGPROF is so that profiling signals do
+  not get taken by the new handler - the new handler does not pass on context 
+  information which causes 'collect' to crash. This is a way of avoiding
+  what looks like a bug in the new handler*/
+    { SIGXCPU,   ACT_ABORT,  NULL },    /* exceeded cpu limit */
+    { SIGXFSZ,   ACT_ABORT,  NULL }     /* exceeded file size limit */
+};
+}
+
+const int NoSignals = sizeof(Signals) / sizeof(struct SignalAction);
+
+#endif /* UNX */
+
+// -----------------------------------------------------------------------------
+void init_signal_Handling(CppUnit::TestResult *_pResult)
+{
+    pTestResult = _pResult;
+#ifdef UNX
+  
+//    signal(SIGSEGV, signalFunction);
+    // signal(SIGSEGV, signalFunction);
+    // signal(SIGFPE, signalFunction);
+
+//    signal(1, signalFunction);
+    // struct sigaction action, oldaction;
+    // action.sa_sigaction = signalFunction2;
+    // action.sa_flags     = SA_ONESHOT /* | SA_SIGINFO */;
+
+    struct sigaction act;
+    struct sigaction oact;
+
+    // act.sa_handler = SignalHandlerFunction;
+    act.sa_flags     = SA_RESTART;
+    // act.sa_flags     = SA_ONESHOT /* | SA_SIGINFO */;
+    act.sa_sigaction = SignalHandlerFunction;
+    
+    sigfillset(&(act.sa_mask));
+
+    /* Initialize the rest of the signals */
+    for (int i = 0; i < NoSignals; i++) 
+    {
+        if (Signals[i].Action != ACT_SYSTEM)
+        {
+            if (Signals[i].Action == ACT_HIDE)
+            {
+                struct sigaction ign;
+                
+                ign.sa_handler = SIG_IGN;
+                ign.sa_flags   = 0;
+                sigemptyset(&ign.sa_mask);
+                
+                if (sigaction(Signals[i].Signal, &ign, &oact) == 0)
+                    Signals[i].Handler = oact.sa_handler;
+                else
+                    Signals[i].Handler = SIG_DFL;
+            }
+            else
+                if (sigaction(Signals[i].Signal, &act, &oact) == 0)
+                    Signals[i].Handler = oact.sa_handler;
+                else
+                    Signals[i].Handler = SIG_DFL;
+        }
+    }
+#endif
+
+    // ------------ signal helper file must exist -----------------
+    FILE* pFile = fopen(getSignalFilename().c_str(), "r");
+    if (!pFile)
+    {
+        createEmptySignalFile( getSignalFilename() );
+    }
+    else
+    {
+        fclose(pFile);
+    }    
+}
+
+// -----------------------------------------------------------------------------
+void release_signal_Handling()
+{
+    // frees all signals
+#ifdef UNX
+	int i;
+	struct sigaction act;
+
+	act.sa_flags   = 0;
+	sigemptyset(&(act.sa_mask));
+
+	/* Initialize the rest of the signals */
+	for (i = NoSignals - 1; i >= 0; i--)
+	{
+		if (Signals[i].Action != ACT_SYSTEM)
+		{
+			act.sa_handler = Signals[i].Handler;
+			
+			sigaction(Signals[i].Signal, &act, NULL);
+		}
+	}
+#endif
+}
+
+// -----------------------------------------------------------------------------
+Signal signalCheck(CppUnit::TestResult* _pResult, std::string const& _sTestName)
+{
+    // BACK: HAS_SIGNAL: the test has already done and signaled
+    if (hasSignaled(_sTestName) == HAS_SIGNAL)
+    {
+        // std::cout << "The Test '" << buildTestFunctionName(_sTestName) << "' is marked as signaled." << std::endl;
+        std::string sTestFunctionName = buildTestFunctionName(_sTestName);
+		fprintf(stderr, "The Test '%s' is marked as signaled.\n", sTestFunctionName.c_str());
+		if (_pResult)
+		{
+			CppUnit::SignalTest *pTest = new CppUnit::SignalTest(_sTestName);
+			
+			std::string sErrorText = "Function is marked as signaled: ";
+			sal_Int32 nSignalNo = m_aSignalHash[sTestFunctionName];
+			sErrorText += getSignalName(nSignalNo);
+			sErrorText += " (";
+			sErrorText += OptionHelper::integerToAscii(nSignalNo);
+			sErrorText += ")";
+			
+			_pResult->addError(pTest, new CppUnit::SignalException(sErrorText), ErrorType::ET_SIGNAL);
+		}
+        return HAS_SIGNAL;
+    }
+    
+    // storeNoSignal(_sTestName);
+    return NO_SIGNAL;
+}
+
+// -----------------------------------------------------------------------------
+bool copyFile(std::string const& _sFrom, std::string const& _sTo)
+{
+    bool bRetValue = false;
+	const int MAXBUFSIZE = 1024;
+	char buff[MAXBUFSIZE];
+	FILE *in = fopen(_sFrom.c_str(), "r");
+    if (in == NULL)
+    {
+        fprintf(stderr, "error: Can't open file %s for read to copy.\n", _sFrom.c_str());
+        bRetValue = false;
+    }
+    else
+    {
+		FILE *out = fopen(_sTo.c_str(), "w");
+		if (out == NULL)
+		{
+			fclose(in);
+			fprintf(stderr, "error: Can't open file %s for write to copy.\n", _sTo.c_str());
+			bRetValue = false;
+		}
+        else
+		{
+			int nRealGot = 0;
+			while(!feof(in))
+			{
+				nRealGot = fread(buff, sizeof(char), MAXBUFSIZE, in);
+				if (nRealGot > 0)
+				{
+					fwrite(buff, sizeof(char), nRealGot, out);
+				}
+			}
+			bRetValue = true;
+			fclose(out);
+			fclose(in);
+		}
+	}
+    return bRetValue;
+}
+
+// -----------------------------------------------------------------------------
+void signalStartTest(std::string const& _sName)
+{
+    if (doNotTouchSignalFile()) return;
+
+    // fprintf(stderr, "### signalStartTest!\n");
+    // due to the fact, that functions are vicious, we write the name first.
+    // if it isn't vivious, than we removed it.
+    std::string sNewName = getSignalFilename();
+    sNewName += ".bak";
+    if (copyFile(getSignalFilename(), sNewName))
+    {
+        // std::ofstream out(getSignalFilename().c_str(), std::ios::out | std::ios::app);
+		FILE *out = fopen(getSignalFilename().c_str(), "a");
+        if (out != NULL)
+        {
+            // out << buildTestFunctionName(_sName) << std::endl;
+			fprintf(out, "%s\n", buildTestFunctionName(_sName).c_str());
+			fclose(out);
+        }
+		else
+        {
+			fprintf(stderr, "error: Can't open file %s for append.\n", getSignalFilename().c_str());
+		}
+    }
+    else
+    {
+		fprintf(stderr, "error: Can't copy signal helper from file %s to file %s, %d\n", getSignalFilename().c_str(), sNewName.c_str(), errno);
+    }
+}
+
+// -----------------------------------------------------------------------------
+void signalEndTest()
+{
+    if (doNotTouchSignalFile()) return;
+
+    // fprintf(stderr, "### signalEndTest!\n");
+    if (0 != remove(getSignalFilename().c_str()))
+    {
+        fprintf(stderr, "error: Can't delete file %s\n", getSignalFilename().c_str());
+    }
+    else
+    {
+        std::string sNewName = getSignalFilename();
+        sNewName += ".bak";
+        if (0 != rename(sNewName.c_str(), getSignalFilename().c_str()))
+        {
+            fprintf(stderr, "error: Can't rename file %s to file %s errno: %d\n", sNewName.c_str(), getSignalFilename().c_str(), errno);
+        }
+    }
+}
+
+// -----------------------------------------------------------------------------
+void removeSignalFile(GetOpt & opt)
+{
+    // fprintf(stderr, "### remove signal file: '%s'\n", sSignalFile.c_str());
+    if (opt.hasOpt("-dnrmsf"))
+    {
+        return;
+    }
+    if (bDoNotTouchSignalFile == true)
+    {
+        return;
+    }
+    remove(getSignalFilename().c_str());
+}
+
+// -----------------------------------------------------------------------------
+
+sal_Int32 SignalHandlerA( TagHelper const& _aTagItems )
+{
+    sal_Int32 nRetValue = 0;
+    TagData nTagType     = _aTagItems.GetTagData(TAG_TYPE, 0);
+// LLA: unused 
+//    hTestResult hResult  = (hTestResult) _aTagItems.GetTagData(TAG_RESULT_PTR, 0 /* NULL */ );
+//    CppUnit::TestResult* pResult = (CppUnit::TestResult*)hResult;
+    
+    try
+    {
+        switch(nTagType)
+        {
+        // old: case SIGNAL_PUSH_NAME:
+        // old: {
+        // old: 	const char* sName = (const char*) _aTagItems.GetTagData(TAG_NODENAME);
+        // old: 	if (sName != NULL)
+        // old: 		signalPushName(sName);
+        // old: 	break;
+        // old: }
+        // old: 		
+        // old: case SIGNAL_POP_NAME:
+        // old: 	signalPopName();
+        // old: 	break;
+                        
+        // old: case SIGNAL_CHECK:
+        // old: {
+        // old:     const char* sName = (const char*) _aTagItems.GetTagData(TAG_NODENAME);
+        // old:     if (sName != NULL)
+        // old:     {
+        // old:         nRetValue = signalCheck(sName);
+        // old:     }
+        // old:     break;
+        // old: }
+
+        // old: case INIT_SIGNAL_HANDLING:
+        // old:     init_signal_Handling();
+        // old:     break;
+        // old: 
+        // old: case RELEASE_SIGNAL_HANDLING:
+        // old:     release_signal_Handling();
+        // old:     break;
+
+        case SIGNAL_START_TEST:
+        {
+            // fprintf(stderr, "### SIGNAL_START_TEST!\n");
+            const char* sName = (const char*) _aTagItems.GetTagData(TAG_NODENAME);
+            if (sName != NULL)
+            {
+                signalStartTest(sName);
+            }
+            break;
+        }
+                
+        case SIGNAL_END_TEST:
+        {
+            // fprintf(stderr, "### SIGNAL_END_TEST!\n");
+            const char* sName = (const char*) _aTagItems.GetTagData(TAG_NODENAME);
+            if (sName != NULL)
+            {
+                signalEndTest();
+            }
+            break;
+        }
+                
+        default:
+            fprintf(stderr, "error: SignalHandlerA: Can't handle the tag type %d\n", SAL_STATIC_CAST(int, nTagType));
+            fflush(stderr);
+            // throw std::exception(/*std::string("Unknown TYPE_TAG Exception.")*/);
+        }
+    }
+    catch (std::exception &e)
+    {
+        fprintf(stderr, "error: SignalHandlerA: Exception caught: %s\n", e.what());
+        fflush(stderr);
+        // throw e;
+    }
+        
+    return nRetValue;
+}
+// -----------------------------------------------------------------------------
+// This a little bit more abstract code, could be easier to modify or expand.
+ 
+sal_Int32 CheckExecution(CppUnit::TestResult* _pResult, std::string const& _sName)
+{
+    // more checks in the corresponding job lists
+	if (_pResult)
+	{
+		if (! _pResult->isAllowedToExecute(_sName))
+		{
+			return DO_NOT_EXECUTE;
+		}
+	}
+
+    // Check if the given test should be executed.
+    if (signalCheck(_pResult, _sName) == HAS_SIGNAL)
+    {
+        return DO_NOT_EXECUTE;
+    }
+    
+    return GO_EXECUTE;
+}
+
+// -----------------------------------------------------------------------------
+sal_Int32 ExecutionA( TagHelper const& _aTagItems )
+{
+    sal_Int32 nRetValue = 0;
+    TagData nTagType     = _aTagItems.GetTagData(TAG_TYPE, 0);
+    hTestResult hResult  = (hTestResult) _aTagItems.GetTagData(TAG_RESULT_PTR, 0 /* NULL */ );
+    CppUnit::TestResult* pResult = (CppUnit::TestResult*)hResult;
+
+    try
+    {
+        switch(nTagType)
+        {
+        case EXECUTION_CHECK:
+        {
+            const char* sName = (const char*) _aTagItems.GetTagData(TAG_NODENAME);
+            if (sName)
+            {
+                nRetValue = CheckExecution(pResult, sName);
+                if (nRetValue == GO_EXECUTE)
+                {
+                    if (pResult && pResult->isOptionWhereAmI())
+                    {
+                        printf("# This is: %s\n", buildTestFunctionName(sName).c_str());
+                    }
+                }
+            }
+  
+            break;
+        }
+                
+        // old: case EXECUTION_PUSH_NAME:
+        // old: {
+        // old:     const char* sName = (const char*) _aTagItems.GetTagData(TAG_NODENAME);
+        // old:     if (sName != NULL)
+        // old:         executionPushName(sName);
+        // old:     break;
+        // old: }
+        // old: 
+        // old: case EXECUTION_POP_NAME:
+        // old:     executionPopName();
+        // old:     break;
+
+        case INIT_TEST:
+            init_signal_Handling(pResult);
+            break;
+        
+        case RELEASE_TEST:
+            release_signal_Handling();
+            break;
+
+        default:
+            fprintf(stderr, "ExceptionA: Can't handle the tag type %d\n", SAL_STATIC_CAST(int, nTagType));
+            break;
+        }
+    }
+    catch (std::exception &e)
+    {
+        fprintf(stderr, "ExecutionA: exception caught: %s\n", e.what());
+        fflush(stderr);
+        // throw e;
+    }
+    return nRetValue;
+}
+
+// -----------------------------------------------------------------------------
+std::string getSignalName(sal_Int32 nSignalNo)
+{
+    std::string sValue;
+#ifdef UNX
+    switch(nSignalNo)
+    {
+    case SIGHUP:
+        sValue = "SIGHUP";
+        break;
+
+    case SIGINT:
+        sValue = "SIGINT";
+        break;
+
+    case SIGQUIT:
+        sValue = "SIGQUIT";
+        break;
+
+    case SIGILL:
+        sValue = "SIGILL";
+        break;
+
+    case SIGTRAP:
+        sValue = "SIGTRAP";
+        break;
+
+#if ( SIGIOT != SIGABRT )
+    case SIGIOT:
+        sValue = "SIGIOT";
+        break;
+#endif 
+//      case SIGABRT:
+#ifdef SIGEMT   
+    case SIGEMT:
+        sValue = "SIGEMT";
+        break;
+#endif  
+    case SIGFPE:
+        sValue = "SIGFPE";
+        break;
+
+    case SIGKILL:
+        sValue = "SIGKILL";
+        break;
+
+    case SIGBUS:
+        sValue = "SIGBUS";
+        break;
+
+    case SIGSEGV:
+        sValue = "SIGSEGV";
+        break;
+
+#ifdef SIGSYS
+    case SIGSYS:
+        sValue = "SIGSYS";
+        break;
+#endif
+    case SIGPIPE:
+        sValue = "SIGPIPE";
+        break;
+
+    case SIGALRM:
+        sValue = "SIGALRM";
+        break;
+
+    case SIGTERM:
+        sValue = "SIGTERM";
+        break;
+
+    case SIGUSR1:
+        sValue = "SIGUSR1";
+        break;
+
+    case SIGUSR2:
+        sValue = "SIGUSR2";
+        break;
+
+    case SIGCHLD:
+        sValue = "SIGCHLD";
+        break;
+
+#ifdef SIGPWR
+    case SIGPWR:
+        sValue = "SIGPWR";
+        break;
+#endif
+    case SIGWINCH:
+        sValue = "SIGWINCH";
+        break;
+
+    case SIGURG:
+        sValue = "SIGURG";
+        break;
+
+#ifdef SIGPOLL
+    case SIGPOLL:
+        sValue = "SIGPOLL";
+        break;
+#endif
+    case SIGSTOP:
+        sValue = "SIGSTOP";
+        break;
+
+    case SIGTSTP:
+        sValue = "SIGTSTP";
+        break;
+
+    case SIGCONT:
+        sValue = "SIGCONT";
+        break;
+
+    case SIGTTIN:
+        sValue = "SIGTTIN";
+        break;
+
+    case SIGTTOU:
+        sValue = "SIGTTOU";
+        break;
+
+    case SIGVTALRM:
+        sValue = "SIGVTALRM";
+        break;
+
+    case SIGPROF:
+        sValue = "SIGPROF";
+        break;
+
+    case SIGXCPU:
+        sValue = "SIGXCPU";
+        break;
+
+    case SIGXFSZ:
+        sValue = "SIGXFSZ";
+        break;
+
+    default:
+        sValue = "Unhandled Signal.";
+    }
+#else
+    (void) nSignalNo; // unused
+#endif
+    return sValue;
+}
+
+// The following sets variables for GNU EMACS
+// Local Variables:
+// tab-width:4
+// End:
Nur in misc/build/cppunit-1.8.0/src/result: signal.cxx.dummy.
--- misc/cppunit-1.8.0/src/result/signal.hxx	2008-12-10 20:46:09.813916116 +0100
+++ misc/build/cppunit-1.8.0/src/result/signal.hxx	2008-07-07 08:14:56.000000000 +0200
@@ -1 +1,42 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SIGNAL_HXX
+#define SIGNAL_HXX
+
+#include <sal/types.h>
+
+#define HAS_SIGNAL 1
+#define NO_SIGNAL  0
+
+typedef sal_Int32 Signal;
+
+#endif
+
Nur in misc/build/cppunit-1.8.0/src/result: signal.hxx.dummy.
--- misc/cppunit-1.8.0/src/result/testshlTestResult.cxx	2008-12-10 20:46:09.880238139 +0100
+++ misc/build/cppunit-1.8.0/src/result/testshlTestResult.cxx	2008-12-09 09:06:11.000000000 +0100
@@ -1 +1,428 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+// #include "precompiled_cppunit.hxx"
+
+#include <stdlib.h>
+
+#include <map>
+#include <cppunit/Exception.h>
+#include <cppunit/NotEqualException.h>
+#include <cppunit/Test.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/result/testshlTestResult.h>
+// #include <TextTestResult.h>
+//!io #include <iostream>
+#include <string>
+
+#include <rtl/string.hxx>
+#include "cppunit/result/outputter.hxx"
+
+namespace CppUnit {
+
+    testshlTestResult::testshlTestResult(GetOpt & _aOptions)
+            :TestResult(_aOptions),
+			 m_aOptions(_aOptions),
+             // m_aOptionHelper(_aOptions),
+             m_aResulter(this)
+    {
+        addListener( &m_aResulter );
+    }
+
+    testshlTestResult::~testshlTestResult()
+    {
+    }
+    
+//# void 
+//# testshlTestResult::addFailure( const TestFailure &failure )
+//# {
+//# 	// TestResultCollector::addFailure( failure );
+//# 	// std::cerr << ( failure.isError() ? "E" : "F" );
+//# 	m_aResulter.addFailure(failure);
+//# }
+//# 
+//# 
+//# void 
+//# testshlTestResult::startTest( Test *test )
+//# {
+//# 	// TestResultCollector::startTest (test);
+//# 	m_aResulter.startTest(test);
+//# 	// std::cerr << ".";
+//# }
+//# 
+//# void testshlTestResult::endTest( Test *test )
+//# {
+//# }
+
+// -----------------------------------------------------------------------------
+
+//# void 
+//# testshlTestResult::printFailures( Outputter &stream )
+//# {
+//#   TestFailures::const_iterator itFailure = failures().begin();
+//#   int failureNumber = 1;
+//#   while ( itFailure != failures().end() ) 
+//#   {
+//# 	  stream  <<  std::endl;
+//# 	  printFailure( *itFailure++, failureNumber++, stream );
+//#   }
+//# }
+//# 
+//# 
+//# void 
+//# testshlTestResult::printFailure( TestFailure *failure,
+//# 							  int failureNumber,
+//# 							  std::ostream &stream )
+//# {
+//#   printFailureListMark( failureNumber, stream );
+//#   stream << ' ';
+//#   printFailureTestName( failure, stream );
+//#   stream << ' ';
+//#   printFailureType( failure, stream );
+//#   stream << ' ';
+//#   printFailureLocation( failure->sourceLine(), stream );
+//#   stream << std::endl;
+//#   printFailureDetail( failure->thrownException(), stream );
+//#   stream << std::endl;
+//# }
+//# 
+//# 
+//# void 
+//# testshlTestResult::printFailureListMark( int failureNumber,
+//# 									  std::ostream &stream )
+//# {
+//# 	stream << failureNumber << ")";
+//# }
+//# 
+//# 
+//# void 
+//# testshlTestResult::printFailureTestName( TestFailure *failure,
+//# 									  std::ostream &stream )
+//# {
+//# 	Test* pTest = failure->failedTest();
+//# 	stream << "test: " << pTest->getName();
+//# }
+//# 
+//# 
+//# void 
+//# testshlTestResult::printFailureType( TestFailure *failure,
+//# 								  std::ostream &stream )
+//# {
+//# 	stream << "("
+//# 		 << (failure->isError() ? "E" : "F")
+//# 		 << ")";
+//# }
+//# 
+//# 
+//# void 
+//# testshlTestResult::printFailureLocation( SourceLine sourceLine,
+//# 									  std::ostream &stream )
+//# {
+//# 	if ( !sourceLine.isValid() )
+//# 		return;
+//# 	
+//# 	stream << "line: " << sourceLine.lineNumber()
+//# 		   << ' ' << sourceLine.fileName();
+//# }
+//# 
+//# 
+//# void 
+//# testshlTestResult::printFailureDetail( Exception *thrownException,
+//# 									std::ostream &stream )
+//# {
+//# 	if ( thrownException->isInstanceOf( NotEqualException::type() ) )
+//# 	{
+//# 		NotEqualException *e = (NotEqualException*)thrownException;
+//# 		stream << "expected: " << e->expectedValue() << std::endl
+//# 			   << "but was:  " << e->actualValue();
+//# 		if ( !e->additionalMessage().empty() )
+//# 		{
+//# 			stream  << std::endl;
+//# 			stream  <<  "additional message:"  <<  std::endl
+//# 					<<  e->additionalMessage();
+//# 		}
+//# 	}
+//# 	else
+//# 	{
+//# 		stream << " \"" << thrownException->what() << "\"";
+//# 	}
+//# }
+
+
+// LLA: output format:
+// Header
+// # -- BEGIN
+// Error lines
+// No error lines
+// unknown lines
+// # -- END
+// Text 'Test #PASSED#' or 'Errors only'
+
+void 
+testshlTestResult::print( Outputter& stream ) 
+{
+    printHeader( stream );
+    // stream << std::endl;
+    // printFailures( stream );
+    
+    bool bPassed = false;
+	if (isOnlyShowJobs())
+	{
+        JobList jl(m_aOptionHelper.getJobOnlyList());
+		HashMap aJobList = jl.getHashMap();
+		printLines(stream, aJobList);
+	}
+	else
+	{
+        stream << "# -- BEGIN:" << Outputter::endl();
+
+		TestPtrList aFailedTests;
+    
+		// List of failures
+		printFailedTests(stream, aFailedTests);
+	
+		if (! m_aOptionHelper.getOptions().hasOpt("-onlyerrors"))
+		{
+		// List of well done tests
+		printTestLines(stream, aFailedTests);
+
+		// List of unknown Tests
+        JobList jl(m_aOptionHelper.getJobOnlyList());
+		HashMap aJobList = jl.getHashMap();
+		printUnknownLines(stream, aJobList);
+		
+            bPassed = true;
+        }
+        stream << "# -- END:" << Outputter::endl();
+
+        if (bPassed)
+        {
+		stream << "Test #PASSED#" << Outputter::endl();
+        }
+        
+        if (m_aOptionHelper.getOptions().hasOpt("-onlyerrors"))
+        {
+			stream << "Errors only." << Outputter::endl();
+		}
+	}
+}
+
+// -----------------------------------------------------------------------------
+void
+testshlTestResult::printLines(Outputter &stream, HashMap & _aJobList)
+{
+	int nCount = _aJobList.size();
+	if (nCount != 0)
+	{
+		for (HashMap::const_iterator it = _aJobList.begin();
+			 it != _aJobList.end();
+			 ++it)
+		{
+			std::string aKey = (*it).first;
+			if (_aJobList[aKey] == JOB_ACCESS)
+			{
+				stream << aKey;
+				stream << Outputter::endl();
+			}
+		}
+	}
+}
+
+void 
+testshlTestResult::printFailedTests(Outputter &stream, TestPtrList &aFailedTests)
+{
+    for (TestResultCollector::TestFailures::const_iterator it2 = m_aResulter.failures().begin();
+         it2 != m_aResulter.failures().end();
+         ++it2)
+    {
+        TestFailureEnvelope *pEnvelop = *it2;
+        TestFailure *pFailure = pEnvelop->getTestFailure();
+        std::string sNodeName = pEnvelop->getString();
+        
+        aFailedTests[ pFailure->failedTest() ] = true;
+        
+        printFailureLine(stream, pFailure, sNodeName);
+    }
+}
+
+void
+testshlTestResult::printTestLines(Outputter &stream, TestPtrList &aFailedTests)
+{
+    for (TestResultCollector::Tests::const_iterator it = m_aResulter.tests().begin();
+         it != m_aResulter.tests().end();
+         ++it)
+    {
+        TestEnvelope *pEnvelop = *it;
+        Test* pTest = pEnvelop->getTest();
+        std::string sNodeName = pEnvelop->getString();
+        
+        if (aFailedTests.find(pTest) == aFailedTests.end())
+        {
+            std::string sInfo = m_aResulter.getInfo(pTest);
+            printTestLine(stream, pTest, sNodeName, sInfo);
+        }
+    }
+}
+
+void 
+testshlTestResult::printUnknownLines(Outputter &stream, HashMap & _aJobList)
+{
+	int nCount = _aJobList.size();
+	if (nCount != 0)
+	{
+		for (HashMap::const_iterator it = _aJobList.begin();
+			 it != _aJobList.end();
+			 ++it)
+		{
+			std::string aKey = (*it).first;
+			if (_aJobList[aKey] == JOB_UNKNOWN)
+			{
+				printUnknownLine(stream, aKey);
+			}
+		}
+	}
+}
+
+void 
+testshlTestResult::printHeader( Outputter &stream )
+{
+	std::string sDate(m_aOptionHelper.createDateTag());
+	if (isOnlyShowJobs())
+	{
+            stream << "# This is an automatically generated job file." << Outputter::endl();
+            stream << "# ";
+    }
+    else
+    {
+        stream << sDate << Outputter::endl();
+    }
+}
+
+void
+testshlTestResult::printFailureLine( Outputter &stream, TestFailure *_pFailure, std::string const& _sNodeName)
+{
+	std::string aName;
+	aName += _sNodeName;
+	aName += ".";
+	aName += _pFailure->failedTestName();
+
+	SourceLine aLine = _pFailure->sourceLine();
+	sal_Int32 nLine = -1;
+	std::string sFilename;
+	if (aLine.isValid())
+	{
+		nLine = aLine.lineNumber();
+		sFilename = aLine.fileName();
+	}
+	
+	Exception  *pExp  = _pFailure->thrownException();
+	std::string sWhat;
+	if (pExp)
+	{
+		sWhat = pExp->what();
+	}
+	
+	ErrorType::num eErr = _pFailure->getErrorType();
+	
+	stream << aName;
+	stream << ";";
+
+	if (eErr == ErrorType::ET_FAILURE)
+		stream << "FAILED";
+
+	else if (eErr == ErrorType::ET_ERROR)
+		stream << "ERROR";
+
+	else if (eErr == ErrorType::ET_SIGNAL)
+		stream << "SIGNAL";
+
+	else
+		stream << "UNKNOWN";
+
+	stream << "#FAILED#";
+
+	stream << sWhat;
+	stream << Outputter::endl();
+}
+
+void 
+testshlTestResult::printTestLine( Outputter &stream, Test* _pTest, std::string const& _sNodeName, std::string const& _sInfo)
+{
+	std::string aName;
+	aName += _sNodeName;
+	aName += ".";
+	aName += _pTest->getName();
+
+	stream << aName;
+	stream << ";";
+	stream << _sInfo << "#";
+	if (_sInfo == "PASSED")
+	{
+		stream << "OK#";
+	}
+	else
+	{
+		stream << "FAILED#";
+	}
+	stream << Outputter::endl();
+}
+
+void 
+testshlTestResult::printUnknownLine( Outputter &stream, std::string const& _sTestName)
+{
+	stream << _sTestName;
+	stream << ";";
+	stream << "UNKNOWN#";
+	stream << "FAILED#";
+	stream << Outputter::endl();
+}
+
+//# void 
+//# testshlTestResult::printStatistics( Outputter &stream )
+//# {
+//# 	stream  << "Test Results:" << std::endl;
+//# 	
+//# 	stream  <<  "Run:  "  <<  runTests()
+//# 			<<  "   Failures: "  <<  testFailures()
+//# 			<<  "   Errors: "  <<  testErrors()
+//# 			<<  std::endl;
+//# }
+
+
+Outputter &
+operator <<( Outputter &stream, 
+             testshlTestResult &result )
+{ 
+	result.print (stream); return stream; 
+}
+
+
+} // namespace CppUnit
Nur in misc/build/cppunit-1.8.0/src/result: testshlTestResult.cxx.dummy.
--- misc/cppunit-1.8.0/src/result/treswrapper.cxx	2008-12-10 20:46:09.979665912 +0100
+++ misc/build/cppunit-1.8.0/src/result/treswrapper.cxx	2008-12-09 09:06:10.000000000 +0100
@@ -1 +1,261 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+// #include "precompiled_cppunit.hxx"
+
+#include <cstdarg>
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <sal/types.h>
+#include <cppunit/Test.h>
+#include "cppunit/autoregister/htestresult.h"
+#include "cppunit/autoregister/callbackfunc_fktptr.h"
+#include "cppunit/result/callbackfunc.h"
+#include "cppunit/result/TestResult.h"
+
+#include <cppunit/tagvalues.hxx>
+
+namespace 
+{
+    void TestResult_startTest(hTestResult _pResult, hTest _pTest)
+    {        
+        CppUnit::TestResult* pResult = (CppUnit::TestResult*)_pResult;
+        CppUnit::Test*       pTest   = (CppUnit::Test*)_pTest;
+
+        std::string sName = pTest->getName();
+        CallbackDispatch(0 /* NULL */, TAG_TYPE, SIGNAL_START_TEST, TAG_RESULT_PTR, _pResult, TAG_NODENAME, sName.c_str(), TAG_DONE);
+
+        pResult->startTest(pTest);
+    }
+	
+    void TestResult_endTest( hTestResult _pResult, hTest _pTest )
+    {
+        CppUnit::TestResult* pResult = (CppUnit::TestResult*)_pResult;
+        CppUnit::Test*       pTest   = (CppUnit::Test*)_pTest;
+        pResult->endTest(pTest);
+
+        std::string sName = pTest->getName();
+        CallbackDispatch(0 /* NULL */, TAG_TYPE, SIGNAL_END_TEST, TAG_RESULT_PTR, _pResult, TAG_NODENAME, sName.c_str(), TAG_DONE);
+    }
+	
+// -----------------------------------------------------------------------------
+
+    void TestResult_addFailure( hTestResult _pResult, hTest _pTest, hException _pException )
+    {
+        CppUnit::TestResult* pResult = (CppUnit::TestResult*)_pResult;
+        CppUnit::Test*       pTest   = (CppUnit::Test*)_pTest;
+        CppUnit::Exception*      pException = (CppUnit::Exception*)_pException;
+        pResult->addFailure(pTest, pException);
+    }
+	
+    void TestResult_addError( hTestResult _pResult, hTest _pTest, hException _pException )
+    {
+        CppUnit::TestResult* pResult = (CppUnit::TestResult*)_pResult;
+        CppUnit::Test*       pTest   = (CppUnit::Test*)_pTest;
+        CppUnit::Exception*      pException = (CppUnit::Exception*)_pException;
+        pResult->addError(pTest, pException);
+    }
+	
+    sal_Int32 TestResult_shouldStop(hTestResult _pResult)
+    {
+        CppUnit::TestResult* pResult = (CppUnit::TestResult*)_pResult;
+        return pResult->shouldStop() == true ? 1 : 0;
+    }
+	
+// -----------------------------------------------------------------------------
+    void TestResult_addInfo( hTestResult _pResult, hTest _pTest, const char* _sInfo )
+    {
+        CppUnit::TestResult* pResult = (CppUnit::TestResult*)_pResult;
+        CppUnit::Test*       pTest   = (CppUnit::Test*)_pTest;
+        // CppUnit::Exception*      pException = (CppUnit::Exception*)_pException;
+        pResult->addInfo(pTest, _sInfo);
+    }
+// -----------------------------------------------------------------------------
+    void TestResult_enterNode( hTestResult _pResult, const char* _sNode )
+    {
+        // signalPushName(getName());
+        // CallbackDispatch(NULL, TAG_TYPE, EXECUTION_PUSH_NAME, TAG_RESULT_PTR, _pResult, TAG_NODENAME, _sNode, TAG_DONE);
+
+        CppUnit::TestResult* pResult = (CppUnit::TestResult*)_pResult;
+        // CppUnit::Test*       pTest   = (CppUnit::Test*)_pTest;
+        // CppUnit::Exception*      pException = (CppUnit::Exception*)_pException;
+        pResult->enterNode(_sNode);
+    }
+    void TestResult_leaveNode( hTestResult _pResult, const char* _sNode )
+    {
+        CppUnit::TestResult* pResult = (CppUnit::TestResult*)_pResult;
+        // CppUnit::Test*       pTest   = (CppUnit::Test*)_pTest;
+        // CppUnit::Exception*      pException = (CppUnit::Exception*)_pException;
+        pResult->leaveNode(_sNode);
+
+        // CallbackDispatch(NULL, TAG_TYPE, EXECUTION_POP_NAME, TAG_RESULT_PTR, _pResult, TAG_DONE);
+    }
+	
+// -----------------------------------------------------------------------------
+    sal_Int32 TestResult_StarterA(TagHelper const& _aTagItems)
+    {
+        sal_Int32 nRetValue = 0;
+        TagData nTagType     = _aTagItems.GetTagData(TAG_TYPE, 0);
+        hTestResult pResult  = (hTestResult) _aTagItems.GetTagData(TAG_RESULT_PTR, 0 /* NULL */);
+        CppUnit::Test* pTest = (CppUnit::Test*) _aTagItems.GetTagData(TAG_TEST_PTR, 0 /* NULL */);
+		
+        try
+        {
+            switch(nTagType)
+            {
+            case RESULT_START:
+                TestResult_startTest(pResult, pTest);
+                break;
+				
+            case RESULT_END:
+                TestResult_endTest(pResult, pTest);
+                break;
+				
+            case RESULT_ADD_FAILURE:
+            {
+                hException pException = (hException) _aTagItems.GetTagData(TAG_EXCEPTION, 0);
+                TestResult_addFailure(pResult, pTest, pException);
+                break;
+            }
+			
+            case RESULT_ADD_ERROR:
+            {
+                hException pException = (hException) _aTagItems.GetTagData(TAG_EXCEPTION, 0);
+                TestResult_addError(pResult, pTest, pException);
+                break;
+            }
+			
+            case RESULT_ADD_INFO:
+            {
+                const char* pInfo = (const char* ) _aTagItems.GetTagData(TAG_INFO, 0);
+                TestResult_addInfo(pResult, pTest, pInfo);
+                break;
+            }
+			
+            case RESULT_ENTER_NODE:
+            {
+                const char* pNode = (const char* )_aTagItems.GetTagData(TAG_NODENAME, 0);
+                TestResult_enterNode(pResult, pNode);
+                break;
+            }
+			
+            case RESULT_LEAVE_NODE:
+            {
+                const char* pNode = (const char* ) _aTagItems.GetTagData(TAG_NODENAME, 0);
+                TestResult_leaveNode(pResult, pNode);
+                break;
+            }
+			
+            case RESULT_SHOULD_STOP:
+                nRetValue = TestResult_shouldStop(pResult);
+                break;
+				
+            default:
+                fprintf(stderr, "TestResult_StarterA: Can't handle the tag type %8x\n", SAL_STATIC_CAST(int, nTagType));
+                fflush(stderr);
+                // throw std::exception(/*std::string("Unknown TYPE_TAG Exception.")*/);
+            }
+        }
+        catch (std::exception &e)
+        {
+            fprintf(stderr, "TestResult_StarterA: Exception caught: %s\n", e.what());
+            // throw e;
+        }
+	
+        return nRetValue;
+    }
+} // namespace anonymous
+
+// --------------------------------- Prototypes ---------------------------------
+
+sal_Int32 SignalHandlerA( TagHelper const& _aTagItems );
+sal_Int32 ExecutionA( TagHelper const& _aTagItems );
+
+// -----------------------------------------------------------------------------
+sal_Int32 CallbackDispatch(int x, ...)
+{
+    (void) x; // avoid warning
+
+    // The idea behind TagItems are from the Amiga OS.
+    // Due to the fact that the following code does not find my ok
+    // I decide to wrote a simple helper
+    //
+    // struct TagItem *tags = (struct TagItem *)&x + 1;
+	
+    TagHelper aTagItems;
+
+	// the following code could also be in a #define, so other functions could 
+	// use this, but at the moment this function a the only one.
+	
+	// FILL_TAGS(aTagItems, x);
+    std::va_list  args;
+    va_start( args, x );
+    Tag nTag;
+    do
+    {
+        nTag = va_arg(args, Tag);
+        if (nTag != TAG_DONE)
+        {
+            TagData nValue = va_arg(args, TagData);
+            // printf("Tag: %8x Value:%8x\n", nTag, nValue);
+            aTagItems.insert(nTag, nValue);
+        }
+    } while (nTag != TAG_DONE);
+
+    va_end   ( args );
+
+	// FILL_TAGS:END
+
+	// printf(".\n");
+
+    sal_Int32 nRetValue = 0;
+    Tag nPreTag = aTagItems.GetTagData(TAG_TYPE);
+    if ( (nPreTag & TAG_RESULT) == TAG_RESULT)
+    {
+        nRetValue = TestResult_StarterA( aTagItems );
+    }
+    else if ((nPreTag & TAG_SIGNAL) == TAG_SIGNAL)
+    {
+        nRetValue = SignalHandlerA(aTagItems);
+    }
+    else if (( nPreTag & TAG_EXECUTION) == TAG_EXECUTION)
+    {
+        nRetValue = ExecutionA(aTagItems);
+    }
+    else
+    {
+        fprintf(stderr, "CallbackDispatch: First tag is unknown %8x\n", SAL_STATIC_CAST(int, nPreTag));
+        // unknown TAG_TYPE
+    }
+    return nRetValue;
+}
+
Nur in misc/build/cppunit-1.8.0/src/result: treswrapper.cxx.dummy.
--- misc/cppunit-1.8.0/src/win32/makefile.mk	2008-12-10 20:46:10.024158685 +0100
+++ misc/build/cppunit-1.8.0/src/win32/makefile.mk	2008-12-10 19:45:23.000000000 +0100
@@ -1 +1,67 @@
-dummy
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile$
+#
+# $Revision$
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+PRJ=..$/..$/..$/..$/..$/..
+INCEXT=..$/..$/include
+# PRJ=..$/..
+# PRJINC=..
+
+PRJNAME=cppunit
+TARGET=c5t_winstuff
+LIBTARGET=NO
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------
+.INCLUDE :  settings.mk
+
+# ------------------------------------------------------------------
+
+SLOFILES = \
+		$(SLO)$/winstuff.obj
+
+#-------------------------------------------------------------------------------
+# This is a static lib
+LIB1TARGET= $(LB)$/$(TARGET).lib
+LIB1OBJFILES= \
+	$(SLOFILES)
+
+.IF "$(GUI)"=="WNT" 
+.IF "$(COM)"=="GCC"
+LIB1ARCHIV=$(LB)$/lib$(TARGET)$(DLLPOSTFIX).a
+.ENDIF
+.ENDIF
+
+.IF "$(GUI)" == "UNX"
+LIB1ARCHIV=$(LB)$/lib$(TARGET)$(DLLPOSTFIX).a
+.ENDIF
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
Nur in misc/build/cppunit-1.8.0/src/win32: makefile.mk.dummy.
--- misc/cppunit-1.8.0/src/win32/winstuff.cxx	2008-12-10 20:46:10.106772548 +0100
+++ misc/build/cppunit-1.8.0/src/win32/winstuff.cxx	2008-12-10 20:42:44.000000000 +0100
@@ -1 +1,143 @@
-dummy
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ * $Revision$
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+// #include "precompiled_cppunit.hxx"
+
+#ifdef WIN32
+#include "testshl/winstuff.hxx"
+
+#if defined _MSC_VER
+#pragma warning(push, 1)
+#endif
+#include <windows.h>
+#if defined _MSC_VER
+#pragma warning(pop)
+#endif 
+#include <MAPIWin.h>
+
+void WinDebugBreak()
+{
+    // forward to WinAPI. Note that the whole story is simply to
+    // disentangle OOo headers from Windows headers (which are largely
+    // incompatible, due to name clashes and macro mess-ups)
+    DebugBreak();
+}
+
+void WinSleep( sal_uInt32 sec )
+{
+    Sleep(sec * 1000);
+}
+
+sal_uInt32 WinGetCurrentProcessId()
+{
+    return GetCurrentProcessId();
+}
+
+#define TA_FAILED 0
+#define TA_SUCCESS_CLEAN 1
+#define TA_SUCCESS_KILL 2
+#define TA_SUCCESS_16 3
+
+   // Declare Callback Enum Functions.
+bool CALLBACK TerminateAppEnum( HWND hwnd, LPARAM lParam );
+
+/*----------------------------------------------------------------
+   DWORD WINAPI TerminateApp( DWORD dwPID, DWORD dwTimeout )
+
+   Purpose:
+      Shut down a 32-Bit Process (or 16-bit process under Windows 95)
+
+   Parameters:
+      dwPID
+         Process ID of the process to shut down.
+
+      dwTimeout
+         Wait time in milliseconds before shutting down the process.
+
+   Return Value:
+      TA_FAILED - If the shutdown failed.
+      TA_SUCCESS_CLEAN - If the process was shutdown using WM_CLOSE.
+      TA_SUCCESS_KILL - if the process was shut down with
+         TerminateProcess().
+      NOTE:  See header for these defines.
+   ----------------------------------------------------------------*/ 
+void WinTerminateApp( sal_uInt32 dwPID, sal_uInt32 dwTimeout )
+{
+    HANDLE   hProc;
+    DWORD   dwRet;
+    
+    // If we can't open the process with PROCESS_TERMINATE rights,
+    // then we give up immediately.
+    hProc = OpenProcess(SYNCHRONIZE|PROCESS_TERMINATE, false,
+                        dwPID);
+    
+    if(hProc == NULL)
+        return;
+    
+    // TerminateAppEnum() posts WM_CLOSE to all windows whose PID
+    // matches your process's.
+    EnumWindows((WNDENUMPROC)TerminateAppEnum, (LPARAM) dwPID);
+    
+    // Wait on the handle. If it signals, great. If it times out,
+    // then you kill it.
+    if (WaitForSingleObject(hProc, dwTimeout) != WAIT_OBJECT_0)
+        dwRet= (TerminateProcess(hProc,0) ? TA_SUCCESS_KILL : TA_FAILED);
+    else
+        dwRet = TA_SUCCESS_CLEAN;
+    
+    CloseHandle(hProc);
+}
+
+bool CALLBACK TerminateAppEnum( HWND hwnd, LPARAM lParam )
+{
+    DWORD dwID;
+    
+    GetWindowThreadProcessId(hwnd, &dwID);
+    
+    if(dwID == (DWORD)lParam)
+    {
+        PostMessage(hwnd, WM_CLOSE, 0, 0);
+    }
+    
+    return true;
+}
+#else
+
+// this file is only need within Windows.
+// due to the fact that empty files don't create libraries
+// we store one function in it.
+int WinStuffDummy_this_function_will_never_need()
+{
+    return 42; // we need some code
+}
+
+#endif /* WIN32 */
+
Nur in misc/build/cppunit-1.8.0/src/win32: winstuff.cxx.dummy.
