{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e3709400_a9efe57f",
        "filename": "sal/rtl/math.cxx",
        "patchSetId": 3
      },
      "lineNbr": 503,
      "author": {
        "id": 1000083
      },
      "writtenOn": "2021-10-01T07:48:27Z",
      "side": 1,
      "message": "if the buffer needs to be that big, we might as well use alloca(), which will be faster for small numbers",
      "revId": "44b0f1ee5d4e4f8cd32f7e48c76d3954a98c8c8d",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3aaa5bc6_31e6e40c",
        "filename": "sal/rtl/math.cxx",
        "patchSetId": 3
      },
      "lineNbr": 503,
      "author": {
        "id": 1000994
      },
      "writtenOn": "2021-10-01T07:51:06Z",
      "side": 1,
      "message": "Oh - why would it be faster? I assumed that allocation on stack is always increase stack pointer register + check stack overflow, regardless of the increase magnitude. I assumed that simplifying here would be reasonable, since the following code is never recursive, nor calling stack-hungry functions?",
      "parentUuid": "e3709400_a9efe57f",
      "revId": "44b0f1ee5d4e4f8cd32f7e48c76d3954a98c8c8d",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8af1f8d6_1e04c924",
        "filename": "sal/rtl/math.cxx",
        "patchSetId": 3
      },
      "lineNbr": 503,
      "author": {
        "id": 1000994
      },
      "writtenOn": "2021-10-01T07:53:59Z",
      "side": 1,
      "message": "Additionally, having the const buffer size should make it even faster, since the compiler would generate a single stack allocation for the whole function at entry, instead of one stack allocation there, and another here?",
      "parentUuid": "3aaa5bc6_31e6e40c",
      "revId": "44b0f1ee5d4e4f8cd32f7e48c76d3954a98c8c8d",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6a2d3ffd_3fc3cfc2",
        "filename": "sal/rtl/math.cxx",
        "patchSetId": 3
      },
      "lineNbr": 503,
      "author": {
        "id": 1000083
      },
      "writtenOn": "2021-10-01T07:58:19Z",
      "side": 1,
      "message": "Stack allocation is almost free, as you noted, since it\u0027s just a register modification and stack overflow check\n\n...... except that allocating a large chunk of stack (e.g. 1024 bytes), might effectively flush the L1 cache.\n\n... but as you note, this is a leaf function, so it doesn\u0027t matter as much\n\n\u003cshrug\u003e :-)",
      "parentUuid": "8af1f8d6_1e04c924",
      "revId": "44b0f1ee5d4e4f8cd32f7e48c76d3954a98c8c8d",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5c8683d6_0c7e3097",
        "filename": "sal/rtl/math.cxx",
        "patchSetId": 3
      },
      "lineNbr": 503,
      "author": {
        "id": 1000994
      },
      "writtenOn": "2021-10-01T08:02:16Z",
      "side": 1,
      "message": "Thanks; yes, I didn\u0027t consider the cache. I will leave the simple logic here for now; the problem I see is rather complex logic here, and simplifying allowed me to see e.g. https://gerrit.libreoffice.org/c/core/+/122863. So for now, let simplicity win. Additionally, I hope that we eventually just drop this all and use some *correct* (and faster) library implementation (plus our formatting post-processing).",
      "parentUuid": "6a2d3ffd_3fc3cfc2",
      "revId": "44b0f1ee5d4e4f8cd32f7e48c76d3954a98c8c8d",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    }
  ]
}