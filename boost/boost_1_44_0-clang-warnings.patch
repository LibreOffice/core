--- misc/boost_1_44_0/boost/algorithm/string/detail/find_format_store.hpp	2010-07-10 22:29:03.000000000 +0200
+++ misc/build/boost_1_44_0/boost/algorithm/string/detail/find_format_store.hpp	2012-06-06 23:13:26.000000000 +0200
@@ -71,7 +71,7 @@
             };
 
             template<typename InputT, typename FindResultT>
-            bool check_find_result(InputT& Input, FindResultT& FindResult)
+            bool check_find_result(InputT&, FindResultT& FindResult)
             {
                 typedef BOOST_STRING_TYPENAME 
                     range_const_iterator<InputT>::type input_iterator_type; 
--- misc/boost_1_44_0/boost/concept_check.hpp
+++ misc/build/boost_1_44_0/boost/concept_check.hpp
@@ -136,7 +136,18 @@ namespace boost
   {
     BOOST_CONCEPT_USAGE(Assignable) {
 #if !defined(_ITERATOR_) // back_insert_iterator broken for VC++ STL
+#if defined __clang__
+#if __clang_major__ == 3 && __clang_minor__ >= 2 || __clang_major__ > 3
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wself-assign-field"
+#endif
+#endif
       a = a;             // require assignment operator
+#if defined __clang__
+#if __clang_major__ == 3 && __clang_minor__ >= 2 || __clang_major__ > 3
+#pragma clang diagnostic pop
+#endif
+#endif
 #endif
       const_constraints(a);
     }
--- misc/boost_1_44_0/boost/date_time/dst_rules.hpp	2008-02-27 21:00:24.000000000 +0100
+++ misc/build/boost_1_44_0/boost/date_time/dst_rules.hpp	2012-06-06 23:11:03.000000000 +0200
@@ -371,7 +371,7 @@
         return is_not_in_dst;
       }
 
-      static bool is_dst_boundary_day(date_type d)
+      static bool is_dst_boundary_day(date_type)
       {
         return false;
       }
--- misc/boost_1_44_0/boost/date_time/gregorian_calendar.ipp	2010-01-10 20:17:23.000000000 +0100
+++ misc/build/boost_1_44_0/boost/date_time/gregorian_calendar.ipp	2012-06-06 22:27:07.000000000 +0200
@@ -47,7 +47,7 @@
       return week;
     }
 
-    if ((week == 53)) {
+    if (week == 53) {
       if((day==6) ||(day == 5 && is_leap_year(ymd.year))) {
         return week; //under these circumstances week == 53.
       } else {
--- misc/boost_1_44_0/boost/date_time/period_formatter.hpp	2008-02-27 21:00:24.000000000 +0100
+++ misc/build/boost_1_44_0/boost/date_time/period_formatter.hpp	2012-06-06 23:12:48.000000000 +0200
@@ -114,10 +114,10 @@
     {
       m_range_option = option;
     }
-    void delimiter_strings(const string_type& separator,
-                           const string_type& start_delim,
-                           const string_type& open_end_delim,
-                           const string_type& closed_end_delim)
+    void delimiter_strings(const string_type&,
+                           const string_type&,
+                           const string_type&,
+                           const string_type&)
     {
       m_period_separator;
       m_period_start_delimeter;
--- misc/boost_1_44_0/boost/multi_array/multi_array_ref.hpp
+++ misc/build/boost_1_44_0/boost/multi_array/multi_array_ref.hpp
@@ -86,24 +86,24 @@ public:
       num_elements_(other.num_elements_)  {  }
 
   template <typename ExtentList>
-  explicit const_multi_array_ref(TPtr base, const ExtentList& extents) :
+  explicit const_multi_array_ref(TPtr base, const ExtentList& extentlist) :
     base_(base), storage_(c_storage_order()) {
     boost::function_requires<
       detail::multi_array::CollectionConcept<ExtentList> >();
 
     index_base_list_.assign(0);
-    init_multi_array_ref(extents.begin());
+    init_multi_array_ref(extentlist.begin());
   }
   
   template <typename ExtentList>
-  explicit const_multi_array_ref(TPtr base, const ExtentList& extents,
+  explicit const_multi_array_ref(TPtr base, const ExtentList& extentlist,
                        const general_storage_order<NumDims>& so) : 
     base_(base), storage_(so) {
     boost::function_requires<
       detail::multi_array::CollectionConcept<ExtentList> >();
 
     index_base_list_.assign(0);
-    init_multi_array_ref(extents.begin());
+    init_multi_array_ref(extentlist.begin());
   }
   
   explicit const_multi_array_ref(TPtr base,
@@ -161,14 +161,14 @@ public:
   }
 
   template <typename SizeList>
-  void reshape(const SizeList& extents) {
+  void reshape(const SizeList& extentlist) {
     boost::function_requires<
       detail::multi_array::CollectionConcept<SizeList> >();
     BOOST_ASSERT(num_elements_ ==
-                 std::accumulate(extents.begin(),extents.end(),
+                 std::accumulate(extentlist.begin(),extentlist.end(),
                                  size_type(1),std::multiplies<size_type>()));
 
-    std::copy(extents.begin(),extents.end(),extent_list_.begin());
+    std::copy(extentlist.begin(),extentlist.end(),extent_list_.begin());
     this->compute_strides(stride_list_,extent_list_,storage_);
 
     origin_offset_ =
@@ -208,11 +208,11 @@ public:
   }
 
   template <typename IndexList>
-  const element& operator()(IndexList indices) const {
+  const element& operator()(IndexList indexlist) const {
     boost::function_requires<
       detail::multi_array::CollectionConcept<IndexList> >();
     return super_type::access_element(boost::type<const element&>(),
-                                      indices,origin(),
+                                      indexlist,origin(),
                                       shape(),strides(),index_bases());
   }
 
@@ -231,12 +231,12 @@ public:
 #endif // BOOST_MSVC
   typename const_array_view<NDims>::type 
   operator[](const detail::multi_array::
-             index_gen<NumDims,NDims>& indices)
+             index_gen<NumDims,NDims>& indexlist)
     const {
     typedef typename const_array_view<NDims>::type return_type;
     return
       super_type::generate_array_view(boost::type<return_type>(),
-                                      indices,
+                                      indexlist,
                                       shape(),
                                       strides(),
                                       index_bases(),
@@ -328,10 +328,10 @@ public:
   const_multi_array_ref(TPtr base,
                         const storage_order_type& so,
                         const index * index_bases_,
-                        const size_type* extents) :
+                        const size_type* extentlist) :
     base_(base), storage_(so), origin_offset_(0), directional_offset_(0)
  {
-   // If index_bases_ or extents is null, then initialize the corresponding
+   // If index_bases_ or extentlist is null, then initialize the corresponding
    // private data to zeroed lists.
    if(index_bases_) {
      boost::detail::multi_array::
@@ -339,8 +339,8 @@ public:
    } else {
      std::fill_n(index_base_list_.begin(),NumDims,0);
    }
-   if(extents) {
-     init_multi_array_ref(extents);
+   if(extentlist) {
+     init_multi_array_ref(extentlist);
    } else {
      boost::array<index,NumDims> extent_list;
      extent_list.assign(0);
@@ -374,12 +374,12 @@ private:
               boost::mem_fun_ref(&extent_range::start));
 
     // calculate the extents
-    extent_list extents;
+    extent_list extentlist;
     std::transform(ranges.ranges_.begin(),ranges.ranges_.end(),
-              extents.begin(),
+              extentlist.begin(),
               boost::mem_fun_ref(&extent_range::size));
 
-    init_multi_array_ref(extents.begin());
+    init_multi_array_ref(extentlist.begin());
   }
 
 
@@ -445,16 +445,16 @@ public:
   };
 
   template <class ExtentList>
-  explicit multi_array_ref(T* base, const ExtentList& extents) :
-    super_type(base,extents) {
+  explicit multi_array_ref(T* base, const ExtentList& extentlist) :
+    super_type(base,extentlist) {
     boost::function_requires<
       detail::multi_array::CollectionConcept<ExtentList> >();
   }
 
   template <class ExtentList>
-  explicit multi_array_ref(T* base, const ExtentList& extents,
+  explicit multi_array_ref(T* base, const ExtentList& extentlist,
                            const general_storage_order<NumDims>& so) :
-    super_type(base,extents,so) {
+    super_type(base,extentlist,so) {
     boost::function_requires<
       detail::multi_array::CollectionConcept<ExtentList> >();
   }
@@ -509,11 +509,11 @@ public:
   element* data() { return super_type::base_; }
 
   template <class IndexList>
-  element& operator()(const IndexList& indices) {
+  element& operator()(const IndexList& indexlist) {
     boost::function_requires<
       detail::multi_array::CollectionConcept<IndexList> >();
     return super_type::access_element(boost::type<element&>(),
-                                      indices,origin(),
+                                      indexlist,origin(),
                                       this->shape(),this->strides(),
                                       this->index_bases());
   }
@@ -535,11 +535,11 @@ public:
 #endif // BOOST_MSVC
   typename array_view<NDims>::type 
   operator[](const detail::multi_array::
-             index_gen<NumDims,NDims>& indices) {
+             index_gen<NumDims,NDims>& indexlist) {
     typedef typename array_view<NDims>::type return_type;
     return
       super_type::generate_array_view(boost::type<return_type>(),
-                                      indices,
+                                      indexlist,
                                       this->shape(),
                                       this->strides(),
                                       this->index_bases(),
@@ -576,10 +576,10 @@ public:
   const element* data() const { return super_type::data(); }
 
   template <class IndexList>
-  const element& operator()(const IndexList& indices) const {
+  const element& operator()(const IndexList& indexlist) const {
     boost::function_requires<
       detail::multi_array::CollectionConcept<IndexList> >();
-    return super_type::operator()(indices);
+    return super_type::operator()(indexlist);
   }
 
   const_reference operator[](index idx) const {
@@ -597,9 +597,9 @@ public:
 #endif // BOOST_MSVC
   typename const_array_view<NDims>::type 
   operator[](const detail::multi_array::
-             index_gen<NumDims,NDims>& indices)
+             index_gen<NumDims,NDims>& indexlist)
     const {
-    return super_type::operator[](indices);
+    return super_type::operator[](indexlist);
   }
   
   const_iterator begin() const {
@@ -623,8 +623,8 @@ protected:
   explicit multi_array_ref(T* base,
                            const storage_order_type& so,
                            const index* index_bases_,
-                           const size_type* extents) :
-    super_type(base,so,index_bases_,extents) { }
+                           const size_type* extentlist) :
+    super_type(base,so,index_bases_,extentlist) { }
 
 };
 
--- misc/boost_1_44_0/boost/token_functions.hpp	2010-06-12 14:06:28.000000000 +0200
+++ misc/build/boost_1_44_0/boost/token_functions.hpp	2012-06-06 23:12:27.000000000 +0200
@@ -285,7 +285,7 @@
   template <>
   struct assign_or_plus_equal<std::input_iterator_tag> {
     template<class Iterator, class Token>
-    static void assign(Iterator b, Iterator e, Token &t) { }
+    static void assign(Iterator, Iterator, Token &) { }
     template<class Token, class Value> 
     static void plus_equal(Token &t, const Value &v) {
       t += v;
