{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "34f33d40_8b70a084",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 30
      },
      "lineNbr": 0,
      "author": {
        "id": 1000135
      },
      "writtenOn": "2022-08-13T09:55:39Z",
      "side": 1,
      "message": "crashtesting shows some asserts which I\u0027ve bisected to this commit. To reproduce:\n\nwget https://bugs.documentfoundation.org/attachment.cgi?id\u003d56101 -O ~/fdo45193-1.docx\n./instdir/program/soffice --headless --convert-to pdf ~/fdo45193-1.docx\n\nsomewhere a sorted list becomes unsorted and so a --enable-dbgutil version asserts o discovering the inconsistency\n\n/usr/bin/../lib/gcc/x86_64-redhat-linux/12/../../../../include/c++/12/bits/stl_algo.h:2002:\nIn function:\n    _ForwardIterator std::lower_bound(_ForwardIterator, _ForwardIterator, \n    const _Tp \u0026, _Compare) [_ForwardIterator \u003d gnu_debug::_Safe_iterator\u003c\n    gnu_cxx::normal_iterator\u003cSwAnchoredObject **, std::\n    vector\u003cSwAnchoredObject *\u003e\u003e, std::vector\u003cSwAnchoredObject *\u003e, \n    std::random_access_iterator_tag\u003e, _Tp \u003d SwAnchoredObject *, _Compare \u003d \n    (anonymous namespace)::ObjAnchorOrder]\n\nError: elements in iterator range [first, last) are not partitioned by the \npredicate __comp and value __val.\n\nObjects involved in the operation:\n    iterator \"first\" @ 0x7fff8f1ab488 {\n      type \u003d gnu_cxx::normal_iterator\u003cSwAnchoredObject**, std::vector\u003cSwAnchoredObject*, std::allocator\u003cSwAnchoredObject*\u003e \u003e \u003e (mutable iterator);\n      state \u003d dereferenceable (start-of-sequence);\n      references sequence with type \u0027std::debug::vector\u003cSwAnchoredObject*, std::allocator\u003cSwAnchoredObject*\u003e \u003e\u0027 @ 0x5202db0\n    }\n    iterator \"last\" @ 0x7fff8f1ab460 {\n      type \u003d gnu_cxx::normal_iterator\u003cSwAnchoredObject**, std::vector\u003cSwAnchoredObject*, std::allocator\u003cSwAnchoredObject*\u003e \u003e \u003e (mutable iterator);\n      state \u003d past-the-end;\n      references sequence with type \u0027std::debug::vector\u003cSwAnchoredObject*, std::allocator\u003cSwAnchoredObject*\u003e \u003e\u0027 @ 0x5202db0\n    }\nUnspecified Application Error\n\n\nFatal exception: Signal 6\n\n",
      "revId": "1d3d2a995239c3c71432006cb795324c56a0412a",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cfd3ea03_ab0cff28",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 30
      },
      "lineNbr": 0,
      "author": {
        "id": 1002210
      },
      "writtenOn": "2022-08-15T07:13:46Z",
      "side": 1,
      "message": "Hello Caol√°n!\n\nThank you for the indication, i will check it as soon as possible. Also thanks for the suggestion, about the sorting. As I see it first, and if i remember well, there was an SwAnchoredObject* instance which might be in layoutcalc (somewhere in the layout submodule of sw, i do not remember well unfortunately, where the layout calcs the frame sizes recursively, but which level i do not know exactly i have to check it again) and that object has stored the anchored objects inside (maybe in a vector) as member. There was a getter before the calc, and the for iteration, which used to gave invalid data but not nullptr, in that case for example when the anchored objects were a shape and a swxtextframe pair (aka textbox) and the anchor of the shape changed to an other frame, but the swxtextframe still had the previous frame as the shape had before, and this calc was called during the synchronisation of the shape textbox pair. So due to this, the calculation had to be done during the sync progress which lead to unexpected behave (maybe oscillation too) and crash (the getter gave invalid content because the address of the shape was there with invalid content because the moving, but the frame was still there). To avoid this, i have done, maybe in this commit, an ugly solution, i force the sync before the calc starts so while layout calculation is reached the shape and frame already in the right frame. But, i know this is far not a good solution. The only problem is i think, there is a call for anchor sync of the textbox in the laycalc.cxx (hopefully that its name), and if i remove that, the sync will not happen that case when the user types in the text body where a textbox anchored inside the text as char. But if that is called here and the layout calc runs, that also will start the sync which will cause the crash mentioned before. So i think that call have to be moved to a better place, firstly but i think better solution can be to use of the client/modify (or similar possibility, because Gabor warned me that is deprecated) observer mechanism for the sync what i plan to implement the only question is that, when :) I think this issue what you reported might be affected by that one what i have written here. But of course this is not sure. Sorry for my so long novel, hope it helps a bit. :)",
      "parentUuid": "34f33d40_8b70a084",
      "revId": "1d3d2a995239c3c71432006cb795324c56a0412a",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    }
  ]
}