/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
 * This file is part of the LibreOffice project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * This file incorporates work covered by the following license notice:
 *
 *   Licensed to the Apache Software Foundation (ASF) under one or more
 *   contributor license agreements. See the NOTICE file distributed
 *   with this work for additional information regarding copyright
 *   ownership. The ASF licenses this file to you under the Apache
 *   License, Version 2.0 (the "License"); you may not use this file
 *   except in compliance with the License. You may obtain a copy of
 *   the License at http://www.apache.org/licenses/LICENSE-2.0 .
 */
#ifndef INCLUDED_SW_INC_TOX_HXX
#define INCLUDED_SW_INC_TOX_HXX

#include <cppuhelper/weakref.hxx>
#include <sal/log.hxx>

#include <i18nlangtag/lang.h>
#include <svl/poolitem.hxx>

#include <editeng/svxenum.hxx>
#include <swtypes.hxx>
#include <toxe.hxx>
#include <calbck.hxx>

#include <vector>

namespace com { namespace sun { namespace star {
    namespace text { class XDocumentIndexMark; }
} } }

class SwTOXType;
class SwTOXMark;
class SwTextTOXMark;
class SwDoc;

typedef std::vector<SwTOXMark*> SwTOXMarks;

// Entry of content index, alphabetical index or user defined index

extern const sal_Unicode C_NUM_REPL;
extern const sal_Unicode C_END_PAGE_NUM;
extern const OUString S_PAGE_DELI;

class SW_DLLPUBLIC SwTOXMark
    : public SfxPoolItem
    , public SwModify
{
    friend void _InitCore();
    friend class SwTextTOXMark;

    OUString m_aAltText;    // Text of caption is different.
    OUString m_aPrimaryKey;
    OUString m_aSecondaryKey;
    OUString m_aCitationKeyReading;

    // three more strings for phonetic sorting
    OUString m_aTextReading;
    OUString m_aPrimaryKeyReading;
    OUString m_aSecondaryKeyReading;

    SwTextTOXMark* m_pTextAttr;

    sal_uInt16  m_nLevel;
    OUString    m_aBookmarkName;
    OUString    m_aEntryTypeName;       // stored specific entry type name for INDEX field \f
    bool    m_bAutoGenerated : 1;     // generated using a concordance file
    bool    m_bMainEntry : 1;         // main entry emphasized by character style

    css::uno::WeakReference<css::text::XDocumentIndexMark> m_wXDocumentIndexMark;

    SwTOXMark();                    // to create the default attribute in _InitCore

protected:
    // SwClient
   virtual void Modify( const SfxPoolItem* pOld, const SfxPoolItem* pNew ) override;

public:

    // single argument ctors shall be explicit.
    explicit SwTOXMark( const SwTOXType* pTyp );
    virtual ~SwTOXMark();

    SwTOXMark( const SwTOXMark& rCopy );
    SwTOXMark& operator=( const SwTOXMark& rCopy );

    // "pure virtual methods" of SfxPoolItem
    virtual bool            operator==( const SfxPoolItem& ) const override;
    virtual SfxPoolItem*    Clone( SfxItemPool* pPool = nullptr ) const override;

    void InvalidateTOXMark();

    OUString                GetText() const;

    inline bool             IsAlternativeText() const;
    inline OUString         GetAlternativeText() const;

    inline void             SetAlternativeText( const OUString& rAlt );

    // content or user defined index
    inline void             SetLevel(sal_uInt16 nLevel);
    inline sal_uInt16           GetLevel() const;
    inline void             SetBookmarkName( const OUString& bName);
    inline OUString         GetBookmarkName() const;
    inline void             SetEntryTypeName( const OUString& sName);
    inline OUString         GetEntryTypeName() const;

    // for alphabetical index only
    inline void             SetPrimaryKey(const OUString& rStr );
    inline void             SetSecondaryKey(const OUString& rStr);
    inline void             SetTextReading(const OUString& rStr);
    inline void             SetPrimaryKeyReading(const OUString& rStr );
    inline void             SetSecondaryKeyReading(const OUString& rStr);
    inline void             SetCitationKeyReading(const OUString& rStr);

    inline OUString         GetPrimaryKey() const;
    inline OUString         GetSecondaryKey() const;
    inline OUString         GetTextReading() const;
    inline OUString         GetPrimaryKeyReading() const;
    inline OUString         GetSecondaryKeyReading() const;

    bool                    IsAutoGenerated() const {return m_bAutoGenerated;}
    void                    SetAutoGenerated(bool bSet) {m_bAutoGenerated = bSet;}

    bool                    IsMainEntry() const {return m_bMainEntry;}
    void                    SetMainEntry(bool bSet) { m_bMainEntry = bSet;}

    inline const SwTOXType*    GetTOXType() const;

    const SwTextTOXMark* GetTextTOXMark() const   { return m_pTextAttr; }
          SwTextTOXMark* GetTextTOXMark()         { return m_pTextAttr; }

    SAL_DLLPRIVATE css::uno::WeakReference<css::text::XDocumentIndexMark> const& GetXTOXMark() const
            { return m_wXDocumentIndexMark; }
    SAL_DLLPRIVATE void SetXTOXMark(css::uno::Reference<css::text::XDocumentIndexMark> const& xMark)
            { m_wXDocumentIndexMark = xMark; }
    void DeRegister() { GetRegisteredInNonConst()->Remove( this ); }
    void RegisterToTOXType( SwTOXType& rMark );
    static void InsertTOXMarks( SwTOXMarks& aMarks, const SwTOXType& rType );
};

// index types
class SwTOXType : public SwModify
{
public:
    SwTOXType(TOXTypes eTyp, const OUString& aName);

    // @@@ public copy ctor, but no copy assignment?
    SwTOXType(const SwTOXType& rCopy);

    inline OUString         GetTypeName() const;
    inline TOXTypes         GetType() const;

private:
    OUString        m_aName;
    TOXTypes        m_eType;

    // @@@ public copy ctor, but no copy assignment?
    SwTOXType & operator= (const SwTOXType &) = delete;
};

// Structure of the index lines
#define FORM_TITLE              0
#define FORM_ALPHA_DELIMITTER   1
#define FORM_PRIMARY_KEY        2
#define FORM_SECONDARY_KEY      3
#define FORM_ENTRY              4

/*
 Pattern structure

 <E#> - entry number                    <E# CharStyleName,PoolId>
 <ET> - entry text                      <ET CharStyleName,PoolId>
 <E>  - entry text and number           <E CharStyleName,PoolId>
 <T>  - tab stop                        <T,,Position,Adjust>
 <C>  - chapter info n = {0, 1, 2, 3, 4 } values of SwChapterFormat <C CharStyleName,PoolId>
 <TX> - text token                      <X CharStyleName,PoolId, TOX_STYLE_DELIMITERTextContentTOX_STYLE_DELIMITER>
 <#>  - Page number                     <# CharStyleName,PoolId>
 <LS> - Link start                      <LS>
 <LE> - Link end                        <LE>
 <A00> - Authority entry field          <A02 CharStyleName, PoolId>
 */

// These enum values are stored and must not be changed!
enum FormTokenType
{
    TOKEN_ENTRY_NO,
    TOKEN_ENTRY_TEXT,
    TOKEN_ENTRY,
    TOKEN_TAB_STOP,
    TOKEN_TEXT,
    TOKEN_PAGE_NUMS,
    TOKEN_CHAPTER_INFO,
    TOKEN_LINK_START,
    TOKEN_LINK_END,
    TOKEN_AUTHORITY,
    TOKEN_END
};

struct SW_DLLPUBLIC SwFormToken
{
    OUString        sText;
    OUString        sCharStyleName;
    SwTwips         nTabStopPosition;
    FormTokenType   eTokenType;
    sal_uInt16          nPoolId;
    SvxTabAdjust    eTabAlign;
    sal_uInt16          nChapterFormat;     //SwChapterFormat;
    sal_uInt16          nOutlineLevel;//the maximum permitted outline level in numbering
    sal_uInt16          nAuthorityField;    //enum ToxAuthorityField
    sal_Unicode     cTabFillChar;
    bool        bWithTab;      // true: do generate tab
                                   // character only the tab stop
                                   // #i21237#

    SwFormToken(FormTokenType eType ) :
        nTabStopPosition(0),
        eTokenType(eType),
        nPoolId(USHRT_MAX),
        eTabAlign( SVX_TAB_ADJUST_LEFT ),
        nChapterFormat(0 /*CF_NUMBER*/),
        nOutlineLevel(MAXLEVEL),   //default to maximum outline level
        nAuthorityField(0 /*AUTH_FIELD_IDENTIFIER*/),
        cTabFillChar(' '),
        bWithTab(true)  // #i21237#
    {}

    OUString GetString() const;
};

struct SwFormTokenEqualToFormTokenType
{
    FormTokenType eType;

    SwFormTokenEqualToFormTokenType(FormTokenType _eType) : eType(_eType) {}
    bool operator()(const SwFormToken & rToken)
    {
        return rToken.eTokenType == eType;
    }
};

/// Vector of tokens.
typedef std::vector<SwFormToken> SwFormTokens;

/**
   Helper class that converts vectors of tokens to strings and vice
   versa.
 */
class SW_DLLPUBLIC SwFormTokensHelper
{
    /// the tokens
    SwFormTokens m_Tokens;

public:
    /**
       constructor

       @param rTokens       vector of tokens
    */
    SwFormTokensHelper(const SwFormTokens & rTokens) : m_Tokens(rTokens) {}

    /**
       constructor

       @param rStr   string representation of the tokens
    */
    SwFormTokensHelper(const OUString & rStr);

    /**
       Returns vector of tokens.

       @return vector of tokens
    */
    const SwFormTokens & GetTokens() const { return m_Tokens; }
};

class SW_DLLPUBLIC SwForm
{
    SwFormTokens    m_aPattern[ AUTH_TYPE_END + 1 ]; // #i21237#
    OUString  m_aTemplate[ AUTH_TYPE_END + 1 ];

    TOXTypes    m_eType;
    sal_uInt16      m_nFormMaxLevel;

    bool    m_bGenerateTabPos : 1;
    bool    m_bIsRelTabPos : 1;
    bool    m_bCommaSeparated : 1;

public:
    SwForm( TOXTypes eTOXType = TOX_CONTENT );
    SwForm( const SwForm& rForm );

    SwForm& operator=( const SwForm& rForm );

    inline void SetTemplate(sal_uInt16 nLevel, const OUString& rName);
    inline OUString GetTemplate(sal_uInt16 nLevel) const;

    // #i21237#
    void    SetPattern(sal_uInt16 nLevel, const SwFormTokens& rName);
    void    SetPattern(sal_uInt16 nLevel, const OUString& rStr);
    const SwFormTokens& GetPattern(sal_uInt16 nLevel) const;

    // fill tab stop positions from template to pattern- #i21237#
    void AdjustTabStops( SwDoc& rDoc );

    inline TOXTypes GetTOXType() const;
    inline sal_uInt16   GetFormMax() const;

    bool IsRelTabPos() const    {   return m_bIsRelTabPos; }
    void SetRelTabPos( bool b ) {   m_bIsRelTabPos = b;       }

    bool IsCommaSeparated() const       { return m_bCommaSeparated;}
    void SetCommaSeparated( bool b)     { m_bCommaSeparated = b;}

    static sal_uInt16 GetFormMaxLevel( TOXTypes eType );

    static OUString GetFormEntry();
    static OUString GetFormTab();
    static OUString GetFormPageNums();
    static OUString GetFormLinkStt();
    static OUString GetFormLinkEnd();
    static OUString GetFormEntryNum();
    static OUString GetFormEntryText();
    static OUString GetFormChapterMark();
    static OUString GetFormText();
    static OUString GetFormAuth();
};

// Content to create indexes of
typedef sal_uInt16 SwTOXElement;
namespace nsSwTOXElement
{
    const SwTOXElement TOX_MARK             = 1;
    const SwTOXElement TOX_OUTLINELEVEL     = 2;
    const SwTOXElement TOX_TEMPLATE         = 4;
    const SwTOXElement TOX_OLE              = 8;
    const SwTOXElement TOX_TABLE            = 16;
    const SwTOXElement TOX_GRAPHIC          = 32;
    const SwTOXElement TOX_FRAME            = 64;
    const SwTOXElement TOX_SEQUENCE         = 128;
    const SwTOXElement TOX_TABLEADER        = 256;
    const SwTOXElement TOX_TAB_IN_TOC       = 512;
    const SwTOXElement TOX_BOOKMARK         = 1024;
    const SwTOXElement TOX_NEWLINE          = 2048;
    const SwTOXElement TOX_PARAGRAPH_OUTLINE_LEVEL = 4096;
    const SwTOXElement TOX_INDEX_ENTRY_TYPE       = 8192;
}

typedef sal_uInt16 SwTOIOptions;
namespace nsSwTOIOptions
{
    const SwTOIOptions TOI_SAME_ENTRY       = 1;
    const SwTOIOptions TOI_FF               = 2;
    const SwTOIOptions TOI_CASE_SENSITIVE   = 4;
    const SwTOIOptions TOI_KEY_AS_ENTRY     = 8;
    const SwTOIOptions TOI_ALPHA_DELIMITTER = 16;
    const SwTOIOptions TOI_DASH             = 32;
    const SwTOIOptions TOI_INITIAL_CAPS     = 64;
}

//which part of the caption is to be displayed
enum SwCaptionDisplay
{
    CAPTION_COMPLETE,
    CAPTION_NUMBER,
    CAPTION_TEXT
};

typedef sal_uInt16 SwTOOElements;
namespace nsSwTOOElements
{
    const SwTOOElements TOO_MATH            = 0x01;
    const SwTOOElements TOO_CHART           = 0x02;
    const SwTOOElements TOO_CALC            = 0x08;
    const SwTOOElements TOO_DRAW_IMPRESS    = 0x10;
    const SwTOOElements TOO_OTHER           = 0x80;
}

#define TOX_STYLE_DELIMITER ((sal_Unicode)0x01)

// Class for all indexes
class SW_DLLPUBLIC SwTOXBase : public SwClient
{
    SwForm      m_aForm;              // description of the lines
    OUString    m_aName;              // unique name
    OUString    m_aTitle;             // title
    OUString    m_aBookmarkName;      //Bookmark Name
    OUString    m_aEntryTypeName;   // Type name

    OUString    m_sMainEntryCharStyle; // name of the character style applied to main index entries

    OUString    m_aStyleNames[MAXLEVEL]; // (additional) style names TOX_CONTENT, TOX_USER
    OUString    m_sSequenceName;      // FieldTypeName of a caption sequence

    LanguageType    m_eLanguage;
    OUString        m_sSortAlgorithm;

    union {
        sal_uInt16      nLevel;             // consider outline levels
        sal_uInt16      nOptions;           // options of alphabetical index
    } m_aData;

    sal_uInt16      m_nCreateType;        // sources to create the index from
    sal_uInt16      m_nOLEOptions;        // OLE sources
    SwCaptionDisplay m_eCaptionDisplay;
    bool        m_bProtected : 1;         // index protected ?
    bool        m_bFromChapter : 1;       // create from chapter or document
    bool        m_bFromObjectNames : 1;   // create a table or object index
                                    // from the names rather than the caption
    bool        m_bLevelFromChapter : 1; // User index: get the level from the source chapter

protected:
    // Add a data member, for record the TOC field expression of MS Word binary format
    // For keeping fidelity and may giving a better exporting performance
    OUString maMSTOCExpression;
    bool mbKeepExpression;

public:
    SwTOXBase( const SwTOXType* pTyp, const SwForm& rForm,
               sal_uInt16 nCreaType, const OUString& rTitle );
    SwTOXBase( const SwTOXBase& rCopy, SwDoc* pDoc = nullptr );
    virtual ~SwTOXBase();

    virtual bool GetInfo( SfxPoolItem& rInfo ) const override;

    // a kind of CopyCtor - check if the TOXBase is at TOXType of the doc.
    // If not, so create it an copy all other used things. The return is this
    SwTOXBase& CopyTOXBase( SwDoc*, const SwTOXBase& );

    const SwTOXType*    GetTOXType() const;

    sal_uInt16              GetCreateType() const;      // creation types

    OUString            GetTOXName() const {return m_aName;}
    void                SetTOXName(const OUString& rSet) {m_aName = rSet;}

    // for record the TOC field expression of MS Word binary format
    const OUString&     GetMSTOCExpression() const{return maMSTOCExpression;}
    void                SetMSTOCExpression(const OUString& rExp) {maMSTOCExpression = rExp;}
    void                EnableKeepExpression() {mbKeepExpression = true;}
    void                DisableKeepExpression() {mbKeepExpression = false;}

    OUString            GetTitle() const;           // Title
    OUString         GetBookmarkName() const;
    OUString            GetTypeName() const;        // Name
    const SwForm&       GetTOXForm() const;         // description of the lines

    void                SetCreate(sal_uInt16);
    void                SetTitle(const OUString& rTitle);
    void                SetTOXForm(const SwForm& rForm);
    void  SetBookmarkName(const OUString& bName);

    TOXTypes            GetType() const;

    OUString            GetMainEntryCharStyle() const {return m_sMainEntryCharStyle;}
    void                SetMainEntryCharStyle(const OUString& rSet)  {m_sMainEntryCharStyle = rSet;}

    // for record the Index field expression of MS Word
    OUString         GetEntryTypeName() const;
    void  SetEntryTypeName(const OUString& sName);

    // content index only
    inline void             SetLevel(sal_uInt16);                   // consider outline level
    inline sal_uInt16           GetLevel() const;

    // alphabetical index only
    inline sal_uInt16           GetOptions() const;                 // alphabetical index options
    inline void             SetOptions(sal_uInt16 nOpt);

    // index of objects
    sal_uInt16      GetOLEOptions() const {return m_nOLEOptions;}
    void        SetOLEOptions(sal_uInt16 nOpt) {m_nOLEOptions = nOpt;}

    // index of objects

    OUString                GetStyleNames(sal_uInt16 nLevel) const
                                {
                                SAL_WARN_IF( nLevel >= MAXLEVEL, "sw", "Which level?");
                                return m_aStyleNames[nLevel];
                                }
    void                    SetStyleNames(const OUString& rSet, sal_uInt16 nLevel)
                                {
                                SAL_WARN_IF( nLevel >= MAXLEVEL, "sw", "Which level?");
                                m_aStyleNames[nLevel] = rSet;
                                }
    bool                    IsFromChapter() const { return m_bFromChapter;}
    void                    SetFromChapter(bool bSet) { m_bFromChapter = bSet;}

    bool                    IsFromObjectNames() const {return m_bFromObjectNames;}
    void                    SetFromObjectNames(bool bSet) {m_bFromObjectNames = bSet;}

    bool                    IsLevelFromChapter() const {return m_bLevelFromChapter;}
    void                    SetLevelFromChapter(bool bSet) {m_bLevelFromChapter = bSet;}

    bool                    IsProtected() const { return m_bProtected; }
    void                    SetProtected(bool bSet) { m_bProtected = bSet; }

    OUString                GetSequenceName() const {return m_sSequenceName;}
    void                    SetSequenceName(const OUString& rSet) {m_sSequenceName = rSet;}

    SwCaptionDisplay        GetCaptionDisplay() const { return m_eCaptionDisplay;}
    void                    SetCaptionDisplay(SwCaptionDisplay eSet) {m_eCaptionDisplay = eSet;}

    bool                    IsTOXBaseInReadonly() const;

    const SfxItemSet*       GetAttrSet() const;
    void                    SetAttrSet( const SfxItemSet& );

    LanguageType    GetLanguage() const {return m_eLanguage;}
    void            SetLanguage(LanguageType nLang)  {m_eLanguage = nLang;}

    OUString        GetSortAlgorithm()const {return m_sSortAlgorithm;}
    void            SetSortAlgorithm(const OUString& rSet) {m_sSortAlgorithm = rSet;}
    // #i21237#
    void AdjustTabStops( SwDoc & rDoc )
    {
        m_aForm.AdjustTabStops( rDoc );
    }

    SwTOXBase& operator=(const SwTOXBase& rSource);
    void RegisterToTOXType( SwTOXType& rMark );
};

//SwTOXMark

inline OUString SwTOXMark::GetAlternativeText() const
    {   return m_aAltText;    }

inline OUString SwTOXMark::GetBookmarkName() const
    {   return m_aBookmarkName;    }

inline OUString SwTOXMark::GetEntryTypeName() const
    {   return m_aEntryTypeName;    }

inline const SwTOXType* SwTOXMark::GetTOXType() const
    { return static_cast<const SwTOXType*>(GetRegisteredIn()); }

inline bool SwTOXMark::IsAlternativeText() const
    { return !m_aAltText.isEmpty(); }

inline void SwTOXMark::SetAlternativeText(const OUString& rAlt)
{
    m_aAltText = rAlt;
}

inline void SwTOXMark::SetBookmarkName(const OUString& bName)
{
    m_aBookmarkName = bName;
}

inline void SwTOXMark::SetEntryTypeName(const OUString& sName)
{
    m_aEntryTypeName = sName;
}
inline void SwTOXMark::SetLevel( sal_uInt16 nLvl )
{
    SAL_WARN_IF( GetTOXType() && GetTOXType()->GetType() == TOX_INDEX, "sw", "Wrong type");
    m_nLevel = nLvl;
}

inline void SwTOXMark::SetPrimaryKey( const OUString& rKey )
{
    SAL_WARN_IF( GetTOXType()->GetType() != TOX_INDEX, "sw", "Wrong type");
    m_aPrimaryKey = rKey;
}

inline void SwTOXMark::SetSecondaryKey( const OUString& rKey )
{
    SAL_WARN_IF(GetTOXType()->GetType() != TOX_INDEX, "sw", "Wrong type");
    m_aSecondaryKey = rKey;
}

inline void SwTOXMark::SetTextReading( const OUString& rText )
{
    SAL_WARN_IF(GetTOXType()->GetType() != TOX_INDEX, "sw", "Wrong type");
    m_aTextReading = rText;
}

inline void SwTOXMark::SetPrimaryKeyReading( const OUString& rKey )
{
    SAL_WARN_IF(GetTOXType()->GetType() != TOX_INDEX, "sw", "Wrong type");
    m_aPrimaryKeyReading = rKey;
}

inline void SwTOXMark::SetCitationKeyReading( const OUString& rKey )
{
    SAL_WARN_IF(GetTOXType()->GetType() != TOX_CITATION, "sw", "Wrong type");
    m_aCitationKeyReading = rKey;
}

inline void SwTOXMark::SetSecondaryKeyReading( const OUString& rKey )
{
    SAL_WARN_IF(GetTOXType()->GetType() != TOX_INDEX, "sw", "Wrong type");
    m_aSecondaryKeyReading = rKey;
}

inline sal_uInt16 SwTOXMark::GetLevel() const
{
    SAL_WARN_IF( GetTOXType() && GetTOXType()->GetType() == TOX_INDEX, "sw", "Wrong type");
    return m_nLevel;
}

inline OUString SwTOXMark::GetPrimaryKey() const
{
    SAL_WARN_IF(GetTOXType()->GetType() != TOX_INDEX, "sw", "Wrong type");
    return m_aPrimaryKey;
}

inline OUString SwTOXMark::GetSecondaryKey() const
{
    SAL_WARN_IF(GetTOXType()->GetType() != TOX_INDEX, "sw", "Wrong type");
    return m_aSecondaryKey;
}

inline OUString SwTOXMark::GetTextReading() const
{
    SAL_WARN_IF(GetTOXType()->GetType() != TOX_INDEX, "sw", "Wrong type");
    return m_aTextReading;
}

inline OUString SwTOXMark::GetPrimaryKeyReading() const
{
    SAL_WARN_IF(GetTOXType()->GetType() != TOX_INDEX, "sw", "Wrong type");
    return m_aPrimaryKeyReading;
}

inline OUString SwTOXMark::GetSecondaryKeyReading() const
{
    SAL_WARN_IF(GetTOXType()->GetType() != TOX_INDEX, "sw", "Wrong type");
    return m_aSecondaryKeyReading;
}

//SwForm

inline void SwForm::SetTemplate(sal_uInt16 nLevel, const OUString& rTemplate)
{
    SAL_WARN_IF(nLevel >= GetFormMax(), "sw", "Index >= GetFormMax()");
    m_aTemplate[nLevel] = rTemplate;
}

inline OUString SwForm::GetTemplate(sal_uInt16 nLevel) const
{
    SAL_WARN_IF(nLevel >= GetFormMax(), "sw", "Index >= GetFormMax()");
    return m_aTemplate[nLevel];
}

inline TOXTypes SwForm::GetTOXType() const
{
    return m_eType;
}

inline sal_uInt16 SwForm::GetFormMax() const
{
    return m_nFormMaxLevel;
}

//SwTOXType

inline OUString SwTOXType::GetTypeName() const
    {   return m_aName;   }

inline TOXTypes SwTOXType::GetType() const
    {   return m_eType;   }

// SwTOXBase

inline const SwTOXType* SwTOXBase::GetTOXType() const
    { return static_cast<const SwTOXType*>(GetRegisteredIn()); }

inline sal_uInt16 SwTOXBase::GetCreateType() const
    { return m_nCreateType; }

inline OUString SwTOXBase::GetTitle() const
    { return m_aTitle; }

inline OUString SwTOXBase::GetBookmarkName() const
    { return m_aBookmarkName; }

inline OUString SwTOXBase::GetEntryTypeName() const
    { return m_aEntryTypeName; }

inline OUString SwTOXBase::GetTypeName() const
    { return GetTOXType()->GetTypeName();  }

inline const SwForm& SwTOXBase::GetTOXForm() const
    { return m_aForm; }

inline void SwTOXBase::SetCreate(sal_uInt16 nCreate)
    { m_nCreateType = nCreate; }

inline void SwTOXBase::SetTOXForm(const SwForm& rForm)
    {  m_aForm = rForm; }

inline TOXTypes SwTOXBase::GetType() const
    { return GetTOXType()->GetType(); }

inline void SwTOXBase::SetLevel(sal_uInt16 nLev)
{
    SAL_WARN_IF(GetTOXType()->GetType() == TOX_INDEX, "sw", "Wrong type");
    m_aData.nLevel = nLev;
}

inline sal_uInt16 SwTOXBase::GetLevel() const
{
    SAL_WARN_IF(GetTOXType()->GetType() == TOX_INDEX, "sw", "Wrong type");
    return m_aData.nLevel;
}

inline sal_uInt16 SwTOXBase::GetOptions() const
{
    SAL_WARN_IF(GetTOXType()->GetType() != TOX_INDEX, "sw", "Wrong type");
    return m_aData.nOptions;
}

inline void SwTOXBase::SetOptions(sal_uInt16 nOpt)
{
    SAL_WARN_IF(GetTOXType()->GetType() != TOX_INDEX, "sw", "Wrong type");
    m_aData.nOptions = nOpt;
}

#endif // INCLUDED_SW_INC_TOX_HXX

/* vim:set shiftwidth=4 softtabstop=4 expandtab: */
