{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "22b870c0_92fb0982",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-12-12T08:41:03Z",
      "side": 1,
      "message": "where exactly do the rtl::is* functions cause problems there?",
      "revId": "4c07f06dedc91e78bed5c0fb2afd52700971b6d5",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c0be42c_7edfdd88",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1000994
      },
      "writtenOn": "2021-12-12T08:49:37Z",
      "side": 1,
      "message": "I mentioned specific code, that I created (and you might call the use of the functions there \"incorrect\" ðŸ˜Š) in the message:\n\nhttps://git.libreoffice.org/core/+/21154ea8c450f9f5568b32123d34a20e498a9290/svtools/source/svrtf/svparser.cxx#244\n\nisHighSurrogat/isLowSurrogate",
      "parentUuid": "22b870c0_92fb0982",
      "revId": "4c07f06dedc91e78bed5c0fb2afd52700971b6d5",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "808f1553_cfb254e4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-12-12T09:53:35Z",
      "side": 1,
      "message": "But what\u0027s the problem there?  cUC is of type sal_Unicode, so rtl::isHigh/LowSurrogate(cUC) will necessarily fulfill the asserts.",
      "parentUuid": "4c0be42c_7edfdd88",
      "revId": "4c07f06dedc91e78bed5c0fb2afd52700971b6d5",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9aafcd60_c00387c8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1000994
      },
      "writtenOn": "2021-12-12T10:27:55Z",
      "side": 1,
      "message": "Yes. Still it feels wrong to assert on what is logically wrong, on user-defined data.",
      "parentUuid": "808f1553_cfb254e4",
      "revId": "4c07f06dedc91e78bed5c0fb2afd52700971b6d5",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1529508d_7092f067",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-12-12T08:41:03Z",
      "side": 1,
      "message": "The functions are meant to check certain properties of Unicode code points, their domains are Unicode code points, hence the asserts checking the precondition that the functions are actually called with values matching their domains.",
      "revId": "4c07f06dedc91e78bed5c0fb2afd52700971b6d5",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "caf9ab7d_d080f1db",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1000994
      },
      "writtenOn": "2021-12-12T08:49:37Z",
      "side": 1,
      "message": "I see the idea. However, I do *not* see how the asserts help programmer, or make anything more correct. If there\u0027s some code that asks if a *random* value is e.g. ascii, it doesn\u0027t make the code more correct if the programmer made a previous call to check that it\u0027s correct Unicode. The outer code would only become incorrect when the programmer does something in \"not ascii\" case, assuming it\u0027s correct Unicode; but then, it\u0027s the other code in fictional \"else\" branch that is incorrect, not the check itself.\n\nI see these asserts just wrong, making any unchecked use of *checks* on user-supplied data wrong, and thus making use of the functions unnecessarily complicated, verbose, and resulting code more difficult to follow.",
      "parentUuid": "1529508d_7092f067",
      "revId": "4c07f06dedc91e78bed5c0fb2afd52700971b6d5",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3c25ddff_c80a3f7d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1000994
      },
      "writtenOn": "2021-12-12T09:04:14Z",
      "side": 1,
      "message": "\u003e their domains are Unicode code points\n\nAdditionally, e.g. surrogates are not even code points. So the check mixes Unicode code points and UTF-16-encoding detail (code units that represent code points, and surrogate code units that are not).",
      "parentUuid": "caf9ab7d_d080f1db",
      "revId": "4c07f06dedc91e78bed5c0fb2afd52700971b6d5",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "11b2fffd_df220944",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-12-12T09:53:35Z",
      "side": 1,
      "message": "The surrogate code points /are/ Unicode code points.  (They are excluded from the Unicode scalar values, though.)",
      "parentUuid": "3c25ddff_c80a3f7d",
      "revId": "4c07f06dedc91e78bed5c0fb2afd52700971b6d5",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b7fc328_52c20fc0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1000994
      },
      "writtenOn": "2021-12-12T10:27:55Z",
      "side": 1,
      "message": "There are reserved *Unicode code points* in the range U+D800 - U+DFFF, that are reserved (to account for evolution of Unicode from \"65535 code points is enough for everyone\" to \"There\u0027s now UTF-16 *encoding*, that is not UCS2, and we need to ensure some compatibility\" - they are *artifacts*).\n\nThere are UTF-16 *code units*, that may be *decoded* to either Unicode code points (happening to have same numeric value), or in combinations with adjacent surrogate code units. You never combine \"code points\", you only combine surrogate code units. So using isUnicodeCodePoint on a UTF-16 code unit is conceptually wrong (even on non-surrogates) - they must be *decoded* first, even if for non-surrogates the decoding is trivial. The more it\u0027s true for surrogates: checking if a surrogate UTF-16 code unit is Unicode code point, to combine it on the next step, is crossing *domains* several times in both directions.",
      "parentUuid": "11b2fffd_df220944",
      "revId": "4c07f06dedc91e78bed5c0fb2afd52700971b6d5",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a260a79c_59542715",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-12-12T14:04:18Z",
      "side": 1,
      "message": "\u003e There are reserved *Unicode code points* in the range U+D800 - U+DFFF, that are reserved (to account for evolution of Unicode from \"65535 code points is enough for everyone\" to \"There\u0027s now UTF-16 *encoding*, that is not UCS2, and we need to ensure some compatibility\" - they are *artifacts*).\n\nReserved code points are something entirely different still :)\n\n\u003e There are UTF-16 *code units*, that may be *decoded* to either Unicode code points (happening to have same numeric value), or in combinations with adjacent surrogate code units. You never combine \"code points\", you only combine surrogate code units. So using isUnicodeCodePoint on a UTF-16 code unit is conceptually wrong (even on non-surrogates) - they must be *decoded* first, even if for non-surrogates the decoding is trivial. The more it\u0027s true for surrogates: checking if a surrogate UTF-16 code unit is Unicode code point, to combine it on the next step, is crossing *domains* several times in both directions.\n\nThe injection from UTF-16 code units into the Unicode codespace is a deliberate and important design decision (similar to the injection from ASCII into the Unicode codespace), and, yes, something that is routinely exploited in code traversing among the domains of UTF-16 code units and Unicode code points.  What would be the alternative, two sets of (otherwise identical) rtl::isHigh/LowSurrogate functions operating on, respectively, UTF-16 code units and Unicode scalar values?  That would look like overkill to me.\n\nSure, a function like rtl::combineSurrogates should conceptually take UTF-16 code units rather than Unicode scalar values.  But then again, it seemed better to uniformly use Unicode scalar values (represented as sal_uInt32) throughout all the rtl/character.hxx functionality.",
      "parentUuid": "6b7fc328_52c20fc0",
      "revId": "4c07f06dedc91e78bed5c0fb2afd52700971b6d5",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9fd19aaf_b9c2c62b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000045
      },
      "writtenOn": "2021-12-12T09:54:05Z",
      "side": 1,
      "message": "[had pressed +2 by accident...]",
      "revId": "4c07f06dedc91e78bed5c0fb2afd52700971b6d5",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    }
  ]
}