{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "cc037d4a_56bd16e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000549
      },
      "writtenOn": "2022-08-23T13:17:52Z",
      "side": 1,
      "message": "Why can\u0027t the interceptor return an actual dispatch object, which will listen to selection changes and send appropriate enable/disable status updates? Invalidating all the ui (all toolbars, menubar, statusbar etc.) just because a different image was selected, sounds like an overkill.",
      "revId": "e77b8950477a080570d2247257d770113766c6c9",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7bb6fa34_275a853c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000013
      },
      "writtenOn": "2022-08-23T13:52:02Z",
      "side": 1,
      "message": "The trouble is that the dispatch interceptor can take the currently selected image into account, so we need to re-query the dispatch objects. See the testcase -- my real-world example is several images, where the toolbar button associated with .uno:SetBorderStyle is meant to be disabled when the image has a hyperlink set. Without this change, we don\u0027t re-query the dispatch objects, so if the first image you select (transitioning from text selection) has a link, the toolbar button is disabled, and it will remain disabled, even if you select a next image which doesn\u0027t have a hyperlink set. Similarly, there is missing update in the other direction: if you first select a without-hyperlink image first, then we keep the toolbar button enabled, and it\u0027ll be enabled even if you select a next image with a hyperlink instead.\n\nOr do you think there is a simpler way to make sure the enabled/disabled status of toolbar buttons is correct without calling contextChanged()?",
      "parentUuid": "cc037d4a_56bd16e0",
      "revId": "e77b8950477a080570d2247257d770113766c6c9",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "00690df0_2a4e1eb7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000013
      },
      "writtenOn": "2022-08-23T14:00:27Z",
      "side": 1,
      "message": "Erm, I forgot to ask. My understanding is that returning an empty dispatcher in queryDispatch() is a supported way to communicate that we want to disable the command, e.g. our framework/source/dispatch/dispatchdisabler.cxx does this, and I assume that 3rd-party extension code does the same.\n\nStill, do you have an example where similar code does this disabling by \"sending appropriate enable/disable status updates\" instead?\n\nIf that\u0027s more efficient, we should somehow advertise that more towards extension authors. Thanks!",
      "parentUuid": "7bb6fa34_275a853c",
      "revId": "e77b8950477a080570d2247257d770113766c6c9",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    }
  ]
}