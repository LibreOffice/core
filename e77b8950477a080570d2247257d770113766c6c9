{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "cc037d4a_56bd16e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000549
      },
      "writtenOn": "2022-08-23T13:17:52Z",
      "side": 1,
      "message": "Why can\u0027t the interceptor return an actual dispatch object, which will listen to selection changes and send appropriate enable/disable status updates? Invalidating all the ui (all toolbars, menubar, statusbar etc.) just because a different image was selected, sounds like an overkill.",
      "revId": "e77b8950477a080570d2247257d770113766c6c9",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7bb6fa34_275a853c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000013
      },
      "writtenOn": "2022-08-23T13:52:02Z",
      "side": 1,
      "message": "The trouble is that the dispatch interceptor can take the currently selected image into account, so we need to re-query the dispatch objects. See the testcase -- my real-world example is several images, where the toolbar button associated with .uno:SetBorderStyle is meant to be disabled when the image has a hyperlink set. Without this change, we don\u0027t re-query the dispatch objects, so if the first image you select (transitioning from text selection) has a link, the toolbar button is disabled, and it will remain disabled, even if you select a next image which doesn\u0027t have a hyperlink set. Similarly, there is missing update in the other direction: if you first select a without-hyperlink image first, then we keep the toolbar button enabled, and it\u0027ll be enabled even if you select a next image with a hyperlink instead.\n\nOr do you think there is a simpler way to make sure the enabled/disabled status of toolbar buttons is correct without calling contextChanged()?",
      "parentUuid": "cc037d4a_56bd16e0",
      "revId": "e77b8950477a080570d2247257d770113766c6c9",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "00690df0_2a4e1eb7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000013
      },
      "writtenOn": "2022-08-23T14:00:27Z",
      "side": 1,
      "message": "Erm, I forgot to ask. My understanding is that returning an empty dispatcher in queryDispatch() is a supported way to communicate that we want to disable the command, e.g. our framework/source/dispatch/dispatchdisabler.cxx does this, and I assume that 3rd-party extension code does the same.\n\nStill, do you have an example where similar code does this disabling by \"sending appropriate enable/disable status updates\" instead?\n\nIf that\u0027s more efficient, we should somehow advertise that more towards extension authors. Thanks!",
      "parentUuid": "7bb6fa34_275a853c",
      "revId": "e77b8950477a080570d2247257d770113766c6c9",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "42d61c6b_e8474c07",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000549
      },
      "writtenOn": "2022-08-23T18:25:56Z",
      "side": 1,
      "message": "Returning an empty dispatcher is surely a supported way to disable commands. But dispatch interception isn\u0027t just about disabling command; It allows to change command behavior or state dynamically, by returning a custom dispatcher. And the case in question surely falls into that category of a dynamically changing state. I would say that if some 3rd party code doesn\u0027t take into account the dynamic nature of this situation, then it\u0027s a bug in that 3rd party code, and we shouldn\u0027t put workarounds to accommodate it.\n\nLet\u0027s take an example from what we\u0027re doing internally: When there is no text selected we have .uno:Copy disabled. We aren\u0027t doing this by passing an empty dispatcher, because then we won\u0027t be able to enable it when a text is finally selected later on. Instead, we pass a valid dispatcher, which upon calling its addStatusListener method initially reports the disabled state, but later on will report an enabled state when the situation changes. I expect 3rd party to do the same.\n\nI don\u0027t have a good example code to reference right now. There\u0027s somewhat similar approach of dynamically changing the state taken in framework::StyleDispatcher (see framework/source/uielement/styletoolbarcontroller.cxx), but it doesn\u0027t use the interception framework. But anyway, what is needed is to implement XDispatch + selection listening (don\u0027t remember the exact interface for this). Then, when addStatusListener is called, record the caller, and call its statusChanged method with the initial status, based on the current selection. Later on when selection changes, call the caller\u0027s statusChanged method again with the updated status. That\u0027s all what needed.",
      "parentUuid": "00690df0_2a4e1eb7",
      "revId": "e77b8950477a080570d2247257d770113766c6c9",
      "serverId": "6622c302-437a-49ad-a91d-55ba7dcf1615"
    }
  ],
  "submitRequirementResults": []
}